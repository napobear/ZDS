|===========================================================================|
Objects : -
PropIO2
   |
   +---vgacolour
   |
   +---vt100
   |
   +---Keyboard
   |
   +---safe_spi
   |
   +---E555_SPKEngine
   |
   +---Parallax Serial Terminal

Object Address : 0010 : Object Name : PropIO2
Object Address : 18F8 : Object Name : vgacolour
Object Address : 2C68 : Object Name : vt100
Object Address : 39BC : Object Name : Keyboard
Object Address : 402C : Object Name : safe_spi
Object Address : 48BC : Object Name : E555_SPKEngine
Object Address : 493C : Object Name : Parallax Serial Terminal

Binary Image Information :
PBASE : 0010
VBASE : 4D80
DBASE : 5144
PCURR : 1480
DCURR : 5148
|===========================================================================|
|===========================================================================|
Object PropIO2
Object Base is 0010
|===========================================================================|
Object Constants
|===========================================================================|
Constant _CLKMODE = 00000408 (1032)
Constant _XINFREQ = 004C4B40 (5000000)
Constant SLEEP = 0000012C (300)
Constant VGA_BASE = 00000010 (16)
Constant KBD_BASE = 0000000E (14)
Constant SD_BASE = 00000018 (24)
Constant SPK_BASE = 0000000D (13)
Constant TURQUOISE = 00000029 (41)
Constant BLUE = 00000027 (39)
Constant BABYBLUE = 00000095 (149)
Constant RED = 000000C1 (193)
Constant GREEN = 00000099 (153)
Constant GOLDBROWN = 000000A2 (162)
Constant AMBERDARK = 000000E2 (226)
Constant LAVENDER = 000000A5 (165)
Constant WHITE = 000000FF (255)
Constant HOTPINK = 000000C9 (201)
Constant GOLD = 000000D9 (217)
Constant PINK = 000000C5 (197)
Constant DSKCMD_RESET = 00000010 (16)
Constant DSKCMD_INIT = 00000020 (32)
Constant DSKCMD_READBLK = 00000030 (48)
Constant DSKCMD_PREPARE = 00000040 (64)
Constant DSKCMD_WRITEBLK = 00000050 (80)
Constant DSKST_ACT = 00000080 (128)
Constant DSKST_ERR = 00000040 (64)
Constant DSKST_OVR = 00000020 (32)
Constant TRMST_ACT = 00000080 (128)
Constant TRMST_ERR = 00000040 (64)
Constant TRMST_KBDACT = 00000020 (32)
Constant TRMST_DSPACT = 00000010 (16)
Constant TRMST_ACTMASK = 00000030 (48)
Constant CHAR_W = 00000050 (80)
Constant CHAR_H = 0000001E (30)
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable DiskBlk
VBASE : 0004 LONG Size 0200 Variable DiskBuf
VBASE : 0204 LONG Size 0040 Variable TimerStack
VBASE : 0244 LONG Size 0004 Variable TimerCount
VBASE : 0248 LONG Size 0018 Variable params
VBASE : 0260 BYTE Size 0001 Variable TermStatKbd
VBASE : 0261 BYTE Size 0001 Variable TermStatDsp
VBASE : 0262 BYTE Size 0001 Variable TermKbdBuf
VBASE : 0263 BYTE Size 0001 Variable TermScrBuf
VBASE : 0264 BYTE Size 0001 Variable DiskStat
VBASE : 0265 BYTE Size 0001 Variable DiskCmd
VBASE : 0266 BYTE Size 0001 Variable VidRdy
|===========================================================================|
Object DAT Blocks
|===========================================================================|
0068(0000) 00 00 00 00 | command                long        0
006C(0001) 20 07       | screen                word        $0720[CHAR_W*CHAR_H]
132C(04B1) 00          | cursor                byte        0,0,%110,0,0,0,0,0
132D(04B1) 00          | 
132E(04B1) 06          | 
132F(04B1) 00          | 
1330(04B2) 00          | 
1331(04B2) 00          | 
1332(04B2) 00          | 
1333(04B2) 00          | 
1334(04B3) 00 00 00 00 | sync                long        0
1338(04B4)             |                         org 0
1338(0000)             | PortIO
1338(0000) 4F EC BF A0 |                         mov     dira, BitCLR            ' Make sure we can write to CLR
133C(0001) 4F E8 BF 68 |                         or      outa, BitCLR            ' Toggle CLR, make it high
1340(0002) 4F E8 BF 64 |                         andn    outa, BitCLR            '   then low
1344(0003) 4D 9A 3C F0 |                         waitpeq MaskCS, MaskCS          ' wait for CS to be deasserted (high)
1348(0004) 4D 98 3C F0 |                         waitpeq Zero, MaskCS            ' wait for CS to be asserted (low)
134C(0005) F2 A7 BC A0 |                         mov     TempAdr, ina            ' get input bits
1350(0006) 09 A6 FC 28 |                         shr     TempAdr, #9             ' /RD, A1, A0 -> bits 2,1,0
1354(0007) 07 A6 FC 60 |                         and     TempAdr, #$07           ' isolate the 3 bits
1358(0008) 0C A6 FC 80 |                         add     TempAdr,#JmpTable
135C(0009) 53 16 BC 50 |                         movs    JmpCmd,TempAdr
1360(000A) 00 00 00 00 |                         nop
1364(000B) 00 00 7C 5C | JmpCmd                  jmp     #0-0
1368(000C) 15 00 7C 5C | JmpTable                jmp     #TermStatus
136C(000D) 1D 00 7C 5C |                         jmp     #TermRead
1370(000E) 31 00 7C 5C |                         jmp     #DiskStatus
1374(000F) 35 00 7C 5C |                         jmp     #DiskRead
1378(0010) 14 00 7C 5C |                         jmp     #TermCommand
137C(0011) 24 00 7C 5C |                         jmp     #TermWrite
1380(0012) 2A 00 7C 5C |                         jmp     #DiskCommand
1384(0013) 3C 00 7C 5C |                         jmp     #DiskWrite
1388(0014)             | TermCommand             ' receive terminal command byte from host
1388(0014) 4A 00 3C 5C |                         jmp LoopRet
138C(0015)             | TermStatus              ' send terminal status byte to host
138C(0015) 42 A4 BC 00 |                         rdbyte TempVal, TermStatKbdAdr  ' get kbd status
1390(0016) 00 E8 FF A0 |                         mov outa, #0
1394(0017) 52 E8 BF 68 |                         or outa, TempVal                ' combine it
1398(0018) 43 A4 BC 00 |                         rdbyte TempVal, TermStatDspAdr  ' get display status
139C(0019) 52 E8 BF 68 |                         or outa, TempVal                ' combine it
13A0(001A) 30 E8 FF 6C |                         xor outa, #TRMST_ACTMASK        ' convert 'active' bits to 'ready' bits for host
13A4(001B) 4B EC BF 68 |                         or dira, BitsData               ' set D0-D7 to output
13A8(001C) 4A 00 3C 5C |                         jmp LoopRet
13AC(001D)             | TermRead                ' return byte in key buf to host
13AC(001D) 44 A4 BC 00 |                         rdbyte TempVal,TermKbdBufAdr    ' get the byte from the buffer
13B0(001E) 52 E8 BF A0 |                         mov outa,TempVal                ' output byte to port
13B4(001F) 42 A4 BC 00 |                         rdbyte TempVal, TermStatKbdAdr
13B8(0020) 20 A4 FC 68 |                         or TempVal, #TRMST_KBDACT
13BC(0021) 42 A4 3C 00 |                         wrbyte TempVal, TermStatKbdAdr
13C0(0022) 4B EC BF 68 |                         or dira, BitsData               ' set D0-D7 to output
13C4(0023) 4A 00 3C 5C |                         jmp LoopRet
13C8(0024)             | TermWrite               ' accept byte from host into screen buf
13C8(0024) F2 A5 BC A0 |                         mov TempVal, ina                ' input byte from port
13CC(0025) 45 A4 3C 00 |                         wrbyte TempVal,TermDspBufAdr    ' put the byte into the buffer
13D0(0026) 43 A4 BC 00 |                         rdbyte TempVal, TermStatDspAdr  ' get current display status
13D4(0027) 10 A4 FC 68 |                         or TempVal, #TRMST_DSPACT       ' set the active bit
13D8(0028) 43 A4 3C 00 |                         wrbyte TempVal, TermStatDspAdr  ' store the updated status
13DC(0029) 4A 00 3C 5C |                         jmp LoopRet
13E0(002A)             | DiskCommand             ' receive disk command byte from host
13E0(002A) F2 A5 BC A0 |                         mov TempVal, ina                ' input command byte from port
13E4(002B) 47 A4 3C 00 |                         wrbyte TempVal, DiskCmdAdr      ' store command byte to global memory
13E8(002C) 46 A4 BC 00 |                         rdbyte TempVal, DiskStatAdr     ' get current disk status
13EC(002D) 80 A4 FC 68 |                         or TempVal, #DSKST_ACT          ' set the active bit
13F0(002E) 46 A4 3C 00 |                         wrbyte TempVal, DiskStatAdr     ' store updated disk status
13F4(002F) 00 92 FC A0 |                         mov DiskBufIdx, #0              ' reset buf index on any incoming command
13F8(0030) 4A 00 3C 5C |                         jmp LoopRet
13FC(0031)             | DiskStatus              ' send disk status byte to host
13FC(0031) 46 A4 BC 00 |                         rdbyte TempVal, DiskStatAdr     ' get status byte from global memory
1400(0032) 52 E8 BF A0 |                         mov outa, TempVal               ' output byte to port
1404(0033) 4B EC BF 68 |                         or  dira, BitsData              ' set D0-D7 to output
1408(0034) 4A 00 3C 5C |                         jmp LoopRet
140C(0035)             | DiskRead               ' send bytes from sector buffer to host
140C(0035) 48 A6 BC A0 |                         mov TempAdr,DiskBufAdr          ' get pointer to sector buffer
1410(0036) 49 A6 BC 80 |                         add TempAdr,DiskBufIdx          ' increment pointer by current index value
1414(0037) 53 A4 BC 00 |                         rdbyte TempVal,TempAdr          ' get the byte from the buffer
1418(0038) 52 E8 BF A0 |                         mov outa,TempVal                ' output byte to port
141C(0039) 01 92 FC 80 |                         add DiskBufIdx,#1               ' increment index for the next read
1420(003A) 4B EC BF 68 |                         or dira, BitsData               ' set D0-D7 to output
1424(003B) 4A 00 3C 5C |                         jmp LoopRet
1428(003C)             | DiskWrite               ' fill bytes of sector buffer from host
1428(003C) 48 A6 BC A0 |                         mov TempAdr,DiskBufAdr          ' get pointer to sector buffer
142C(003D) 49 A6 BC 80 |                         add TempAdr,DiskBufIdx          ' increment pointer by current index value
1430(003E) F2 A5 BC A0 |                         mov TempVal, ina                ' input byte from port
1434(003F) 53 A4 3C 00 |                         wrbyte TempVal,TempAdr          ' put the byte into the buffer
1438(0040) 01 92 FC 80 |                         add DiskBufIdx,#1               ' increment the index for the next write
143C(0041) 4A 00 3C 5C |                         jmp LoopRet
1440(0042) 00 00 00 00 | TermStatKbdAdr          long    0
1444(0043) 00 00 00 00 | TermStatDspAdr          long    0
1448(0044) 00 00 00 00 | TermKbdBufAdr           long    0
144C(0045) 00 00 00 00 | TermDspBufAdr           long    0
1450(0046) 00 00 00 00 | DiskStatAdr             long    0
1454(0047) 00 00 00 00 | DiskCmdAdr              long    0
1458(0048) 00 00 00 00 | DiskBufAdr              long    0
145C(0049) 00 00 00 00 | DiskBufIdx              long    0
1460(004A) 00 00 00 00 | LoopRet                 long    PortIO
1464(004B) FF 00 00 00 | BitsData                long    $00FF
1468(004C) 00 00 00 00 | Zero                    long    $0000
146C(004D) 00 01 00 00 | MaskCS                  long    $0100
1470(004E) 00 01 00 00 | BitCS                   long    $0100
1474(004F) 00 10 00 00 | BitCLR                  long    $1000
1478(0050) 00 10 00 00 | DirMask                 long    $1000
147C(0051) 00 11 00 00 | WaitMask                long    $1100
1480(0052)             | TempVal                 res     1
1480(0053)             | TempAdr                 res     1
1480(0054)             |                         fit
1480(0054)             | There are 412 ($19C) Longs left in the cog
|===========================================================================|
|===========================================================================|
Spin Block main with 0 Parameters and 0 Extra Stack Longs. Method 1
PUB main

Local Parameter DBASE:0000 - Result
|===========================================================================|
113                        VidRdy := false
Addr : 1480:             35  : Constant 1 $00000000
Addr : 1481:       89 82 66  : Memory Op Byte VBASE + WRITE Address = 0266
114                        dbg.Start(115200)
Addr : 1484:             01  : Drop Anchor   
Addr : 1485:    3A 01 C2 00  : Constant 3 Bytes - 01 C2 00 
Addr : 1489:       06 15 01  : Call Obj.Sub 21 1
116                        MsgStr(string("Starting PropIO..."))
Addr : 148C:             01  : Drop Anchor   
Addr : 148D: PBASE Constant Address of Label0002
Addr : 148D:       87 96 34  : Memory Op Byte PBASE + ADDRESS Address = 1634
Addr : 1490:          05 08  : Call Sub 8    
117                        MsgNewLine
Addr : 1492:             01  : Drop Anchor   
Addr : 1493:          05 07  : Call Sub 7    
132                        MsgStr(string("Initializing Video..."))
Addr : 1495:             01  : Drop Anchor   
Addr : 1496: PBASE Constant Address of Label0003
Addr : 1496:       87 96 47  : Memory Op Byte PBASE + ADDRESS Address = 1647
Addr : 1499:          05 08  : Call Sub 8    
133                        Result := vga.start(16, @screen, @cursor, @sync)
Addr : 149B:             00  : Drop Anchor Push 
Addr : 149C:          37 03  : Constant Mask Y=3 00000010
Addr : 149E:          A7 5C  : Memory Op Word PBASE + ADDRESS Address = 005C
Addr : 14A0:       87 93 1C  : Memory Op Byte PBASE + ADDRESS Address = 131C
Addr : 14A3:       C7 93 24  : Memory Op Long PBASE + ADDRESS Address = 1324
Addr : 14A6:       06 10 01  : Call Obj.Sub 16 1
Addr : 14A9:             61  : Variable Operation Local Offset - 0 Write
134                        if (Result < 0)
Addr : 14AA:             60  : Variable Operation Local Offset - 0 Read
Addr : 14AB:             35  : Constant 1 $00000000
Addr : 14AC:             F9  : Math Op <     
Addr : 14AD: JZ Label0004
Addr : 14AD:          0A 10  : jz Address = 14BF 16
135                          MsgStr(string(" Failed!   Error: "))
Addr : 14AF:             01  : Drop Anchor   
Addr : 14B0: PBASE Constant Address of Label0006
Addr : 14B0:       87 96 5D  : Memory Op Byte PBASE + ADDRESS Address = 165D
Addr : 14B3:          05 08  : Call Sub 8    
136                          MsgDec(Result)
Addr : 14B5:             01  : Drop Anchor   
Addr : 14B6:             60  : Variable Operation Local Offset - 0 Read
Addr : 14B7:          05 09  : Call Sub 9    
137                          MsgNewLine
Addr : 14B9:             01  : Drop Anchor   
Addr : 14BA:          05 07  : Call Sub 7    
Addr : 14BC: JMP Label0005
Addr : 14BC:       04 80 5F  : Jmp 151E 95   
Addr : 14BF: Label0004
139                          MsgStr(string(" OK"))
Addr : 14BF:             01  : Drop Anchor   
Addr : 14C0: PBASE Constant Address of Label0008
Addr : 14C0:       87 96 70  : Memory Op Byte PBASE + ADDRESS Address = 1670
Addr : 14C3:          05 08  : Call Sub 8    
140                          MsgNewLine
Addr : 14C5:             01  : Drop Anchor   
Addr : 14C6:          05 07  : Call Sub 7    
141                          params[0] := @command
Addr : 14C8:          C7 58  : Memory Op Long PBASE + ADDRESS Address = 0058
Addr : 14CA:             35  : Constant 1 $00000000
Addr : 14CB:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
142                          params[1] := @screen
Addr : 14CE:          A7 5C  : Memory Op Word PBASE + ADDRESS Address = 005C
Addr : 14D0:             36  : Constant 2 $00000001
Addr : 14D1:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
143                          params[2] := @cursor
Addr : 14D4:       87 93 1C  : Memory Op Byte PBASE + ADDRESS Address = 131C
Addr : 14D7:          37 00  : Constant Mask Y=0 00000002
Addr : 14D9:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
144                          params[3] := @sync
Addr : 14DC:       C7 93 24  : Memory Op Long PBASE + ADDRESS Address = 1324
Addr : 14DF:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 14E1:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
145                          params[4] := CHAR_W
Addr : 14E4:          38 50  : Constant 1 Bytes - 50 
Addr : 14E6:          37 01  : Constant Mask Y=1 00000004
Addr : 14E8:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
146                          params[5] := CHAR_H
Addr : 14EB:          38 1E  : Constant 1 Bytes - 1E 
Addr : 14ED:          38 05  : Constant 1 Bytes - 05 
Addr : 14EF:       D9 82 48  : Memory Op Long VBASE + POP Index WRITE Address = 0248
148                          MsgStr(string("Initializing Emulation..."))
Addr : 14F2:             01  : Drop Anchor   
Addr : 14F3: PBASE Constant Address of Label0009
Addr : 14F3:       87 96 74  : Memory Op Byte PBASE + ADDRESS Address = 1674
Addr : 14F6:          05 08  : Call Sub 8    
149                          Result := vt100.start(@params)
Addr : 14F8:             00  : Drop Anchor Push 
Addr : 14F9:       CB 82 48  : Memory Op Long VBASE + ADDRESS Address = 0248
Addr : 14FC:       06 11 01  : Call Obj.Sub 17 1
Addr : 14FF:             61  : Variable Operation Local Offset - 0 Write
150                          if (Result < 0)
Addr : 1500:             60  : Variable Operation Local Offset - 0 Read
Addr : 1501:             35  : Constant 1 $00000000
Addr : 1502:             F9  : Math Op <     
Addr : 1503: JZ Label000A
Addr : 1503:          0A 0C  : jz Address = 1511 12
151                            MsgStr(string(" Failed!   Error: "))
Addr : 1505:             01  : Drop Anchor   
Addr : 1506: PBASE Constant Address of Label000C
Addr : 1506:       87 96 8E  : Memory Op Byte PBASE + ADDRESS Address = 168E
Addr : 1509:          05 08  : Call Sub 8    
152                            MsgDec(Result)
Addr : 150B:             01  : Drop Anchor   
Addr : 150C:             60  : Variable Operation Local Offset - 0 Read
Addr : 150D:          05 09  : Call Sub 9    
Addr : 150F: JMP Label000B
Addr : 150F:          04 0A  : Jmp 151B 10   
Addr : 1511: Label000A
154                            MsgStr(string(" OK"))
Addr : 1511:             01  : Drop Anchor   
Addr : 1512: PBASE Constant Address of Label000E
Addr : 1512:       87 96 A1  : Memory Op Byte PBASE + ADDRESS Address = 16A1
Addr : 1515:          05 08  : Call Sub 8    
155                            VidRdy := true
Addr : 1517:             34  : Constant 0 $FFFFFFFF
Addr : 1518:       89 82 66  : Memory Op Byte VBASE + WRITE Address = 0266
Addr : 151B: Label000D
Addr : 151B: Label000B
156                          MsgNewLine
Addr : 151B:             01  : Drop Anchor   
Addr : 151C:          05 07  : Call Sub 7    
Addr : 151E: Label0007
Addr : 151E: Label0005
158                        TimerCount := SLEEP  
Addr : 151E:       39 01 2C  : Constant 2 Bytes - 01 2C 
Addr : 1521:       C9 82 44  : Memory Op Long VBASE + WRITE Address = 0244
161                        MsgStr(string("Initializing PropIO..."))
Addr : 1524:             01  : Drop Anchor   
Addr : 1525: PBASE Constant Address of Label000F
Addr : 1525:       87 96 A5  : Memory Op Byte PBASE + ADDRESS Address = 16A5
Addr : 1528:          05 08  : Call Sub 8    
163                        TermStatKbdAdr := @TermStatKbd
Addr : 152A:       8B 82 60  : Memory Op Byte VBASE + ADDRESS Address = 0260
Addr : 152D:       C5 94 30  : Memory Op Long PBASE + WRITE Address = 1430
164                        TermStatDspAdr := @TermStatDsp
Addr : 1530:       8B 82 61  : Memory Op Byte VBASE + ADDRESS Address = 0261
Addr : 1533:       C5 94 34  : Memory Op Long PBASE + WRITE Address = 1434
165                        TermKbdBufAdr := @TermKbdBuf
Addr : 1536:       8B 82 62  : Memory Op Byte VBASE + ADDRESS Address = 0262
Addr : 1539:       C5 94 38  : Memory Op Long PBASE + WRITE Address = 1438
166                        TermDspBufAdr := @TermScrBuf
Addr : 153C:       8B 82 63  : Memory Op Byte VBASE + ADDRESS Address = 0263
Addr : 153F:       C5 94 3C  : Memory Op Long PBASE + WRITE Address = 143C
167                        DiskStatAdr := @DiskStat
Addr : 1542:       8B 82 64  : Memory Op Byte VBASE + ADDRESS Address = 0264
Addr : 1545:       C5 94 40  : Memory Op Long PBASE + WRITE Address = 1440
168                        DiskCmdAdr := @DiskCmd
Addr : 1548:       8B 82 65  : Memory Op Byte VBASE + ADDRESS Address = 0265
Addr : 154B:       C5 94 44  : Memory Op Long PBASE + WRITE Address = 1444
169                        DiskBufAdr := @DiskBuf
Addr : 154E:             47  : Variable Operation Global Offset - 1 Address
Addr : 154F:       C5 94 48  : Memory Op Long PBASE + WRITE Address = 1448
171                        DiskBufIdx := 0
Addr : 1552:             35  : Constant 1 $00000000
Addr : 1553:       C5 94 4C  : Memory Op Long PBASE + WRITE Address = 144C
172                        TermStatKbd := TRMST_KBDACT
Addr : 1556:          37 04  : Constant Mask Y=4 00000020
Addr : 1558:       89 82 60  : Memory Op Byte VBASE + WRITE Address = 0260
173                        TermStatDsp := 0
Addr : 155B:             35  : Constant 1 $00000000
Addr : 155C:       89 82 61  : Memory Op Byte VBASE + WRITE Address = 0261
174                        DiskStat := 0
Addr : 155F:             35  : Constant 1 $00000000
Addr : 1560:       89 82 64  : Memory Op Byte VBASE + WRITE Address = 0264
176                        ByteFill(@DiskBuf, $00, 512)
Addr : 1563:             47  : Variable Operation Global Offset - 1 Address
Addr : 1564:             35  : Constant 1 $00000000
Addr : 1565:          37 08  : Constant Mask Y=8 00000200
Addr : 1567:             18  : ByteFill(Start, Value, Count)
178                        MsgStr(string(" OK"))
Addr : 1568:             01  : Drop Anchor   
Addr : 1569: PBASE Constant Address of Label0010
Addr : 1569:       87 96 BC  : Memory Op Byte PBASE + ADDRESS Address = 16BC
Addr : 156C:          05 08  : Call Sub 8    
179                        MsgNewLine
Addr : 156E:             01  : Drop Anchor   
Addr : 156F:          05 07  : Call Sub 7    
181                        MsgStr(string("Initializing Keyboard..."))
Addr : 1571:             01  : Drop Anchor   
Addr : 1572: PBASE Constant Address of Label0011
Addr : 1572:       87 96 C0  : Memory Op Byte PBASE + ADDRESS Address = 16C0
Addr : 1575:          05 08  : Call Sub 8    
182                        Result := kbd.Start(KBD_BASE, KBD_BASE + 1)
Addr : 1577:             00  : Drop Anchor Push 
Addr : 1578:          38 0E  : Constant 1 Bytes - 0E 
Addr : 157A:          38 0E  : Constant 1 Bytes - 0E 
Addr : 157C:             36  : Constant 2 $00000001
Addr : 157D:             EC  : Math Op +     
Addr : 157E:       06 12 01  : Call Obj.Sub 18 1
Addr : 1581:             61  : Variable Operation Local Offset - 0 Write
183                        if (Result < 0)
Addr : 1582:             60  : Variable Operation Local Offset - 0 Read
Addr : 1583:             35  : Constant 1 $00000000
Addr : 1584:             F9  : Math Op <     
Addr : 1585: JZ Label0012
Addr : 1585:          0A 0C  : jz Address = 1593 12
184                          MsgStr(string(" Failed!   Error: "))
Addr : 1587:             01  : Drop Anchor   
Addr : 1588: PBASE Constant Address of Label0014
Addr : 1588:       87 96 D9  : Memory Op Byte PBASE + ADDRESS Address = 16D9
Addr : 158B:          05 08  : Call Sub 8    
185                          MsgDec(Result)
Addr : 158D:             01  : Drop Anchor   
Addr : 158E:             60  : Variable Operation Local Offset - 0 Read
Addr : 158F:          05 09  : Call Sub 9    
Addr : 1591: JMP Label0013
Addr : 1591:          04 06  : Jmp 1599 6    
Addr : 1593: Label0012
187                          MsgStr(string(" OK"))
Addr : 1593:             01  : Drop Anchor   
Addr : 1594: PBASE Constant Address of Label0016
Addr : 1594:       87 96 EC  : Memory Op Byte PBASE + ADDRESS Address = 16EC
Addr : 1597:          05 08  : Call Sub 8    
Addr : 1599: Label0015
Addr : 1599: Label0013
188                        MsgNewLine
Addr : 1599:             01  : Drop Anchor   
Addr : 159A:          05 07  : Call Sub 7    
199                        MsgStr(string("Starting PortIO cog..."))
Addr : 159C:             01  : Drop Anchor   
Addr : 159D: PBASE Constant Address of Label0017
Addr : 159D:       87 96 F0  : Memory Op Byte PBASE + ADDRESS Address = 16F0
Addr : 15A0:          05 08  : Call Sub 8    
200                        Result := cognew(@PortIO, 0) + 1
Addr : 15A2:             34  : Constant 0 $FFFFFFFF
Addr : 15A3:       C7 93 28  : Memory Op Long PBASE + ADDRESS Address = 1328
Addr : 15A6:             35  : Constant 1 $00000000
Addr : 15A7:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 15A8:             36  : Constant 2 $00000001
Addr : 15A9:             EC  : Math Op +     
Addr : 15AA:             61  : Variable Operation Local Offset - 0 Write
201                        if (Result < 0)
Addr : 15AB:             60  : Variable Operation Local Offset - 0 Read
Addr : 15AC:             35  : Constant 1 $00000000
Addr : 15AD:             F9  : Math Op <     
Addr : 15AE: JZ Label0018
Addr : 15AE:          0A 0C  : jz Address = 15BC 12
202                          MsgStr(string(" Failed!   Error: "))
Addr : 15B0:             01  : Drop Anchor   
Addr : 15B1: PBASE Constant Address of Label001A
Addr : 15B1:       87 97 07  : Memory Op Byte PBASE + ADDRESS Address = 1707
Addr : 15B4:          05 08  : Call Sub 8    
203                          MsgDec(Result)
Addr : 15B6:             01  : Drop Anchor   
Addr : 15B7:             60  : Variable Operation Local Offset - 0 Read
Addr : 15B8:          05 09  : Call Sub 9    
Addr : 15BA: JMP Label0019
Addr : 15BA:          04 06  : Jmp 15C2 6    
Addr : 15BC: Label0018
205                          MsgStr(string(" OK"))
Addr : 15BC:             01  : Drop Anchor   
Addr : 15BD: PBASE Constant Address of Label001C
Addr : 15BD:       87 97 1A  : Memory Op Byte PBASE + ADDRESS Address = 171A
Addr : 15C0:          05 08  : Call Sub 8    
Addr : 15C2: Label001B
Addr : 15C2: Label0019
206                        MsgNewLine
Addr : 15C2:             01  : Drop Anchor   
Addr : 15C3:          05 07  : Call Sub 7    
208                        spk.speakerFrequency(1000, SPK_BASE)
Addr : 15C5:             01  : Drop Anchor   
Addr : 15C6:       39 03 E8  : Constant 2 Bytes - 03 E8 
Addr : 15C9:          38 0D  : Constant 1 Bytes - 0D 
Addr : 15CB:       06 14 01  : Call Obj.Sub 20 1
209                        waitcnt((clkfreq >> 4) + cnt)
Addr : 15CE:             35  : Constant 1 $00000000
Addr : 15CF:             C0  : Memory Op Long POP Address READ 
Addr : 15D0:          37 01  : Constant Mask Y=1 00000004
Addr : 15D2:             E2  : Math Op >>    
Addr : 15D3:          3F 91  : Register op CNT Read
Addr : 15D5:             EC  : Math Op +     
Addr : 15D6:             23  : WaitCnt(count)
210                        spk.speakerFrequency(-1, SPK_BASE)
Addr : 15D7:             01  : Drop Anchor   
Addr : 15D8:             34  : Constant 0 $FFFFFFFF
Addr : 15D9:          38 0D  : Constant 1 Bytes - 0D 
Addr : 15DB:       06 14 01  : Call Obj.Sub 20 1
212                        MsgStr(string("PropIO Ready!"))
Addr : 15DE:             01  : Drop Anchor   
Addr : 15DF: PBASE Constant Address of Label001D
Addr : 15DF:       87 97 1E  : Memory Op Byte PBASE + ADDRESS Address = 171E
Addr : 15E2:          05 08  : Call Sub 8    
213                        MsgNewLine
Addr : 15E4:             01  : Drop Anchor   
Addr : 15E5:          05 07  : Call Sub 7    
Addr : 15E7: Label001E
216                          if (DiskStat & DSKST_ACT)
Addr : 15E7:       88 82 64  : Memory Op Byte VBASE + READ Address = 0264
Addr : 15EA:          37 06  : Constant Mask Y=6 00000080
Addr : 15EC:             E8  : Math Op &     
Addr : 15ED: JZ Label0021
Addr : 15ED:          0A 0E  : jz Address = 15FD 14
217                            ProcessDiskCmd
Addr : 15EF:             01  : Drop Anchor   
Addr : 15F0:          05 03  : Call Sub 3    
218                            DiskCmd := 0
Addr : 15F2:             35  : Constant 1 $00000000
Addr : 15F3:       89 82 65  : Memory Op Byte VBASE + WRITE Address = 0265
219                            DiskStat &= !DSKST_ACT
Addr : 15F6:          37 06  : Constant Mask Y=6 00000080
Addr : 15F8:             E7  : Math Op !     
Addr : 15F9:    8A 82 64 48  : Memory Op Byte VBASE + ASSIGN Address = 0264 BitMathop &
Addr : 15FD: Label0021
Addr : 15FD: Label0022
221                          if (TermStatDsp & TRMST_DSPACT)
Addr : 15FD:       88 82 61  : Memory Op Byte VBASE + READ Address = 0261
Addr : 1600:          37 03  : Constant Mask Y=3 00000010
Addr : 1602:             E8  : Math Op &     
Addr : 1603: JZ Label0023
Addr : 1603:          0A 10  : jz Address = 1615 16
223                            DispChar(TermScrBuf)
Addr : 1605:             01  : Drop Anchor   
Addr : 1606:       88 82 63  : Memory Op Byte VBASE + READ Address = 0263
Addr : 1609:          05 0D  : Call Sub 13   
224                            Activity
Addr : 160B:             01  : Drop Anchor   
Addr : 160C:          05 0C  : Call Sub 12   
225                            TermStatDsp &= !TRMST_DSPACT
Addr : 160E:          37 03  : Constant Mask Y=3 00000010
Addr : 1610:             E7  : Math Op !     
Addr : 1611:    8A 82 61 48  : Memory Op Byte VBASE + ASSIGN Address = 0261 BitMathop &
Addr : 1615: Label0023
Addr : 1615: Label0024
227                          if (TermStatKbd & TRMST_KBDACT)
Addr : 1615:       88 82 60  : Memory Op Byte VBASE + READ Address = 0260
Addr : 1618:          37 04  : Constant Mask Y=4 00000020
Addr : 161A:             E8  : Math Op &     
Addr : 161B: JZ Label0025
Addr : 161B:          0A 17  : jz Address = 1634 23
228                            if (kbd.GotKey)
Addr : 161D:             00  : Drop Anchor Push 
Addr : 161E:       06 12 08  : Call Obj.Sub 18 8
Addr : 1621: JZ Label0027
Addr : 1621:          0A 11  : jz Address = 1634 17
229                              TermKbdBuf := kbd.GetKey
Addr : 1623:             00  : Drop Anchor Push 
Addr : 1624:       06 12 06  : Call Obj.Sub 18 6
Addr : 1627:       89 82 62  : Memory Op Byte VBASE + WRITE Address = 0262
230                              Activity
Addr : 162A:             01  : Drop Anchor   
Addr : 162B:          05 0C  : Call Sub 12   
231                              TermStatKbd &= !TRMST_KBDACT
Addr : 162D:          37 04  : Constant Mask Y=4 00000020
Addr : 162F:             E7  : Math Op !     
Addr : 1630:    8A 82 60 48  : Memory Op Byte VBASE + ASSIGN Address = 0260 BitMathop &
Addr : 1634: Label0027
Addr : 1634: Label0028
Addr : 1634: Label0025
Addr : 1634: Label0026
Addr : 1634: Label001F
Addr : 1634: JMP Label001E
Addr : 1634:       04 FF B0  : Jmp 15E7 -80  
Addr : 1637: Label0020
233                        MsgNewLine
Addr : 1637:             01  : Drop Anchor   
Addr : 1638:          05 07  : Call Sub 7    
234                        MsgStr(string("PropIO Shutdown!"))
Addr : 163A:             01  : Drop Anchor   
Addr : 163B: PBASE Constant Address of Label0029
Addr : 163B:       87 97 2C  : Memory Op Byte PBASE + ADDRESS Address = 172C
Addr : 163E:          05 08  : Call Sub 8    
235                        MsgNewLine
Addr : 1640:             01  : Drop Anchor   
Addr : 1641:          05 07  : Call Sub 7    
Addr : 1643:             32  : Return        
Addr : 1644: Label0002
Addr : 1644: Data : 53 74 61 72 74 69 6E 67  Starting
Addr : 164C: Data : 20 50 72 6F 70 49 4F 2E   PropIO.
Addr : 1654: Data : 2E 2E 00                 ...
Addr : 1657: Label0003
Addr : 1657: Data : 49 6E 69 74 69 61 6C 69  Initiali
Addr : 165F: Data : 7A 69 6E 67 20 56 69 64  zing Vid
Addr : 1667: Data : 65 6F 2E 2E 2E 00        eo....
Addr : 166D: Label0006
Addr : 166D: Data : 20 46 61 69 6C 65 64 21   Failed!
Addr : 1675: Data : 20 20 20 45 72 72 6F 72     Error
Addr : 167D: Data : 3A 20 00                 : .
Addr : 1680: Label0008
Addr : 1680: Data : 20 4F 4B 00               OK.
Addr : 1684: Label0009
Addr : 1684: Data : 49 6E 69 74 69 61 6C 69  Initiali
Addr : 168C: Data : 7A 69 6E 67 20 45 6D 75  zing Emu
Addr : 1694: Data : 6C 61 74 69 6F 6E 2E 2E  lation..
Addr : 169C: Data : 2E 00                    ..
Addr : 169E: Label000C
Addr : 169E: Data : 20 46 61 69 6C 65 64 21   Failed!
Addr : 16A6: Data : 20 20 20 45 72 72 6F 72     Error
Addr : 16AE: Data : 3A 20 00                 : .
Addr : 16B1: Label000E
Addr : 16B1: Data : 20 4F 4B 00               OK.
Addr : 16B5: Label000F
Addr : 16B5: Data : 49 6E 69 74 69 61 6C 69  Initiali
Addr : 16BD: Data : 7A 69 6E 67 20 50 72 6F  zing Pro
Addr : 16C5: Data : 70 49 4F 2E 2E 2E 00     pIO....
Addr : 16CC: Label0010
Addr : 16CC: Data : 20 4F 4B 00               OK.
Addr : 16D0: Label0011
Addr : 16D0: Data : 49 6E 69 74 69 61 6C 69  Initiali
Addr : 16D8: Data : 7A 69 6E 67 20 4B 65 79  zing Key
Addr : 16E0: Data : 62 6F 61 72 64 2E 2E 2E  board...
Addr : 16E8: Data : 00                       .
Addr : 16E9: Label0014
Addr : 16E9: Data : 20 46 61 69 6C 65 64 21   Failed!
Addr : 16F1: Data : 20 20 20 45 72 72 6F 72     Error
Addr : 16F9: Data : 3A 20 00                 : .
Addr : 16FC: Label0016
Addr : 16FC: Data : 20 4F 4B 00               OK.
Addr : 1700: Label0017
Addr : 1700: Data : 53 74 61 72 74 69 6E 67  Starting
Addr : 1708: Data : 20 50 6F 72 74 49 4F 20   PortIO 
Addr : 1710: Data : 63 6F 67 2E 2E 2E 00     cog....
Addr : 1717: Label001A
Addr : 1717: Data : 20 46 61 69 6C 65 64 21   Failed!
Addr : 171F: Data : 20 20 20 45 72 72 6F 72     Error
Addr : 1727: Data : 3A 20 00                 : .
Addr : 172A: Label001C
Addr : 172A: Data : 20 4F 4B 00               OK.
Addr : 172E: Label001D
Addr : 172E: Data : 50 72 6F 70 49 4F 20 52  PropIO R
Addr : 1736: Data : 65 61 64 79 21 00        eady!.
Addr : 173C: Label0029
Addr : 173C: Data : 50 72 6F 70 49 4F 20 53  PropIO S
Addr : 1744: Data : 68 75 74 64 6F 77 6E 21  hutdown!
Addr : 174C: Data : 00                       .
|===========================================================================|
Spin Block DispHex with 2 Parameters and 0 Extra Stack Longs. Method 2
PUB DispHex(value, digits)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - digits
|===========================================================================|
383                        repeat while digits > 8
Addr : 174D: Label0002
Addr : 174D:             68  : Variable Operation Local Offset - 2 Read
Addr : 174E:          37 02  : Constant Mask Y=2 00000008
Addr : 1750:             FA  : Math Op >     
Addr : 1751: JZ Label0004
Addr : 1751:          0A 09  : jz Address = 175C 9
384                          DispChar("0")
Addr : 1753:             01  : Drop Anchor   
Addr : 1754:          38 30  : Constant 1 Bytes - 30 
Addr : 1756:          05 0D  : Call Sub 13   
385                          digits--
Addr : 1758:          6A 3E  : Variable Operation Local Offset - 2 Assign VAR-- post-dec Long
Addr : 175A: Label0003
Addr : 175A: JMP Label0002
Addr : 175A:          04 71  : Jmp 174D -15  
Addr : 175C: Label0004
387                        value <<= (8 - digits) << 2
Addr : 175C:          37 02  : Constant Mask Y=2 00000008
Addr : 175E:             68  : Variable Operation Local Offset - 2 Read
Addr : 175F:             ED  : Math Op -     
Addr : 1760:          37 00  : Constant Mask Y=0 00000002
Addr : 1762:             E3  : Math Op <<    
Addr : 1763:          66 43  : Variable Operation Local Offset - 1 Assign ByteMathop <<
389                        repeat digits
Addr : 1765:             68  : Variable Operation Local Offset - 2 Read
Addr : 1766: TJZ Label0007
Addr : 1766:          08 1B  : tjz Address = 1783 27
Addr : 1768: Label0005
390                          DispChar(lookupz((value <-= 4) & $f : "0".."9", "A".."F"))
Addr : 1768:             01  : Drop Anchor   
Addr : 1769:             35  : Constant 1 $00000000
Addr : 176A: Constant Address of Label0008
Addr : 176A:       39 17 6F  : Constant 2 Bytes - 17 6F 
Addr : 176D:          37 01  : Constant Mask Y=1 00000004
Addr : 176F:          66 C1  : Variable Operation Local Offset - 1 Assign BitMathop -< Push
Addr : 1771:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 1773:             E8  : Math Op &     
Addr : 1774:          38 30  : Constant 1 Bytes - 30 
Addr : 1776:          38 39  : Constant 1 Bytes - 39 
Addr : 1778:             12  : Range LookUp  
Addr : 1779:          38 41  : Constant 1 Bytes - 41 
Addr : 177B:          38 46  : Constant 1 Bytes - 46 
Addr : 177D:             12  : Range LookUp  
Addr : 177E:             0F  : Lookdone      
Addr : 177F: Label0008
Addr : 177F:          05 0D  : Call Sub 13   
Addr : 1781: Label0006
Addr : 1781: DJNZ Label0005
Addr : 1781:          09 65  : djnz Address = 1768 -27
Addr : 1783: Label0007
Addr : 1783:             32  : Return        
|===========================================================================|
Spin Block ProcessDiskCmd with 0 Parameters and 1 Extra Stack Longs. Method 3
PRI ProcessDiskCmd | rsp

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - rsp
|===========================================================================|
243                        if (DiskCmd == DSKCMD_RESET)
Addr : 1784:       88 82 65  : Memory Op Byte VBASE + READ Address = 0265
Addr : 1787:          37 03  : Constant Mask Y=3 00000010
Addr : 1789:             FC  : Math Op ==    
Addr : 178A: JZ Label0002
Addr : 178A:          0A 0A  : jz Address = 1796 10
244                          DiskBlk := -1
Addr : 178C:             34  : Constant 0 $FFFFFFFF
Addr : 178D:             41  : Variable Operation Global Offset - 0 Write
245                          DiskStat := DSKST_ACT
Addr : 178E:          37 06  : Constant Mask Y=6 00000080
Addr : 1790:       89 82 64  : Memory Op Byte VBASE + WRITE Address = 0264
Addr : 1793: JMP Label0003
Addr : 1793:       04 80 7A  : Jmp 1810 122  
Addr : 1796: Label0002
247                        elseif (DiskCmd == DSKCMD_INIT)
Addr : 1796:       88 82 65  : Memory Op Byte VBASE + READ Address = 0265
Addr : 1799:          37 04  : Constant Mask Y=4 00000020
Addr : 179B:             FC  : Math Op ==    
Addr : 179C: JZ Label0004
Addr : 179C:          0A 19  : jz Address = 17B7 25
248                          rsp := InitCard 
Addr : 179E:             00  : Drop Anchor Push 
Addr : 179F:          05 04  : Call Sub 4    
Addr : 17A1:             65  : Variable Operation Local Offset - 1 Write
249                          if (rsp < 0)
Addr : 17A2:             64  : Variable Operation Local Offset - 1 Read
Addr : 17A3:             35  : Constant 1 $00000000
Addr : 17A4:             F9  : Math Op <     
Addr : 17A5: JZ Label0005
Addr : 17A5:          0A 0D  : jz Address = 17B4 13
250                            DiskStat := (DiskStat | DSKST_ERR)
Addr : 17A7:       88 82 64  : Memory Op Byte VBASE + READ Address = 0264
Addr : 17AA:          37 05  : Constant Mask Y=5 00000040
Addr : 17AC:             EA  : Math Op |     
Addr : 17AD:       89 82 64  : Memory Op Byte VBASE + WRITE Address = 0264
251                            DiskBuf[0] := rsp
Addr : 17B0:             64  : Variable Operation Local Offset - 1 Read
Addr : 17B1:             35  : Constant 1 $00000000
Addr : 17B2:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 17B4: Label0005
Addr : 17B4: Label0006
Addr : 17B4: JMP Label0003
Addr : 17B4:       04 80 59  : Jmp 1810 89   
Addr : 17B7: Label0004
253                        elseif (DiskCmd == DSKCMD_READBLK)
Addr : 17B7:       88 82 65  : Memory Op Byte VBASE + READ Address = 0265
Addr : 17BA:          38 30  : Constant 1 Bytes - 30 
Addr : 17BC:             FC  : Math Op ==    
Addr : 17BD: JZ Label0007
Addr : 17BD:          0A 1E  : jz Address = 17DD 30
254                          DiskBlk := DiskBuf[0]
Addr : 17BF:             35  : Constant 1 $00000000
Addr : 17C0:          D8 04  : Memory Op Long VBASE + POP Index READ Address = 0004
Addr : 17C2:             41  : Variable Operation Global Offset - 0 Write
255                          rsp := ReadSector(DiskBlk, @DiskBuf) 
Addr : 17C3:             00  : Drop Anchor Push 
Addr : 17C4:             40  : Variable Operation Global Offset - 0 Read
Addr : 17C5:             47  : Variable Operation Global Offset - 1 Address
Addr : 17C6:          05 05  : Call Sub 5    
Addr : 17C8:             65  : Variable Operation Local Offset - 1 Write
256                          if (rsp < 0)
Addr : 17C9:             64  : Variable Operation Local Offset - 1 Read
Addr : 17CA:             35  : Constant 1 $00000000
Addr : 17CB:             F9  : Math Op <     
Addr : 17CC: JZ Label0008
Addr : 17CC:          0A 0D  : jz Address = 17DB 13
257                            DiskStat := (DiskStat | DSKST_ERR)
Addr : 17CE:       88 82 64  : Memory Op Byte VBASE + READ Address = 0264
Addr : 17D1:          37 05  : Constant Mask Y=5 00000040
Addr : 17D3:             EA  : Math Op |     
Addr : 17D4:       89 82 64  : Memory Op Byte VBASE + WRITE Address = 0264
258                            DiskBuf[0] := rsp
Addr : 17D7:             64  : Variable Operation Local Offset - 1 Read
Addr : 17D8:             35  : Constant 1 $00000000
Addr : 17D9:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 17DB: Label0008
Addr : 17DB: Label0009
Addr : 17DB: JMP Label0003
Addr : 17DB:          04 33  : Jmp 1810 51   
Addr : 17DD: Label0007
260                        elseif (DiskCmd == DSKCMD_PREPARE)
Addr : 17DD:       88 82 65  : Memory Op Byte VBASE + READ Address = 0265
Addr : 17E0:          37 05  : Constant Mask Y=5 00000040
Addr : 17E2:             FC  : Math Op ==    
Addr : 17E3: JZ Label000A
Addr : 17E3:          0A 0B  : jz Address = 17F0 11
261                          DiskBlk := DiskBuf[0]
Addr : 17E5:             35  : Constant 1 $00000000
Addr : 17E6:          D8 04  : Memory Op Long VBASE + POP Index READ Address = 0004
Addr : 17E8:             41  : Variable Operation Global Offset - 0 Write
262                          ByteFill(@DiskBuf, $00, 512)
Addr : 17E9:             47  : Variable Operation Global Offset - 1 Address
Addr : 17EA:             35  : Constant 1 $00000000
Addr : 17EB:          37 08  : Constant Mask Y=8 00000200
Addr : 17ED:             18  : ByteFill(Start, Value, Count)
Addr : 17EE: JMP Label0003
Addr : 17EE:          04 20  : Jmp 1810 32   
Addr : 17F0: Label000A
264                        elseif (DiskCmd == DSKCMD_WRITEBLK)
Addr : 17F0:       88 82 65  : Memory Op Byte VBASE + READ Address = 0265
Addr : 17F3:          38 50  : Constant 1 Bytes - 50 
Addr : 17F5:             FC  : Math Op ==    
Addr : 17F6: JZ Label000B
Addr : 17F6:          0A 18  : jz Address = 1810 24
265                          rsp := WriteSector(DiskBlk, @DiskBuf)  
Addr : 17F8:             00  : Drop Anchor Push 
Addr : 17F9:             40  : Variable Operation Global Offset - 0 Read
Addr : 17FA:             47  : Variable Operation Global Offset - 1 Address
Addr : 17FB:          05 06  : Call Sub 6    
Addr : 17FD:             65  : Variable Operation Local Offset - 1 Write
266                          if (rsp < 0)
Addr : 17FE:             64  : Variable Operation Local Offset - 1 Read
Addr : 17FF:             35  : Constant 1 $00000000
Addr : 1800:             F9  : Math Op <     
Addr : 1801: JZ Label000C
Addr : 1801:          0A 0D  : jz Address = 1810 13
267                            DiskStat := (DiskStat | DSKST_ERR)
Addr : 1803:       88 82 64  : Memory Op Byte VBASE + READ Address = 0264
Addr : 1806:          37 05  : Constant Mask Y=5 00000040
Addr : 1808:             EA  : Math Op |     
Addr : 1809:       89 82 64  : Memory Op Byte VBASE + WRITE Address = 0264
268                            DiskBuf[0] := rsp
Addr : 180C:             64  : Variable Operation Local Offset - 1 Read
Addr : 180D:             35  : Constant 1 $00000000
Addr : 180E:          D9 04  : Memory Op Long VBASE + POP Index WRITE Address = 0004
Addr : 1810: Label000C
Addr : 1810: Label000D
Addr : 1810: Label000B
Addr : 1810: Label0003
Addr : 1810:             32  : Return        
|===========================================================================|
Spin Block InitCard with 0 Parameters and 0 Extra Stack Longs. Method 4
PRI InitCard

Local Parameter DBASE:0000 - Result
|===========================================================================|
277                        Result := \sdc.Start(SD_BASE)
Addr : 1811:             02  : Drop Anchor Push Try
Addr : 1812:          38 18  : Constant 1 Bytes - 18 
Addr : 1814:       06 13 01  : Call Obj.Sub 19 1
Addr : 1817:             61  : Variable Operation Local Offset - 0 Write
Addr : 1818:             32  : Return        
|===========================================================================|
Spin Block ReadSector with 2 Parameters and 0 Extra Stack Longs. Method 5
PRI ReadSector(Sector, Buffer)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - Sector
Local Parameter DBASE:0008 - Buffer
|===========================================================================|
284                        Result := \sdc.ReadBlock(Sector, Buffer)
Addr : 1819:             02  : Drop Anchor Push Try
Addr : 181A:             64  : Variable Operation Local Offset - 1 Read
Addr : 181B:             68  : Variable Operation Local Offset - 2 Read
Addr : 181C:       06 13 02  : Call Obj.Sub 19 2
Addr : 181F:             61  : Variable Operation Local Offset - 0 Write
Addr : 1820:             32  : Return        
|===========================================================================|
Spin Block WriteSector with 2 Parameters and 0 Extra Stack Longs. Method 6
PRI WriteSector(Sector, Buffer)    

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - Sector
Local Parameter DBASE:0008 - Buffer
|===========================================================================|
293                        Result := \sdc.WriteBlock(Sector, Buffer)
Addr : 1821:             02  : Drop Anchor Push Try
Addr : 1822:             64  : Variable Operation Local Offset - 1 Read
Addr : 1823:             68  : Variable Operation Local Offset - 2 Read
Addr : 1824:       06 13 03  : Call Obj.Sub 19 3
Addr : 1827:             61  : Variable Operation Local Offset - 0 Write
Addr : 1828:             32  : Return        
|===========================================================================|
Spin Block MsgNewLine with 0 Parameters and 0 Extra Stack Longs. Method 7
PRI MsgNewLine

Local Parameter DBASE:0000 - Result
|===========================================================================|
301                        dbg.NewLine
Addr : 1829:             01  : Drop Anchor   
Addr : 182A:       06 15 17  : Call Obj.Sub 21 23
302                        if (VidRdy)
Addr : 182D:       88 82 66  : Memory Op Byte VBASE + READ Address = 0266
Addr : 1830: JZ Label0002
Addr : 1830:          0A 0A  : jz Address = 183C 10
304                          DispChar(13)
Addr : 1832:             01  : Drop Anchor   
Addr : 1833:          38 0D  : Constant 1 Bytes - 0D 
Addr : 1835:          05 0D  : Call Sub 13   
306                          DispChar(10)
Addr : 1837:             01  : Drop Anchor   
Addr : 1838:          38 0A  : Constant 1 Bytes - 0A 
Addr : 183A:          05 0D  : Call Sub 13   
Addr : 183C: Label0002
Addr : 183C: Label0003
Addr : 183C:             32  : Return        
|===========================================================================|
Spin Block MsgStr with 1 Parameters and 0 Extra Stack Longs. Method 8
PRI MsgStr(StrPtr)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - StrPtr
|===========================================================================|
309                        dbg.Str(StrPtr)
Addr : 183D:             01  : Drop Anchor   
Addr : 183E:             64  : Variable Operation Local Offset - 1 Read
Addr : 183F:       06 15 07  : Call Obj.Sub 21 7
310                        if (VidRdy)
Addr : 1842:       88 82 66  : Memory Op Byte VBASE + READ Address = 0266
Addr : 1845: JZ Label0002
Addr : 1845:          0A 04  : jz Address = 184B 4
312                          DispStr(StrPtr)
Addr : 1847:             01  : Drop Anchor   
Addr : 1848:             64  : Variable Operation Local Offset - 1 Read
Addr : 1849:          05 0E  : Call Sub 14   
Addr : 184B: Label0002
Addr : 184B: Label0003
Addr : 184B:             32  : Return        
|===========================================================================|
Spin Block MsgDec with 1 Parameters and 0 Extra Stack Longs. Method 9
PRI MsgDec(Val)                  

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - Val
|===========================================================================|
315                        dbg.Dec(Val)
Addr : 184C:             01  : Drop Anchor   
Addr : 184D:             64  : Variable Operation Local Offset - 1 Read
Addr : 184E:       06 15 0A  : Call Obj.Sub 21 10
316                        if (VidRdy)
Addr : 1851:       88 82 66  : Memory Op Byte VBASE + READ Address = 0266
Addr : 1854: JZ Label0002
Addr : 1854:          0A 04  : jz Address = 185A 4
318                          DispDec(Val)
Addr : 1856:             01  : Drop Anchor   
Addr : 1857:             64  : Variable Operation Local Offset - 1 Read
Addr : 1858:          05 0F  : Call Sub 15   
Addr : 185A: Label0002
Addr : 185A: Label0003
Addr : 185A:             32  : Return        
|===========================================================================|
Spin Block MsgHex with 2 Parameters and 0 Extra Stack Longs. Method 10
PRI MsgHex(Val, Digits)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - Val
Local Parameter DBASE:0008 - Digits
|===========================================================================|
321                        dbg.Hex(Val, Digits)
Addr : 185B:             01  : Drop Anchor   
Addr : 185C:             64  : Variable Operation Local Offset - 1 Read
Addr : 185D:             68  : Variable Operation Local Offset - 2 Read
Addr : 185E:       06 15 0E  : Call Obj.Sub 21 14
322                        if (VidRdy)
Addr : 1861:       88 82 66  : Memory Op Byte VBASE + READ Address = 0266
Addr : 1864: JZ Label0002
Addr : 1864:          0A 05  : jz Address = 186B 5
324                          DispHex(Val, Digits)
Addr : 1866:             01  : Drop Anchor   
Addr : 1867:             64  : Variable Operation Local Offset - 1 Read
Addr : 1868:             68  : Variable Operation Local Offset - 2 Read
Addr : 1869:          05 02  : Call Sub 2    
Addr : 186B: Label0002
Addr : 186B: Label0003
Addr : 186B:             32  : Return        
|===========================================================================|
Spin Block Timer with 0 Parameters and 0 Extra Stack Longs. Method 11
PRI Timer

Local Parameter DBASE:0000 - Result
|===========================================================================|
327                        TimerCount := SLEEP
Addr : 186C:       39 01 2C  : Constant 2 Bytes - 01 2C 
Addr : 186F:       C9 82 44  : Memory Op Long VBASE + WRITE Address = 0244
Addr : 1872: Label0002
329                          waitcnt(clkfreq * 1 + cnt)
Addr : 1872:             35  : Constant 1 $00000000
Addr : 1873:             C0  : Memory Op Long POP Address READ 
Addr : 1874:             36  : Constant 2 $00000001
Addr : 1875:             F4  : Math Op *     
Addr : 1876:          3F 91  : Register op CNT Read
Addr : 1878:             EC  : Math Op +     
Addr : 1879:             23  : WaitCnt(count)
330                          if (TimerCount > 0)
Addr : 187A:       C8 82 44  : Memory Op Long VBASE + READ Address = 0244
Addr : 187D:             35  : Constant 1 $00000000
Addr : 187E:             FA  : Math Op >     
Addr : 187F: JZ Label0005
Addr : 187F:          0A 0B  : jz Address = 188C 11
331                            if (TimerCount == 1)
Addr : 1881:       C8 82 44  : Memory Op Long VBASE + READ Address = 0244
Addr : 1884:             36  : Constant 2 $00000001
Addr : 1885:             FC  : Math Op ==    
Addr : 1886: JZ Label0007
Addr : 1886:          0A 00  : jz Address = 1888 0
Addr : 1888: Label0007
Addr : 1888: Label0008
333                            TimerCount--
Addr : 1888:    CA 82 44 3E  : Memory Op Long VBASE + ASSIGN Address = 0244 VAR-- post-dec Long
Addr : 188C: Label0005
Addr : 188C: Label0006
Addr : 188C: Label0003
Addr : 188C: JMP Label0002
Addr : 188C:          04 64  : Jmp 1872 -28  
Addr : 188E: Label0004
Addr : 188E:             32  : Return        
|===========================================================================|
Spin Block Activity with 0 Parameters and 0 Extra Stack Longs. Method 12
PRI Activity

Local Parameter DBASE:0000 - Result
|===========================================================================|
336                        if (TimerCount == 0)
Addr : 188F:       C8 82 44  : Memory Op Long VBASE + READ Address = 0244
Addr : 1892:             35  : Constant 1 $00000000
Addr : 1893:             FC  : Math Op ==    
Addr : 1894: JZ Label0002
Addr : 1894:          0A 00  : jz Address = 1896 0
Addr : 1896: Label0002
Addr : 1896: Label0003
338                        TimerCount := SLEEP
Addr : 1896:       39 01 2C  : Constant 2 Bytes - 01 2C 
Addr : 1899:       C9 82 44  : Memory Op Long VBASE + WRITE Address = 0244
Addr : 189C:             32  : Return        
|===========================================================================|
Spin Block DispChar with 1 Parameters and 0 Extra Stack Longs. Method 13
PRI DispChar(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
353                        command := $100 | c
Addr : 189D:          37 07  : Constant Mask Y=7 00000100
Addr : 189F:             64  : Variable Operation Local Offset - 1 Read
Addr : 18A0:             EA  : Math Op |     
Addr : 18A1:          C5 58  : Memory Op Long PBASE + WRITE Address = 0058
Addr : 18A3: Label0002
354                        repeat while command
Addr : 18A3:          C4 58  : Memory Op Long PBASE + READ Address = 0058
Addr : 18A5: JZ Label0004
Addr : 18A5:          0A 02  : jz Address = 18A9 2
Addr : 18A7: Label0003
Addr : 18A7: JMP Label0002
Addr : 18A7:          04 7A  : Jmp 18A3 -6   
Addr : 18A9: Label0004
Addr : 18A9:             32  : Return        
|===========================================================================|
Spin Block DispStr with 1 Parameters and 1 Extra Stack Longs. Method 14
PRI DispStr(strptr) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - strptr
Local Variable  DBASE:0008 - i
|===========================================================================|
357                        repeat i from 0 to strsize(strptr)
Addr : 18AA:             35  : Constant 1 $00000000
Addr : 18AB:             69  : Variable Operation Local Offset - 2 Write
Addr : 18AC: Label0002
358                          DispChar(byte[strptr][i])
Addr : 18AC:             01  : Drop Anchor   
Addr : 18AD:             64  : Variable Operation Local Offset - 1 Read
Addr : 18AE:             68  : Variable Operation Local Offset - 2 Read
Addr : 18AF:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 18B0:          05 0D  : Call Sub 13   
Addr : 18B2: Label0003
357                        repeat i from 0 to strsize(strptr)
Addr : 18B2:             35  : Constant 1 $00000000
Addr : 18B3:             64  : Variable Operation Local Offset - 1 Read
Addr : 18B4:             16  : StrSize(String)
Addr : 18B5: Repeat i Step Label0002
Addr : 18B5:       6A 02 74  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 18AC -12
Addr : 18B8: Label0004
Addr : 18B8:             32  : Return        
|===========================================================================|
Spin Block DispDec with 1 Parameters and 1 Extra Stack Longs. Method 15
PRI DispDec(value) | i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Variable  DBASE:0008 - i
|===========================================================================|
364                        if value < 0
Addr : 18B9:             64  : Variable Operation Local Offset - 1 Read
Addr : 18BA:             35  : Constant 1 $00000000
Addr : 18BB:             F9  : Math Op <     
Addr : 18BC: JZ Label0002
Addr : 18BC:          0A 07  : jz Address = 18C5 7
365                          -value
Addr : 18BE:          66 46  : Variable Operation Local Offset - 1 Assign LongMathop -
366                          DispChar("-")
Addr : 18C0:             01  : Drop Anchor   
Addr : 18C1:          38 2D  : Constant 1 Bytes - 2D 
Addr : 18C3:          05 0D  : Call Sub 13   
Addr : 18C5: Label0002
Addr : 18C5: Label0003
368                        i := 1_000_000_000
Addr : 18C5: 3B 3B 9A CA 00  : Constant 4 Bytes - 3B 9A CA 00 
Addr : 18CA:             69  : Variable Operation Local Offset - 2 Write
370                        repeat 10
Addr : 18CB:          38 0A  : Constant 1 Bytes - 0A 
Addr : 18CD: TJZ Label0006
Addr : 18CD:          08 27  : tjz Address = 18F6 39
Addr : 18CF: Label0004
371                          if value => i
Addr : 18CF:             64  : Variable Operation Local Offset - 1 Read
Addr : 18D0:             68  : Variable Operation Local Offset - 2 Read
Addr : 18D1:             FE  : Math Op =>    
Addr : 18D2: JZ Label0007
Addr : 18D2:          0A 10  : jz Address = 18E4 16
372                            DispChar(value/i + "0")
Addr : 18D4:             01  : Drop Anchor   
Addr : 18D5:             64  : Variable Operation Local Offset - 1 Read
Addr : 18D6:             68  : Variable Operation Local Offset - 2 Read
Addr : 18D7:             F6  : Math Op /     
Addr : 18D8:          38 30  : Constant 1 Bytes - 30 
Addr : 18DA:             EC  : Math Op +     
Addr : 18DB:          05 0D  : Call Sub 13   
373                            value //= i
Addr : 18DD:             68  : Variable Operation Local Offset - 2 Read
Addr : 18DE:          66 57  : Variable Operation Local Offset - 1 Assign LongMathop //
374                            result~~
Addr : 18E0:          62 1C  : Variable Operation Local Offset - 0 Assign VAR~~ Post-set
Addr : 18E2: JMP Label0008
Addr : 18E2:          04 0C  : Jmp 18F0 12   
Addr : 18E4: Label0007
375                          elseif result or i == 1
Addr : 18E4:             60  : Variable Operation Local Offset - 0 Read
Addr : 18E5:             68  : Variable Operation Local Offset - 2 Read
Addr : 18E6:             36  : Constant 2 $00000001
Addr : 18E7:             FC  : Math Op ==    
Addr : 18E8:             F2  : Math Op OR    
Addr : 18E9: JZ Label0009
Addr : 18E9:          0A 05  : jz Address = 18F0 5
376                            DispChar("0")
Addr : 18EB:             01  : Drop Anchor   
Addr : 18EC:          38 30  : Constant 1 Bytes - 30 
Addr : 18EE:          05 0D  : Call Sub 13   
Addr : 18F0: Label0009
Addr : 18F0: Label0008
377                          i /= 10     
Addr : 18F0:          38 0A  : Constant 1 Bytes - 0A 
Addr : 18F2:          6A 56  : Variable Operation Local Offset - 2 Assign LongMathop /
Addr : 18F4: Label0005
Addr : 18F4: DJNZ Label0004
Addr : 18F4:          09 59  : djnz Address = 18CF -39
Addr : 18F6: Label0006
Addr : 18F6:             32  : Return        
|===========================================================================|
Object vgacolour
Object Base is 18F8
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0008 Variable cog
|===========================================================================|
Object DAT Blocks
|===========================================================================|
1904(0000)             |                         org        0                                ' set origin to $000 for start of program
1904(0000) 00 02 00 00 | d0                        long        1 << 9                                ' d0 always resides here at $000, executes as NOP
1908(0001) D1 DE BF A0 | :move                        mov        $1EF, main_begin + main_size - 1
190C(0002) 18 02 BC 84 |                         sub        :move,d0s0                        ' (do reverse move to avoid overwrite)
1910(0003) 01 34 FC E4 |                         djnz        main_ctr,#:move
1914(0004) 1C 42 BD A0 | :waitvid                mov        scancode+0, i0                        ' org        scancode
1918(0005) 1D 44 BD A0 | :shr                        mov        scancode+1, i1                        ' waitvid colorbuff+0, scanbuff+0
191C(0006) 19 08 BC 80 |                         add        :waitvid, d1                        ' shr        scanbuff+0,#8
1920(0007) 19 0A BC 80 |                         add        :shr, d1                         ' waitvid colorbuff+1, scanbuff+1
1924(0008) 18 38 BC 80 |                         add        i0, d0s0                        ' shr        scanbuff+1,#8
1928(0009) 00 3A BC 80 |                         add        i1, d0                                ' ...
192C(000A) 04 36 FC E4 |                         djnz        scan_ctr, #:waitvid                ' waitvid colorbuff+cols-1, scanbuff+cols-1
1930(000B) 1E 80 BE A0 |                         mov        scancode+cols*2-1, i2                ' mov        vscl,#hf
1934(000C) 1F 82 BE A0 |                         mov        scancode+cols*2+0, i3                ' waitvid hvsync,#0
1938(000D) 20 84 BE A0 |                         mov        scancode+cols*2+1, i4                ' jmp        #scanret
193C(000E) 21 EC BF A0 |                         mov        dira, reg_dira                        ' set pin directions
1940(000F) 22 EE BF A0 |                         mov        dirb, reg_dirb
1944(0010) 18 F4 FF 58 |                         movi        frqa, #(pr / 5) << 2                ' set pixel rate
1948(0011) 23 FC BF A0 |                         mov        vcfg, reg_vcfg                        ' set video configuration
194C(0012) 01 FE FF A0 |                         mov        vscl, #1                         ' set video to reload on every pixel
1950(0013) A7 49 BC F8 |                         waitcnt sync_cnt, colormask                ' wait for start value in cnt, add ~1ms
1954(0014) 0E F0 FF 58 |                         movi        ctra, #%00001_110                ' COGs in sync! enable PLLs now - NCOs locked!
1958(0015) 00 48 FC F8 |                         waitcnt sync_cnt, #0                        ' wait ~1ms for PLLs to stabilize - PLLs locked!
195C(0016) 64 FE FF A0 |                         mov        vscl, #100                        ' insure initial WAITVIDs lock cleanly
1960(0017) 43 01 7C 5C |                         jmp        #vsync                                ' jump to vsync - WAITVIDs will now be locked!
1964(0018) 01 02 00 00 | d0s0                        long        1 << 9 + 1
1968(0019) 00 04 00 00 | d1                        long        1 << 10
196C(001A) AD 00 00 00 | main_ctr                long        main_size
1970(001B) 50 00 00 00 | scan_ctr                long        cols
1974(001C) 01 A2 3C FC | i0                        waitvid colorbuff+0, scanbuff+0
1978(001D) 08 02 FC 28 | i1                        shr        scanbuff+0, #8
197C(001E) 18 FE FF A0 | i2                        mov        vscl, #hf
1980(001F) 00 5A 7F FC | i3                        waitvid hvsync, #0
1984(0020) 85 01 7C 5C | i4                        jmp        #scanret
1988(0021) 00 00 00 00 | reg_dira                long        0                                ' set at runtime
198C(0022) 00 00 00 00 | reg_dirb                long        0                                ' set at runtime
1990(0023) 00 00 00 00 | reg_vcfg                long        0                                ' set at runtime
1994(0024) 00 00 00 00 | sync_cnt                long        0                                ' set at runtime
1998(0025)             |                         fit        scancode                        ' make sure initialization code and data fit
1998(0025)             | There are 124 ($07C) Longs left in the cog
1998(0025)             | main_begin                org        maincode                        ' main code follows (gets moved into maincode)
1998(0143) 03 A0 FF A0 | vsync                        mov        x, #vs                                ' do vertical sync lines
199C(0144) 94 3D FF 5C |                         call        #blank_vsync
19A0(0145) 11 A0 FF A0 | vb_lines                mov        x, #vb                                ' do vertical back porch lines (# set at runtime)
19A4(0146) 94 3D FF 5C |                         call        #blank_vsync
19A8(0147) 9F 9D BF A0 |                         mov        screen_ptr, screen_base                ' reset screen pointer to upper-left character
19AC(0148) 00 AA FF A0 |                         mov        row, #0                                ' reset row counter for cursor insertion
19B0(0149) 3C AC FF A0 |                         mov        fours, #rows * 4 / 2                ' set number of 4-line builds for whole screen
19B4(014A) A2 9F BF A0 | fourline                mov        font_ptr, font_part                ' get address of appropriate font section
19B8(014B) 0A 9E FF 2C |                         shl        font_ptr, #8+2
19BC(014C) A1 9F BF 80 |                         add        font_ptr, font_base
19C0(014D) 00 B6 FE 54 |                         movd        :pixa, #scanbuff-1                ' reset scanbuff address (pre-decremented)
19C4(014E) 50 CA FE 54 |                         movd        :cola, #colorbuff-1                ' reset colorbuff address (pre-decremented)
19C8(014F) 50 CC FE 54 |                         movd        :colb, #colorbuff-1
19CC(0150) 02 A2 FF A0 |                         mov        y, #2                                ' must build scanbuff in two sections because
19D0(0151) A5 FF BF A0 |                         mov        vscl, vscl_line2x                ' ..pixel counter is limited to twelve bits
19D4(0152) 00 56 7F FC | :halfrow                waitvid underscore, #0                        ' output lows to let other COG drive VGA pins
19D8(0153) 28 A0 FF A0 |                         mov        x, #cols/2                        ' ..for 2 scan lines, ready for half a row
19DC(0154) CE A5 BF 04 | :column                         rdword        z, screen_ptr                        ' get character and colors from screen memory
19E0(0155) D2 A9 BF A0 |                         mov        bg, z
19E4(0156) FF A4 FF 60 |                         and        z, #$ff                                ' mask character code
19E8(0157) 02 A4 FF 2C |                         shl        z, #2                                ' * 4
19EC(0158) CF A5 BF 80 |                         add        z, font_ptr                        ' add font section address to point to 8*4 pixels
19F0(0159) 00 B6 BE 80 |                         add        :pixa, d0                        ' increment scanbuff destination addresses
19F4(015A) 02 9C FF 80 |                         add        screen_ptr, #2                        ' increment screen memory address
19F8(015B) D2 03 BC 08 | :pixa                        rdlong        scanbuff, z                        ' read pixel long (8*4) into scanbuff
19FC(015C) 0C A8 FF 20 |                         ror        bg, #12                                ' background color in bits 3..0
1A00(015D) D4 A7 BF A0 |                         mov        fg, bg                                ' foreground color in bits 31..28
1A04(015E) 1C A6 FF 28 |                         shr        fg, #28                                ' bits 3..0
1A08(015F) BE A7 FF 80 |                         add        fg, #fg_clut                        ' + offset to foreground CLUT
1A0C(0160) D3 CB BE 50 |                         movs        :cola, fg
1A10(0161) 00 CA BE 80 |                         add        :cola, d0
1A14(0162) AE A9 FF 80 |                         add        bg, #bg_clut                        ' + offset to background CLUT
1A18(0163) D4 CD BE 50 |                         movs        :colb, bg
1A1C(0164) 00 CC BE 80 |                         add        :colb, d0
1A20(0165) 00 A2 BC A0 | :cola                        mov        colorbuff, 0-0
1A24(0166) 00 A2 BC 68 | :colb                        or        colorbuff, 0-0
1A28(0167) 54 A1 FF E4 |                         djnz        x, #:column                        ' another character in this half-row?
1A2C(0168) 52 A3 FF E4 |                         djnz        y, #:halfrow                        ' loop to do 2nd half-row, time for 2nd WAITVID
1A30(0169) A0 9C FF 84 |                         sub        screen_ptr, #2*cols                ' back up to start of same row in screen memory
1A34(016A) 02 A4 FF A0 |                         mov        z, #2                                ' ready for two cursors
1A38(016B) A0 A1 BF 00 | :cursor                        rdbyte        x, cursor_base                        ' x in range?
1A3C(016C) 01 40 FF 80 |                         add        cursor_base, #1
1A40(016D) 50 A0 7F 85 |                         cmp        x, #cols        wc
1A44(016E) A0 A3 BF 00 |                         rdbyte        y, cursor_base                        ' y match?
1A48(016F) 01 40 FF 80 |                         add        cursor_base, #1
1A4C(0170) D5 A3 3F 86 |                         cmp        y, row                wz
1A50(0171) A0 A3 BF 00 |                         rdbyte        y, cursor_base                        ' get cursor mode
1A54(0172) 01 40 FF 80 |                         add        cursor_base, #1
1A58(0173) 80 01 5C 5C |         if_nc_or_nz        jmp        #:nocursor                        ' if cursor not in scanbuff, no cursor
1A5C(0174) 01 A0 FF 80 |                         add        x, #scanbuff                        ' cursor in scanbuff, set scanbuff address
1A60(0175) D0 FF BE 54 |                         movd        :xor, x
1A64(0176) 02 A2 7F 61 |                         test        y, #%010        wc                ' get mode bits into flags
1A68(0177) 01 A2 7F 62 |                         test        y, #%001        wz
1A6C(0178) 80 01 48 5C |         if_nc_and_z        jmp        #:nocursor                        ' if cursor disabled, no cursor
1A70(0179) F1 53 23 61 |         if_c_and_z        test        slowbit, cnt        wc                ' if blink mode, get blink state
1A74(017A) F1 55 13 61 |         if_c_and_nz        test        fastbit, cnt        wc
1A78(017B) 04 A2 7F 62 |                         test        y, #%100        wz                ' get box or underscore cursor piece
1A7C(017C) A8 A1 AB A0 |         if_z                mov        x, longmask
1A80(017D) AB A1 97 A0 |         if_nz                mov        x, underscore
1A84(017E) 03 44 57 86 |         if_nz                cmp        font_part, #3        wz                ' if underscore, must be last font section
1A88(017F) D0 03 88 6C | :xor        if_nc_and_z        xor        scanbuff, x                        ' conditionally xor cursor into scanbuff
1A8C(0180) 6B A5 FF E4 | :nocursor                djnz        z, #:cursor                        ' second cursor?
1A90(0181) 06 40 FF 84 |                         sub        cursor_base, #3*2                ' restore cursor base
1A94(0182) 04 A2 FF A0 |                         mov        y, #4                                ' ready for four scan lines
1A98(0183) A6 FF BF A0 | scanline                mov        vscl, vscl_chr                        ' set pixel rate for characters
1A9C(0184) A1 00 7C 5C |                         jmp        #scancode                        ' jump to scanbuff display routine in scancode
1AA0(0185) 28 FE FF A0 | scanret                         mov        vscl, #hs                        ' do horizontal sync pixels
1AA4(0186) 01 5A 7F FC |                         waitvid hvsync, #1                        ' #1 makes hsync active
1AA8(0187) 80 FE FF A0 |                         mov        vscl, #hb                        ' do horizontal back porch pixels
1AAC(0188) 00 5A 7F FC |                         waitvid hvsync, #0                        ' #0 makes hsync inactive
1AB0(0189) 08 A0 FC 28 |                         shr        scanbuff+cols-1, #8                ' shift last column's pixels right by 8
1AB4(018A) 83 A3 FF E4 |                         djnz        y, #scanline                        ' another scan line?
1AB8(018B) 02 44 FF 80 |                         add        font_part, #2                        ' if font_part + 2 => 4, subtract 4 (new row)
1ABC(018C) 04 44 FF E1 |                         cmpsub        font_part, #4                wc        ' c=0 for same row, c=1 for new row
1AC0(018D) A0 9C F3 80 |         if_c                add        screen_ptr, #2*cols                ' if new row, advance screen pointer
1AC4(018E) 01 AA F3 80 |         if_c                add        row, #1                                ' if new row, increment row counter
1AC8(018F) 4A AD FF E4 |                         djnz        fours, #fourline                 ' another 4-line build/display?
1ACC(0190) F0 51 3F 08 |                         wrlong        longmask,par                        ' write -1 to refresh indicator
1AD0(0191) 14 A0 FF A0 | vf_lines                mov        x,#vf                                ' do vertical front porch lines (# set at runtime)
1AD4(0192) 95 3D FF 5C |                         call        #blank
1AD8(0193) 43 01 7C 5C |                         jmp        #vsync                                ' new field, loop to vsync
1ADC(0194) 01 5B FF 6C | blank_vsync                xor        hvsync,#$101                        ' flip vertical sync bits
1AE0(0195) A3 FF BF A0 | blank                        mov        vscl, hx                         ' do blank pixels
1AE4(0196) 00 5A 7F FC |                         waitvid hvsync, #0
1AE8(0197) 18 FE FF A0 |                         mov        vscl, #hf                        ' do horizontal front porch pixels
1AEC(0198) 00 5A 7F FC |                         waitvid hvsync, #0
1AF0(0199) 28 FE FF A0 |                         mov        vscl, #hs                        ' do horizontal sync pixels
1AF4(019A) 01 5A 7F FC |                         waitvid hvsync, #1
1AF8(019B) 80 FE FF A0 |                         mov        vscl, #hb                        ' do horizontal back porch pixels
1AFC(019C) 00 5A 7F FC |                         waitvid hvsync, #0
1B00(019D) 95 A1 FF E4 |                         djnz        x,#blank                        ' another line?
1B04(019E)             | blank_ret
1B04(019E)             | blank_vsync_ret
1B04(019E) 00 00 7C 5C |                         ret
1B08(019F) 00 00 00 00 | screen_base                long        0                                ' set at runtime (3 contiguous longs)
1B0C(01A0) 00 00 00 00 | cursor_base                long        0                                ' set at runtime
1B10(01A1) 00 00 00 00 | font_base                long        0                                ' set at runtime
1B14(01A2) 00 00 00 00 | font_part                long        0                                ' set at runtime
1B18(01A3) 80 02 00 00 | hx                        long        hp                                ' visible pixels per scan line
1B1C(01A4) 40 03 00 00 | vscl_line                long        hp + hf + hs + hb                ' total number of pixels per scan line
1B20(01A5) 80 06 00 00 | vscl_line2x                long        (hp + hf + hs + hb) * 2         ' total number of pixels per 2 scan lines
1B24(01A6) 08 10 00 00 | vscl_chr                long        1 << 12 + 8                        ' 1 clock per pixel and 8 pixels per set
1B28(01A7) FC FC 00 00 | colormask                long        $FCFC                                ' mask to isolate R,G,B bits from H,V
1B2C(01A8) FF FF FF FF | longmask                long        $FFFFFFFF                        ' all bits set
1B30(01A9) 00 00 00 02 | slowbit                        long        1 << 25                                ' cnt mask for slow cursor blink
1B34(01AA) 00 00 00 01 | fastbit                        long        1 << 24                                ' cnt mask for fast cursor blink
1B38(01AB) 00 00 FF FF | underscore                long        $FFFF0000                        ' underscore cursor pattern
1B3C(01AC) 03 03 00 00 | hv                        long        hv_inactive                        ' -H,-V states
1B40(01AD) 03 01 00 00 | hvsync                        long        hv_inactive ^ $200                ' +/-H,-V states
1B44(01AE) 03 03 00 00 | bg_clut                        long        %00000011_00000011                ' black
1B48(01AF) 0B 03 00 00 |                         long        %00000011_00001011                ' dark blue
1B4C(01B0) 23 03 00 00 |                         long        %00000011_00100011                ' dark green
1B50(01B1) 2B 03 00 00 |                         long        %00000011_00101011                ' dark cyan
1B54(01B2) 83 03 00 00 |                         long        %00000011_10000011                ' dark red
1B58(01B3) 8B 03 00 00 |                         long        %00000011_10001011                ' dark magenta
1B5C(01B4) A3 03 00 00 |                         long        %00000011_10100011                ' brown
1B60(01B5) AB 03 00 00 |                         long        %00000011_10101011                ' light gray
1B64(01B6) 57 03 00 00 |                         long        %00000011_01010111                ' dark gray
1B68(01B7) 0F 03 00 00 |                         long        %00000011_00001111                ' light blue
1B6C(01B8) 33 03 00 00 |                         long        %00000011_00110011                ' light green
1B70(01B9) 3F 03 00 00 |                         long        %00000011_00111111                ' light cyan
1B74(01BA) C3 03 00 00 |                         long        %00000011_11000011                ' light red
1B78(01BB) CF 03 00 00 |                         long        %00000011_11001111                ' light magenta
1B7C(01BC) F3 03 00 00 |                         long        %00000011_11110011                ' light yellow
1B80(01BD) FF 03 00 00 |                         long        %00000011_11111111                ' white
1B84(01BE) 03 03 00 00 | fg_clut                        long        %00000011_00000011                ' black
1B88(01BF) 03 07 00 00 |                         long        %00000111_00000011                ' dark blue
1B8C(01C0) 03 13 00 00 |                         long        %00010011_00000011                ' dark green
1B90(01C1) 03 17 00 00 |                         long        %00010111_00000011                ' dark cyan
1B94(01C2) 03 43 00 00 |                         long        %01000011_00000011                ' dark red
1B98(01C3) 03 47 00 00 |                         long        %01000111_00000011                ' dark magenta
1B9C(01C4) 03 53 00 00 |                         long        %01010011_00000011                ' brown
1BA0(01C5) 03 AB 00 00 |                         long        %10101011_00000011                ' light gray
1BA4(01C6) 03 57 00 00 |                         long        %01010111_00000011                ' dark gray
1BA8(01C7) 03 0B 00 00 |                         long        %00001011_00000011                ' blue
1BAC(01C8) 03 23 00 00 |                         long        %00100011_00000011                ' green
1BB0(01C9) 03 2B 00 00 |                         long        %00101011_00000011                ' cyan
1BB4(01CA) 03 83 00 00 |                         long        %10000011_00000011                ' red
1BB8(01CB) 03 8B 00 00 |                         long        %10001011_00000011                ' magenta
1BBC(01CC) 03 A3 00 00 |                         long        %10100011_00000011                ' yellow
1BC0(01CD) 03 FF 00 00 |                         long        %11111111_00000011                ' white
1BC4(01CE)             | screen_ptr                res        1
1BC4(01CF)             | font_ptr                res        1
1BC4(01D0)             | x                        res        1
1BC4(01D1)             | y                        res        1
1BC4(01D2)             | z                        res        1
1BC4(01D3)             | fg                        res        1
1BC4(01D4)             | bg                        res        1
1BC4(01D5)             | row                        res        1
1BC4(01D6)             | fours                        res        1
1BC4(01D7)             |                         fit        $1f0
1BC4(01D7)             | There are 25 ($019) Longs left in the cog
1BC4(01D7) 00 00 00 00 | font        long
1BC4(01D7) 00 BA 82 00 |   long $0082ba00,$00000000,$2a552a00,$36360000,$061e0000,$061c0000,$06060000,$3c000000
1BC8(01D8) 00 00 00 00 | 
1BCC(01D9) 00 2A 55 2A | 
1BD0(01DA) 00 00 36 36 | 
1BD4(01DB) 00 00 1E 06 | 
1BD8(01DC) 00 00 1C 06 | 
1BDC(01DD) 00 00 06 06 | 
1BE0(01DE) 00 00 00 3C | 
1BE4(01DF) 00 00 00 00 |   long $00000000,$6e660000,$66660000,$18181818,$00000000,$00000000,$18181818,$18181818
1BE8(01E0) 00 00 66 6E | 
1BEC(01E1) 00 00 66 66 | 
1BF0(01E2) 18 18 18 18 | 
1BF4(01E3) 00 00 00 00 | 
1BF8(01E4) 00 00 00 00 | 
1BFC(01E5) 18 18 18 18 | 
1C00(01E6) 18 18 18 18 | 
1C04(01E7) FF FF 00 00 |   long $0000ffff,$00000000,$00000000,$00000000,$00000000,$18181818,$18181818,$18181818
1C08(01E8) 00 00 00 00 | 
1C0C(01E9) 00 00 00 00 | 
1C10(01EA) 00 00 00 00 | 
1C14(01EB) 00 00 00 00 | 
1C18(01EC) 18 18 18 18 | 
1C1C(01ED) 18 18 18 18 | 
1C20(01EE) 18 18 18 18 | 
1C24(01EF) 00 00 00 00 |   long $00000000,$18181818,$60000000,$06000000,$00000000,$00000000,$38000000,$00000000
1C28(01F0) 18 18 18 18 | 
1C2C(01F1) 00 00 00 60 | 
1C30(01F2) 00 00 00 06 | 
1C34(01F3) 00 00 00 00 | 
1C38(01F4) 00 00 00 00 | 
1C3C(01F5) 00 00 00 38 | 
1C40(01F6) 00 00 00 00 | 
1C44(01F7) 00 00 00 00 |   long $00000000,$18000000,$36000000,$24000000,$18000000,$4e000000,$1c000000,$18000000
1C48(01F8) 00 00 00 18 | 
1C4C(01F9) 00 00 00 36 | 
1C50(01FA) 00 00 00 24 | 
1C54(01FB) 00 00 00 18 | 
1C58(01FC) 00 00 00 4E | 
1C5C(01FD) 00 00 00 1C | 
1C60(01FE) 00 00 00 18 | 
1C64(01FF) 00 00 00 30 |   long $30000000,$0c000000,$00000000,$00000000,$00000000,$00000000,$00000000,$60000000
1C68(0200) 00 00 00 0C | 
1C6C(0201) 00 00 00 00 | 
1C70(0202) 00 00 00 00 | 
1C74(0203) 00 00 00 00 | 
1C78(0204) 00 00 00 00 | 
1C7C(0205) 00 00 00 00 | 
1C80(0206) 00 00 00 60 | 
1C84(0207) 00 00 00 18 |   long $18000000,$18000000,$3c000000,$7e000000,$60000000,$7e000000,$3c000000,$7e000000
1C88(0208) 00 00 00 18 | 
1C8C(0209) 00 00 00 3C | 
1C90(020A) 00 00 00 7E | 
1C94(020B) 00 00 00 60 | 
1C98(020C) 00 00 00 7E | 
1C9C(020D) 00 00 00 3C | 
1CA0(020E) 00 00 00 7E | 
1CA4(020F) 00 00 00 3C |   long $3c000000,$3c000000,$00000000,$00000000,$60000000,$00000000,$06000000,$3c000000
1CA8(0210) 00 00 00 3C | 
1CAC(0211) 00 00 00 00 | 
1CB0(0212) 00 00 00 00 | 
1CB4(0213) 00 00 00 60 | 
1CB8(0214) 00 00 00 00 | 
1CBC(0215) 00 00 00 06 | 
1CC0(0216) 00 00 00 3C | 
1CC4(0217) 00 00 00 3C |   long $3c000000,$3c000000,$3e000000,$3c000000,$3e000000,$7e000000,$7e000000,$3c000000
1CC8(0218) 00 00 00 3C | 
1CCC(0219) 00 00 00 3E | 
1CD0(021A) 00 00 00 3C | 
1CD4(021B) 00 00 00 3E | 
1CD8(021C) 00 00 00 7E | 
1CDC(021D) 00 00 00 7E | 
1CE0(021E) 00 00 00 3C | 
1CE4(021F) 00 00 00 66 |   long $66000000,$7e000000,$60000000,$46000000,$06000000,$42000000,$66000000,$3c000000
1CE8(0220) 00 00 00 7E | 
1CEC(0221) 00 00 00 60 | 
1CF0(0222) 00 00 00 46 | 
1CF4(0223) 00 00 00 06 | 
1CF8(0224) 00 00 00 42 | 
1CFC(0225) 00 00 00 66 | 
1D00(0226) 00 00 00 3C | 
1D04(0227) 00 00 00 3E |   long $3e000000,$3c000000,$3e000000,$3c000000,$7e000000,$66000000,$66000000,$66000000
1D08(0228) 00 00 00 3C | 
1D0C(0229) 00 00 00 3E | 
1D10(022A) 00 00 00 3C | 
1D14(022B) 00 00 00 7E | 
1D18(022C) 00 00 00 66 | 
1D1C(022D) 00 00 00 66 | 
1D20(022E) 00 00 00 66 | 
1D24(022F) 00 00 00 42 |   long $42000000,$66000000,$7e000000,$3c000000,$06000000,$3c000000,$18000000,$00000000
1D28(0230) 00 00 00 66 | 
1D2C(0231) 00 00 00 7E | 
1D30(0232) 00 00 00 3C | 
1D34(0233) 00 00 00 06 | 
1D38(0234) 00 00 00 3C | 
1D3C(0235) 00 00 00 18 | 
1D40(0236) 00 00 00 00 | 
1D44(0237) 00 00 0C 18 |   long $180c0000,$00000000,$06000000,$00000000,$60000000,$00000000,$38000000,$00000000
1D48(0238) 00 00 00 00 | 
1D4C(0239) 00 00 00 06 | 
1D50(023A) 00 00 00 00 | 
1D54(023B) 00 00 00 60 | 
1D58(023C) 00 00 00 00 | 
1D5C(023D) 00 00 00 38 | 
1D60(023E) 00 00 00 00 | 
1D64(023F) 00 00 00 06 |   long $06000000,$18000000,$60000000,$06000000,$1c000000,$00000000,$00000000,$00000000
1D68(0240) 00 00 00 18 | 
1D6C(0241) 00 00 00 60 | 
1D70(0242) 00 00 00 06 | 
1D74(0243) 00 00 00 1C | 
1D78(0244) 00 00 00 00 | 
1D7C(0245) 00 00 00 00 | 
1D80(0246) 00 00 00 00 | 
1D84(0247) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
1D88(0248) 00 00 00 00 | 
1D8C(0249) 00 00 00 00 | 
1D90(024A) 00 00 00 00 | 
1D94(024B) 00 00 00 00 | 
1D98(024C) 00 00 00 00 | 
1D9C(024D) 00 00 00 00 | 
1DA0(024E) 00 00 00 00 | 
1DA4(024F) 00 00 00 00 |   long $00000000,$00000000,$00000000,$38000000,$18000000,$1c000000,$4c000000,$aa55aa55
1DA8(0250) 00 00 00 00 | 
1DAC(0251) 00 00 00 00 | 
1DB0(0252) 00 00 00 38 | 
1DB4(0253) 00 00 00 18 | 
1DB8(0254) 00 00 00 1C | 
1DBC(0255) 00 00 00 4C | 
1DC0(0256) 55 AA 55 AA | 
1DC4(0257) 00 00 00 00 |   long $00000000,$00000000,$2a552a00,$36360000,$061e0000,$061c0000,$06060000,$3c000000
1DC8(0258) 00 00 00 00 | 
1DCC(0259) 00 2A 55 2A | 
1DD0(025A) 00 00 36 36 | 
1DD4(025B) 00 00 1E 06 | 
1DD8(025C) 00 00 1C 06 | 
1DDC(025D) 00 00 06 06 | 
1DE0(025E) 00 00 00 3C | 
1DE4(025F) 00 00 00 00 |   long $00000000,$6e660000,$66660000,$24242424,$00000000,$00000000,$24242424,$24242424
1DE8(0260) 00 00 66 6E | 
1DEC(0261) 00 00 66 66 | 
1DF0(0262) 24 24 24 24 | 
1DF4(0263) 00 00 00 00 | 
1DF8(0264) 00 00 00 00 | 
1DFC(0265) 24 24 24 24 | 
1E00(0266) 24 24 24 24 | 
1E04(0267) FF 00 FF 00 |   long $00ff00ff,$ff000000,$00000000,$00000000,$00000000,$24242424,$24242424,$24242424
1E08(0268) 00 00 00 FF | 
1E0C(0269) 00 00 00 00 | 
1E10(026A) 00 00 00 00 | 
1E14(026B) 00 00 00 00 | 
1E18(026C) 24 24 24 24 | 
1E1C(026D) 24 24 24 24 | 
1E20(026E) 24 24 24 24 | 
1E24(026F) 00 00 00 00 |   long $00000000,$24242424,$60000000,$06000000,$00000000,$00000000,$38000000,$00000000
1E28(0270) 24 24 24 24 | 
1E2C(0271) 00 00 00 60 | 
1E30(0272) 00 00 00 06 | 
1E34(0273) 00 00 00 00 | 
1E38(0274) 00 00 00 00 | 
1E3C(0275) 00 00 00 38 | 
1E40(0276) 00 00 00 00 | 
1E44(0277) 00 00 00 00 |   long $00000000,$18000000,$36000000,$24000000,$18000000,$4e000000,$1c000000,$18000000
1E48(0278) 00 00 00 18 | 
1E4C(0279) 00 00 00 36 | 
1E50(027A) 00 00 00 24 | 
1E54(027B) 00 00 00 18 | 
1E58(027C) 00 00 00 4E | 
1E5C(027D) 00 00 00 1C | 
1E60(027E) 00 00 00 18 | 
1E64(027F) 00 00 00 30 |   long $30000000,$0c000000,$00000000,$00000000,$00000000,$00000000,$00000000,$60000000
1E68(0280) 00 00 00 0C | 
1E6C(0281) 00 00 00 00 | 
1E70(0282) 00 00 00 00 | 
1E74(0283) 00 00 00 00 | 
1E78(0284) 00 00 00 00 | 
1E7C(0285) 00 00 00 00 | 
1E80(0286) 00 00 00 60 | 
1E84(0287) 00 00 00 18 |   long $18000000,$18000000,$3c000000,$7e000000,$60000000,$7e000000,$3c000000,$7e000000
1E88(0288) 00 00 00 18 | 
1E8C(0289) 00 00 00 3C | 
1E90(028A) 00 00 00 7E | 
1E94(028B) 00 00 00 60 | 
1E98(028C) 00 00 00 7E | 
1E9C(028D) 00 00 00 3C | 
1EA0(028E) 00 00 00 7E | 
1EA4(028F) 00 00 00 3C |   long $3c000000,$3c000000,$00000000,$00000000,$60000000,$00000000,$06000000,$3c000000
1EA8(0290) 00 00 00 3C | 
1EAC(0291) 00 00 00 00 | 
1EB0(0292) 00 00 00 00 | 
1EB4(0293) 00 00 00 60 | 
1EB8(0294) 00 00 00 00 | 
1EBC(0295) 00 00 00 06 | 
1EC0(0296) 00 00 00 3C | 
1EC4(0297) 00 00 00 3C |   long $3c000000,$3c000000,$3e000000,$3c000000,$3e000000,$7e000000,$7e000000,$3c000000
1EC8(0298) 00 00 00 3C | 
1ECC(0299) 00 00 00 3E | 
1ED0(029A) 00 00 00 3C | 
1ED4(029B) 00 00 00 3E | 
1ED8(029C) 00 00 00 7E | 
1EDC(029D) 00 00 00 7E | 
1EE0(029E) 00 00 00 3C | 
1EE4(029F) 00 00 00 66 |   long $66000000,$7e000000,$60000000,$46000000,$06000000,$42000000,$66000000,$3c000000
1EE8(02A0) 00 00 00 7E | 
1EEC(02A1) 00 00 00 60 | 
1EF0(02A2) 00 00 00 46 | 
1EF4(02A3) 00 00 00 06 | 
1EF8(02A4) 00 00 00 42 | 
1EFC(02A5) 00 00 00 66 | 
1F00(02A6) 00 00 00 3C | 
1F04(02A7) 00 00 00 3E |   long $3e000000,$3c000000,$3e000000,$3c000000,$7e000000,$66000000,$66000000,$66000000
1F08(02A8) 00 00 00 3C | 
1F0C(02A9) 00 00 00 3E | 
1F10(02AA) 00 00 00 3C | 
1F14(02AB) 00 00 00 7E | 
1F18(02AC) 00 00 00 66 | 
1F1C(02AD) 00 00 00 66 | 
1F20(02AE) 00 00 00 66 | 
1F24(02AF) 00 00 00 42 |   long $42000000,$66000000,$7e000000,$3c000000,$06000000,$3c000000,$18000000,$00000000
1F28(02B0) 00 00 00 66 | 
1F2C(02B1) 00 00 00 7E | 
1F30(02B2) 00 00 00 3C | 
1F34(02B3) 00 00 00 06 | 
1F38(02B4) 00 00 00 3C | 
1F3C(02B5) 00 00 00 18 | 
1F40(02B6) 00 00 00 00 | 
1F44(02B7) 00 00 0C 18 |   long $180c0000,$00000000,$06000000,$00000000,$60000000,$00000000,$38000000,$00000000
1F48(02B8) 00 00 00 00 | 
1F4C(02B9) 00 00 00 06 | 
1F50(02BA) 00 00 00 00 | 
1F54(02BB) 00 00 00 60 | 
1F58(02BC) 00 00 00 00 | 
1F5C(02BD) 00 00 00 38 | 
1F60(02BE) 00 00 00 00 | 
1F64(02BF) 00 00 00 06 |   long $06000000,$18000000,$60000000,$06000000,$1c000000,$00000000,$00000000,$00000000
1F68(02C0) 00 00 00 18 | 
1F6C(02C1) 00 00 00 60 | 
1F70(02C2) 00 00 00 06 | 
1F74(02C3) 00 00 00 1C | 
1F78(02C4) 00 00 00 00 | 
1F7C(02C5) 00 00 00 00 | 
1F80(02C6) 00 00 00 00 | 
1F84(02C7) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
1F88(02C8) 00 00 00 00 | 
1F8C(02C9) 00 00 00 00 | 
1F90(02CA) 00 00 00 00 | 
1F94(02CB) 00 00 00 00 | 
1F98(02CC) 00 00 00 00 | 
1F9C(02CD) 00 00 00 00 | 
1FA0(02CE) 00 00 00 00 | 
1FA4(02CF) 00 00 00 00 |   long $00000000,$00000000,$00000000,$38000000,$18000000,$1c000000,$4c000000,$aa55aa55
1FA8(02D0) 00 00 00 00 | 
1FAC(02D1) 00 00 00 00 | 
1FB0(02D2) 00 00 00 38 | 
1FB4(02D3) 00 00 00 18 | 
1FB8(02D4) 00 00 00 1C | 
1FBC(02D5) 00 00 00 4C | 
1FC0(02D6) 55 AA 55 AA | 
1FC4(02D7) 82 82 00 82 |   long $82008282,$3c180000,$2a552a55,$0036363e,$0006060e,$001c0606,$001e0606,$003c6666
1FC8(02D8) 00 00 18 3C | 
1FCC(02D9) 55 2A 55 2A | 
1FD0(02DA) 3E 36 36 00 | 
1FD4(02DB) 0E 06 06 00 | 
1FD8(02DC) 06 06 1C 00 | 
1FDC(02DD) 06 06 1E 00 | 
1FE0(02DE) 66 66 3C 00 | 
1FE4(02DF) 18 18 7E 18 |   long $187e1818,$0066767e,$00183c24,$1f181818,$1f000000,$f8000000,$f8181818,$ff181818
1FE8(02E0) 7E 76 66 00 | 
1FEC(02E1) 24 3C 18 00 | 
1FF0(02E2) 18 18 18 1F | 
1FF4(02E3) 00 00 00 1F | 
1FF8(02E4) 00 00 00 F8 | 
1FFC(02E5) 18 18 18 F8 | 
2000(02E6) 18 18 18 FF | 
2004(02E7) 00 00 00 00 |   long $00000000,$0000ffff,$00000000,$00000000,$00000000,$f8181818,$1f181818,$ff181818
2008(02E8) FF FF 00 00 | 
200C(02E9) 00 00 00 00 | 
2010(02EA) 00 00 00 00 | 
2014(02EB) 00 00 00 00 | 
2018(02EC) 18 18 18 F8 | 
201C(02ED) 18 18 18 1F | 
2020(02EE) 18 18 18 FF | 
2024(02EF) 00 00 00 FF |   long $ff000000,$18181818,$0c060c30,$3060300c,$667e0000,$187e3030,$3e0c0c6c,$18180000
2028(02F0) 18 18 18 18 | 
202C(02F1) 30 0C 06 0C | 
2030(02F2) 0C 30 60 30 | 
2034(02F3) 00 00 7E 66 | 
2038(02F4) 30 30 7E 18 | 
203C(02F5) 6C 0C 0C 3E | 
2040(02F6) 00 00 18 18 | 
2044(02F7) 00 00 00 00 |   long $00000000,$18181818,$00003636,$247e7e24,$3c1a5a3c,$18302e6a,$1c363636,$00181818
2048(02F8) 18 18 18 18 | 
204C(02F9) 36 36 00 00 | 
2050(02FA) 24 7E 7E 24 | 
2054(02FB) 3C 5A 1A 3C | 
2058(02FC) 6A 2E 30 18 | 
205C(02FD) 36 36 36 1C | 
2060(02FE) 18 18 18 00 | 
2064(02FF) 18 18 0C 0C |   long $0c0c1818,$30301818,$7e182400,$7e181800,$00000000,$00000000,$00000000,$18303060
2068(0300) 18 18 30 30 | 
206C(0301) 00 24 18 7E | 
2070(0302) 00 18 18 7E | 
2074(0303) 00 00 00 00 | 
2078(0304) 00 00 00 00 | 
207C(0305) 00 00 00 00 | 
2080(0306) 60 30 30 18 | 
2084(0307) 24 66 66 66 |   long $66666624,$18181a1c,$38606666,$3c183060,$666c7870,$663e0606,$3e060666,$30306060
2088(0308) 1C 1A 18 18 | 
208C(0309) 66 66 60 38 | 
2090(030A) 60 30 18 3C | 
2094(030B) 70 78 6C 66 | 
2098(030C) 06 06 3E 66 | 
209C(030D) 66 06 06 3E | 
20A0(030E) 60 60 30 30 | 
20A4(030F) 66 66 66 3C |   long $3c666666,$7c666666,$183c1800,$183c1800,$060c1830,$007e0000,$6030180c,$38606666
20A8(0310) 66 66 66 7C | 
20AC(0311) 00 18 3C 18 | 
20B0(0312) 00 18 3C 18 | 
20B4(0313) 30 18 0C 06 | 
20B8(0314) 00 00 7E 00 | 
20BC(0315) 0C 18 30 60 | 
20C0(0316) 66 66 60 38 | 
20C4(0317) 62 62 7A 6A |   long $6a7a6262,$7e666666,$3e666666,$06060666,$66666666,$3e060606,$3e060606,$76060666
20C8(0318) 66 66 66 7E | 
20CC(0319) 66 66 66 3E | 
20D0(031A) 66 06 06 06 | 
20D4(031B) 66 66 66 66 | 
20D8(031C) 06 06 06 3E | 
20DC(031D) 06 06 06 3E | 
20E0(031E) 66 06 06 76 | 
20E4(031F) 66 66 66 7E |   long $7e666666,$18181818,$60606060,$0e1e3666,$06060606,$667e7e66,$7e6e6e66,$66666666
20E8(0320) 18 18 18 18 | 
20EC(0321) 60 60 60 60 | 
20F0(0322) 66 36 1E 0E | 
20F4(0323) 06 06 06 06 | 
20F8(0324) 66 7E 7E 66 | 
20FC(0325) 66 6E 6E 7E | 
2100(0326) 66 66 66 66 | 
2104(0327) 66 66 66 3E |   long $3e666666,$66666666,$3e666666,$3c060666,$18181818,$66666666,$24246666,$66666666
2108(0328) 66 66 66 66 | 
210C(0329) 66 66 66 3E | 
2110(032A) 66 06 06 3C | 
2114(032B) 18 18 18 18 | 
2118(032C) 66 66 66 66 | 
211C(032D) 66 66 24 24 | 
2120(032E) 66 66 66 66 | 
2124(032F) 66 24 3C 18 |   long $183c2466,$183c3c66,$18306060,$0c0c0c0c,$180c0c06,$30303030,$0042663c,$00000000
2128(0330) 66 3C 3C 18 | 
212C(0331) 60 60 30 18 | 
2130(0332) 0C 0C 0C 0C | 
2134(0333) 06 0C 0C 18 | 
2138(0334) 30 30 30 30 | 
213C(0335) 3C 66 42 00 | 
2140(0336) 00 00 00 00 | 
2144(0337) 30 00 00 00 |   long $00000030,$603c0000,$663e0606,$663c0000,$667c6060,$663c0000,$1e0c0c6c,$665c0000
2148(0338) 00 00 3C 60 | 
214C(0339) 06 06 3E 66 | 
2150(033A) 00 00 3C 66 | 
2154(033B) 60 60 7C 66 | 
2158(033C) 00 00 3C 66 | 
215C(033D) 6C 0C 0C 1E | 
2160(033E) 00 00 5C 66 | 
2164(033F) 06 06 3E 66 |   long $663e0606,$181c0018,$60600060,$36660606,$18181818,$fe6a0000,$663e0000,$663c0000
2168(0340) 18 00 1C 18 | 
216C(0341) 60 00 60 60 | 
2170(0342) 06 06 66 36 | 
2174(0343) 18 18 18 18 | 
2178(0344) 00 00 6A FE | 
217C(0345) 00 00 3E 66 | 
2180(0346) 00 00 3C 66 | 
2184(0347) 00 00 3E 66 |   long $663e0000,$667c0000,$663e0000,$663c0000,$0c3e0c0c,$66660000,$66660000,$66660000
2188(0348) 00 00 7C 66 | 
218C(0349) 00 00 3E 66 | 
2190(034A) 00 00 3C 66 | 
2194(034B) 0C 0C 3E 0C | 
2198(034C) 00 00 66 66 | 
219C(034D) 00 00 66 66 | 
21A0(034E) 00 00 66 66 | 
21A4(034F) 00 00 66 66 |   long $66660000,$66660000,$607e0000,$0c180c0c,$18181818,$30183030,$0000327e,$aa55aa55
21A8(0350) 00 00 66 66 | 
21AC(0351) 00 00 7E 60 | 
21B0(0352) 0C 0C 18 0C | 
21B4(0353) 18 18 18 18 | 
21B8(0354) 30 30 18 30 | 
21BC(0355) 7E 32 00 00 | 
21C0(0356) 55 AA 55 AA | 
21C4(0357) 00 00 00 00 |   long $00000000,$3c180000,$2a552a55,$0036363e,$0006060e,$001c0606,$001e0606,$003c6666
21C8(0358) 00 00 18 3C | 
21CC(0359) 55 2A 55 2A | 
21D0(035A) 3E 36 36 00 | 
21D4(035B) 0E 06 06 00 | 
21D8(035C) 06 06 1C 00 | 
21DC(035D) 06 06 1E 00 | 
21E0(035E) 66 66 3C 00 | 
21E4(035F) 18 18 7E 18 |   long $187e1818,$0066767e,$00183c24,$20272424,$203f0000,$04fc0000,$04e42424,$00e72424
21E8(0360) 7E 76 66 00 | 
21EC(0361) 24 3C 18 00 | 
21F0(0362) 24 24 27 20 | 
21F4(0363) 00 00 3F 20 | 
21F8(0364) 00 00 FC 04 | 
21FC(0365) 24 24 E4 04 | 
2200(0366) 24 24 E7 00 | 
2204(0367) 00 00 00 00 |   long $00000000,$0000ff00,$ff000000,$00000000,$00000000,$04e42424,$20272424,$00e72424
2208(0368) 00 FF 00 00 | 
220C(0369) 00 00 00 FF | 
2210(036A) 00 00 00 00 | 
2214(036B) 00 00 00 00 | 
2218(036C) 24 24 E4 04 | 
221C(036D) 24 24 27 20 | 
2220(036E) 24 24 E7 00 | 
2224(036F) 00 00 FF 00 |   long $00ff0000,$24242424,$0c060c30,$3060300c,$667e0000,$187e3030,$3e0c0c6c,$18180000
2228(0370) 24 24 24 24 | 
222C(0371) 30 0C 06 0C | 
2230(0372) 0C 30 60 30 | 
2234(0373) 00 00 7E 66 | 
2238(0374) 30 30 7E 18 | 
223C(0375) 6C 0C 0C 3E | 
2240(0376) 00 00 18 18 | 
2244(0377) 00 00 00 00 |   long $00000000,$18181818,$00003636,$247e7e24,$3c1a5a3c,$18302e6a,$1c363636,$00181818
2248(0378) 18 18 18 18 | 
224C(0379) 36 36 00 00 | 
2250(037A) 24 7E 7E 24 | 
2254(037B) 3C 5A 1A 3C | 
2258(037C) 6A 2E 30 18 | 
225C(037D) 36 36 36 1C | 
2260(037E) 18 18 18 00 | 
2264(037F) 18 18 0C 0C |   long $0c0c1818,$30301818,$7e182400,$7e181800,$00000000,$00000000,$00000000,$18303060
2268(0380) 18 18 30 30 | 
226C(0381) 00 24 18 7E | 
2270(0382) 00 18 18 7E | 
2274(0383) 00 00 00 00 | 
2278(0384) 00 00 00 00 | 
227C(0385) 00 00 00 00 | 
2280(0386) 60 30 30 18 | 
2284(0387) 24 66 66 66 |   long $66666624,$18181a1c,$38606666,$3c183060,$666c7870,$663e0606,$3e060666,$30306060
2288(0388) 1C 1A 18 18 | 
228C(0389) 66 66 60 38 | 
2290(038A) 60 30 18 3C | 
2294(038B) 70 78 6C 66 | 
2298(038C) 06 06 3E 66 | 
229C(038D) 66 06 06 3E | 
22A0(038E) 60 60 30 30 | 
22A4(038F) 66 66 66 3C |   long $3c666666,$7c666666,$183c1800,$183c1800,$060c1830,$007e0000,$6030180c,$38606666
22A8(0390) 66 66 66 7C | 
22AC(0391) 00 18 3C 18 | 
22B0(0392) 00 18 3C 18 | 
22B4(0393) 30 18 0C 06 | 
22B8(0394) 00 00 7E 00 | 
22BC(0395) 0C 18 30 60 | 
22C0(0396) 66 66 60 38 | 
22C4(0397) 66 66 76 76 |   long $76766666,$7e666666,$3e666666,$06060666,$66666666,$3e060606,$3e060606,$76060666
22C8(0398) 66 66 66 7E | 
22CC(0399) 66 66 66 3E | 
22D0(039A) 66 06 06 06 | 
22D4(039B) 66 66 66 66 | 
22D8(039C) 06 06 06 3E | 
22DC(039D) 06 06 06 3E | 
22E0(039E) 66 06 06 76 | 
22E4(039F) 66 66 66 7E |   long $7e666666,$18181818,$60606060,$0e1e3666,$06060606,$667e7e66,$7e6e6e66,$66666666
22E8(03A0) 18 18 18 18 | 
22EC(03A1) 60 60 60 60 | 
22F0(03A2) 66 36 1E 0E | 
22F4(03A3) 06 06 06 06 | 
22F8(03A4) 66 7E 7E 66 | 
22FC(03A5) 66 6E 6E 7E | 
2300(03A6) 66 66 66 66 | 
2304(03A7) 66 66 66 3E |   long $3e666666,$66666666,$3e666666,$3c060666,$18181818,$66666666,$24246666,$66666666
2308(03A8) 66 66 66 66 | 
230C(03A9) 66 66 66 3E | 
2310(03AA) 66 06 06 3C | 
2314(03AB) 18 18 18 18 | 
2318(03AC) 66 66 66 66 | 
231C(03AD) 66 66 24 24 | 
2320(03AE) 66 66 66 66 | 
2324(03AF) 66 24 3C 18 |   long $183c2466,$183c3c66,$18306060,$0c0c0c0c,$180c0c06,$30303030,$0042663c,$00000000
2328(03B0) 66 3C 3C 18 | 
232C(03B1) 60 60 30 18 | 
2330(03B2) 0C 0C 0C 0C | 
2334(03B3) 06 0C 0C 18 | 
2338(03B4) 30 30 30 30 | 
233C(03B5) 3C 66 42 00 | 
2340(03B6) 00 00 00 00 | 
2344(03B7) 30 00 00 00 |   long $00000030,$603c0000,$663e0606,$663c0000,$667c6060,$663c0000,$1e0c0c6c,$665c0000
2348(03B8) 00 00 3C 60 | 
234C(03B9) 06 06 3E 66 | 
2350(03BA) 00 00 3C 66 | 
2354(03BB) 60 60 7C 66 | 
2358(03BC) 00 00 3C 66 | 
235C(03BD) 6C 0C 0C 1E | 
2360(03BE) 00 00 5C 66 | 
2364(03BF) 06 06 3E 66 |   long $663e0606,$181c0018,$60600060,$36660606,$18181818,$fe6a0000,$663e0000,$663c0000
2368(03C0) 18 00 1C 18 | 
236C(03C1) 60 00 60 60 | 
2370(03C2) 06 06 66 36 | 
2374(03C3) 18 18 18 18 | 
2378(03C4) 00 00 6A FE | 
237C(03C5) 00 00 3E 66 | 
2380(03C6) 00 00 3C 66 | 
2384(03C7) 00 00 3E 66 |   long $663e0000,$667c0000,$663e0000,$663c0000,$0c3e0c0c,$66660000,$66660000,$66660000
2388(03C8) 00 00 7C 66 | 
238C(03C9) 00 00 3E 66 | 
2390(03CA) 00 00 3C 66 | 
2394(03CB) 0C 0C 3E 0C | 
2398(03CC) 00 00 66 66 | 
239C(03CD) 00 00 66 66 | 
23A0(03CE) 00 00 66 66 | 
23A4(03CF) 00 00 66 66 |   long $66660000,$66660000,$607e0000,$0c180c0c,$18181818,$30183030,$0000327e,$aa55aa55
23A8(03D0) 00 00 66 66 | 
23AC(03D1) 00 00 7E 60 | 
23B0(03D2) 0C 0C 18 0C | 
23B4(03D3) 18 18 18 18 | 
23B8(03D4) 30 30 18 30 | 
23BC(03D5) 7E 32 00 00 | 
23C0(03D6) 55 AA 55 AA | 
23C4(03D7) 82 00 82 82 |   long $82820082,$00183c7e,$2a552a55,$30303078,$18381878,$58385838,$18381878,$00000000
23C8(03D8) 7E 3C 18 00 | 
23CC(03D9) 55 2A 55 2A | 
23D0(03DA) 78 30 30 30 | 
23D4(03DB) 78 18 38 18 | 
23D8(03DC) 38 58 38 58 | 
23DC(03DD) 78 18 38 18 | 
23E0(03DE) 00 00 00 00 | 
23E4(03DF) 18 00 7E 00 |   long $007e0018,$18181818,$30303078,$0000001f,$1818181f,$181818f8,$000000f8,$181818ff
23E8(03E0) 18 18 18 18 | 
23EC(03E1) 78 30 30 30 | 
23F0(03E2) 1F 00 00 00 | 
23F4(03E3) 1F 18 18 18 | 
23F8(03E4) F8 18 18 18 | 
23FC(03E5) F8 00 00 00 | 
2400(03E6) FF 18 18 18 | 
2404(03E7) 00 00 00 00 |   long $00000000,$00000000,$0000ffff,$ff000000,$00000000,$181818f8,$1818181f,$000000ff
2408(03E8) 00 00 00 00 | 
240C(03E9) FF FF 00 00 | 
2410(03EA) 00 00 00 FF | 
2414(03EB) 00 00 00 00 | 
2418(03EC) F8 18 18 18 | 
241C(03ED) 1F 18 18 18 | 
2420(03EE) FF 00 00 00 | 
2424(03EF) FF 18 18 18 |   long $181818ff,$18181818,$7e006030,$7e00060c,$66666666,$0c0c7e18,$3a6c0c0c,$00000000
2428(03F0) 18 18 18 18 | 
242C(03F1) 30 60 00 7E | 
2430(03F2) 0C 06 00 7E | 
2434(03F3) 66 66 66 66 | 
2438(03F4) 18 7E 0C 0C | 
243C(03F5) 0C 0C 6C 3A | 
2440(03F6) 00 00 00 00 | 
2444(03F7) 00 00 00 00 |   long $00000000,$18180018,$00000000,$24247e7e,$183c5a58,$7256740c,$5c367656,$00000000
2448(03F8) 18 00 18 18 | 
244C(03F9) 00 00 00 00 | 
2450(03FA) 7E 7E 24 24 | 
2454(03FB) 58 5A 3C 18 | 
2458(03FC) 0C 74 56 72 | 
245C(03FD) 56 76 36 5C | 
2460(03FE) 00 00 00 00 | 
2464(03FF) 0C 18 18 30 |   long $3018180c,$0c181830,$0024187e,$0018187e,$18383800,$0000007e,$3c180000,$06060c0c
2468(0400) 30 18 18 0C | 
246C(0401) 7E 18 24 00 | 
2470(0402) 7E 18 18 00 | 
2474(0403) 00 38 38 18 | 
2478(0404) 7E 00 00 00 | 
247C(0405) 00 00 18 3C | 
2480(0406) 0C 0C 06 06 | 
2484(0407) 66 66 24 18 |   long $18246666,$7e181818,$7e06060c,$3c666060,$60607e66,$3c666060,$3c666666,$0c0c1818
2488(0408) 18 18 18 7E | 
248C(0409) 0C 06 06 7E | 
2490(040A) 60 60 66 3C | 
2494(040B) 66 7E 60 60 | 
2498(040C) 60 60 66 3C | 
249C(040D) 66 66 66 3C | 
24A0(040E) 18 18 0C 0C | 
24A4(040F) 66 66 66 3C |   long $3c666666,$3c666060,$3c180000,$18383800,$6030180c,$00007e00,$060c1830,$18180018
24A8(0410) 60 60 66 3C | 
24AC(0411) 00 00 18 3C | 
24B0(0412) 00 38 38 18 | 
24B4(0413) 0C 18 30 60 | 
24B8(0414) 00 7E 00 00 | 
24BC(0415) 30 18 0C 06 | 
24C0(0416) 18 00 18 18 | 
24C4(0417) 7A 02 62 3C |   long $3c62027a,$66666666,$3e666666,$3c660606,$3e666666,$7e060606,$06060606,$7c666666
24C8(0418) 66 66 66 66 | 
24CC(0419) 66 66 66 3E | 
24D0(041A) 06 06 66 3C | 
24D4(041B) 66 66 66 3E | 
24D8(041C) 06 06 06 7E | 
24DC(041D) 06 06 06 06 | 
24E0(041E) 66 66 66 7C | 
24E4(041F) 66 66 66 66 |   long $66666666,$7e181818,$3c666060,$4666361e,$7e060606,$66666666,$66667676,$3c666666
24E8(0420) 18 18 18 7E | 
24EC(0421) 60 60 66 3C | 
24F0(0422) 1E 36 66 46 | 
24F4(0423) 06 06 06 7E | 
24F8(0424) 66 66 66 66 | 
24FC(0425) 76 76 66 66 | 
2500(0426) 66 66 66 3C | 
2504(0427) 06 06 06 06 |   long $06060606,$3c766e66,$4666361e,$3c666060,$18181818,$3c666666,$1818183c,$42667e7e
2508(0428) 66 6E 76 3C | 
250C(0429) 1E 36 66 46 | 
2510(042A) 60 60 66 3C | 
2514(042B) 18 18 18 18 | 
2518(042C) 66 66 66 3C | 
251C(042D) 3C 18 18 18 | 
2520(042E) 7E 7E 66 42 | 
2524(042F) 3C 24 66 42 |   long $4266243c,$18181818,$7e06060c,$3c0c0c0c,$60603030,$3c303030,$00000000,$fe000000
2528(0430) 18 18 18 18 | 
252C(0431) 0C 06 06 7E | 
2530(0432) 0C 0C 0C 3C | 
2534(0433) 30 30 60 60 | 
2538(0434) 30 30 30 3C | 
253C(0435) 00 00 00 00 | 
2540(0436) 00 00 00 FE | 
2544(0437) 00 00 00 00 |   long $00000000,$7c66667c,$3e666666,$3c660606,$7c666666,$3c66067e,$0c0c0c0c,$3c063c66
2548(0438) 7C 66 66 7C | 
254C(0439) 66 66 66 3E | 
2550(043A) 06 06 66 3C | 
2554(043B) 66 66 66 7C | 
2558(043C) 7E 06 66 3C | 
255C(043D) 0C 0C 0C 0C | 
2560(043E) 66 3C 06 3C | 
2564(043F) 66 66 66 66 |   long $66666666,$7e181818,$60606060,$66361e1e,$7e181818,$c6c6d6d6,$66666666,$3c666666
2568(0440) 18 18 18 7E | 
256C(0441) 60 60 60 60 | 
2570(0442) 1E 1E 36 66 | 
2574(0443) 18 18 18 7E | 
2578(0444) D6 D6 C6 C6 | 
257C(0445) 66 66 66 66 | 
2580(0446) 66 66 66 3C | 
2584(0447) 66 66 3E 06 |   long $063e6666,$607c6666,$06060606,$3c66300c,$386c0c0c,$7c666666,$183c3c66,$247e7e66
2588(0448) 66 66 7C 60 | 
258C(0449) 06 06 06 06 | 
2590(044A) 0C 30 66 3C | 
2594(044B) 0C 0C 6C 38 | 
2598(044C) 66 66 66 7C | 
259C(044D) 66 3C 3C 18 | 
25A0(044E) 66 7E 7E 24 | 
25A4(044F) 3C 3C 66 66 |   long $66663c3c,$607c6666,$7e060c30,$380c0c18,$18181818,$1c303018,$00000000,$aa55aa55
25A8(0450) 66 66 7C 60 | 
25AC(0451) 30 0C 06 7E | 
25B0(0452) 18 0C 0C 38 | 
25B4(0453) 18 18 18 18 | 
25B8(0454) 18 30 30 1C | 
25BC(0455) 00 00 00 00 | 
25C0(0456) 55 AA 55 AA | 
25C4(0457) 00 00 00 00 |   long $00000000,$00183c7e,$2a552a55,$30303078,$18381878,$58385838,$18381878,$00000000
25C8(0458) 7E 3C 18 00 | 
25CC(0459) 55 2A 55 2A | 
25D0(045A) 78 30 30 30 | 
25D4(045B) 78 18 38 18 | 
25D8(045C) 38 58 38 58 | 
25DC(045D) 78 18 38 18 | 
25E0(045E) 00 00 00 00 | 
25E4(045F) 18 00 7E 00 |   long $007e0018,$18181818,$30303078,$00003f20,$24242720,$2424e404,$0000fc04,$2424e700
25E8(0460) 18 18 18 18 | 
25EC(0461) 78 30 30 30 | 
25F0(0462) 20 3F 00 00 | 
25F4(0463) 20 27 24 24 | 
25F8(0464) 04 E4 24 24 | 
25FC(0465) 04 FC 00 00 | 
2600(0466) 00 E7 24 24 | 
2604(0467) 00 00 00 00 |   long $00000000,$00000000,$0000ff00,$00ff0000,$00000000,$2424e404,$24242720,$0000ff00
2608(0468) 00 00 00 00 | 
260C(0469) 00 FF 00 00 | 
2610(046A) 00 00 FF 00 | 
2614(046B) 00 00 00 00 | 
2618(046C) 04 E4 24 24 | 
261C(046D) 20 27 24 24 | 
2620(046E) 00 FF 00 00 | 
2624(046F) 00 E7 24 24 |   long $2424e700,$24242424,$7e006030,$7e00060c,$66666666,$0c0c7e18,$3a6c0c0c,$00000000
2628(0470) 24 24 24 24 | 
262C(0471) 30 60 00 7E | 
2630(0472) 0C 06 00 7E | 
2634(0473) 66 66 66 66 | 
2638(0474) 18 7E 0C 0C | 
263C(0475) 0C 0C 6C 3A | 
2640(0476) 00 00 00 00 | 
2644(0477) 00 00 00 00 |   long $00000000,$18180018,$00000000,$24247e7e,$183c5a58,$7256740c,$5c367656,$00000000
2648(0478) 18 00 18 18 | 
264C(0479) 00 00 00 00 | 
2650(047A) 7E 7E 24 24 | 
2654(047B) 58 5A 3C 18 | 
2658(047C) 0C 74 56 72 | 
265C(047D) 56 76 36 5C | 
2660(047E) 00 00 00 00 | 
2664(047F) 0C 18 18 30 |   long $3018180c,$0c181830,$0024187e,$0018187e,$18383800,$0000007e,$3c180000,$06060c0c
2668(0480) 30 18 18 0C | 
266C(0481) 7E 18 24 00 | 
2670(0482) 7E 18 18 00 | 
2674(0483) 00 38 38 18 | 
2678(0484) 7E 00 00 00 | 
267C(0485) 00 00 18 3C | 
2680(0486) 0C 0C 06 06 | 
2684(0487) 66 66 24 18 |   long $18246666,$7e181818,$7e06060c,$3c666060,$60607e66,$3c666060,$3c666666,$0c0c1818
2688(0488) 18 18 18 7E | 
268C(0489) 0C 06 06 7E | 
2690(048A) 60 60 66 3C | 
2694(048B) 66 7E 60 60 | 
2698(048C) 60 60 66 3C | 
269C(048D) 66 66 66 3C | 
26A0(048E) 18 18 0C 0C | 
26A4(048F) 66 66 66 3C |   long $3c666666,$3c666060,$3c180000,$18383800,$6030180c,$00007e00,$060c1830,$18180018
26A8(0490) 60 60 66 3C | 
26AC(0491) 00 00 18 3C | 
26B0(0492) 00 38 38 18 | 
26B4(0493) 0C 18 30 60 | 
26B8(0494) 00 7E 00 00 | 
26BC(0495) 30 18 0C 06 | 
26C0(0496) 18 00 18 18 | 
26C4(0497) 76 06 66 3C |   long $3c660676,$66666666,$3e666666,$3c660606,$3e666666,$7e060606,$06060606,$7c666666
26C8(0498) 66 66 66 66 | 
26CC(0499) 66 66 66 3E | 
26D0(049A) 06 06 66 3C | 
26D4(049B) 66 66 66 3E | 
26D8(049C) 06 06 06 7E | 
26DC(049D) 06 06 06 06 | 
26E0(049E) 66 66 66 7C | 
26E4(049F) 66 66 66 66 |   long $66666666,$7e181818,$3c666060,$4666361e,$7e060606,$66666666,$66667676,$3c666666
26E8(04A0) 18 18 18 7E | 
26EC(04A1) 60 60 66 3C | 
26F0(04A2) 1E 36 66 46 | 
26F4(04A3) 06 06 06 7E | 
26F8(04A4) 66 66 66 66 | 
26FC(04A5) 76 76 66 66 | 
2700(04A6) 66 66 66 3C | 
2704(04A7) 06 06 06 06 |   long $06060606,$3c766e66,$4666361e,$3c666060,$18181818,$3c666666,$1818183c,$42667e7e
2708(04A8) 66 6E 76 3C | 
270C(04A9) 1E 36 66 46 | 
2710(04AA) 60 60 66 3C | 
2714(04AB) 18 18 18 18 | 
2718(04AC) 66 66 66 3C | 
271C(04AD) 3C 18 18 18 | 
2720(04AE) 7E 7E 66 42 | 
2724(04AF) 3C 24 66 42 |   long $4266243c,$18181818,$7e06060c,$3c0c0c0c,$60603030,$3c303030,$00000000,$fe000000
2728(04B0) 18 18 18 18 | 
272C(04B1) 0C 06 06 7E | 
2730(04B2) 0C 0C 0C 3C | 
2734(04B3) 30 30 60 60 | 
2738(04B4) 30 30 30 3C | 
273C(04B5) 00 00 00 00 | 
2740(04B6) 00 00 00 FE | 
2744(04B7) 00 00 00 00 |   long $00000000,$7c66667c,$3e666666,$3c660606,$7c666666,$3c66067e,$0c0c0c0c,$3c063c66
2748(04B8) 7C 66 66 7C | 
274C(04B9) 66 66 66 3E | 
2750(04BA) 06 06 66 3C | 
2754(04BB) 66 66 66 7C | 
2758(04BC) 7E 06 66 3C | 
275C(04BD) 0C 0C 0C 0C | 
2760(04BE) 66 3C 06 3C | 
2764(04BF) 66 66 66 66 |   long $66666666,$7e181818,$60606060,$66361e1e,$7e181818,$c6c6d6d6,$66666666,$3c666666
2768(04C0) 18 18 18 7E | 
276C(04C1) 60 60 60 60 | 
2770(04C2) 1E 1E 36 66 | 
2774(04C3) 18 18 18 7E | 
2778(04C4) D6 D6 C6 C6 | 
277C(04C5) 66 66 66 66 | 
2780(04C6) 66 66 66 3C | 
2784(04C7) 66 66 3E 06 |   long $063e6666,$607c6666,$06060606,$3c66300c,$386c0c0c,$7c666666,$183c3c66,$247e7e66
2788(04C8) 66 66 7C 60 | 
278C(04C9) 06 06 06 06 | 
2790(04CA) 0C 30 66 3C | 
2794(04CB) 0C 0C 6C 38 | 
2798(04CC) 66 66 66 7C | 
279C(04CD) 66 3C 3C 18 | 
27A0(04CE) 66 7E 7E 24 | 
27A4(04CF) 3C 3C 66 66 |   long $66663c3c,$607c6666,$7e060c30,$380c0c18,$18181818,$1c303018,$00000000,$aa55aa55
27A8(04D0) 66 66 7C 60 | 
27AC(04D1) 30 0C 06 7E | 
27B0(04D2) 18 0C 0C 38 | 
27B4(04D3) 18 18 18 18 | 
27B8(04D4) 18 30 30 1C | 
27BC(04D5) 00 00 00 00 | 
27C0(04D6) 55 AA 55 AA | 
27C4(04D7) 00 82 BA 00 |   long $00ba8200,$00000000,$00002a55,$00000030,$00000018,$00000058,$00000018,$00000000
27C8(04D8) 00 00 00 00 | 
27CC(04D9) 55 2A 00 00 | 
27D0(04DA) 30 00 00 00 | 
27D4(04DB) 18 00 00 00 | 
27D8(04DC) 58 00 00 00 | 
27DC(04DD) 18 00 00 00 | 
27E0(04DE) 00 00 00 00 | 
27E4(04DF) 00 00 00 00 |   long $00000000,$00000078,$00000030,$00000000,$18181818,$18181818,$00000000,$18181818
27E8(04E0) 78 00 00 00 | 
27EC(04E1) 30 00 00 00 | 
27F0(04E2) 00 00 00 00 | 
27F4(04E3) 18 18 18 18 | 
27F8(04E4) 18 18 18 18 | 
27FC(04E5) 00 00 00 00 | 
2800(04E6) 18 18 18 18 | 
2804(04E7) 00 00 00 00 |   long $00000000,$00000000,$00000000,$000000ff,$ffff0000,$18181818,$18181818,$00000000
2808(04E8) 00 00 00 00 | 
280C(04E9) 00 00 00 00 | 
2810(04EA) FF 00 00 00 | 
2814(04EB) 00 00 FF FF | 
2818(04EC) 18 18 18 18 | 
281C(04ED) 18 18 18 18 | 
2820(04EE) 00 00 00 00 | 
2824(04EF) 18 18 18 18 |   long $18181818,$18181818,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
2828(04F0) 18 18 18 18 | 
282C(04F1) 00 00 00 00 | 
2830(04F2) 00 00 00 00 | 
2834(04F3) 00 00 00 00 | 
2838(04F4) 00 00 00 00 | 
283C(04F5) 00 00 00 00 | 
2840(04F6) 00 00 00 00 | 
2844(04F7) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
2848(04F8) 00 00 00 00 | 
284C(04F9) 00 00 00 00 | 
2850(04FA) 00 00 00 00 | 
2854(04FB) 00 00 00 00 | 
2858(04FC) 00 00 00 00 | 
285C(04FD) 00 00 00 00 | 
2860(04FE) 00 00 00 00 | 
2864(04FF) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$0000000c,$00000000,$00000018,$00000000
2868(0500) 00 00 00 00 | 
286C(0501) 00 00 00 00 | 
2870(0502) 00 00 00 00 | 
2874(0503) 0C 00 00 00 | 
2878(0504) 00 00 00 00 | 
287C(0505) 18 00 00 00 | 
2880(0506) 00 00 00 00 | 
2884(0507) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
2888(0508) 00 00 00 00 | 
288C(0509) 00 00 00 00 | 
2890(050A) 00 00 00 00 | 
2894(050B) 00 00 00 00 | 
2898(050C) 00 00 00 00 | 
289C(050D) 00 00 00 00 | 
28A0(050E) 00 00 00 00 | 
28A4(050F) 00 00 00 00 |   long $00000000,$00000000,$00000018,$0000000c,$00000000,$00000000,$00000000,$00000000
28A8(0510) 00 00 00 00 | 
28AC(0511) 18 00 00 00 | 
28B0(0512) 0C 00 00 00 | 
28B4(0513) 00 00 00 00 | 
28B8(0514) 00 00 00 00 | 
28BC(0515) 00 00 00 00 | 
28C0(0516) 00 00 00 00 | 
28C4(0517) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
28C8(0518) 00 00 00 00 | 
28CC(0519) 00 00 00 00 | 
28D0(051A) 00 00 00 00 | 
28D4(051B) 00 00 00 00 | 
28D8(051C) 00 00 00 00 | 
28DC(051D) 00 00 00 00 | 
28E0(051E) 00 00 00 00 | 
28E4(051F) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
28E8(0520) 00 00 00 00 | 
28EC(0521) 00 00 00 00 | 
28F0(0522) 00 00 00 00 | 
28F4(0523) 00 00 00 00 | 
28F8(0524) 00 00 00 00 | 
28FC(0525) 00 00 00 00 | 
2900(0526) 00 00 00 00 | 
2904(0527) 00 00 00 00 |   long $00000000,$00000060,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
2908(0528) 60 00 00 00 | 
290C(0529) 00 00 00 00 | 
2910(052A) 00 00 00 00 | 
2914(052B) 00 00 00 00 | 
2918(052C) 00 00 00 00 | 
291C(052D) 00 00 00 00 | 
2920(052E) 00 00 00 00 | 
2924(052F) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$000000fe
2928(0530) 00 00 00 00 | 
292C(0531) 00 00 00 00 | 
2930(0532) 00 00 00 00 | 
2934(0533) 00 00 00 00 | 
2938(0534) 00 00 00 00 | 
293C(0535) 00 00 00 00 | 
2940(0536) FE 00 00 00 | 
2944(0537) 00 00 00 00 |   long $00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000,$00003c66
2948(0538) 00 00 00 00 | 
294C(0539) 00 00 00 00 | 
2950(053A) 00 00 00 00 | 
2954(053B) 00 00 00 00 | 
2958(053C) 00 00 00 00 | 
295C(053D) 00 00 00 00 | 
2960(053E) 66 3C 00 00 | 
2964(053F) 00 00 00 00 |   long $00000000,$00000000,$00003c66,$00000000,$00000000,$00000000,$00000000,$00000000
2968(0540) 00 00 00 00 | 
296C(0541) 66 3C 00 00 | 
2970(0542) 00 00 00 00 | 
2974(0543) 00 00 00 00 | 
2978(0544) 00 00 00 00 | 
297C(0545) 00 00 00 00 | 
2980(0546) 00 00 00 00 | 
2984(0547) 06 06 00 00 |   long $00000606,$00006060,$00000000,$00000000,$00000000,$00000000,$00000000,$00000000
2988(0548) 60 60 00 00 | 
298C(0549) 00 00 00 00 | 
2990(054A) 00 00 00 00 | 
2994(054B) 00 00 00 00 | 
2998(054C) 00 00 00 00 | 
299C(054D) 00 00 00 00 | 
29A0(054E) 00 00 00 00 | 
29A4(054F) 00 00 00 00 |   long $00000000,$00003c66,$00000000,$00000000,$00000000,$00000000,$00000000,$aa55aa55
29A8(0550) 66 3C 00 00 | 
29AC(0551) 00 00 00 00 | 
29B0(0552) 00 00 00 00 | 
29B4(0553) 00 00 00 00 | 
29B8(0554) 00 00 00 00 | 
29BC(0555) 00 00 00 00 | 
29C0(0556) 55 AA 55 AA | 
29C4(0557) 00 00 00 FF |   long $ff000000,$ff000000,$ff002a55,$ff000030,$ff000018,$ff000058,$ff000018,$ff000000
29C8(0558) 00 00 00 FF | 
29CC(0559) 55 2A 00 FF | 
29D0(055A) 30 00 00 FF | 
29D4(055B) 18 00 00 FF | 
29D8(055C) 58 00 00 FF | 
29DC(055D) 18 00 00 FF | 
29E0(055E) 00 00 00 FF | 
29E4(055F) 00 00 00 FF |   long $ff000000,$ff000078,$ff000030,$00000000,$24242424,$24242424,$00000000,$24242424
29E8(0560) 78 00 00 FF | 
29EC(0561) 30 00 00 FF | 
29F0(0562) 00 00 00 00 | 
29F4(0563) 24 24 24 24 | 
29F8(0564) 24 24 24 24 | 
29FC(0565) 00 00 00 00 | 
2A00(0566) 24 24 24 24 | 
2A04(0567) 00 00 00 00 |   long $00000000,$00000000,$00000000,$000000ff,$ff00ff00,$24242424,$24242424,$00000000
2A08(0568) 00 00 00 00 | 
2A0C(0569) 00 00 00 00 | 
2A10(056A) FF 00 00 00 | 
2A14(056B) 00 FF 00 FF | 
2A18(056C) 24 24 24 24 | 
2A1C(056D) 24 24 24 24 | 
2A20(056E) 00 00 00 00 | 
2A24(056F) 24 24 24 24 |   long $24242424,$24242424,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2A28(0570) 24 24 24 24 | 
2A2C(0571) 00 00 00 FF | 
2A30(0572) 00 00 00 FF | 
2A34(0573) 00 00 00 FF | 
2A38(0574) 00 00 00 FF | 
2A3C(0575) 00 00 00 FF | 
2A40(0576) 00 00 00 FF | 
2A44(0577) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2A48(0578) 00 00 00 FF | 
2A4C(0579) 00 00 00 FF | 
2A50(057A) 00 00 00 FF | 
2A54(057B) 00 00 00 FF | 
2A58(057C) 00 00 00 FF | 
2A5C(057D) 00 00 00 FF | 
2A60(057E) 00 00 00 FF | 
2A64(057F) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff00000c,$ff000000,$ff000018,$ff000000
2A68(0580) 00 00 00 FF | 
2A6C(0581) 00 00 00 FF | 
2A70(0582) 00 00 00 FF | 
2A74(0583) 0C 00 00 FF | 
2A78(0584) 00 00 00 FF | 
2A7C(0585) 18 00 00 FF | 
2A80(0586) 00 00 00 FF | 
2A84(0587) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2A88(0588) 00 00 00 FF | 
2A8C(0589) 00 00 00 FF | 
2A90(058A) 00 00 00 FF | 
2A94(058B) 00 00 00 FF | 
2A98(058C) 00 00 00 FF | 
2A9C(058D) 00 00 00 FF | 
2AA0(058E) 00 00 00 FF | 
2AA4(058F) 00 00 00 FF |   long $ff000000,$ff000000,$ff000018,$ff00000c,$ff000000,$ff000000,$ff000000,$ff000000
2AA8(0590) 00 00 00 FF | 
2AAC(0591) 18 00 00 FF | 
2AB0(0592) 0C 00 00 FF | 
2AB4(0593) 00 00 00 FF | 
2AB8(0594) 00 00 00 FF | 
2ABC(0595) 00 00 00 FF | 
2AC0(0596) 00 00 00 FF | 
2AC4(0597) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2AC8(0598) 00 00 00 FF | 
2ACC(0599) 00 00 00 FF | 
2AD0(059A) 00 00 00 FF | 
2AD4(059B) 00 00 00 FF | 
2AD8(059C) 00 00 00 FF | 
2ADC(059D) 00 00 00 FF | 
2AE0(059E) 00 00 00 FF | 
2AE4(059F) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2AE8(05A0) 00 00 00 FF | 
2AEC(05A1) 00 00 00 FF | 
2AF0(05A2) 00 00 00 FF | 
2AF4(05A3) 00 00 00 FF | 
2AF8(05A4) 00 00 00 FF | 
2AFC(05A5) 00 00 00 FF | 
2B00(05A6) 00 00 00 FF | 
2B04(05A7) 00 00 00 FF |   long $ff000000,$ff000060,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2B08(05A8) 60 00 00 FF | 
2B0C(05A9) 00 00 00 FF | 
2B10(05AA) 00 00 00 FF | 
2B14(05AB) 00 00 00 FF | 
2B18(05AC) 00 00 00 FF | 
2B1C(05AD) 00 00 00 FF | 
2B20(05AE) 00 00 00 FF | 
2B24(05AF) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff0000fe
2B28(05B0) 00 00 00 FF | 
2B2C(05B1) 00 00 00 FF | 
2B30(05B2) 00 00 00 FF | 
2B34(05B3) 00 00 00 FF | 
2B38(05B4) 00 00 00 FF | 
2B3C(05B5) 00 00 00 FF | 
2B40(05B6) FE 00 00 FF | 
2B44(05B7) 00 00 00 FF |   long $ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff003c66
2B48(05B8) 00 00 00 FF | 
2B4C(05B9) 00 00 00 FF | 
2B50(05BA) 00 00 00 FF | 
2B54(05BB) 00 00 00 FF | 
2B58(05BC) 00 00 00 FF | 
2B5C(05BD) 00 00 00 FF | 
2B60(05BE) 66 3C 00 FF | 
2B64(05BF) 00 00 00 FF |   long $ff000000,$ff000000,$ff003c66,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2B68(05C0) 00 00 00 FF | 
2B6C(05C1) 66 3C 00 FF | 
2B70(05C2) 00 00 00 FF | 
2B74(05C3) 00 00 00 FF | 
2B78(05C4) 00 00 00 FF | 
2B7C(05C5) 00 00 00 FF | 
2B80(05C6) 00 00 00 FF | 
2B84(05C7) 06 06 00 FF |   long $ff000606,$ff006060,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000
2B88(05C8) 60 60 00 FF | 
2B8C(05C9) 00 00 00 FF | 
2B90(05CA) 00 00 00 FF | 
2B94(05CB) 00 00 00 FF | 
2B98(05CC) 00 00 00 FF | 
2B9C(05CD) 00 00 00 FF | 
2BA0(05CE) 00 00 00 FF | 
2BA4(05CF) 00 00 00 FF |   long $ff000000,$ff003c66,$ff000000,$ff000000,$ff000000,$ff000000,$ff000000,$ff55aa55
2BA8(05D0) 66 3C 00 FF | 
2BAC(05D1) 00 00 00 FF | 
2BB0(05D2) 00 00 00 FF | 
2BB4(05D3) 00 00 00 FF | 
2BB8(05D4) 00 00 00 FF | 
2BBC(05D5) 00 00 00 FF | 
2BC0(05D6) 55 AA 55 FF | 
|===========================================================================|
|===========================================================================|
Spin Block start with 4 Parameters and 2 Extra Stack Longs. Method 1
PUB start(BasePin, ScreenPtr, CursorPtr, SyncPtr) : okay | i, j

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - BasePin
Local Parameter DBASE:0008 - ScreenPtr
Local Parameter DBASE:000C - CursorPtr
Local Parameter DBASE:0010 - SyncPtr
Local Variable  DBASE:0014 - i
Local Variable  DBASE:0018 - j
|===========================================================================|
85                              stop
Addr : 2BC4:             01  : Drop Anchor   
Addr : 2BC5:          05 02  : Call Sub 2    
88                              reg_vcfg := $200000FF + (BasePin & %111000) << 6
Addr : 2BC7: 3B 20 00 00 FF  : Constant 4 Bytes - 20 00 00 FF 
Addr : 2BCC:             64  : Variable Operation Local Offset - 1 Read
Addr : 2BCD:          38 38  : Constant 1 Bytes - 38 
Addr : 2BCF:             E8  : Math Op &     
Addr : 2BD0:          38 06  : Constant 1 Bytes - 06 
Addr : 2BD2:             E3  : Math Op <<    
Addr : 2BD3:             EC  : Math Op +     
Addr : 2BD4:       C5 80 98  : Memory Op Long PBASE + WRITE Address = 0098
89                              i := $FF << (BasePin & %011000)
Addr : 2BD7:          37 27  : Constant Mask Y=39 Decrement 000000FF
Addr : 2BD9:             64  : Variable Operation Local Offset - 1 Read
Addr : 2BDA:          38 18  : Constant 1 Bytes - 18 
Addr : 2BDC:             E8  : Math Op &     
Addr : 2BDD:             E3  : Math Op <<    
Addr : 2BDE:             75  : Variable Operation Local Offset - 5 Write
90                              j := BasePin & %100000 == 0
Addr : 2BDF:             64  : Variable Operation Local Offset - 1 Read
Addr : 2BE0:          37 04  : Constant Mask Y=4 00000020
Addr : 2BE2:             E8  : Math Op &     
Addr : 2BE3:             35  : Constant 1 $00000000
Addr : 2BE4:             FC  : Math Op ==    
Addr : 2BE5:             79  : Variable Operation Local Offset - 6 Write
91                              reg_dira := i & j
Addr : 2BE6:             74  : Variable Operation Local Offset - 5 Read
Addr : 2BE7:             78  : Variable Operation Local Offset - 6 Read
Addr : 2BE8:             E8  : Math Op &     
Addr : 2BE9:       C5 80 90  : Memory Op Long PBASE + WRITE Address = 0090
92                              reg_dirb := i & !j
Addr : 2BEC:             74  : Variable Operation Local Offset - 5 Read
Addr : 2BED:             78  : Variable Operation Local Offset - 6 Read
Addr : 2BEE:             E7  : Math Op !     
Addr : 2BEF:             E8  : Math Op &     
Addr : 2BF0:       C5 80 94  : Memory Op Long PBASE + WRITE Address = 0094
95                              sync_cnt := cnt + $10000
Addr : 2BF3:          3F 91  : Register op CNT Read
Addr : 2BF5:          37 0F  : Constant Mask Y=15 00010000
Addr : 2BF7:             EC  : Math Op +     
Addr : 2BF8:       C5 80 9C  : Memory Op Long PBASE + WRITE Address = 009C
98                              longmove(@screen_base, @ScreenPtr, 2)
Addr : 2BFB:       C7 82 10  : Memory Op Long PBASE + ADDRESS Address = 0210
Addr : 2BFE:             6B  : Variable Operation Local Offset - 2 Address
Addr : 2BFF:          37 00  : Constant Mask Y=0 00000002
Addr : 2C01:             1E  : LongMove(To, From, Count)
99                              font_base := @font
Addr : 2C02:       C7 82 CC  : Memory Op Long PBASE + ADDRESS Address = 02CC
Addr : 2C05:       C5 82 18  : Memory Op Long PBASE + WRITE Address = 0218
102                              vf_lines.byte := vf
Addr : 2C08:          38 14  : Constant 1 Bytes - 14 
Addr : 2C0A:       85 81 D8  : Memory Op Byte PBASE + WRITE Address = 01D8
103                              vb_lines.byte := vb
Addr : 2C0D:          38 11  : Constant 1 Bytes - 11 
Addr : 2C0F:       85 80 A8  : Memory Op Byte PBASE + WRITE Address = 00A8
104                              font_part := 1
Addr : 2C12:             36  : Constant 2 $00000001
Addr : 2C13:       C5 82 1C  : Memory Op Long PBASE + WRITE Address = 021C
105                              cog[1] := cognew(@d0, SyncPtr) + 1
Addr : 2C16:             34  : Constant 0 $FFFFFFFF
Addr : 2C17:          C7 0C  : Memory Op Long PBASE + ADDRESS Address = 000C
Addr : 2C19:             70  : Variable Operation Local Offset - 4 Read
Addr : 2C1A:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 2C1B:             36  : Constant 2 $00000001
Addr : 2C1C:             EC  : Math Op +     
Addr : 2C1D:             36  : Constant 2 $00000001
Addr : 2C1E:          D9 00  : Memory Op Long VBASE + POP Index WRITE Address = 0000
108                              waitcnt($2000 + cnt)
Addr : 2C20:          37 0C  : Constant Mask Y=12 00002000
Addr : 2C22:          3F 91  : Register op CNT Read
Addr : 2C24:             EC  : Math Op +     
Addr : 2C25:             23  : WaitCnt(count)
111                              vf_lines.byte := vf+4
Addr : 2C26:          38 14  : Constant 1 Bytes - 14 
Addr : 2C28:          37 01  : Constant Mask Y=1 00000004
Addr : 2C2A:             EC  : Math Op +     
Addr : 2C2B:       85 81 D8  : Memory Op Byte PBASE + WRITE Address = 01D8
112                              vb_lines.byte := vb-4
Addr : 2C2E:          38 11  : Constant 1 Bytes - 11 
Addr : 2C30:          37 01  : Constant Mask Y=1 00000004
Addr : 2C32:             ED  : Math Op -     
Addr : 2C33:       85 80 A8  : Memory Op Byte PBASE + WRITE Address = 00A8
113                              font_part := 0
Addr : 2C36:             35  : Constant 1 $00000000
Addr : 2C37:       C5 82 1C  : Memory Op Long PBASE + WRITE Address = 021C
114                              cog[0] := cognew(@d0, SyncPtr) + 1
Addr : 2C3A:             34  : Constant 0 $FFFFFFFF
Addr : 2C3B:          C7 0C  : Memory Op Long PBASE + ADDRESS Address = 000C
Addr : 2C3D:             70  : Variable Operation Local Offset - 4 Read
Addr : 2C3E:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 2C3F:             36  : Constant 2 $00000001
Addr : 2C40:             EC  : Math Op +     
Addr : 2C41:             35  : Constant 1 $00000000
Addr : 2C42:          D9 00  : Memory Op Long VBASE + POP Index WRITE Address = 0000
117                              if cog[0] and cog[1]
Addr : 2C44:             35  : Constant 1 $00000000
Addr : 2C45:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 2C47:             36  : Constant 2 $00000001
Addr : 2C48:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 2C4A:             F0  : Math Op AND   
Addr : 2C4B: JZ Label0008
Addr : 2C4B:          0A 02  : jz Address = 2C4F 2
119                                      return 0
Addr : 2C4D:             35  : Constant 1 $00000000
Addr : 2C4E:             33  : Return value  
Addr : 2C4F: Label0008
Addr : 2C4F: Label0009
122                              stop
Addr : 2C4F:             01  : Drop Anchor   
Addr : 2C50:          05 02  : Call Sub 2    
Addr : 2C52:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 1 Extra Stack Longs. Method 2
PUB stop | i

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - i
|===========================================================================|
129                              repeat i from 0 to 1
Addr : 2C53:             35  : Constant 1 $00000000
Addr : 2C54:             65  : Variable Operation Local Offset - 1 Write
Addr : 2C55: Label0008
Addr : 2C55: Label0009
Addr : 2C55:             35  : Constant 1 $00000000
Addr : 2C56:             36  : Constant 2 $00000001
Addr : 2C57: Repeat i Step Label0008
Addr : 2C57:       66 02 7B  : Variable Operation Local Offset - 1 Assign Repeat-Var loop Address= 2C55 -5
Addr : 2C5A: Label000A
130                              if cog[i]
Addr : 2C5A:             64  : Variable Operation Local Offset - 1 Read
Addr : 2C5B:          D8 00  : Memory Op Long VBASE + POP Index READ Address = 0000
Addr : 2C5D: JZ Label000B
Addr : 2C5D:          0A 00  : jz Address = 2C5F 0
Addr : 2C5F: Label000B
Addr : 2C5F: Label000C
131                              cogstop(cog[i]~ - 1)
Addr : 2C5F:             64  : Variable Operation Local Offset - 1 Read
Addr : 2C60:       DA 00 98  : Memory Op Long VBASE + POP Index ASSIGN Address = 0000 VAR~ Post-clear Push
Addr : 2C63:             36  : Constant 2 $00000001
Addr : 2C64:             ED  : Math Op -     
Addr : 2C65:             21  : CogStop(id)   
Addr : 2C66:             32  : Return        
|===========================================================================|
Object vt100
Object Base is 2C68
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable cog
|===========================================================================|
Object DAT Blocks
|===========================================================================|
2C74(0000)             |                 org        0
2C74(0000)             | entry
2C74(0000) F0 69 BC A0 | command_ptr        mov        t1, PAR
2C78(0001) 34 00 BC 08 | cmd                rdlong        command_ptr, t1                ' parameter 0
2C7C(0002) 04 68 FC 80 | screen_ptr        add        t1, #4
2C80(0003) 34 04 BC 08 | screen_end        rdlong        screen_ptr, t1                ' parameter 1
2C84(0004) 04 68 FC 80 | cursor_ptr        add        t1, #4
2C88(0005) 34 08 BC 08 | vsync_ptr        rdlong        cursor_ptr, t1                ' parameter 2
2C8C(0006) 04 68 FC 80 | screen_w        add        t1, #4
2C90(0007) 34 0A BC 08 | screen_w2        rdlong        vsync_ptr, t1                ' parameter 3
2C94(0008) 04 68 FC 80 | screen_h        add        t1, #4
2C98(0009) 34 0C BC 08 | cur_ptr         rdlong        screen_w, t1                ' parameter 4
2C9C(000A) 04 68 FC 80 | scroll_top        add        t1, #4
2CA0(000B) 34 10 BC 08 | scroll_bot        rdlong        screen_h, t1                ' parameter 5
2CA4(000C) 06 0E BC A0 | dst                 mov        screen_w2, screen_w
2CA8(000D) 01 0E FC 28 | src                 shr        screen_w2, #1                ' screen width / 2
2CAC(000E) 06 68 BC A0 | end                mov        t1, screen_w
2CB0(000F) 08 6A BC A0 | data                mov        t2, screen_h
2CB4(0010) 79 FF FE 5C | cols                call        #mul16x16
2CB8(0011) 35 06 BC A0 | rows                      mov        screen_end, t2                ' result in t2
2CBC(0012) 35 06 BC 80 | lmm_pc                add        screen_end, t2                ' * 2
2CC0(0013) 02 06 BC 80 | cur_x_save        add        screen_end, screen_ptr
2CC4(0014) 00 14 FC A0 | cur_y_save        mov        scroll_top, #0
2CC8(0015) 08 16 BC A0 | new_x_save        mov        scroll_bot, screen_h
2CCC(0016) F1 47 BC A0 | attr_save        mov        cur_delay, CNT
2CD0(0017) 45 00 7C 5C |                 jmp        #startup
2CD4(0018) A8 32 00 00 | control_ptr        long        @@@control_table
2CD8(0019) E8 32 00 00 | csi_cmds_ptr        long        @@@csi_cmds
2CDC(001A) 20 00 20 00 | x00200020        long        $00200020
2CE0(001B) 5F 00 00 00 | cur_block        long        $5f
2CE4(001C) 00 00 00 00 | inverse                long        0
2CE8(001D) 00 00 00 00 | cur_x                long        0
2CEC(001E) 00 00 00 00 | new_x                long        0
2CF0(001F) 00 00 00 00 | cur_y                long        0
2CF4(0020) 00 00 00 00 | attr                long        0                        ' attribute mode
2CF8(0021) 24 00 00 00 | flags                long        flag_decom | flag_decawm
2CFC(0022) 00 00 00 00 | cur_char        long        0
2D00(0023) 00 00 00 00 | cur_delay        long        0
2D04(0024) 07 00 00 00 | fgcol                long        %0111                        ' foreground color
2D08(0025) 00 00 00 00 | bgcol                long        %0000                        ' background color
2D0C(0026) 00 07 00 00 | color                long        %00000111_00000000        ' composed fore- and background
2D10(0027) 00 00 00 00 | esc_mode        long        0
2D14(0028) 00 00 00 00 | csi_mode        long        0
2D18(0029) 00 00 00 00 | csi_argc        long        0
2D1C(002A) 00 00 00 00 | csi_argf        long        0
2D20(002B) 00 00 00 00 | csi_args        long        0,0,0,0,0,0,0,0
2D24(002C) 00 00 00 00 | 
2D28(002D) 00 00 00 00 | 
2D2C(002E) 00 00 00 00 | 
2D30(002F) 00 00 00 00 | 
2D34(0030) 00 00 00 00 | 
2D38(0031) 00 00 00 00 | 
2D3C(0032) 00 00 00 00 | 
2D40(0033) 00 00 00 00 | question_mark        long        0
2D44(0034) 00 00 00 00 | t1                long        0
2D48(0035) 00 00 00 00 | t2                long        0
2D4C(0036) 00 00 00 00 | t3                long        0
2D50(0037)             | goto_xay
2D50(0037) 0A 3E BC 80 |                 add        cur_y, scroll_top
2D54(0038)             | validate_cursor
2D54(0038) 1D 3A BC A1 |                 mov        cur_x, cur_x                WC        ' negative x?
2D58(0039) 00 3A F0 A0 |         if_c        mov        cur_x, #0                        ' yes, clip to 0
2D5C(003A) 06 3A 3C 87 |                 cmp        cur_x, screen_w                WZ, WC
2D60(003B) 06 3A 8C A0 |         if_ae        mov        cur_x, screen_w                        ' stay inside the boundaries
2D64(003C) 01 3A CC 84 |         if_ae        sub        cur_x, #1
2D68(003D) 1D 3C BC A0 |                 mov        new_x, cur_x
2D6C(003E) 1F 3E BC A1 |                 mov        cur_y, cur_y                WC        ' negative y?
2D70(003F) 00 3E F0 A0 |         if_c        mov        cur_y, #0                        ' yes, clip to 0
2D74(0040) 08 3E 3C 87 |                 cmp        cur_y, screen_h                WZ, WC
2D78(0041) 08 3E 8C A0 |         if_ae        mov        cur_y, screen_h                        ' stay inside the boundaries
2D7C(0042) 01 3E CC 84 |         if_ae        sub        cur_y, #1
2D80(0043)             | cmdloop
2D80(0043) 00 02 FC A0 |                 mov        cmd, #0
2D84(0044) 00 02 3C 08 |                 wrlong        cmd, command_ptr
2D88(0045)             | startup
2D88(0045) 4C 08 7C EC | :loop                tjz        cursor_ptr, #:cursor                ' skip if cursor_ptr is null
2D8C(0046) 04 3C 3C 00 |                 wrbyte        new_x, cursor_ptr                ' write the (new) cursor position
2D90(0047) 01 08 FC 80 |                 add        cursor_ptr, #1
2D94(0048) 04 3E 3C 00 |                 wrbyte        cur_y, cursor_ptr                ' and the cursor row, too
2D98(0049) 01 08 FC 84 |                 sub        cursor_ptr, #1
2D9C(004A) 5A C3 FE 5C |                 call        #calc_cursor
2DA0(004B) 5B 00 7C 5C |                 jmp        #:check_cmd
2DA4(004C) 23 68 BC A0 | :cursor                mov        t1, cur_delay                        ' software cursor
2DA8(004D) F1 69 BC 84 |                 sub        t1, CNT
2DAC(004E) 00 68 7C C3 |                 cmps        t1, #0                        WZ, WC
2DB0(004F) 5B 00 4C 5C |         if_ae        jmp        #:check_cmd
2DB4(0050) 00 68 FC 08 |                 rdlong        t1, #0                                ' get clkfreq
2DB8(0051) 02 68 FC 28 |                 shr        t1, #2                                ' / 4
2DBC(0052) 34 46 BC 80 |                 add        cur_delay, t1                        ' next cursor flash event
2DC0(0053) 5A C3 FE 5C |                 call        #calc_cursor
2DC4(0054) 06 3C 3C 87 |                 cmp        new_x, screen_w                WZ, WC        ' new_x beyond last column?
2DC8(0055) 5B 00 4C 5C |         if_ae        jmp        #:check_cmd
2DCC(0056) 22 68 BC A2 |                 mov        t1, cur_char                WZ        ' get saved character
2DD0(0057) 09 44 A8 00 |         if_z        rdbyte        cur_char, cur_ptr                ' none: save character under cursor
2DD4(0058) 09 36 28 00 |         if_z        wrbyte        cur_block, cur_ptr                ' display a cursor block
2DD8(0059) 00 44 D4 A0 |         if_nz        mov        cur_char, #0                        ' reset saved character
2DDC(005A) 09 68 14 00 |         if_nz        wrbyte        t1, cur_ptr                        ' restore saved character in screen buffer
2DE0(005B) 00 02 BC 0A | :check_cmd        rdlong        cmd, command_ptr        WZ
2DE4(005C) 45 00 68 5C |         if_z        jmp        #:loop
2DE8(005D) 22 68 BC A2 |                 mov        t1, cur_char                WZ        ' get saved character
2DEC(005E) 03 12 14 85 |         if_nz        cmp        cur_ptr, screen_end        WC
2DF0(005F) 00 44 D0 A0 |  if_nz_and_c        mov        cur_char, #0                        ' reset saved character
2DF4(0060) 09 68 10 00 |  if_nz_and_c        wrbyte        t1, cur_ptr                        ' restore saved character in screen buffer
2DF8(0061) FF 02 FC 60 |                 and        cmd, #$ff
2DFC(0062) 88 50 7C E8 |                 tjnz        csi_mode, #csi                        ' go to CSI decoding if enabled
2E00(0063) 7F 4E 7C E8 |                 tjnz        esc_mode, #esc                        ' go to ESC decoding if enabled
2E04(0064) 20 02 7C 87 |                 cmp        cmd, #$20                WZ, WC        ' other control characters?
2E08(0065) 6A 00 4C 5C |         if_ae        jmp        #do_emit                        ' no, just emit to the screen buffer
2E0C(0066) 01 02 FC 2C |                 shl        cmd, #1
2E10(0067) 18 02 BC 80 |                 add        cmd, control_ptr
2E14(0068) 01 02 BC 04 |                 rdword        cmd, cmd
2E18(0069) 01 00 3C 5C |                 jmp        cmd                                ' dispatch on control_table
2E1C(006A) 4A B3 FE 5C | do_emit                call        #emit
2E20(006B) 43 00 7C 5C |                 jmp        #cmdloop
2E24(006C)             | do_nul                ' NUL - null character
2E24(006C)             | do_soh                ' SOH - start of header
2E24(006C)             | do_stx                ' STX - start of text
2E24(006C)             | do_etx                ' ETX - end of text
2E24(006C)             | do_eot                ' EOT - end of transmission
2E24(006C)             | do_enq                ' ENQ - enquiry
2E24(006C)             | do_ack                ' ACK - acknowledgement
2E24(006C)             | do_bel                ' BEL - bell
2E24(006C)             | do_dle                ' DLE - data link escape
2E24(006C)             | do_dc1                ' DC1 - device control 1 (XON)
2E24(006C)             | do_dc2                ' DC2 - device control 2
2E24(006C)             | do_dc3                ' DC3 - device control 3 (XOFF)
2E24(006C)             | do_dc4                ' DC4 - device control 4
2E24(006C)             | do_nak                ' NAK - negative acknowledgement
2E24(006C)             | do_syn                ' SYN - synchronous idle
2E24(006C)             | do_etb                ' ETB - end of transmission block
2E24(006C)             | do_em                ' EM  - end of medium
2E24(006C)             | do_sub                ' SUB - substitute
2E24(006C)             | do_fs                ' FS  - file separator
2E24(006C)             | do_gs                ' GS  - group separator
2E24(006C)             | do_rs                ' RS  - request to send
2E24(006C)             | do_us                ' US  - unit separator
2E24(006C) 43 00 7C 5C |                 jmp        #cmdloop
2E28(006D) C4 8C FD 5C | do_cr                call        #cr
2E2C(006E) 43 00 7C 5C |                 jmp        #cmdloop
2E30(006F) C7 9A FD 5C | do_bs                call        #bs
2E34(0070) 43 00 7C 5C |                 jmp        #cmdloop
2E38(0071) D2 AC FD 5C | do_ht                call        #ht
2E3C(0072) 43 00 7C 5C |                 jmp        #cmdloop
2E40(0073) D7 04 FE 5C | do_lf                call        #lf
2E44(0074) 43 00 7C 5C |                 jmp        #cmdloop
2E48(0075) 03 59 FE 5C | do_vt                call        #vt
2E4C(0076) 43 00 7C 5C |                 jmp        #cmdloop
2E50(0077) 2D 73 FE 5C | do_ff                call        #ff
2E54(0078) 43 00 7C 5C |                 jmp        #cmdloop
2E58(0079)             | do_so                ' ???
2E58(0079) 43 00 7C 5C |                 jmp        #cmdloop
2E5C(007A)             | do_si                ' ???
2E5C(007A) 43 00 7C 5C |                 jmp        #cmdloop
2E60(007B)             | do_can                ' CAN - cancel
2E60(007B) 3E 93 FE 5C |                 call        #can
2E64(007C) 43 00 7C 5C |                 jmp        #cmdloop
2E68(007D)             | do_esc
2E68(007D) 01 4E FC A0 |                 mov        esc_mode, #1
2E6C(007E) 43 00 7C 5C |                 jmp        #cmdloop
2E70(007F)             | esc
2E70(007F) 00 4E FC A0 |                 mov        esc_mode, #0
2E74(0080) 5B 02 7C 86 |                 cmp        cmd, #"["                WZ
2E78(0081) 83 00 68 5C |         if_z        jmp        #:csi
2E7C(0082) 43 00 7C 5C |                 jmp        #cmdloop
2E80(0083)             | :csi
2E80(0083) 01 50 FC A0 |                 mov        csi_mode, #1                        ' start CSI mode
2E84(0084) 00 52 FC A0 |                 mov        csi_argc, #0                        ' argument count = 0
2E88(0085) 00 54 FC A0 |                 mov        csi_argf, #0                        ' argument flag = 0
2E8C(0086) 00 56 FC A0 |                 mov        csi_args, #0                        ' first argument = 0
2E90(0087) 43 00 7C 5C |                 jmp        #cmdloop
2E94(0088)             | csi
2E94(0088) 01 50 7C 86 |                 cmp        csi_mode, #1                WZ        ' first character after "["?
2E98(0089) 8E 00 54 5C |         if_nz        jmp        #:not_question                        ' no, check arguments
2E9C(008A) 02 50 FC A0 |                 mov        csi_mode, #2                        ' skip this test in the future
2EA0(008B) 3F 02 7C 86 |                 cmp        cmd, #"?"                WZ        ' "<ESC>[?" mode?
2EA4(008C) 01 66 FC 78 |                 muxz        question_mark, #1
2EA8(008D) 43 00 68 5C |         if_z        jmp        #cmdloop
2EAC(008E)             | :not_question
2EAC(008E) 30 02 7C 87 |                 cmp        cmd, #"0"                WZ, WC
2EB0(008F) A0 00 70 5C |         if_b        jmp        #:not_numeric
2EB4(0090) 39 02 7C 87 |                 cmp        cmd, #"9"                WZ, WC
2EB8(0091) A0 00 44 5C |         if_a        jmp        #:not_numeric
2EBC(0092) 29 68 BC A0 |                 mov        t1, csi_argc
2EC0(0093) 2B 68 FC 80 |                 add        t1, #csi_args
2EC4(0094) 34 2E BD 50 |                 movs        :get_arg, t1
2EC8(0095) 34 3C BD 54 |                 movd        :put_arg, t1
2ECC(0096) 01 54 FC A0 |                 mov        csi_argf, #1                        ' set the "seen arguments" flag
2ED0(0097) 00 68 BC A0 | :get_arg        mov        t1, 0-0                                ' get csi_args[csi_argc]
2ED4(0098) 34 6A BC A0 |                 mov        t2, t1                                ' to t2 also
2ED8(0099) 02 68 FC 2C |                 shl        t1, #2                                ' * 4
2EDC(009A) 35 68 BC 80 |                 add        t1, t2                                ' * 5
2EE0(009B) 01 68 FC 2C |                 shl        t1, #1                                ' * 10
2EE4(009C) 01 68 BC 80 |                 add        t1, cmd                                ' + digit
2EE8(009D) 30 68 FC 84 |                 sub        t1, #"0"                        ' - ASCII for "0"
2EEC(009E) 34 00 BC A0 | :put_arg        mov        0-0, t1                                ' put csi_args[csi_argc]
2EF0(009F) 43 00 7C 5C |                 jmp        #cmdloop
2EF4(00A0)             | :not_numeric
2EF4(00A0) 3B 02 7C 86 |                 cmp        cmd, #";"                WZ        ' next argument delimiter?
2EF8(00A1) AA 00 54 5C |         if_nz        jmp        #:not_delimiter
2EFC(00A2) 07 52 7C 86 |                 cmp        csi_argc, #7                WZ        ' reached maximum number of arguments?
2F00(00A3) 01 52 D4 80 |         if_nz        add        csi_argc, #1                        ' no, use next slot
2F04(00A4) 29 68 BC A0 |                 mov        t1, csi_argc
2F08(00A5) 2B 68 FC 80 |                 add        t1, #csi_args
2F0C(00A6) 34 50 BD 54 |                 movd        :clr_arg, t1
2F10(00A7) 00 00 00 00 |                 nop
2F14(00A8) 00 00 FC A0 | :clr_arg        mov        0-0, #0                                ' preset csi_args[csi_argc] to 0
2F18(00A9) 43 00 7C 5C |                 jmp        #cmdloop
2F1C(00AA)             | :not_delimiter
2F1C(00AA) 00 50 FC A0 |                 mov        csi_mode, #0                        ' end CSI mode
2F20(00AB) 2A 52 BC 80 |                 add        csi_argc, csi_argf                ' incr. argument count, if any arguments were specified
2F24(00AC) 40 02 7C 87 |                 cmp        cmd, #"@"                WZ, WC        ' below @?
2F28(00AD) 43 00 70 5C |         if_b        jmp        #cmdloop
2F2C(00AE) 7A 02 7C 87 |                 cmp        cmd, #"z"                WZ, WC        ' above z?
2F30(00AF) 43 00 4C 5C |         if_ae        jmp        #cmdloop
2F34(00B0) 40 02 FC 84 |                 sub        cmd, #"@"
2F38(00B1) 01 02 FC 2C |                 shl        cmd, #1                                ' function word index
2F3C(00B2) 19 02 BC 80 |                 add        cmd, csi_cmds_ptr
2F40(00B3) 01 02 BC 04 |                 rdword        cmd, cmd                        ' get function pointer
2F44(00B4) FF 03 7C 66 |                 testn        cmd, #$1ff                WZ        ' any bits outside the cog?
2F48(00B5) 01 00 28 5C |         if_z        jmp        cmd                                ' cog function
2F4C(00B6) 01 24 BC A0 |                 mov        lmm_pc, cmd                        ' otherwise it's an LMM address
2F50(00B7) 80 01 7C 5C |                 jmp        #lmm_loop                        ' execute LMM code
2F54(00B8)             | non_zero_args
2F54(00B8) BA 56 7C E8 |                 tjnz        csi_args, #non_zero_args_ret
2F58(00B9) 01 56 FC 80 |                 add        csi_args, #1
2F5C(00BA)             | non_zero_args_ret
2F5C(00BA) 00 00 7C 5C |                 ret
2F60(00BB)             | shift_csi_args
2F60(00BB) 2C 56 BC A0 |                 mov        csi_args, csi_args + 1
2F64(00BC) 2D 58 BC A0 |                 mov        csi_args + 1, csi_args + 2
2F68(00BD) 2E 5A BC A0 |                 mov        csi_args + 2, csi_args + 3
2F6C(00BE) 2F 5C BC A0 |                 mov        csi_args + 3, csi_args + 4
2F70(00BF) 30 5E BC A0 |                 mov        csi_args + 4, csi_args + 5
2F74(00C0) 31 60 BC A0 |                 mov        csi_args + 5, csi_args + 6
2F78(00C1) 32 62 BC A0 |                 mov        csi_args + 6, csi_args + 7
2F7C(00C2) 00 64 FC A0 |                 mov        csi_args + 7, #0
2F80(00C3)             | shift_csi_args_ret
2F80(00C3) 00 00 7C 5C |                 ret
2F84(00C4)             | cr
2F84(00C4) 00 3A FC A0 |                 mov        cur_x, #0
2F88(00C5) 00 3C FC A0 |                 mov        new_x, #0
2F8C(00C6)             | cr_ret
2F8C(00C6) 00 00 7C 5C |                 ret
2F90(00C7)             | bs
2F90(00C7) 00 3C 7C 86 |                 cmp        new_x, #0                WZ
2F94(00C8) 01 3C D4 84 |         if_nz        sub        new_x, #1
2F98(00C9) CD 00 54 5C |         if_nz        jmp        #bs_ret
2F9C(00CA) 06 3C BC A0 |                 mov        new_x, screen_w
2FA0(00CB) 01 3C FC 84 |                 sub        new_x, #1
2FA4(00CC) 03 59 FE 5C |                 call        #vt
2FA8(00CD)             | bs_ret
2FA8(00CD) 00 00 7C 5C |                 ret
2FAC(00CE)             | fs
2FAC(00CE) 01 3A FC 80 |                 add        cur_x, #1
2FB0(00CF) 06 3A 3C 86 |                 cmp        cur_x, screen_w                WZ
2FB4(00D0) 01 3A E8 84 |         if_z        sub        cur_x, #1                                ' stay in last column
2FB8(00D1)             | fs_ret
2FB8(00D1) 00 00 7C 5C |                 ret
2FBC(00D2)             | ht
2FBC(00D2) 20 02 FC A0 |                 mov        cmd, #$20
2FC0(00D3) 4A B3 FE 5C |                 call        #emit
2FC4(00D4) 07 3C 7C 62 |                 test        new_x, #7                WZ
2FC8(00D5) D2 00 54 5C |         if_nz        jmp        #ht
2FCC(00D6)             | ht_ret
2FCC(00D6) 00 00 7C 5C |                 ret
2FD0(00D7)             | lf
2FD0(00D7) 01 3E FC 80 |                 add        cur_y, #1
2FD4(00D8) 04 42 7C 62 |                 test        flags, #flag_decom        WZ                ' origin mode enabled?
2FD8(00D9) E2 00 54 5C |         if_nz        jmp        #:origin                                ' yes, check cursor in scroll range
2FDC(00DA) 08 3E 3C 87 | :screen                cmp        cur_y, screen_h                WZ, WC                ' no, check cursor in screen range
2FE0(00DB) 02 01 70 5C |         if_b        jmp        #lf_ret
2FE4(00DC) 08 3E BC A0 |                 mov        cur_y, screen_h
2FE8(00DD) 01 3E FC 84 |                 sub        cur_y, #1
2FEC(00DE) 02 18 BC A0 |                 mov        dst, screen_ptr                                ' destination = screen buffer
2FF0(00DF) 02 1A BC A0 |                 mov        src, screen_ptr                                ' source = dito
2FF4(00E0) 08 22 BC A0 |                 mov        rows, screen_h                                ' screen height
2FF8(00E1) EF 00 7C 5C |                 jmp        #scroll_up_1                                ' scroll the entire screen
2FFC(00E2) 0B 3E 3C 87 | :origin                cmp        cur_y, scroll_bot        WZ, WC
3000(00E3) 02 01 70 5C |         if_b        jmp        #lf_ret
3004(00E4) 0B 3E BC A0 |                 mov        cur_y, scroll_bot
3008(00E5) 01 3E FC 84 |                 sub        cur_y, #1
300C(00E6)             | scroll_up
300C(00E6) 0A 68 BC A0 |                 mov        t1, scroll_top
3010(00E7) 06 6A BC A0 |                 mov        t2, screen_w
3014(00E8) 79 FF FE 5C |                 call        #mul16x16
3018(00E9) 01 6A FC 2C |                 shl        t2, #1
301C(00EA) 02 6A BC 80 |                 add        t2, screen_ptr
3020(00EB) 35 18 BC A0 |                 mov        dst, t2                                        ' destination = scroll_top of screen buffer
3024(00EC) 35 1A BC A0 |                 mov        src, t2                                        ' source = dito
3028(00ED) 0B 22 BC A0 |                 mov        rows, scroll_bot                        ' scroll range height
302C(00EE) 0A 22 BC 84 |                 sub        rows, scroll_top
3030(00EF)             | scroll_up_1
3030(00EF) 06 1A BC 80 |                 add        src, screen_w                                ' copy from one line below
3034(00F0) 06 1A BC 80 |                 add        src, screen_w
3038(00F1) 01 22 FC 87 |                 sub        rows, #1                WZ, WC                ' - 1 rows to move
303C(00F2) FA 00 78 5C |         if_be        jmp        #:fill                                        ' nothing left to scroll?
3040(00F3) 07 20 BC A0 | :rows                mov        cols, screen_w2                                ' columns = screen width / 2
3044(00F4) 0D 1E BC 08 | :cols                rdlong        data, src
3048(00F5) 04 1A FC 80 |                 add        src, #4
304C(00F6) 0C 1E 3C 08 |                 wrlong        data, dst
3050(00F7) 04 18 FC 80 |                 add        dst, #4
3054(00F8) F4 20 FC E4 |                 djnz        cols, #:cols
3058(00F9) F3 22 FC E4 |                 djnz        rows, #:rows
305C(00FA) 07 20 BC A0 | :fill                mov        cols, screen_w2                                ' columns = screen width / 2
3060(00FB) 1A 68 BC A0 |                 mov        t1, x00200020
3064(00FC) 26 68 BC 68 |                 or        t1, color
3068(00FD) 10 68 FC 24 |                 rol        t1, #16
306C(00FE) 26 68 BC 68 |                 or        t1, color
3070(00FF) 0C 68 3C 08 | :blank                wrlong        t1, dst                                        ' fill 4 spaces
3074(0100) 04 18 FC 80 |                 add        dst, #4
3078(0101) FF 20 FC E4 |                 djnz        cols, #:blank
307C(0102)             | scroll_up_ret
307C(0102)             | lf_ret
307C(0102) 00 00 7C 5C |                 ret
3080(0103)             | vt
3080(0103) 01 3E FC 84 |                 sub        cur_y, #1
3084(0104) 04 42 7C 62 |                 test        flags, #flag_decom        WZ                ' origin mode enabled?
3088(0105) 0D 01 54 5C |         if_nz        jmp        #:origin                                ' yes, check cursor in scroll range
308C(0106)             | :screen                                                                ' no, check cursor in screen range
308C(0106) 00 3E 7C C3 |                 cmps        cur_y, #0                WZ, WC                ' < 0?
3090(0107) 2C 01 4C 5C |         if_ae        jmp        #vt_ret                                        ' in range
3094(0108) 00 3E FC A0 |                 mov        cur_y, #0                                ' stay in line 0
3098(0109) 03 1A BC A0 |                 mov        src, screen_end
309C(010A) 03 18 BC A0 |                 mov        dst, screen_end
30A0(010B) 08 22 BC A0 |                 mov        rows, screen_h
30A4(010C) 19 01 7C 5C |                 jmp        #scroll_down_1
30A8(010D)             | :origin
30A8(010D) 0A 3E 3C C3 |                 cmps        cur_y, scroll_top        WZ, WC
30AC(010E) 2C 01 4C 5C |         if_ae        jmp        #vt_ret
30B0(010F) 0A 3E BC A0 |                 mov        cur_y, scroll_top
30B4(0110)             | scroll_down
30B4(0110) 0B 68 BC A0 |                 mov        t1, scroll_bot
30B8(0111) 06 6A BC A0 |                 mov        t2, screen_w
30BC(0112) 79 FF FE 5C |                 call        #mul16x16
30C0(0113) 01 6A FC 2C |                 shl        t2, #1
30C4(0114) 02 6A BC 80 |                 add        t2, screen_ptr
30C8(0115) 35 18 BC A0 |                 mov        dst, t2                                        ' destination = end of scroll range buffer
30CC(0116) 35 1A BC A0 |                 mov        src, t2                                        ' source = last row of scroll range buffer
30D0(0117) 0B 22 BC A0 |                 mov        rows, scroll_bot                        ' scroll range height
30D4(0118) 0A 22 BC 84 |                 sub        rows, scroll_top
30D8(0119)             | scroll_down_1
30D8(0119) 06 1A BC 84 |                 sub        src, screen_w
30DC(011A) 06 1A BC 84 |                 sub        src, screen_w
30E0(011B) 01 22 FC 87 |                 sub        rows, #1                WZ, WC                ' - 1 rows to move
30E4(011C) 24 01 78 5C |         if_be        jmp        #:fill                                        ' nothing left to scroll?
30E8(011D) 07 20 BC A0 | :rows                mov        cols, screen_w2                                ' columns = screen width / 2
30EC(011E) 04 1A FC 84 | :cols                sub        src, #4                                        ' pre decrement source
30F0(011F) 0D 1E BC 08 |                 rdlong        data, src
30F4(0120) 04 18 FC 84 |                 sub        dst, #4                                        ' pre decrement destination
30F8(0121) 0C 1E 3C 08 |                 wrlong        data, dst
30FC(0122) 1E 21 FC E4 |                 djnz        cols, #:cols                                ' for all columns
3100(0123) 1D 23 FC E4 |                 djnz        rows, #:rows                                ' for all rows
3104(0124) 1A 68 BC A0 | :fill                mov        t1, x00200020
3108(0125) 26 68 BC 68 |                 or        t1, color
310C(0126) 10 68 FC 24 |                 rol        t1, #16
3110(0127) 26 68 BC 68 |                 or        t1, color
3114(0128) 07 20 BC A0 |                 mov        cols, screen_w2                                ' columns = screen width / 2
3118(0129) 04 18 FC 84 | :blank                sub        dst, #4
311C(012A) 0C 68 3C 08 |                 wrlong        t1, dst
3120(012B) 29 21 FC E4 |                 djnz        cols, #:blank
3124(012C)             | scroll_down_ret
3124(012C)             | vt_ret
3124(012C) 00 00 7C 5C |                 ret
3128(012D)             | ff
3128(012D) 02 18 BC A0 |                 mov        dst, screen_ptr
312C(012E) 08 22 BC A0 |                 mov        rows, screen_h                                ' screen height rows
3130(012F) 1A 68 BC A0 |                 mov        t1, x00200020
3134(0130) 26 68 BC 68 |                 or        t1, color
3138(0131) 10 68 FC 24 |                 rol        t1, #16
313C(0132) 26 68 BC 68 |                 or        t1, color
3140(0133) 07 20 BC A0 | :rows                mov        cols, screen_w2                                ' columns = screen width / 2
3144(0134) 0C 68 3C 08 | :cols                wrlong        t1, dst                                        ' fill with 4 blanks
3148(0135) 04 18 FC 80 |                 add        dst, #4
314C(0136) 34 21 FC E4 |                 djnz        cols, #:cols                                ' for all columns
3150(0137) 33 23 FC E4 |                 djnz        rows, #:rows                                ' for all rows
3154(0138) 3A 7B FE 5C |                 call        #home
3158(0139)             | ff_ret
3158(0139) 00 00 7C 5C |                 ret
315C(013A)             | home
315C(013A) 00 3A FC A0 |                 mov        cur_x, #0
3160(013B) 00 3C FC A0 |                 mov        new_x, #0
3164(013C) 00 3E FC A0 |                 mov        cur_y, #0
3168(013D)             | home_ret
3168(013D) 00 00 7C 5C |                 ret
316C(013E)             | can
316C(013E) 09 18 BC A0 |                 mov        dst, cur_ptr
3170(013F) 06 20 BC A0 |                 mov        cols, screen_w
3174(0140) 1E 20 BC 87 |                 sub        cols, new_x                WZ, WC
3178(0141) 49 01 78 5C |         if_be        jmp        #can_ret
317C(0142) 1A 68 BC A0 |                 mov        t1, x00200020
3180(0143) 26 68 BC 68 |                 or        t1, color
3184(0144) 10 68 FC 24 |                 rol        t1, #16
3188(0145) 26 68 BC 68 |                 or        t1, color
318C(0146) 0C 68 3C 04 | :fill                wrword        t1, dst
3190(0147) 02 18 FC 80 |                 add        dst, #2
3194(0148) 46 21 FC E4 |                 djnz        cols, #:fill
3198(0149)             | can_ret
3198(0149) 00 00 7C 5C |                 ret
319C(014A)             | emit
319C(014A) 06 3C 3C 87 |                 cmp        new_x, screen_w                WZ, WC                ' reached end of line?
31A0(014B) 50 01 70 5C |         if_b        jmp        #:in_bounds
31A4(014C) 20 42 7C 62 |                 test        flags, #flag_decawm        WZ                ' auto wrap mode active?
31A8(014D) 59 01 68 5C |         if_z        jmp        #emit_ret                                ' no, don't emit character
31AC(014E) C4 8C FD 5C |                 call        #cr
31B0(014F) D7 04 FE 5C |                 call        #lf                
31B4(0150) 1E 3A BC A0 | :in_bounds        mov        cur_x, new_x
31B8(0151) 5A C3 FE 5C |                 call        #calc_cursor
31BC(0152) 26 02 BC 68 |                 or        cmd, color
31C0(0153) 02 40 7C 62 |                 test        attr, #attr_underline        WZ
31C4(0154) 80 02 FC 7C |                 muxnz        cmd, #$80
31C8(0155) 09 02 3C 04 |                 wrword        cmd, cur_ptr                                ' write character to screen RAM
31CC(0156) 1D 3C BC A0 |                 mov        new_x, cur_x
31D0(0157) 01 3C FC 80 |                 add        new_x, #1
31D4(0158) 02 12 FC 80 |                 add        cur_ptr, #2
31D8(0159)             | emit_ret
31D8(0159) 00 00 7C 5C |                 ret
31DC(015A)             | calc_cursor
31DC(015A) 1F 68 BC A0 |                 mov        t1, cur_y                                ' cursor row
31E0(015B) 06 6A BC A0 |                 mov        t2, screen_w                                ' * screen width
31E4(015C) 79 FF FE 5C |                 call        #mul16x16
31E8(015D) 35 12 BC A0 |                 mov        cur_ptr, t2                                ' product in cur_ptr
31EC(015E) 1E 12 BC 80 |                 add        cur_ptr, new_x                                ' + new cursor column
31F0(015F) 01 12 FC 2C |                 shl        cur_ptr, #1                                ' * 2
31F4(0160) 02 12 BC 80 |                 add        cur_ptr, screen_ptr                        ' + screen buffer address
31F8(0161)             | calc_cursor_ret
31F8(0161) 00 00 7C 5C |                 ret
31FC(0162)             | enable_cursor
31FC(0162) 43 08 7C EC |                 tjz        cursor_ptr, #cmdloop
3200(0163) 01 42 7C 62 |                 test        flags, #flag_deccm        WZ                ' cursor enabled?
3204(0164) 00 68 E8 A0 |         if_z        mov        t1, #%000                                ' cursor off
3208(0165) 06 68 D4 A0 |         if_nz        mov        t1, #%110                                ' cursor on, blink slow
320C(0166) 02 08 FC 80 |                 add        cursor_ptr, #2                                ' cursor control
3210(0167) 04 68 3C 00 |                 wrbyte        t1, cursor_ptr
3214(0168) 02 08 FC 84 |                 sub        cursor_ptr, #2
3218(0169) 43 00 7C 5C |                 jmp        #cmdloop
321C(016A)             | set_color
321C(016A) 04 40 7C 62 |                 test        attr, #attr_inverse        WZ
3220(016B) 70 01 68 5C |         if_z        jmp        #:default
3224(016C)             | :inverse
3224(016C) 24 4C BC A0 |                 mov        color, fgcol                                ' compose inverse color
3228(016D) 04 4C FC 2C |                 shl        color, #4
322C(016E) 25 4C BC 68 |                 or        color, bgcol
3230(016F) 73 01 7C 5C |                 jmp        #:cont
3234(0170)             | :default
3234(0170) 25 4C BC A0 |                 mov        color, bgcol                                ' compose default color
3238(0171) 04 4C FC 2C |                 shl        color, #4
323C(0172) 24 4C BC 68 |                 or        color, fgcol
3240(0173)             | :cont
3240(0173) 01 40 7C 62 |                 test        attr, #attr_highlite        WZ
3244(0174) 08 4C FC 7C |                 muxnz        color, #$08
3248(0175) 08 40 7C 62 |                 test        attr, #attr_blinking        WZ
324C(0176) 80 4C FC 7C |                 muxnz        color, #$80
3250(0177) 08 4C FC 2C |                 shl        color, #8                                ' in bits 15..8
3254(0178) 43 00 7C 5C |                 jmp        #cmdloop
3258(0179)             | mul16x16
3258(0179) 10 68 FC 2C |                 shl        t1, #16                                        ' multiplicand in bits 31..16
325C(017A) 10 6C FC A0 |                 mov        t3, #16                                        ' loop 16 times
3260(017B) 01 6A FC 29 |                 shr        t2, #1                        WC                ' get initial multiplier bit in carry
3264(017C) 34 6A B0 81 | :loop        if_c        add        t2, t1                        WC                ' if carry set, add multiplicand to product
3268(017D) 01 6A FC 31 |                 rcr        t2, #1                        WC                ' next multiplier bit to carry, shift product
326C(017E) 7C 6D FC E4 |                 djnz        t3, #:loop                                ' until done
3270(017F)             | mul16x16_ret
3270(017F) 00 00 7C 5C |                 ret
3274(0180)             | lmm_loop
3274(0180) 12 04 BF 08 |                 rdlong        :op1, lmm_pc
3278(0181) 04 24 FC 80 |                 add        lmm_pc, #4
327C(0182) 00 00 00 00 | :op1                nop
3280(0183) 12 0A BF 08 |                 rdlong        :op2, lmm_pc
3284(0184) 04 24 FC 80 |                 add        lmm_pc, #4
3288(0185) 00 00 00 00 | :op2                nop
328C(0186) 12 10 BF 08 |                 rdlong        :op3, lmm_pc
3290(0187) 04 24 FC 80 |                 add        lmm_pc, #4
3294(0188) 00 00 00 00 | :op3                nop
3298(0189) 12 16 BF 08 |                 rdlong        :op4, lmm_pc
329C(018A) 04 24 FC 80 |                 add        lmm_pc, #4
32A0(018B) 00 00 00 00 | :op4                nop
32A4(018C) 80 01 7C 5C |                 jmp        #lmm_loop
32A8(018D)             |                 fit        $1f0
32A8(018D)             | There are 99 ($063) Longs left in the cog
32A8(018D) 6C 00       | control_table        word        do_nul, do_soh, do_stx, do_etx, do_eot, do_enq, do_ack, do_bel
32AA(018D) 6C 00       | 
32AC(018E) 6C 00       | 
32AE(018E) 6C 00       | 
32B0(018F) 6C 00       | 
32B2(018F) 6C 00       | 
32B4(0190) 6C 00       | 
32B6(0190) 6C 00       | 
32B8(0191) 6F 00       |                 word        do_bs,  do_ht,  do_lf,  do_vt,  do_ff,  do_cr,  do_so,  do_si
32BA(0191) 71 00       | 
32BC(0192) 73 00       | 
32BE(0192) 75 00       | 
32C0(0193) 77 00       | 
32C2(0193) 6D 00       | 
32C4(0194) 79 00       | 
32C6(0194) 7A 00       | 
32C8(0195) 6C 00       |                 word        do_dle, do_dc1, do_dc2, do_dc3, do_dc4, do_nak, do_syn, do_etb
32CA(0195) 6C 00       | 
32CC(0196) 6C 00       | 
32CE(0196) 6C 00       | 
32D0(0197) 6C 00       | 
32D2(0197) 6C 00       | 
32D4(0198) 6C 00       | 
32D6(0198) 6C 00       | 
32D8(0199) 7B 00       |                 word        do_can, do_em,  do_sub, do_esc, do_fs,  do_gs,  do_rs,  do_us
32DA(0199) 6C 00       | 
32DC(019A) 6C 00       | 
32DE(019A) 7D 00       | 
32E0(019B) 6C 00       | 
32E2(019B) 6C 00       | 
32E4(019C) 6C 00       | 
32E6(019C) 6C 00       | 
32E8(019D) 5E 33       | csi_cmds        word        @@@do_insert_char                        ' <ESC>[...@
32EA(019D) D8 33       |                 word        @@@do_cursor_up                                ' <ESC>[...A
32EC(019E) EC 33       |                 word        @@@do_cursor_down                        ' <ESC>[...B
32EE(019E) FC 33       |                 word        @@@do_cursor_left                        ' <ESC>[...C
32F0(019F) 10 34       |                 word        @@@do_cursor_right                        ' <ESC>[...D
32F2(019F) 20 34       |                 word        @@@do_rows_up                                ' <ESC>[...E
32F4(01A0) 38 34       |                 word        @@@do_rows_down                                ' <ESC>[...F
32F6(01A0) 70 34       |                 word        @@@do_cursor_column                        ' <ESC>[...G
32F8(01A1) 4C 34       |                 word        @@@do_cursor_address                        ' <ESC>[...H
32FA(01A1) 43 00       |                 word        cmdloop                                        ' I unused?
32FC(01A2) 80 34       |                 word        @@@do_clear_screen                        ' <ESC>[...J
32FE(01A2) E0 34       |                 word        @@@do_clear_row                                ' <ESC>[...K
3300(01A3) 54 35       |                 word        @@@do_insert_line                        ' <ESC>[...L
3302(01A3) C8 35       |                 word        @@@do_delete_line                        ' <ESC>[...M
3304(01A4) 43 00       |                 word        cmdloop                                        ' N unused?
3306(01A4) 43 00       |                 word        cmdloop                                        ' O unused?
3308(01A5) 54 36       |                 word        @@@do_delete_char                        ' P unused?
330A(01A5) 43 00       |                 word        cmdloop                                        ' Q unused?
330C(01A6) 43 00       |                 word        cmdloop                                        ' R unused?
330E(01A6) 43 00       |                 word        cmdloop                                        ' S unused?
3310(01A7) 43 00       |                 word        cmdloop                                        ' T unused?
3312(01A7) 43 00       |                 word        cmdloop                                        ' U unused?
3314(01A8) 43 00       |                 word        cmdloop                                        ' V unused?
3316(01A8) 43 00       |                 word        cmdloop                                        ' W unused?
3318(01A9) CC 36       |                 word        @@@do_blank_chars                        ' <ESC>[...X
331A(01A9) 43 00       |                 word        cmdloop                                        ' Y unused?
331C(01AA) 43 00       |                 word        cmdloop                                        ' Z unused?
331E(01AA) 43 00       |                 word        cmdloop                                        ' [ unused
3320(01AB) 43 00       |                 word        cmdloop                                        ' \ unused
3322(01AB) 43 00       |                 word        cmdloop                                        ' ] unused
3324(01AC) 43 00       |                 word        cmdloop                                        ' ^ unused
3326(01AC) 43 00       |                 word        cmdloop                                        ' _ unused
3328(01AD) 70 34       |                 word        @@@do_cursor_column                        ' <ESC>[...` alternate form for <ESC>[...G
332A(01AD) 43 00       |                 word        cmdloop                                        ' a unused?
332C(01AE) 43 00       |                 word        cmdloop                                        ' b unused?
332E(01AE) 43 00       |                 word        cmdloop                                        ' c unused?
3330(01AF) 43 00       |                 word        cmdloop                                        ' d unused?
3332(01AF) 43 00       |                 word        cmdloop                                        ' e unused?
3334(01B0) 4C 34       |                 word        @@@do_cursor_address                        ' <ESC>[...f alternate form for <ESC>[...H
3336(01B0) 43 00       |                 word        cmdloop                                        ' g unused?
3338(01B1) 0C 37       |                 word        @@@do_flag_set                                ' h unused?
333A(01B1) 43 00       |                 word        cmdloop                                        ' i unused?
333C(01B2) 43 00       |                 word        cmdloop                                        ' j unused?
333E(01B2) 43 00       |                 word        cmdloop                                        ' k unused?
3340(01B3) 7C 37       |                 word        @@@do_flag_res                                ' h unused?
3342(01B3) EC 37       |                 word        @@@do_mode_attributes                        ' <ESC>[...m
3344(01B4) 43 00       |                 word        cmdloop                                        ' n unused?
3346(01B4) 43 00       |                 word        cmdloop                                        ' o unused?
3348(01B5) 43 00       |                 word        cmdloop                                        ' p unused?
334A(01B5) 43 00       |                 word        cmdloop                                        ' q unused?
334C(01B6) 2C 39       |                 word        @@@do_scroll_range                        ' <ESC>[...r
334E(01B6) 7C 39       |                 word        @@@do_save_cursor                        ' <ESC>[?...s
3350(01B7) 43 00       |                 word        cmdloop                                        ' t unused?
3352(01B7) 90 39       |                 word        @@@do_restore_cursor                        ' <ESC>[?...u
3354(01B8) 43 00       |                 word        cmdloop                                        ' v unused?
3356(01B8) 43 00       |                 word        cmdloop                                        ' w unused?
3358(01B9) 43 00       |                 word        cmdloop                                        ' x unused?
335A(01B9) 43 00       |                 word        cmdloop                                        ' y unused?
335C(01BA) 43 00       |                 word        cmdloop                                        ' z unused?
335E(01BA)             | do_insert_char
335E(01BA) B8 74 FD 5C |                 call        #non_zero_args
3364(01BC) 06 3C 3C 87 |                 cmp        new_x, screen_w                WZ, WC
3368(01BD) 43 00 4C 5C |         if_ae        jmp        #cmdloop
336C(01BE) 1F 68 BC A0 | :loop                mov        t1, cur_y
3370(01BF) 06 6A BC A0 |                 mov        t2, screen_w
3374(01C0) 79 FF FE 5C |                 call        #mul16x16
3378(01C1) 1E 6A BC 80 |                 add        t2, new_x
337C(01C2) 01 6A FC 2C |                 shl        t2, #1
3380(01C3) 02 6A BC 80 |                 add        t2, screen_ptr
3384(01C4) 35 18 BC A0 |                 mov        dst, t2
3388(01C5) 02 18 FC 80 |                 add        dst, #2
338C(01C6) 35 1A BC A0 |                 mov        src, t2
3390(01C7) 06 20 BC A0 |                 mov        cols, screen_w
3394(01C8) 1E 20 BC 84 |                 sub        cols, new_x
3398(01C9) 01 20 FC 87 |                 sub        cols, #1                WZ, WC
339C(01CA) 28 24 F8 80 |         if_be        add        lmm_pc, #4*(:blank - $ - 1)
33A0(01CB) 0D 1E BC 04 | :insert                rdword        data, src
33A4(01CC) 02 1A FC 80 |                 add        src, #2
33A8(01CD) 0C 1E 3C 04 |                 wrword        data, dst
33AC(01CE) 02 18 FC 80 |                 add        dst, #2
33B0(01CF) 01 20 FC 86 |                 sub        cols, #1                WZ
33B4(01D0) 18 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :insert)
33B8(01D1) 1A 68 BC A0 |                 mov        t1, x00200020
33BC(01D2) 26 68 BC 68 |                 or        t1, color
33C0(01D3) 10 68 FC 24 |                 rol        t1, #16
33C4(01D4) 26 68 BC 68 |                 or        t1, color
33C8(01D5) 35 68 3C 04 | :blank                wrword        t1, t2
33CC(01D6) 01 56 FC 86 |                 sub        csi_args, #1                WZ
33D0(01D7) 68 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
33D4(01D8) 43 00 7C 5C |                 jmp        #cmdloop
33D8(01D9)             | do_cursor_up
33D8(01D9) B8 74 FD 5C |                 call        #non_zero_args
33DC(01DA) 03 59 FE 5C | :loop                call        #vt
33E0(01DB) 01 56 FC 86 |                 sub        csi_args, #1                WZ
33E4(01DC) 0C 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
33E8(01DD) 43 00 7C 5C |                 jmp        #cmdloop
33EC(01DE)             | do_cursor_down
33EC(01DE) B8 74 FD 5C |                 call        #non_zero_args
33F0(01DF) D7 04 FE 5C | :loop                call        #lf
33F4(01E0) DF 57 FC E4 |                 djnz        csi_args, #:loop
33F8(01E1) 43 00 7C 5C |                 jmp        #cmdloop
33FC(01E2)             | do_cursor_left
33FC(01E2) B8 74 FD 5C |                 call        #non_zero_args
3400(01E3) 1E 3A BC A0 |                 mov        cur_x, new_x
3404(01E4) 2B 3A BC 85 |                 sub        cur_x, csi_args                WC
3408(01E5) 00 3A F0 A0 |         if_c        mov        cur_x, #0
340C(01E6) 38 00 7C 5C |                 jmp        #validate_cursor
3410(01E7)             | do_cursor_right
3410(01E7) B8 74 FD 5C |                 call        #non_zero_args
3414(01E8) 1E 3A BC A0 |                 mov        cur_x, new_x
3418(01E9) 2B 3A BC 80 |                 add        cur_x, csi_args
341C(01EA) 38 00 7C 5C |                 jmp        #validate_cursor
3420(01EB)             | do_rows_up
3420(01EB) B8 74 FD 5C |                 call        #non_zero_args
3424(01EC) 00 3A FC A0 |                 mov        cur_x, #0
3428(01ED) 00 3C FC A0 |                 mov        new_x, #0
342C(01EE) 2B 3E BC 85 |                 sub        cur_y, csi_args                WC
3430(01EF) 00 3E F0 A0 |         if_c        mov        cur_y, #0
3434(01F0) 38 00 7C 5C |                 jmp        #validate_cursor
3438(01F1)             | do_rows_down
3438(01F1) B8 74 FD 5C |                 call        #non_zero_args
343C(01F2) 00 3A FC A0 |                 mov        cur_x, #0
3440(01F3) 00 3C FC A0 |                 mov        new_x, #0
3444(01F4) 2B 3E BC 80 |                 add        cur_y, csi_args
3448(01F5) 38 00 7C 5C |                 jmp        #validate_cursor
344C(01F6)             | do_cursor_address
344C(01F6) 00 54 7C 86 |                 cmp        csi_argf, #0                WZ                ' nor arguments at all?
3450(01F7) 3A 7B EA 5C |         if_z        call        #home
3454(01F8) 43 00 68 5C |         if_z        jmp        #cmdloop
3458(01F9) B8 74 FD 5C |                 call        #non_zero_args
345C(01FA) 2B 3E BC A0 |                 mov        cur_y, csi_args
3460(01FB) 01 3E FC 84 |                 sub        cur_y, #1
3464(01FC) 01 52 7C 87 |                 cmp        csi_argc, #1                WZ, WC                ' the caller specified just a row?
3468(01FD) 38 00 78 5C |         if_be        jmp        #validate_cursor
346C(01FE) BB 86 FD 5C |                 call        #shift_csi_args
3470(01FF)             | do_cursor_column
3470(01FF) B8 74 FD 5C |                 call        #non_zero_args
3474(0200) 2B 3A BC A0 |                 mov        cur_x, csi_args
3478(0201) 01 3A FC 84 |                 sub        cur_x, #1
347C(0202) 38 00 7C 5C |                 jmp        #validate_cursor
3480(0203)             | do_clear_screen
3480(0203) 5A C3 FE 5C |                 call        #calc_cursor
3484(0204) 00 56 7C 86 |                 cmp        csi_args, #0                WZ                ' cursor to end of screen?
3488(0205) 0C 24 D4 80 |         if_nz        add        lmm_pc, #4*(:not_0 - $ - 1)
348C(0206) 09 18 BC A0 |                 mov        dst, cur_ptr
3490(0207) 03 1C BC A0 |                 mov        end, screen_end
3494(0208) 24 24 FC 80 |                 add        lmm_pc, #4*(:fill - $ - 1)
3498(0209) 01 56 7C 86 | :not_0                cmp        csi_args, #1                WZ                ' start of screen to cursor?
349C(020A) 0C 24 D4 80 |         if_nz        add        lmm_pc, #4*(:not_1 - $ - 1)
34A0(020B) 02 18 BC A0 |                 mov        dst, screen_ptr
34A4(020C) 09 1C BC A0 |                 mov        end, cur_ptr
34A8(020D) 10 24 FC 80 |                 add        lmm_pc, #4*(:fill - $ - 1)
34AC(020E) 02 56 7C 86 | :not_1                cmp        csi_args, #2                WZ                ' entire screen?
34B0(020F) 43 00 54 5C |         if_nz        jmp        #cmdloop                                ' invalid argument
34B4(0210) 02 18 BC A0 |                 mov        dst, screen_ptr                                ' default = entire screen
34B8(0211) 03 1C BC A0 |                 mov        end, screen_end
34BC(0212) 1A 68 BC A0 | :fill                mov        t1, x00200020
34C0(0213) 26 68 BC 68 |                 or        t1, color
34C4(0214) 10 68 FC 24 |                 rol        t1, #16
34C8(0215) 26 68 BC 68 |                 or        t1, color
34CC(0216) 0C 68 3C 04 | :loop                wrword        t1, dst                                        ' fill a word
34D0(0217) 02 18 FC 80 |                 add        dst, #2
34D4(0218) 0E 18 3C 87 |                 cmp        dst, end                WZ, WC
34D8(0219) 10 24 F0 84 |         if_b        sub        lmm_pc, #4*($ + 1 - :loop)
34DC(021A) 43 00 7C 5C |                 jmp        #cmdloop
34E0(021B)             | do_clear_row
34E0(021B) 5A C3 FE 5C |                 call        #calc_cursor
34E4(021C) 00 56 7C 86 |                 cmp        csi_args, #0                WZ                ' cursor to end of row?
34E8(021D) 14 24 D4 80 |         if_nz        add        lmm_pc, #4*(:not_0 - $ - 1)
34EC(021E) 09 18 BC A0 |                 mov        dst, cur_ptr                                ' default = cursor to end of row
34F0(021F) 09 1C BC A0 |                 mov        end, cur_ptr
34F4(0220) 1E 1C BC 84 |                 sub        end, new_x
34F8(0221) 06 1C BC 80 |                 add        end, screen_w                                ' end of row
34FC(0222) 30 24 FC 80 |                 add        lmm_pc, #4*(:fill - $ - 1)
3500(0223) 01 56 7C 86 | :not_0                cmp        csi_args, #1                WZ                ' start of row to cursor?
3504(0224) 10 24 D4 80 |         if_nz        add        lmm_pc, #4*(:not_1 - $ - 1)
3508(0225) 09 18 BC A0 |                 mov        dst, cur_ptr
350C(0226) 1E 18 BC 84 |                 sub        dst, new_x                                ' start of row
3510(0227) 09 1C BC A0 |                 mov        end, cur_ptr                                ' to cursor
3514(0228) 18 24 FC 80 |                 add        lmm_pc, #4*(:fill - $ - 1)
3518(0229) 02 56 7C 86 | :not_1                cmp        csi_args, #2                WZ                ' entire row?
351C(022A) 43 00 54 5C |         if_nz        jmp        #cmdloop                                ' invalid argument
3520(022B) 09 18 BC A0 |                 mov        dst, cur_ptr
3524(022C) 1E 18 BC 84 |                 sub        dst, new_x                                ' start of row
3528(022D) 0C 1C BC A0 |                 mov        end, dst
352C(022E) 06 1C BC 80 |                 add        end, screen_w                                ' end of row
3530(022F) 1A 68 BC A0 | :fill                mov        t1, x00200020
3534(0230) 26 68 BC 68 |                 or        t1, color
3538(0231) 10 68 FC 24 |                 rol        t1, #16
353C(0232) 26 68 BC 68 |                 or        t1, color
3540(0233) 0C 68 3C 04 | :loop                wrword        t1, dst                                        ' fill a word
3544(0234) 02 18 FC 80 |                 add        dst, #2
3548(0235) 0E 18 3C 87 |                 cmp        dst, end                WZ, WC
354C(0236) 10 24 F0 84 |         if_b        sub        lmm_pc, #4*($ + 1 - :loop)
3550(0237) 43 00 7C 5C |                 jmp        #cmdloop
3554(0238)             | do_insert_line
3554(0238) B8 74 FD 5C |                 call        #non_zero_args
3558(0239) 03 18 BC A0 | :loop                mov        dst, screen_end
355C(023A) 03 1A BC A0 |                 mov        src, screen_end
3560(023B) 06 1A BC 84 |                 sub        src, screen_w
3564(023C) 08 22 BC A0 |                 mov        rows, screen_h                                ' screen rows
3568(023D) 1F 22 BC 84 |                 sub        rows, cur_y                                ' - cursor row
356C(023E) 01 22 FC 87 |                 sub        rows, #1                WZ, WC                ' - 1
3570(023F) 24 24 F8 80 |         if_be        add        lmm_pc, #4*(:fill - $ - 1)                ' nothing left to move?
3574(0240) 07 20 BC A0 | :rows                mov        cols, screen_w2                                ' columns = screen width / 2
3578(0241) 04 1A FC 84 | :cols                sub        src, #4
357C(0242) 0D 1E BC 08 |                 rdlong        data, src
3580(0243) 04 18 FC 84 |                 sub        dst, #4
3584(0244) 0C 1E 3C 08 |                 wrlong        data, dst
3588(0245) 01 20 FC 86 |                 sub        cols, #1                WZ
358C(0246) 18 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :cols)
3590(0247) 01 22 FC 86 |                 sub        rows, #1                WZ
3594(0248) 24 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :rows)
3598(0249) 1A 68 BC A0 | :fill                mov        t1, x00200020
359C(024A) 26 68 BC 68 |                 or        t1, color
35A0(024B) 10 68 FC 24 |                 rol        t1, #16
35A4(024C) 26 68 BC 68 |                 or        t1, color
35A8(024D) 07 20 BC A0 |                 mov        cols, screen_w2                                ' columns = screen width / 2
35AC(024E) 04 18 FC 84 | :blank                sub        dst, #4
35B0(024F) 0C 68 3C 08 |                 wrlong        t1, dst
35B4(0250) 01 20 FC 86 |                 sub        cols, #1                WZ
35B8(0251) 10 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :blank)                ' for all columns
35BC(0252) 01 56 FC 86 |                 sub        csi_args, #1                WZ                ' more lines to insert?
35C0(0253) 6C 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
35C4(0254) 43 00 7C 5C |                 jmp        #cmdloop
35C8(0255)             | do_delete_line
35C8(0255) B8 74 FD 5C |                 call        #non_zero_args
35CC(0256) 1F 68 BC A0 | :loop                mov        t1, cur_y
35D0(0257) 06 6A BC A0 |                 mov        t2, screen_w
35D4(0258) 79 FF FE 5C |                 call        #mul16x16
35D8(0259) 01 6A FC 2C |                 shl        t2, #1
35DC(025A) 02 6A BC 80 |                 add        t2, screen_ptr                                ' cursor row address
35E0(025B) 35 18 BC A0 |                 mov        dst, t2
35E4(025C) 35 1A BC A0 |                 mov        src, t2
35E8(025D) 06 1A BC 80 |                 add        src, screen_w                                ' one row down
35EC(025E) 06 1A BC 80 |                 add        src, screen_w
35F0(025F) 08 22 BC A0 |                 mov        rows, screen_h                                ' screen rows
35F4(0260) 1F 22 BC 84 |                 sub        rows, cur_y                                ' - cursor row
35F8(0261) 01 22 FC 87 |                 sub        rows, #1                WZ, WC                ' - 1
35FC(0262) 24 24 F8 80 |         if_be        add        lmm_pc, #4*(:fill - $ - 1)                ' nothing left to move?
3600(0263) 07 20 BC A0 | :rows                mov        cols, screen_w2                                ' columns = screen width / 2
3604(0264) 0D 1E BC 08 | :cols                rdlong        data, src
3608(0265) 04 1A FC 80 |                 add        src, #4
360C(0266) 0C 1E 3C 08 |                 wrlong        data, dst
3610(0267) 04 18 FC 80 |                 add        dst, #4
3614(0268) 01 20 FC 86 |                 sub        cols, #1                WZ
3618(0269) 18 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :cols)
361C(026A) 01 22 FC 86 |                 sub        rows, #1                WZ
3620(026B) 24 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :rows)
3624(026C) 1A 68 BC A0 | :fill                mov        t1, x00200020
3628(026D) 26 68 BC 68 |                 or        t1, color
362C(026E) 10 68 FC 24 |                 rol        t1, #16
3630(026F) 26 68 BC 68 |                 or        t1, color
3634(0270) 07 20 BC A0 |                 mov        cols, screen_w2                                ' columns = screen width / 2
3638(0271) 0C 68 3C 08 | :blank                wrlong        t1, dst
363C(0272) 04 18 FC 80 |                 add        dst, #4
3640(0273) 01 20 FC 86 |                 sub        cols, #1                WZ
3644(0274) 10 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :blank)                ' for all columns
3648(0275) 01 56 FC 86 |                 sub        csi_args, #1                WZ                ' more lines to insert?
364C(0276) 84 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
3650(0277) 43 00 7C 5C |                 jmp        #cmdloop
3654(0278)             | do_delete_char
3654(0278) B8 74 FD 5C |                 call        #non_zero_args
3658(0279) 06 3C 3C 87 |                 cmp        new_x, screen_w                WZ, WC
365C(027A) 43 00 4C 5C |         if_ae        jmp        #cmdloop                                ' can't delete beyond last column
3660(027B) 1F 68 BC A0 | :loop                mov        t1, cur_y
3664(027C) 06 6A BC A0 |                 mov        t2, screen_w
3668(027D) 79 FF FE 5C |                 call        #mul16x16
366C(027E) 1E 6A BC 80 |                 add        t2, new_x
3670(027F) 01 6A FC 2C |                 shl        t2, #1
3674(0280) 02 6A BC 80 |                 add        t2, screen_ptr
3678(0281) 35 18 BC A0 |                 mov        dst, t2
367C(0282) 35 1A BC A0 |                 mov        src, t2
3680(0283) 02 1A FC 80 |                 add        src, #2
3684(0284) 06 20 BC A0 |                 mov        cols, screen_w
3688(0285) 1E 20 BC 84 |                 sub        cols, new_x
368C(0286) 01 20 FC 87 |                 sub        cols, #1                WZ, WC
3690(0287) 18 24 F8 80 |         if_be        add        lmm_pc, #4*(:blank - $ - 1)                ' new_x is beyond the last column
3694(0288) 0D 1E BC 04 | :insert                rdword        data, src
3698(0289) 02 1A FC 80 |                 add        src, #2
369C(028A) 0C 1E 3C 04 |                 wrword        data, dst
36A0(028B) 02 18 FC 80 |                 add        dst, #2
36A4(028C) 01 20 FC 86 |                 sub        cols, #1                WZ
36A8(028D) 18 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :insert)
36AC(028E) 1A 68 BC A0 | :blank                mov        t1, x00200020
36B0(028F) 26 68 BC 68 |                 or        t1, color
36B4(0290) 10 68 FC 24 |                 rol        t1, #16
36B8(0291) 26 68 BC 68 |                 or        t1, color
36BC(0292) 0C 68 3C 04 |                 wrword        t1, dst                                        ' clear the last character in the row
36C0(0293) 01 56 FC 86 |                 sub        csi_args, #1                WZ
36C4(0294) 68 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
36C8(0295) 43 00 7C 5C |                 jmp        #cmdloop
36CC(0296)             | do_blank_chars
36CC(0296) B8 74 FD 5C |                 call        #non_zero_args
36D0(0297) 09 18 BC A0 |                 mov        dst, cur_ptr
36D4(0298) 06 20 BC A0 |                 mov        cols, screen_w
36D8(0299) 1E 20 BC 87 |                 sub        cols, new_x                WZ, WC
36DC(029A) 43 00 78 5C |         if_be        jmp        #cmdloop
36E0(029B) 1A 68 BC A0 |                 mov        t1, x00200020
36E4(029C) 26 68 BC 68 |                 or        t1, color
36E8(029D) 10 68 FC 24 |                 rol        t1, #16
36EC(029E) 26 68 BC 68 |                 or        t1, color
36F0(029F) 0C 68 3C 04 | :fill                wrword        t1, dst
36F4(02A0) 02 18 FC 80 |                 add        dst, #2
36F8(02A1) 01 56 FC 86 |                 sub        csi_args, #1                WZ
36FC(02A2) 43 00 68 5C |         if_z        jmp        #cmdloop
3700(02A3) 01 20 FC 86 |                 sub        cols, #1                WZ
3704(02A4) 18 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :fill)
3708(02A5) 43 00 7C 5C |                 jmp        #cmdloop
370C(02A6)             | do_flag_set
370C(02A6)             | :loop
370C(02A6) 2B 02 BC A0 |                 mov        cmd, csi_args
3710(02A7) 01 66 7C 86 |                 cmp        question_mark, #1        WZ                ' <ESC>[? sequence?
3714(02A8) 1C 24 E8 80 |         if_z        add        lmm_pc, #4*(:ques - $ - 1)
3718(02A9) 03 02 7C 86 |                 cmp        cmd, #3                        WZ                ' <ESC>[3h - display control characters
371C(02AA) 00 43 E8 68 |         if_z        or        flags, #flag_ctrl
3720(02AB) 04 02 7C 86 |                 cmp        cmd, #4                        WZ                ' <ESC>[4h - set insert mode
3724(02AC) 02 42 E8 68 |         if_z        or        flags, #flag_decim
3728(02AD) 14 02 7C 86 |                 cmp        cmd, #20                WZ                ' <ESC>[20h - set auto CR mode
372C(02AE) 08 42 E8 68 |         if_z        or        flags, #flag_deccr
3730(02AF) 30 24 FC 80 |                 add        lmm_pc, #4*(:next - $ - 1)
3734(02B0)             | :ques
3734(02B0) 01 02 7C 86 |                 cmp        cmd, #1                        WZ                ' <ESC>[?1h - enable cursor keys
3738(02B1) 10 42 E8 68 |         if_z        or        flags, #flag_decck
373C(02B2) 05 02 7C 86 |                 cmp        cmd, #5                        WZ                ' <ESC>[?5h - inverse terminal on
3740(02B3) 01 38 E8 68 |         if_z        or        inverse, #1
3744(02B4) 06 02 7C 86 |                 cmp        cmd, #6                        WZ                ' <ESC>[?6h - enable origin mode
3748(02B5) 04 42 E8 68 |         if_z        or        flags, #flag_decom
374C(02B6) 07 02 7C 86 |                 cmp        cmd, #7                        WZ                ' <ESC>[?7h - enable auto wrap mode
3750(02B7) 20 42 E8 68 |         if_z        or        flags, #flag_decawm
3754(02B8) 08 02 7C 86 |                 cmp        cmd, #8                        WZ                ' <ESC>[?8h - enable auto repeat mode
3758(02B9) 40 42 E8 68 |         if_z        or        flags, #flag_decarm
375C(02BA) 19 02 7C 86 |                 cmp        cmd, #25                WZ                ' <ESC>[?25h - enable cursor
3760(02BB) 01 42 E8 68 |         if_z        or        flags, #flag_deccm
3764(02BC)             | :next
3764(02BC) 00 54 7C 86 |                 cmp        csi_argf, #0                WZ                ' no arguments specified?
3768(02BD) 43 00 68 5C |         if_z        jmp        #cmdloop
376C(02BE) BB 86 FD 5C |                 call        #shift_csi_args
3770(02BF) 01 52 FC 86 |                 sub        csi_argc, #1                WZ
3774(02C0) 6C 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
3778(02C1) 62 01 7C 5C |                 jmp        #enable_cursor
377C(02C2)             | do_flag_res
377C(02C2)             | :loop
377C(02C2) 2B 02 BC A0 |                 mov        cmd, csi_args
3780(02C3) 01 66 7C 86 |                 cmp        question_mark, #1        WZ                ' <ESC>[? sequence?
3784(02C4) 1C 24 E8 80 |         if_z        add        lmm_pc, #4*(:ques - $ - 1)
3788(02C5) 03 02 7C 86 |                 cmp        cmd, #3                        WZ                ' <ESC>[3l - don't display control characters
378C(02C6) 00 43 E8 64 |         if_z        andn        flags, #flag_ctrl
3790(02C7) 04 02 7C 86 |                 cmp        cmd, #4                        WZ                ' <ESC>[4l - reset insert mode
3794(02C8) 02 42 E8 64 |         if_z        andn        flags, #flag_decim
3798(02C9) 14 02 7C 86 |                 cmp        cmd, #20                WZ                ' <ESC>[20l - reset auto CR mode
379C(02CA) 08 42 E8 64 |         if_z        andn        flags, #flag_deccr
37A0(02CB) 30 24 FC 80 |                 add        lmm_pc, #4*(:next - $ - 1)
37A4(02CC)             | :ques
37A4(02CC) 01 02 7C 86 |                 cmp        cmd, #1                        WZ                ' <ESC>[?1l - disable cursor keys
37A8(02CD) 10 42 E8 64 |         if_z        andn        flags, #flag_decck
37AC(02CE) 05 02 7C 86 |                 cmp        cmd, #5                        WZ                ' <ESC>[?5l - inverse terminal off
37B0(02CF) 01 38 E8 64 |         if_z        andn        inverse, #1
37B4(02D0) 06 02 7C 86 |                 cmp        cmd, #6                        WZ                ' <ESC>[?6l - disable origin mode
37B8(02D1) 04 42 E8 64 |         if_z        andn        flags, #flag_decom
37BC(02D2) 07 02 7C 86 |                 cmp        cmd, #7                        WZ                ' <ESC>[?7l - disable auto wrap mode
37C0(02D3) 20 42 E8 64 |         if_z        andn        flags, #flag_decawm
37C4(02D4) 08 02 7C 86 |                 cmp        cmd, #8                        WZ                ' <ESC>[?8l - disable auto repeat mode
37C8(02D5) 40 42 E8 64 |         if_z        andn        flags, #flag_decarm
37CC(02D6) 19 02 7C 86 |                 cmp        cmd, #25                WZ                ' <ESC>[?25l - disable cursor
37D0(02D7) 01 42 E8 64 |         if_z        andn        flags, #flag_deccm
37D4(02D8)             | :next
37D4(02D8) 00 54 7C 86 |                 cmp        csi_argf, #0                WZ                ' no arguments specified?
37D8(02D9) 43 00 68 5C |         if_z        jmp        #cmdloop
37DC(02DA) BB 86 FD 5C |                 call        #shift_csi_args
37E0(02DB) 01 52 FC 86 |                 sub        csi_argc, #1                WZ
37E4(02DC) 6C 24 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :loop)
37E8(02DD) 62 01 7C 5C |                 jmp        #enable_cursor
37EC(02DE)             | do_mode_attributes
37EC(02DE) 2B 02 BC A0 | :get_arg        mov        cmd, csi_args                                ' get next argument
37F0(02DF) 00 02 7C 86 |                 cmp        cmd, #0                        WZ                ' 0 = reset all attributes
37F4(02E0) 00 40 E8 A0 |         if_z        mov        attr, #0
37F8(02E1) 00 4A E8 A0 |         if_z        mov        bgcol, #%0000
37FC(02E2) 07 48 E8 A0 |         if_z        mov        fgcol, #%0111
3800(02E3) 01 02 7C 86 |                 cmp        cmd, #1                        WZ                ' 1 = highlight on
3804(02E4) 01 40 E8 68 |         if_z        or        attr, #attr_highlite
3808(02E5) 02 02 7C 86 |                 cmp        cmd, #2                        WZ                ' 2 = highlight off
380C(02E6) 01 40 E8 64 |         if_z        andn        attr, #attr_highlite
3810(02E7) 04 02 7C 86 |                 cmp        cmd, #4                        WZ                ' 4 = underline on
3814(02E8) 02 40 E8 68 |         if_z        or        attr, #attr_underline
3818(02E9) 05 02 7C 86 |                 cmp        cmd, #5                        WZ                ' 5 = blinking on
381C(02EA) 08 40 E8 68 |         if_z        or        attr, #attr_blinking
3820(02EB) 07 02 7C 86 |                 cmp        cmd, #7                        WZ                ' 7 = inverse on
3824(02EC) 04 40 E8 68 |         if_z        or        attr, #attr_inverse
3828(02ED) 0A 02 7C 86 |                 cmp        cmd, #10                WZ                ' 10 = primary font, no ctrl, no meta
382C(02EE) 00 43 E8 64 |         if_z        andn        flags, #flag_ctrl
3830(02EF) 80 42 E8 64 |         if_z        andn        flags, #flag_meta
3834(02F0) 0B 02 7C 86 |                 cmp        cmd, #11                WZ                ' 11 = alternate font, ctrl chars, low half, meta off
3838(02F1) 00 43 E8 68 |         if_z        or        flags, #flag_ctrl
383C(02F2) 80 42 E8 64 |         if_z        andn        flags, #flag_meta
3840(02F3) 0C 02 7C 86 |                 cmp        cmd, #12                WZ                ' 12 = alternate font, ctrl chars, low half, meta on
3844(02F4) 00 43 E8 68 |         if_z        or        flags, #flag_ctrl
3848(02F5) 80 42 E8 68 |         if_z        or        flags, #flag_meta
384C(02F6) 15 02 7C 86 |                 cmp        cmd, #21                WZ                ' 21 = highlight on
3850(02F7) 01 40 E8 68 |         if_z        or        attr, #attr_highlite
3854(02F8) 16 02 7C 86 |                 cmp        cmd, #22                WZ                ' 22 = highlight on
3858(02F9) 01 40 E8 68 |         if_z        or        attr, #attr_highlite
385C(02FA) 18 02 7C 86 |                 cmp        cmd, #24                WZ                ' 24 = underline off
3860(02FB) 02 40 E8 64 |         if_z        andn        attr, #attr_underline
3864(02FC) 19 02 7C 86 |                 cmp        cmd, #25                WZ                ' 25 = blinking off
3868(02FD) 08 40 E8 64 |         if_z        andn        attr, #attr_blinking
386C(02FE) 1B 02 7C 86 |                 cmp        cmd, #27                WZ                ' 27 = inverse off
3870(02FF) 04 40 E8 64 |         if_z        andn        attr, #attr_inverse
3874(0300) 1E 02 7C 86 |                 cmp        cmd, #30                WZ                ' 30 = foreground color 0
3878(0301) 00 48 E8 A0 |         if_z        mov        fgcol, #%0000
387C(0302) 1F 02 7C 86 |                 cmp        cmd, #31                WZ                ' 31 = foreground color 1
3880(0303) 01 48 E8 A0 |         if_z        mov        fgcol, #%0001
3884(0304) 20 02 7C 86 |                 cmp        cmd, #32                WZ                ' 32 = foreground color 2
3888(0305) 02 48 E8 A0 |         if_z        mov        fgcol, #%0010
388C(0306) 21 02 7C 86 |                 cmp        cmd, #33                WZ                ' 33 = foreground color 3
3890(0307) 03 48 E8 A0 |         if_z        mov        fgcol, #%0011
3894(0308) 22 02 7C 86 |                 cmp        cmd, #34                WZ                ' 34 = foreground color 4
3898(0309) 04 48 E8 A0 |         if_z        mov        fgcol, #%0100
389C(030A) 23 02 7C 86 |                 cmp        cmd, #35                WZ                ' 35 = foreground color 5
38A0(030B) 05 48 E8 A0 |         if_z        mov        fgcol, #%0101
38A4(030C) 24 02 7C 86 |                 cmp        cmd, #36                WZ                ' 36 = foreground color 6
38A8(030D) 06 48 E8 A0 |         if_z        mov        fgcol, #%0110
38AC(030E) 25 02 7C 86 |                 cmp        cmd, #37                WZ                ' 37 = foreground color 7
38B0(030F) 07 48 E8 A0 |         if_z        mov        fgcol, #%0111
38B4(0310) 26 02 7C 86 |                 cmp        cmd, #38                WZ                ' 38 = default color and underline on
38B8(0311) 07 48 E8 A0 |         if_z        mov        fgcol, #%0111
38BC(0312) 02 40 E8 68 |         if_z        or        attr, #attr_underline
38C0(0313) 27 02 7C 86 |                 cmp        cmd, #39                WZ                ' 39 = default color and underline off
38C4(0314) 07 48 E8 A0 |         if_z        mov        fgcol, #%0111
38C8(0315) 02 40 E8 64 |         if_z        andn        attr, #attr_underline
38CC(0316) 28 02 7C 86 |                 cmp        cmd, #40                WZ                ' 40 = default background
38D0(0317) 00 4A E8 A0 |         if_z        mov        bgcol, #%0000                                ' black
38D4(0318) 29 02 7C 86 |                 cmp        cmd, #41                WZ                ' 41 = background color 1
38D8(0319) 01 4A E8 A0 |         if_z        mov        bgcol, #%0001
38DC(031A) 2A 02 7C 86 |                 cmp        cmd, #42                WZ                ' 42 = background color 2
38E0(031B) 02 4A E8 A0 |         if_z        mov        bgcol, #%0010
38E4(031C) 2B 02 7C 86 |                 cmp        cmd, #43                WZ                ' 43 = background color 3
38E8(031D) 03 4A E8 A0 |         if_z        mov        bgcol, #%0011
38EC(031E) 2C 02 7C 86 |                 cmp        cmd, #44                WZ                ' 44 = background color 4
38F0(031F) 04 4A E8 A0 |         if_z        mov        bgcol, #%0100
38F4(0320) 2D 02 7C 86 |                 cmp        cmd, #45                WZ                ' 45 = background color 5
38F8(0321) 05 4A E8 A0 |         if_z        mov        bgcol, #%0101
38FC(0322) 2E 02 7C 86 |                 cmp        cmd, #46                WZ                ' 46 = background color 6
3900(0323) 06 4A E8 A0 |         if_z        mov        bgcol, #%0110
3904(0324) 2F 02 7C 86 |                 cmp        cmd, #47                WZ                ' 47 = background color 7
3908(0325) 07 4A E8 A0 |         if_z        mov        bgcol, #%0111
390C(0326) 31 02 7C 86 |                 cmp        cmd, #49                WZ                ' 49 = default background
3910(0327) 00 4A E8 A0 |         if_z        mov        bgcol, #%0000                                ' black
3914(0328) 00 54 7C 86 |                 cmp        csi_argf, #0                WZ                ' no arguments specified?
3918(0329) 43 00 68 5C |         if_z        jmp        #cmdloop
391C(032A) BB 86 FD 5C |                 call        #shift_csi_args
3920(032B) 01 52 FC 86 |                 sub        csi_argc, #1                WZ
3924(032C) 3C 25 D4 84 |         if_nz        sub        lmm_pc, #4*($ + 1 - :get_arg)
3928(032D) 6A 01 7C 5C |                 jmp        #set_color
392C(032E)             | do_scroll_range
392C(032E) 02 52 7C 87 |                 cmp        csi_argc, #2                WZ, WC                ' 2 arguments specified?
3930(032F) 0C 24 CC 80 |         if_ae        add        lmm_pc, #4*(:set_range - $ - 1)
3934(0330) 01 14 FC A0 |                 mov        scroll_top, #1
3938(0331) 08 16 BC A0 |                 mov        scroll_bot, screen_h
393C(0332) 2C 24 FC 80 |                 add        lmm_pc, #4*(:bottom_ok - $ - 1)
3940(0333)             | :set_range
3940(0333) 2B 14 BC A0 |                 mov        scroll_top, csi_args
3944(0334) 2C 16 BC A0 |                 mov        scroll_bot, csi_args + 1
3948(0335) 0B 14 3C 87 |                 cmp        scroll_top, scroll_bot        WZ, WC                ' bottom => top?
394C(0336) 0C 24 F8 80 |         if_be        add        lmm_pc, #4*(:order_ok - $ - 1)
3950(0337) 01 14 FC A0 |                 mov        scroll_top, #1
3954(0338) 08 16 BC A0 |                 mov        scroll_bot, screen_h
3958(0339) 10 24 FC 80 |                 add        lmm_pc, #4*(:bottom_ok - $ - 1)
395C(033A)             | :order_ok
395C(033A) 08 16 3C 87 |                 cmp        scroll_bot, screen_h        WZ, WC                ' bottom > screen height?
3960(033B) 08 24 F8 80 |         if_be        add        lmm_pc, #4*(:bottom_ok - $ - 1)
3964(033C) 01 14 FC A0 |                 mov        scroll_top, #1
3968(033D) 08 16 BC A0 |                 mov        scroll_bot, screen_h
396C(033E)             | :bottom_ok
396C(033E) 01 14 FC 84 |                 sub        scroll_top, #1
3970(033F) 00 3A FC A0 |                 mov        cur_x, #0
3974(0340) 00 3E FC A0 |                 mov        cur_y, #0
3978(0341) 37 00 7C 5C |                 jmp        #goto_xay
397C(0342)             | do_save_cursor
397C(0342) 1D 26 BC A0 |                 mov        cur_x_save, cur_x
3980(0343) 1E 2A BC A0 |                 mov        new_x_save, new_x
3984(0344) 1F 28 BC A0 |                 mov        cur_y_save, cur_y
3988(0345) 20 2C BC A0 |                 mov        attr_save, attr
398C(0346) 43 00 7C 5C |                 jmp        #cmdloop
3990(0347)             | do_restore_cursor
3990(0347) 13 3A BC A0 |                 mov        cur_x, cur_x_save
3994(0348) 15 3C BC A0 |                 mov        new_x, new_x_save
3998(0349) 14 3E BC A0 |                 mov        cur_y, cur_y_save
399C(034A) 16 40 BC A0 |                 mov        attr, attr_save
39A0(034B) 43 00 7C 5C |                 jmp        #cmdloop
|===========================================================================|
|===========================================================================|
Spin Block start with 1 Parameters and 0 Extra Stack Longs. Method 1
PUB start(params) : okay

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - params
|===========================================================================|
29                              stop
Addr : 39A4:             01  : Drop Anchor   
Addr : 39A5:          05 02  : Call Sub 2    
30                              okay := cog := COGNEW(@entry, params) + 1
Addr : 39A7:             34  : Constant 0 $FFFFFFFF
Addr : 39A8:          C7 0C  : Memory Op Long PBASE + ADDRESS Address = 000C
Addr : 39AA:             64  : Variable Operation Local Offset - 1 Read
Addr : 39AB:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 39AC:             36  : Constant 2 $00000001
Addr : 39AD:             EC  : Math Op +     
Addr : 39AE:          42 80  : Variable Operation Global Offset - 0 Assign Write Push
Addr : 39B0:             61  : Variable Operation Local Offset - 0 Write
Addr : 39B1:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 2
PUB stop : okay

Local Parameter DBASE:0000 - Result
|===========================================================================|
33                              if cog
Addr : 39B2:             40  : Variable Operation Global Offset - 0 Read
Addr : 39B3: JZ Label0008
Addr : 39B3:          0A 05  : jz Address = 39BA 5
34                                      COGSTOP(cog~~ - 1)
Addr : 39B5:          42 9C  : Variable Operation Global Offset - 0 Assign VAR~~ Post-set Push
Addr : 39B7:             36  : Constant 2 $00000001
Addr : 39B8:             ED  : Math Op -     
Addr : 39B9:             21  : CogStop(id)   
Addr : 39BA: Label0008
Addr : 39BA: Label0009
Addr : 39BA:             32  : Return        
|===========================================================================|
Object Keyboard
Object Base is 39BC
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable cog
VBASE : 0004 LONG Size 0004 Variable par_tail
VBASE : 0008 LONG Size 0004 Variable par_head
VBASE : 000C LONG Size 0004 Variable par_present
VBASE : 0010 LONG Size 0020 Variable par_states
VBASE : 0030 LONG Size 0020 Variable par_keys
VBASE : 0050 LONG Size 0004 Variable nkey
VBASE : 0054 LONG Size 0004 Variable dkeyhd
VBASE : 0058 LONG Size 0004 Variable dkeytail
VBASE : 005C BYTE Size 0010 Variable dkeys
|===========================================================================|
Object DAT Blocks
|===========================================================================|
39F4(0000)             |                         org
39F4(0000) 3D 09 FC 54 | entry                   movd    :par,#_dpin             'load input parameters _dpin/_cpin/_locks/_auto
39F8(0001) F0 61 BE A0 |                         mov     x,par
39FC(0002) 2C 60 FE 80 |                         add     x,#11*4
3A00(0003) 04 62 FE A0 |                         mov     y,#4
3A04(0004) 30 01 BC 08 | :par                    rdlong  0,x
3A08(0005) D8 08 BC 80 |                         add     :par,dlsb
3A0C(0006) 04 60 FE 80 |                         add     x,#4
3A10(0007) 04 62 FE E4 |                         djnz    y,#:par
3A14(0008) 01 58 FE A0 |                         mov     dmask,#1                'set pin masks
3A18(0009) 3D 59 BE 2C |                         shl     dmask,_dpin
3A1C(000A) 01 5A FE A0 |                         mov     cmask,#1
3A20(000B) 3E 5B BE 2C |                         shl     cmask,_cpin
3A24(000C) 20 7A 7E 61 |                         test    _dpin,#$20      wc      'modify port registers within code
3A28(000D) D8 3E BD 70 |                         muxc    _d1,dlsb
3A2C(000E) D8 52 BD 70 |                         muxc    _d2,dlsb
3A30(000F) 01 76 FD 70 |                         muxc    _d3,#1
3A34(0010) 01 94 FD 70 |                         muxc    _d4,#1
3A38(0011) 20 7C 7E 61 |                         test    _cpin,#$20      wc
3A3C(0012) D8 38 BD 70 |                         muxc    _c1,dlsb
3A40(0013) D8 44 BD 70 |                         muxc    _c2,dlsb
3A44(0014) 01 92 FD 70 |                         muxc    _c3,#1
3A48(0015) 00 66 FE A0 |                         mov     _head,#0                'reset output parameter _head
3A4C(0016) 00 EC FF A0 | reset                   mov     dira,#0                 'reset directions
3A50(0017) 00 EE FF A0 |                         mov     dirb,#0
3A54(0018) 34 35 FC 54 |                         movd    :par,#_present          'reset output parameters _present/_states[8]
3A58(0019) 09 60 FE A0 |                         mov     x,#1+8
3A5C(001A) 00 00 FC A0 | :par                    mov     0,#0
3A60(001B) D8 34 BC 80 |                         add     :par,dlsb
3A64(001C) 1A 60 FE E4 |                         djnz    x,#:par
3A68(001D) 08 5C FE A0 |                         mov     stat,#8                 'set reset flag
3A6C(001E) 33 45 FC 54 | update                  movd    :par,#_head             'update output parameters _head/_present/_states[8]
3A70(001F) F0 61 BE A0 |                         mov     x,par
3A74(0020) 04 60 FE 80 |                         add     x,#1*4
3A78(0021) 0A 62 FE A0 |                         mov     y,#1+1+8
3A7C(0022) 30 01 3C 08 | :par                    wrlong  0,x
3A80(0023) D8 44 BC 80 |                         add     :par,dlsb
3A84(0024) 04 60 FE 80 |                         add     x,#4
3A88(0025) 22 62 FE E4 |                         djnz    y,#:par
3A8C(0026) 08 5C 7E 61 |                         test    stat,#8         wc      'if reset flag, transmit reset command
3A90(0027) FF 5E F2 A0 |         if_c            mov     data,#$FF
3A94(0028) 9C 68 F1 5C |         if_c            call    #transmit
3A98(0029) 00 5C FE A0 | newcode                 mov     stat,#0                 'reset state
3A9C(002A) B5 88 FD 5C | :same                   call    #receive                'receive byte from keyboard
3AA0(002B) 84 5E 7E 85 |                         cmp     data,#$83+1     wc      'scancode?
3AA4(002C) AA 5E 4E 86 |         if_nc           cmp     data,#$AA       wz      'powerup/reset?
3AA8(002D) 80 00 48 5C |         if_nc_and_z     jmp     #configure
3AAC(002E) E0 5E 4E 86 |         if_nc           cmp     data,#$E0       wz      'extended?
3AB0(002F) 01 5C CA 68 |         if_nc_and_z     or      stat,#1
3AB4(0030) 2A 00 48 5C |         if_nc_and_z     jmp     #:same
3AB8(0031) F0 5E 4E 86 |         if_nc           cmp     data,#$F0       wz      'released?
3ABC(0032) 02 5C CA 68 |         if_nc_and_z     or      stat,#2
3AC0(0033) 2A 00 48 5C |         if_nc_and_z     jmp     #:same
3AC4(0034) 29 00 4C 5C |         if_nc           jmp     #newcode                'unknown, ignore
3AC8(0035) 01 5C 7E 61 |                         test    stat,#1         wc      'lookup code with extended flag
3ACC(0036) 01 5E FE 34 |                         rcl     data,#1
3AD0(0037) 94 88 FD 5C |                         call    #look
3AD4(0038) 00 5E 7E 86 |                         cmp     data,#0         wz      'if unknown, ignore
3AD8(0039) 29 00 68 5C |         if_z            jmp     #newcode
3ADC(003A) 3B 65 BE A0 |                         mov     t,_states+6             'remember lock keys in _states
3AE0(003B) 2F 61 BE A0 |                         mov     x,data                  'set/clear key bit in _states
3AE4(003C) 05 60 FE 28 |                         shr     x,#5
3AE8(003D) 35 61 FE 80 |                         add     x,#_states
3AEC(003E) 30 85 BC 54 |                         movd    :reg,x
3AF0(003F) 01 62 FE A0 |                         mov     y,#1
3AF4(0040) 2F 63 BE 2C |                         shl     y,data
3AF8(0041) 02 5C 7E 61 |                         test    stat,#2         wc
3AFC(0042) 31 01 BC 74 | :reg                    muxnc   0,y
3B00(0043) F0 5E CE E1 |         if_nc           cmpsub  data,#$F0       wc      'if released or shift/ctrl/alt/win, done
3B04(0044) 1E 00 70 5C |         if_c            jmp     #update
3B08(0045) 3C 63 BE A0 |                         mov     y,_states+7             'get shift/ctrl/alt/win bit pairs
3B0C(0046) 10 62 FE 28 |                         shr     y,#16
3B10(0047) E0 5E FE E1 |                         cmpsub  data,#$E0       wc      'translate keypad, considering numlock
3B14(0048) 04 7E 72 62 |         if_c            test    _locks,#%100    wz
3B18(0049) 08 5F E2 80 |         if_c_and_z      add     data,#@keypad1-@table
3B1C(004A) 18 5F D2 80 |         if_c_and_nz     add     data,#@keypad2-@table
3B20(004B) 94 88 F1 5C |         if_c            call    #look
3B24(004C) 6A 00 70 5C |         if_c            jmp     #:flags
3B28(004D) DD 5E FE E1 |                         cmpsub  data,#$DD       wc      'handle scrlock/capslock/numlock
3B2C(004E) 08 60 F2 A0 |         if_c            mov     x,#%001_000
3B30(004F) 2F 61 B2 2C |         if_c            shl     x,data
3B34(0050) 3F 61 B2 64 |         if_c            andn    x,_locks
3B38(0051) 03 60 F2 28 |         if_c            shr     x,#3
3B3C(0052) 1D 64 F2 28 |         if_c            shr     t,#29                   'ignore auto-repeat
3B40(0053) 32 61 B2 66 |         if_c            andn    x,t             wz
3B44(0054) 30 7F B2 6C |         if_c            xor     _locks,x
3B48(0055) DD 5E F2 80 |         if_c            add     data,#$DD
3B4C(0056) 04 5C D2 68 |         if_c_and_nz     or      stat,#4                 'if change, set configure flag to update leds
3B50(0057) 03 62 7E 62 |                         test    y,#%11          wz      'get shift into nz
3B54(0058) 61 5E 56 85 |         if_nz           cmp     data,#$60+1     wc      'check shift1
3B58(0059) 5B 5E D2 E1 |         if_nz_and_c     cmpsub  data,#$5B       wc
3B5C(005A) 28 5F D2 80 |         if_nz_and_c     add     data,#@shift1-@table
3B60(005B) 94 88 D1 5C |         if_nz_and_c     call    #look
3B64(005C) 03 62 D2 64 |         if_nz_and_c     andn    y,#%11
3B68(005D) 3E 5E 56 85 |         if_nz           cmp     data,#$3D+1     wc      'check shift2
3B6C(005E) 27 5E D2 E1 |         if_nz_and_c     cmpsub  data,#$27       wc
3B70(005F) 2E 5F D2 80 |         if_nz_and_c     add     data,#@shift2-@table
3B74(0060) 94 88 D1 5C |         if_nz_and_c     call    #look
3B78(0061) 03 62 D2 64 |         if_nz_and_c     andn    y,#%11
3B7C(0062) 02 7E 7E 61 |                         test    _locks,#%010    wc      'check shift-alpha, considering capslock
3B80(0063) 20 D0 FC 74 |                         muxnc   :shift,#$20
3B84(0064) 40 7E 7E 61 |                         test    _locks,#$40     wc
3B88(0065) 20 D0 C4 6C |         if_nz_and_nc    xor     :shift,#$20
3B8C(0066) 7B 5E 7E 85 |                         cmp     data,#"z"+1     wc
3B90(0067) 61 5E F2 E1 |         if_c            cmpsub  data,#"a"       wc
3B94(0068) 41 5E F2 80 | :shift  if_c            add     data,#"A"
3B98(0069) 03 62 F2 64 |         if_c            andn    y,#%11
3B9C(006A) 08 5E FE 20 | :flags                  ror     data,#8                 'add shift/ctrl/alt/win flags
3BA0(006B) 04 60 FE A0 |                         mov     x,#4                    '+$100 if shift
3BA4(006C) 03 62 7E 62 | :loop                   test    y,#%11          wz      '+$200 if ctrl
3BA8(006D) 02 62 FE 28 |                         shr     y,#2                    '+$400 if alt
3BAC(006E) 01 5E D6 68 |         if_nz           or      data,#1                 '+$800 if win
3BB0(006F) 01 5E FE 20 |                         ror     data,#1
3BB4(0070) 6C 60 FE E4 |                         djnz    x,#:loop
3BB8(0071) 0C 5E FE 24 |                         rol     data,#12
3BBC(0072) F0 61 BE 08 |                         rdlong  x,par                   'if room in buffer and key valid, enter
3BC0(0073) 01 60 FE 84 |                         sub     x,#1
3BC4(0074) 0F 60 FE 60 |                         and     x,#$F
3BC8(0075) 33 61 3E 86 |                         cmp     x,_head         wz
3BCC(0076) FF 5E 56 62 |         if_nz           test    data,#$FF       wz
3BD0(0077) F0 61 96 A0 |         if_nz           mov     x,par
3BD4(0078) 2C 60 D6 80 |         if_nz           add     x,#11*4
3BD8(0079) 33 61 96 80 |         if_nz           add     x,_head
3BDC(007A) 33 61 96 80 |         if_nz           add     x,_head
3BE0(007B) 30 5F 16 04 |         if_nz           wrword  data,x
3BE4(007C) 01 66 D6 80 |         if_nz           add     _head,#1
3BE8(007D) 0F 66 D6 60 |         if_nz           and     _head,#$F
3BEC(007E) 04 5C 7E 61 |                         test    stat,#4         wc      'if not configure flag, done
3BF0(007F) 1E 00 4C 5C |         if_nc           jmp     #update                 'else configure to update leds
3BF4(0080) F3 5E FE A0 | configure               mov     data,#$F3               'set keyboard auto-repeat
3BF8(0081) 9C 68 FD 5C |                         call    #transmit
3BFC(0082) 40 5F BE A0 |                         mov     data,_auto
3C00(0083) 7F 5E FE 60 |                         and     data,#%11_11111
3C04(0084) 9C 68 FD 5C |                         call    #transmit
3C08(0085) ED 5E FE A0 |                         mov     data,#$ED               'set keyboard lock-leds
3C0C(0086) 9C 68 FD 5C |                         call    #transmit
3C10(0087) 3F 5F BE A0 |                         mov     data,_locks
3C14(0088) 1D 5E FE 3C |                         rev     data,#-3 & $1F
3C18(0089) 04 5E 7E 61 |                         test    data,#%100      wc
3C1C(008A) 01 5E FE 34 |                         rcl     data,#1
3C20(008B) 07 5E FE 60 |                         and     data,#%111
3C24(008C) 9C 68 FD 5C |                         call    #transmit
3C28(008D) 3F 61 BE A0 |                         mov     x,_locks                'insert locks into _states
3C2C(008E) 07 60 FE 60 |                         and     x,#%111
3C30(008F) 03 78 FE 2C |                         shl     _states+7,#3
3C34(0090) 30 79 BE 68 |                         or      _states+7,x
3C38(0091) 03 78 FE 20 |                         ror     _states+7,#3
3C3C(0092) 01 68 FE A0 |                         mov     _present,#1             'set _present
3C40(0093) 1E 00 7C 5C |                         jmp     #update                 'done
3C44(0094) 02 5E FE 20 | look                    ror     data,#2                 'perform lookup
3C48(0095) 2F 33 BD 50 |                         movs    :reg,data
3C4C(0096) DA 32 FD 80 |                         add     :reg,#table
3C50(0097) 1B 5E FE 28 |                         shr     data,#27
3C54(0098) 2F 61 BE A0 |                         mov     x,data
3C58(0099) 00 5E BE A0 | :reg                    mov     data,0
3C5C(009A) 30 5F BE 28 |                         shr     data,x
3C60(009B) C3 00 7C 5C |                         jmp     #rand                   'isolate byte
3C64(009C)             | transmit
3C64(009C) 2D ED BF 68 | _c1                     or      dira,cmask              'pull clock low
3C68(009D) 0D A6 FD 50 |                         movs    napshr,#13              'hold clock for ~128us (must be >100us)
3C6C(009E) D2 AE FD 5C |                         call    #nap
3C70(009F) 2C ED BF 68 | _d1                     or      dira,dmask              'pull data low
3C74(00A0) 12 A6 FD 50 |                         movs    napshr,#18              'hold data for ~4us
3C78(00A1) D2 AE FD 5C |                         call    #nap
3C7C(00A2) 2D ED BF 6C | _c2                     xor     dira,cmask              'release clock
3C80(00A3) FF 5E 7E 61 |                         test    data,#$0FF      wc      'append parity and stop bits to byte
3C84(00A4) 00 5F FE 74 |                         muxnc   data,#$100
3C88(00A5) D8 5E BE 68 |                         or      data,dlsb
3C8C(00A6) 0A 60 FE A0 |                         mov     x,#10                   'ready 10 bits
3C90(00A7) C5 9A FD 5C | transmit_bit            call    #wait_c0                'wait until clock low
3C94(00A8) 01 5E FE 29 |                         shr     data,#1         wc      'output data bit
3C98(00A9) 2C ED BF 74 | _d2                     muxnc   dira,dmask
3C9C(00AA) CF 96 BD A0 |                         mov     wcond,c1                'wait until clock high
3CA0(00AB) C6 9A FD 5C |                         call    #wait
3CA4(00AC) A7 60 FE E4 |                         djnz    x,#transmit_bit         'another bit?
3CA8(00AD) D0 96 BD A0 |                         mov     wcond,c0d0              'wait until clock and data low
3CAC(00AE) C6 9A FD 5C |                         call    #wait
3CB0(00AF) D1 96 BD A0 |                         mov     wcond,c1d1              'wait until clock and data high
3CB4(00B0) C6 9A FD 5C |                         call    #wait
3CB8(00B1) B7 88 FD 5C |                         call    #receive_ack            'receive ack byte with timed wait
3CBC(00B2) FA 5E 7E 86 |                         cmp     data,#$FA       wz      'if ack error, reset keyboard
3CC0(00B3) 16 00 54 5C |         if_nz           jmp     #reset
3CC4(00B4) 00 00 7C 5C | transmit_ret            ret
3CC8(00B5) 20 7C 7E 61 | receive                 test    _cpin,#$20      wc      'wait indefinitely for initial clock low
3CCC(00B6) 2D 5B 3E F4 |                         waitpne cmask,cmask
3CD0(00B7)             | receive_ack
3CD0(00B7) 0B 60 FE A0 |                         mov     x,#11                   'ready 11 bits
3CD4(00B8) C5 9A FD 5C | receive_bit             call    #wait_c0                'wait until clock low
3CD8(00B9) 10 A6 FD 50 |                         movs    napshr,#16              'pause ~16us
3CDC(00BA) D2 AE FD 5C |                         call    #nap
3CE0(00BB) F2 59 3E 61 | _d3                     test    dmask,ina       wc      'input data bit
3CE4(00BC) 01 5E FE 30 |                         rcr     data,#1
3CE8(00BD) CF 96 BD A0 |                         mov     wcond,c1                'wait until clock high
3CEC(00BE) C6 9A FD 5C |                         call    #wait
3CF0(00BF) B8 60 FE E4 |                         djnz    x,#receive_bit          'another bit?
3CF4(00C0) 16 5E FE 28 |                         shr     data,#22                'align byte
3CF8(00C1) FF 5F 7E 61 |                         test    data,#$1FF      wc      'if parity error, reset keyboard
3CFC(00C2) 16 00 4C 5C |         if_nc           jmp     #reset
3D00(00C3) FF 5E FE 60 | rand                    and     data,#$FF               'isolate byte
3D04(00C4)             | look_ret
3D04(00C4)             | receive_ack_ret
3D04(00C4) 00 00 7C 5C | receive_ret             ret
3D08(00C5) CE 96 BD A0 | wait_c0                 mov     wcond,c0                '(wait until clock low)
3D0C(00C6) D9 62 BE A0 | wait                    mov     y,tenms                 'set timeout to 10ms
3D10(00C7) 12 A6 FD 50 | wloop                   movs    napshr,#18              'nap ~4us
3D14(00C8) D2 AE FD 5C |                         call    #nap
3D18(00C9) F2 5B 3E 61 | _c3                     test    cmask,ina       wc      'check required state(s)
3D1C(00CA) F2 59 3E 62 | _d4                     test    dmask,ina       wz      'loop until got state(s) or timeout
3D20(00CB) C7 62 C2 E4 | wcond   if_never        djnz    y,#wloop                '(replaced with c0/c1/c0d0/c1d1)
3D24(00CC) 16 62 7E EC |                         tjz     y,#reset                'if timeout, reset keyboard
3D28(00CD)             | wait_ret
3D28(00CD) 00 00 7C 5C | wait_c0_ret             ret
3D2C(00CE) C7 62 F2 E4 | c0      if_c            djnz    y,#wloop                '(if_never replacements)
3D30(00CF) C7 62 CE E4 | c1      if_nc           djnz    y,#wloop
3D34(00D0) C7 62 F6 E4 | c0d0    if_c_or_nz      djnz    y,#wloop
3D38(00D1) C7 62 EE E4 | c1d1    if_nc_or_z      djnz    y,#wloop
3D3C(00D2) 00 64 FE 08 | nap                     rdlong  t,#0                    'get clkfreq
3D40(00D3) 00 64 FE 28 | napshr                  shr     t,#18/16/13             'shr scales time
3D44(00D4) 03 64 FE 48 |                         min     t,#3                    'ensure waitcnt won't snag
3D48(00D5) F1 65 BE 80 |                         add     t,cnt                   'add cnt to time
3D4C(00D6) 00 64 FE F8 |                         waitcnt t,#0                    'wait until time elapses (nap)
3D50(00D7) 00 00 7C 5C | nap_ret                 ret
3D54(00D8) 00 02 00 00 | dlsb                    long    1 << 9
3D58(00D9) C4 09 00 00 | tenms                   long    10_000 / 4
3D5C(00DA) 00 00       | table                   word    $0000   '00
3D5E(00DA) D8 00       |                         word    $00D8   '01             F9
3D60(00DB) 00 00       |                         word    $0000   '02
3D62(00DB) D4 00       |                         word    $00D4   '03             F5
3D64(00DC) D2 00       |                         word    $00D2   '04             F3
3D66(00DC) D0 00       |                         word    $00D0   '05             F1
3D68(00DD) D1 00       |                         word    $00D1   '06             F2
3D6A(00DD) DB 00       |                         word    $00DB   '07             F12
3D6C(00DE) 00 00       |                         word    $0000   '08
3D6E(00DE) D9 00       |                         word    $00D9   '09             F10
3D70(00DF) D7 00       |                         word    $00D7   '0A             F8
3D72(00DF) D5 00       |                         word    $00D5   '0B             F6
3D74(00E0) D3 00       |                         word    $00D3   '0C             F4
3D76(00E0) 09 00       |                         word    $0009   '0D             Tab
3D78(00E1) 60 00       |                         word    $0060   '0E             `
3D7A(00E1) 00 00       |                         word    $0000   '0F
3D7C(00E2) 00 00       |                         word    $0000   '10
3D7E(00E2) F4 F5       |                         word    $F5F4   '11     Alt-R   Alt-L
3D80(00E3) F0 00       |                         word    $00F0   '12             Shift-L
3D82(00E3) 00 00       |                         word    $0000   '13
3D84(00E4) F2 F3       |                         word    $F3F2   '14     Ctrl-R  Ctrl-L
3D86(00E4) 71 00       |                         word    $0071   '15             q
3D88(00E5) 31 00       |                         word    $0031   '16             1
3D8A(00E5) 00 00       |                         word    $0000   '17
3D8C(00E6) 00 00       |                         word    $0000   '18
3D8E(00E6) 00 00       |                         word    $0000   '19
3D90(00E7) 7A 00       |                         word    $007A   '1A             z
3D92(00E7) 73 00       |                         word    $0073   '1B             s
3D94(00E8) 61 00       |                         word    $0061   '1C             a
3D96(00E8) 77 00       |                         word    $0077   '1D             w
3D98(00E9) 32 00       |                         word    $0032   '1E             2
3D9A(00E9) 00 F6       |                         word    $F600   '1F     Win-L
3D9C(00EA) 00 00       |                         word    $0000   '20
3D9E(00EA) 63 00       |                         word    $0063   '21             c
3DA0(00EB) 78 00       |                         word    $0078   '22             x
3DA2(00EB) 64 00       |                         word    $0064   '23             d
3DA4(00EC) 65 00       |                         word    $0065   '24             e
3DA6(00EC) 34 00       |                         word    $0034   '25             4
3DA8(00ED) 33 00       |                         word    $0033   '26             3
3DAA(00ED) 00 F7       |                         word    $F700   '27     Win-R
3DAC(00EE) 00 00       |                         word    $0000   '28
3DAE(00EE) 20 00       |                         word    $0020   '29             Space
3DB0(00EF) 76 00       |                         word    $0076   '2A             v
3DB2(00EF) 66 00       |                         word    $0066   '2B             f
3DB4(00F0) 74 00       |                         word    $0074   '2C             t
3DB6(00F0) 72 00       |                         word    $0072   '2D             r
3DB8(00F1) 35 00       |                         word    $0035   '2E             5
3DBA(00F1) 00 CC       |                         word    $CC00   '2F     Apps
3DBC(00F2) 00 00       |                         word    $0000   '30
3DBE(00F2) 6E 00       |                         word    $006E   '31             n
3DC0(00F3) 62 00       |                         word    $0062   '32             b
3DC2(00F3) 68 00       |                         word    $0068   '33             h
3DC4(00F4) 67 00       |                         word    $0067   '34             g
3DC6(00F4) 79 00       |                         word    $0079   '35             y
3DC8(00F5) 36 00       |                         word    $0036   '36             6
3DCA(00F5) 00 CD       |                         word    $CD00   '37     Power
3DCC(00F6) 00 00       |                         word    $0000   '38
3DCE(00F6) 00 00       |                         word    $0000   '39
3DD0(00F7) 6D 00       |                         word    $006D   '3A             m
3DD2(00F7) 6A 00       |                         word    $006A   '3B             j
3DD4(00F8) 75 00       |                         word    $0075   '3C             u
3DD6(00F8) 37 00       |                         word    $0037   '3D             7
3DD8(00F9) 38 00       |                         word    $0038   '3E             8
3DDA(00F9) 00 CE       |                         word    $CE00   '3F     Sleep
3DDC(00FA) 00 00       |                         word    $0000   '40
3DDE(00FA) 2C 00       |                         word    $002C   '41             ,
3DE0(00FB) 6B 00       |                         word    $006B   '42             k
3DE2(00FB) 69 00       |                         word    $0069   '43             i
3DE4(00FC) 6F 00       |                         word    $006F   '44             o
3DE6(00FC) 30 00       |                         word    $0030   '45             0
3DE8(00FD) 39 00       |                         word    $0039   '46             9
3DEA(00FD) 00 00       |                         word    $0000   '47
3DEC(00FE) 00 00       |                         word    $0000   '48
3DEE(00FE) 2E 00       |                         word    $002E   '49             .
3DF0(00FF) 2F EF       |                         word    $EF2F   '4A     (/)     /
3DF2(00FF) 6C 00       |                         word    $006C   '4B             l
3DF4(0100) 3B 00       |                         word    $003B   '4C             ;
3DF6(0100) 70 00       |                         word    $0070   '4D             p
3DF8(0101) 2D 00       |                         word    $002D   '4E             -
3DFA(0101) 00 00       |                         word    $0000   '4F
3DFC(0102) 00 00       |                         word    $0000   '50
3DFE(0102) 00 00       |                         word    $0000   '51
3E00(0103) 27 00       |                         word    $0027   '52             '
3E02(0103) 00 00       |                         word    $0000   '53
3E04(0104) 5B 00       |                         word    $005B   '54             [
3E06(0104) 3D 00       |                         word    $003D   '55             =
3E08(0105) 00 00       |                         word    $0000   '56
3E0A(0105) 00 00       |                         word    $0000   '57
3E0C(0106) DE 00       |                         word    $00DE   '58             CapsLock
3E0E(0106) F1 00       |                         word    $00F1   '59             Shift-R
3E10(0107) 0D EB       |                         word    $EB0D   '5A     (Enter) Enter
3E12(0107) 5D 00       |                         word    $005D   '5B             ]
3E14(0108) 00 00       |                         word    $0000   '5C
3E16(0108) 5C 00       |                         word    $005C   '5D             \
3E18(0109) 00 CF       |                         word    $CF00   '5E     WakeUp
3E1A(0109) 00 00       |                         word    $0000   '5F
3E1C(010A) 00 00       |                         word    $0000   '60
3E1E(010A) 00 00       |                         word    $0000   '61
3E20(010B) 00 00       |                         word    $0000   '62
3E22(010B) 00 00       |                         word    $0000   '63
3E24(010C) 00 00       |                         word    $0000   '64
3E26(010C) 00 00       |                         word    $0000   '65
3E28(010D) C8 00       |                         word    $00C8   '66             BackSpace
3E2A(010D) 00 00       |                         word    $0000   '67
3E2C(010E) 00 00       |                         word    $0000   '68
3E2E(010E) E1 C5       |                         word    $C5E1   '69     End     (1)
3E30(010F) 00 00       |                         word    $0000   '6A
3E32(010F) E4 C0       |                         word    $C0E4   '6B     Left    (4)
3E34(0110) E7 C4       |                         word    $C4E7   '6C     Home    (7)
3E36(0110) 00 00       |                         word    $0000   '6D
3E38(0111) 00 00       |                         word    $0000   '6E
3E3A(0111) 00 00       |                         word    $0000   '6F
3E3C(0112) E0 CA       |                         word    $CAE0   '70     Insert  (0)
3E3E(0112) EA C9       |                         word    $C9EA   '71     Delete  (.)
3E40(0113) E2 C3       |                         word    $C3E2   '72     Down    (2)
3E42(0113) E5 00       |                         word    $00E5   '73             (5)
3E44(0114) E6 C1       |                         word    $C1E6   '74     Right   (6)
3E46(0114) E8 C2       |                         word    $C2E8   '75     Up      (8)
3E48(0115) CB 00       |                         word    $00CB   '76             Esc
3E4A(0115) DF 00       |                         word    $00DF   '77             NumLock
3E4C(0116) DA 00       |                         word    $00DA   '78             F11
3E4E(0116) EC 00       |                         word    $00EC   '79             (+)
3E50(0117) E3 C7       |                         word    $C7E3   '7A     PageDn  (3)
3E52(0117) ED 00       |                         word    $00ED   '7B             (-)
3E54(0118) EE DC       |                         word    $DCEE   '7C     PrScr   (*)
3E56(0118) E9 C6       |                         word    $C6E9   '7D     PageUp  (9)
3E58(0119) DD 00       |                         word    $00DD   '7E             ScrLock
3E5A(0119) 00 00       |                         word    $0000   '7F
3E5C(011A) 00 00       |                         word    $0000   '80
3E5E(011A) 00 00       |                         word    $0000   '81
3E60(011B) 00 00       |                         word    $0000   '82
3E62(011B) D6 00       |                         word    $00D6   '83             F7
3E64(011C) CA          | keypad1                 byte    $CA, $C5, $C3, $C7, $C0, 0, $C1, $C4, $C2, $C6, $C9, $0D, "+-*/"
3E65(011C) C5          | 
3E66(011C) C3          | 
3E67(011C) C7          | 
3E68(011D) C0          | 
3E69(011D) 00          | 
3E6A(011D) C1          | 
3E6B(011D) C4          | 
3E6C(011E) C2          | 
3E6D(011E) C6          | 
3E6E(011E) C9          | 
3E6F(011E) 0D          | 
3E70(011F) 2B          | 
3E71(011F) 2D          | 
3E72(011F) 2A          | 
3E73(011F) 2F          | 
3E74(0120) 30          | keypad2                 byte    "0123456789.", $0D, "+-*/"
3E75(0120) 31          | 
3E76(0120) 32          | 
3E77(0120) 33          | 
3E78(0121) 34          | 
3E79(0121) 35          | 
3E7A(0121) 36          | 
3E7B(0121) 37          | 
3E7C(0122) 38          | 
3E7D(0122) 39          | 
3E7E(0122) 2E          | 
3E7F(0122) 0D          | 
3E80(0123) 2B          | 
3E81(0123) 2D          | 
3E82(0123) 2A          | 
3E83(0123) 2F          | 
3E84(0124) 7B          | shift1                  byte    "{|}", 0, 0, "~"
3E85(0124) 7C          | 
3E86(0124) 7D          | 
3E87(0124) 00          | 
3E88(0125) 00          | 
3E89(0125) 7E          | 
3E8A(0125) 22          | shift2                  byte    $22, 0, 0, 0, 0, "<_>?)!@#$%^&*(", 0, ":", 0, "+"
3E8B(0125) 00          | 
3E8C(0126) 00          | 
3E8D(0126) 00          | 
3E8E(0126) 00          | 
3E8F(0126) 3C          | 
3E90(0127) 5F          | 
3E91(0127) 3E          | 
3E92(0127) 3F          | 
3E93(0127) 29          | 
3E94(0128) 21          | 
3E95(0128) 40          | 
3E96(0128) 23          | 
3E97(0128) 24          | 
3E98(0129) 25          | 
3E99(0129) 5E          | 
3E9A(0129) 26          | 
3E9B(0129) 2A          | 
3E9C(012A) 28          | 
3E9D(012A) 00          | 
3E9E(012A) 3A          | 
3E9F(012A) 00          | 
3EA0(012B) 2B          | 
3EA1(012B)             | dmask                   res     1
3EA4(012D)             | cmask                   res     1
3EA4(012E)             | stat                    res     1
3EA4(012F)             | data                    res     1
3EA4(0130)             | x                       res     1
3EA4(0131)             | y                       res     1
3EA4(0132)             | t                       res     1
3EA4(0133)             | _head                   res     1       'write-only
3EA4(0134)             | _present                res     1       'write-only
3EA4(0135)             | _states                 res     8       'write-only
3EA4(013D)             | _dpin                   res     1       'read-only at start
3EA4(013E)             | _cpin                   res     1       'read-only at start
3EA4(013F)             | _locks                  res     1       'read-only at start
3EA4(0140)             | _auto                   res     1       'read-only at start
|===========================================================================|
|===========================================================================|
Spin Block start with 2 Parameters and 0 Extra Stack Longs. Method 1
PUB start(dpin, cpin) : okay

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - dpin
Local Parameter DBASE:0008 - cpin
|===========================================================================|
40                        okay := startx(dpin, cpin, %0_000_100, %01_01000)
Addr : 3EA4:             00  : Drop Anchor Push 
Addr : 3EA5:             64  : Variable Operation Local Offset - 1 Read
Addr : 3EA6:             68  : Variable Operation Local Offset - 2 Read
Addr : 3EA7:          37 01  : Constant Mask Y=1 00000004
Addr : 3EA9:          38 28  : Constant 1 Bytes - 28 
Addr : 3EAB:          05 02  : Call Sub 2    
Addr : 3EAD:             61  : Variable Operation Local Offset - 0 Write
41                        nkey := dkeyhd := dkeytail := 0
Addr : 3EAE:             35  : Constant 1 $00000000
Addr : 3EAF:       CA 58 80  : Memory Op Long VBASE + ASSIGN Address = 0058 Write Push
Addr : 3EB2:       CA 54 80  : Memory Op Long VBASE + ASSIGN Address = 0054 Write Push
Addr : 3EB5:          C9 50  : Memory Op Long VBASE + WRITE Address = 0050
Addr : 3EB7:             32  : Return        
|===========================================================================|
Spin Block startx with 4 Parameters and 0 Extra Stack Longs. Method 2
PUB startx(dpin, cpin, locks, auto) : okay

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - dpin
Local Parameter DBASE:0008 - cpin
Local Parameter DBASE:000C - locks
Local Parameter DBASE:0010 - auto
|===========================================================================|
59                        stop
Addr : 3EB8:             01  : Drop Anchor   
Addr : 3EB9:          05 03  : Call Sub 3    
60                        longmove(@par_keys, @dpin, 4)
Addr : 3EBB:          CB 30  : Memory Op Long VBASE + ADDRESS Address = 0030
Addr : 3EBD:             67  : Variable Operation Local Offset - 1 Address
Addr : 3EBE:          37 01  : Constant Mask Y=1 00000004
Addr : 3EC0:             1E  : LongMove(To, From, Count)
61                        okay := cog := cognew(@entry, @par_tail) + 1
Addr : 3EC1:             34  : Constant 0 $FFFFFFFF
Addr : 3EC2:          C7 38  : Memory Op Long PBASE + ADDRESS Address = 0038
Addr : 3EC4:             47  : Variable Operation Global Offset - 1 Address
Addr : 3EC5:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 3EC6:             36  : Constant 2 $00000001
Addr : 3EC7:             EC  : Math Op +     
Addr : 3EC8:          42 80  : Variable Operation Global Offset - 0 Assign Write Push
Addr : 3ECA:             61  : Variable Operation Local Offset - 0 Write
Addr : 3ECB:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 3
PUB stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
68                        if cog
Addr : 3ECC:             40  : Variable Operation Global Offset - 0 Read
Addr : 3ECD: JZ Label0002
Addr : 3ECD:          0A 05  : jz Address = 3ED4 5
69                          cogstop(cog~ -  1)
Addr : 3ECF:          42 98  : Variable Operation Global Offset - 0 Assign VAR~ Post-clear Push
Addr : 3ED1:             36  : Constant 2 $00000001
Addr : 3ED2:             ED  : Math Op -     
Addr : 3ED3:             21  : CogStop(id)   
Addr : 3ED4: Label0002
Addr : 3ED4: Label0003
70                        longfill(@par_tail, 0, 19)
Addr : 3ED4:             47  : Variable Operation Global Offset - 1 Address
Addr : 3ED5:             35  : Constant 1 $00000000
Addr : 3ED6:          38 13  : Constant 1 Bytes - 13 
Addr : 3ED8:             1A  : LongFill(Start, Value, Count)
Addr : 3ED9:             32  : Return        
|===========================================================================|
Spin Block present with 0 Parameters and 0 Extra Stack Longs. Method 4
PUB present : truefalse

Local Parameter DBASE:0000 - Result
|===========================================================================|
78                        truefalse := -par_present
Addr : 3EDA:             4C  : Variable Operation Global Offset - 3 Read
Addr : 3EDB:             E6  : Math Op -     
Addr : 3EDC:             61  : Variable Operation Local Offset - 0 Write
Addr : 3EDD:             32  : Return        
|===========================================================================|
Spin Block key with 0 Parameters and 0 Extra Stack Longs. Method 5
PUB key : keycode

Local Parameter DBASE:0000 - Result
|===========================================================================|
93                        if par_tail <> par_head
Addr : 3EDE:             44  : Variable Operation Global Offset - 1 Read
Addr : 3EDF:             48  : Variable Operation Global Offset - 2 Read
Addr : 3EE0:             FB  : Math Op <>    
Addr : 3EE1: JZ Label0002
Addr : 3EE1:          0A 0A  : jz Address = 3EED 10
94                          keycode := par_keys.word[par_tail]
Addr : 3EE3:             44  : Variable Operation Global Offset - 1 Read
Addr : 3EE4:          B8 30  : Memory Op Word VBASE + POP Index READ Address = 0030
Addr : 3EE6:             61  : Variable Operation Local Offset - 0 Write
95                          par_tail := ++par_tail & $F
Addr : 3EE7:          46 A6  : Variable Operation Global Offset - 1 Assign ++VAR pre-inc Long Push
Addr : 3EE9:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 3EEB:             E8  : Math Op &     
Addr : 3EEC:             45  : Variable Operation Global Offset - 1 Write
Addr : 3EED: Label0002
Addr : 3EED: Label0003
Addr : 3EED:             32  : Return        
|===========================================================================|
Spin Block getkey with 0 Parameters and 1 Extra Stack Longs. Method 6
PUB getkey : keycode | temp

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - temp
|===========================================================================|
160                        temp := key
Addr : 3EEE:             00  : Drop Anchor Push 
Addr : 3EEF:          05 05  : Call Sub 5    
Addr : 3EF1:             65  : Variable Operation Local Offset - 1 Write
162                        if temp > 0
Addr : 3EF2:             64  : Variable Operation Local Offset - 1 Read
Addr : 3EF3:             35  : Constant 1 $00000000
Addr : 3EF4:             FA  : Math Op >     
Addr : 3EF5: JZ Label0002
Addr : 3EF5:          0A 04  : jz Address = 3EFB 4
163                          decode_key(temp)
Addr : 3EF7:             01  : Drop Anchor   
Addr : 3EF8:             64  : Variable Operation Local Offset - 1 Read
Addr : 3EF9:          05 0D  : Call Sub 13   
Addr : 3EFB: Label0002
Addr : 3EFB: Label0003
165                        keycode := 0
Addr : 3EFB:             35  : Constant 1 $00000000
Addr : 3EFC:             61  : Variable Operation Local Offset - 0 Write
166                        if nkey
Addr : 3EFD:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 3EFF: JZ Label0004
Addr : 3EFF:          0A 14  : jz Address = 3F15 20
167                          nkey -= 1
Addr : 3F01:             36  : Constant 2 $00000001
Addr : 3F02:       CA 50 4D  : Memory Op Long VBASE + ASSIGN Address = 0050 WordMathop -
168                          keycode := dkeys[dkeytail]
Addr : 3F05:          C8 58  : Memory Op Long VBASE + READ Address = 0058
Addr : 3F07:          98 5C  : Memory Op Byte VBASE + POP Index READ Address = 005C
Addr : 3F09:             61  : Variable Operation Local Offset - 0 Write
169                          dkeys[dkeytail++] := 0
Addr : 3F0A:             35  : Constant 1 $00000000
Addr : 3F0B:       CA 58 AE  : Memory Op Long VBASE + ASSIGN Address = 0058 VAR++ post inc Long Push
Addr : 3F0E:          99 5C  : Memory Op Byte VBASE + POP Index WRITE Address = 005C
170                          dkeytail &= $F
Addr : 3F10:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 3F12:       CA 58 48  : Memory Op Long VBASE + ASSIGN Address = 0058 BitMathop &
Addr : 3F15: Label0004
Addr : 3F15: Label0005
Addr : 3F15:             32  : Return        
|===========================================================================|
Spin Block newkey with 0 Parameters and 0 Extra Stack Longs. Method 7
PUB newkey : keycode

Local Parameter DBASE:0000 - Result
|===========================================================================|
178                        par_tail := par_head
Addr : 3F16:             48  : Variable Operation Global Offset - 2 Read
Addr : 3F17:             45  : Variable Operation Global Offset - 1 Write
179                        keycode := getkey
Addr : 3F18:             00  : Drop Anchor Push 
Addr : 3F19:          05 06  : Call Sub 6    
Addr : 3F1B:             61  : Variable Operation Local Offset - 0 Write
Addr : 3F1C:             32  : Return        
|===========================================================================|
Spin Block gotkey with 0 Parameters and 1 Extra Stack Longs. Method 8
PUB gotkey : truefalse | temp

Local Parameter DBASE:0000 - Result
Local Variable  DBASE:0004 - temp
|===========================================================================|
190                        temp := key
Addr : 3F1D:             00  : Drop Anchor Push 
Addr : 3F1E:          05 05  : Call Sub 5    
Addr : 3F20:             65  : Variable Operation Local Offset - 1 Write
192                        if temp > 0
Addr : 3F21:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F22:             35  : Constant 1 $00000000
Addr : 3F23:             FA  : Math Op >     
Addr : 3F24: JZ Label0002
Addr : 3F24:          0A 04  : jz Address = 3F2A 4
193                          decode_key(temp)
Addr : 3F26:             01  : Drop Anchor   
Addr : 3F27:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F28:          05 0D  : Call Sub 13   
Addr : 3F2A: Label0002
Addr : 3F2A: Label0003
195                        return nkey
Addr : 3F2A:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 3F2C:             33  : Return value  
Addr : 3F2D: Data : 32                       2
|===========================================================================|
Spin Block clearkeys with 0 Parameters and 0 Extra Stack Longs. Method 9
PUB clearkeys

Local Parameter DBASE:0000 - Result
|===========================================================================|
201                        par_tail := par_head
Addr : 3F2E:             48  : Variable Operation Global Offset - 2 Read
Addr : 3F2F:             45  : Variable Operation Global Offset - 1 Write
Addr : 3F30:             32  : Return        
|===========================================================================|
Spin Block keystate with 1 Parameters and 0 Extra Stack Longs. Method 10
PUB keystate(k) : state

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - k
|===========================================================================|
209                        state := -(par_states[k >> 5] >> k & 1)
Addr : 3F31:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F32:          38 05  : Constant 1 Bytes - 05 
Addr : 3F34:             E2  : Math Op >>    
Addr : 3F35:          D8 10  : Memory Op Long VBASE + POP Index READ Address = 0010
Addr : 3F37:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F38:             E2  : Math Op >>    
Addr : 3F39:             36  : Constant 2 $00000001
Addr : 3F3A:             E8  : Math Op &     
Addr : 3F3B:             E6  : Math Op -     
Addr : 3F3C:             61  : Variable Operation Local Offset - 0 Write
Addr : 3F3D:             32  : Return        
|===========================================================================|
Spin Block enqueue with 1 Parameters and 0 Extra Stack Longs. Method 11
PRI enqueue(c)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - c
|===========================================================================|
82                        if nkey == 16
Addr : 3F3E:          C8 50  : Memory Op Long VBASE + READ Address = 0050
Addr : 3F40:          37 03  : Constant Mask Y=3 00000010
Addr : 3F42:             FC  : Math Op ==    
Addr : 3F43: JZ Label0002
Addr : 3F43:          0A 01  : jz Address = 3F46 1
83                          return
Addr : 3F45:             32  : Return        
Addr : 3F46: Label0002
Addr : 3F46: Label0003
84                        dkeys[dkeyhd++] := c
Addr : 3F46:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F47:       CA 54 AE  : Memory Op Long VBASE + ASSIGN Address = 0054 VAR++ post inc Long Push
Addr : 3F4A:          99 5C  : Memory Op Byte VBASE + POP Index WRITE Address = 005C
85                        nkey += 1
Addr : 3F4C:             36  : Constant 2 $00000001
Addr : 3F4D:       CA 50 4C  : Memory Op Long VBASE + ASSIGN Address = 0050 WordMathop +
86                        dkeyhd &=$F
Addr : 3F50:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 3F52:       CA 54 48  : Memory Op Long VBASE + ASSIGN Address = 0054 BitMathop &
Addr : 3F55:             32  : Return        
|===========================================================================|
Spin Block escstr with 1 Parameters and 1 Extra Stack Longs. Method 12
PRI escstr(s) | xx

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - s
Local Variable  DBASE:0008 - xx
|===========================================================================|
98                        enqueue($1B)
Addr : 3F56:             01  : Drop Anchor   
Addr : 3F57:          38 1B  : Constant 1 Bytes - 1B 
Addr : 3F59:          05 0B  : Call Sub 11   
99                        repeat xx from 0 to STRSIZE(s) - 1
Addr : 3F5B:             35  : Constant 1 $00000000
Addr : 3F5C:             69  : Variable Operation Local Offset - 2 Write
Addr : 3F5D: Label0002
100                          enqueue(BYTE[s][xx])
Addr : 3F5D:             01  : Drop Anchor   
Addr : 3F5E:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F5F:             68  : Variable Operation Local Offset - 2 Read
Addr : 3F60:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 3F61:          05 0B  : Call Sub 11   
Addr : 3F63: Label0003
99                        repeat xx from 0 to STRSIZE(s) - 1
Addr : 3F63:             35  : Constant 1 $00000000
Addr : 3F64:             64  : Variable Operation Local Offset - 1 Read
Addr : 3F65:             16  : StrSize(String)
Addr : 3F66:             36  : Constant 2 $00000001
Addr : 3F67:             ED  : Math Op -     
Addr : 3F68: Repeat xx Step Label0002
Addr : 3F68:       6A 02 72  : Variable Operation Local Offset - 2 Assign Repeat-Var loop Address= 3F5D -14
Addr : 3F6B: Label0004
Addr : 3F6B:             32  : Return        
|===========================================================================|
Spin Block decode_key with 1 Parameters and 1 Extra Stack Longs. Method 13
PRI decode_key(scode)   | s

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - scode
Local Variable  DBASE:0008 - s
|===========================================================================|
104                        case scode
Addr : 3F6C: Constant Address of Label0002
Addr : 3F6C:       39 06 47  : Constant 2 Bytes - 06 47 
Addr : 3F6F:             64  : Variable Operation Local Offset - 1 Read
106                          $C0:    'LEFT
Addr : 3F70:          38 C0  : Constant 1 Bytes - C0 
Addr : 3F72: Case_Value Label0003
Addr : 3F72:       0D 80 5C  : Value Case Address = 3FD1 92
109                          $C1:    'RIGHT
Addr : 3F75:          38 C1  : Constant 1 Bytes - C1 
Addr : 3F77: Case_Value Label0005
Addr : 3F77:       0D 80 5C  : Value Case Address = 3FD6 92
112                          $C2:    'UP                   
Addr : 3F7A:          38 C2  : Constant 1 Bytes - C2 
Addr : 3F7C: Case_Value Label0007
Addr : 3F7C:       0D 80 5C  : Value Case Address = 3FDB 92
115                          $C3:    'DOWN
Addr : 3F7F:          38 C3  : Constant 1 Bytes - C3 
Addr : 3F81: Case_Value Label0009
Addr : 3F81:       0D 80 5C  : Value Case Address = 3FE0 92
118                          $C4:    'Home
Addr : 3F84:          38 C4  : Constant 1 Bytes - C4 
Addr : 3F86: Case_Value Label000B
Addr : 3F86:       0D 80 5C  : Value Case Address = 3FE5 92
121                          $C5:    'End
Addr : 3F89:          38 C5  : Constant 1 Bytes - C5 
Addr : 3F8B: Case_Value Label000D
Addr : 3F8B:       0D 80 5C  : Value Case Address = 3FEA 92
124                          $C6:    'Page Up
Addr : 3F8E:          38 C6  : Constant 1 Bytes - C6 
Addr : 3F90: Case_Value Label000F
Addr : 3F90:       0D 80 5C  : Value Case Address = 3FEF 92
127                          $C7:    'Page Dn
Addr : 3F93:          38 C7  : Constant 1 Bytes - C7 
Addr : 3F95: Case_Value Label0011
Addr : 3F95:       0D 80 5C  : Value Case Address = 3FF4 92
130                          $C9:    'Delete    
Addr : 3F98:          38 C9  : Constant 1 Bytes - C9 
Addr : 3F9A: Case_Value Label0013
Addr : 3F9A:       0D 80 5C  : Value Case Address = 3FF9 92
133                          $CA:    'Insert
Addr : 3F9D:          38 CA  : Constant 1 Bytes - CA 
Addr : 3F9F: Case_Value Label0015
Addr : 3F9F:       0D 80 5C  : Value Case Address = 3FFE 92
138                            if scode == $CB
Addr : 3FA2:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FA3:          38 CB  : Constant 1 Bytes - CB 
Addr : 3FA5:             FC  : Math Op ==    
Addr : 3FA6: JZ Label0017
Addr : 3FA6:          0A 03  : jz Address = 3FAB 3
139                              scode := $1B
Addr : 3FA8:          38 1B  : Constant 1 Bytes - 1B 
Addr : 3FAA:             65  : Variable Operation Local Offset - 1 Write
Addr : 3FAB: Label0017
Addr : 3FAB: Label0018
140                            if scode == $C8
Addr : 3FAB:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FAC:          38 C8  : Constant 1 Bytes - C8 
Addr : 3FAE:             FC  : Math Op ==    
Addr : 3FAF: JZ Label0019
Addr : 3FAF:          0A 03  : jz Address = 3FB4 3
141                              scode := $08
Addr : 3FB1:          37 02  : Constant Mask Y=2 00000008
Addr : 3FB3:             65  : Variable Operation Local Offset - 1 Write
Addr : 3FB4: Label0019
Addr : 3FB4: Label001A
143                            if (scode > $260) AND (scode < $27B)
Addr : 3FB4:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FB5:       39 02 60  : Constant 2 Bytes - 02 60 
Addr : 3FB8:             FA  : Math Op >     
Addr : 3FB9:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FBA:       39 02 7B  : Constant 2 Bytes - 02 7B 
Addr : 3FBD:             F9  : Math Op <     
Addr : 3FBE:             F0  : Math Op AND   
Addr : 3FBF: JZ Label001B
Addr : 3FBF:          0A 04  : jz Address = 3FC5 4
144                              scode &= $1F
Addr : 3FC1:          37 24  : Constant Mask Y=36 Decrement 0000001F
Addr : 3FC3:          66 48  : Variable Operation Local Offset - 1 Assign BitMathop &
Addr : 3FC5: Label001B
Addr : 3FC5: Label001C
146                            if (scode < $80)
Addr : 3FC5:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FC6:          37 06  : Constant Mask Y=6 00000080
Addr : 3FC8:             F9  : Math Op <     
Addr : 3FC9: JZ Label001D
Addr : 3FC9:          0A 04  : jz Address = 3FCF 4
147                              enqueue(scode)
Addr : 3FCB:             01  : Drop Anchor   
Addr : 3FCC:             64  : Variable Operation Local Offset - 1 Read
Addr : 3FCD:          05 0B  : Call Sub 11   
Addr : 3FCF: Label001D
Addr : 3FCF: Label001E
149                            return
Addr : 3FCF:             32  : Return        
Addr : 3FD0: CaseDone Label0015
Addr : 3FD0:             0C  : Casedone      
Addr : 3FD1: Label0003
Addr : 3FD1: PBASE Constant Address of Label0004
Addr : 3FD1:       87 86 4C  : Memory Op Byte PBASE + ADDRESS Address = 064C
107                            s := string("[D")
Addr : 3FD4:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FD5: CaseDone Label0003
Addr : 3FD5:             0C  : Casedone      
Addr : 3FD6: Label0005
Addr : 3FD6: PBASE Constant Address of Label0006
Addr : 3FD6:       87 86 4F  : Memory Op Byte PBASE + ADDRESS Address = 064F
110                            s := string("[C")
Addr : 3FD9:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FDA: CaseDone Label0005
Addr : 3FDA:             0C  : Casedone      
Addr : 3FDB: Label0007
Addr : 3FDB: PBASE Constant Address of Label0008
Addr : 3FDB:       87 86 52  : Memory Op Byte PBASE + ADDRESS Address = 0652
113                            s := string("[A")
Addr : 3FDE:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FDF: CaseDone Label0007
Addr : 3FDF:             0C  : Casedone      
Addr : 3FE0: Label0009
Addr : 3FE0: PBASE Constant Address of Label000A
Addr : 3FE0:       87 86 55  : Memory Op Byte PBASE + ADDRESS Address = 0655
116                            s := string("[B")
Addr : 3FE3:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FE4: CaseDone Label0009
Addr : 3FE4:             0C  : Casedone      
Addr : 3FE5: Label000B
Addr : 3FE5: PBASE Constant Address of Label000C
Addr : 3FE5:       87 86 58  : Memory Op Byte PBASE + ADDRESS Address = 0658
119                            s := string("OH")
Addr : 3FE8:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FE9: CaseDone Label000B
Addr : 3FE9:             0C  : Casedone      
Addr : 3FEA: Label000D
Addr : 3FEA: PBASE Constant Address of Label000E
Addr : 3FEA:       87 86 5B  : Memory Op Byte PBASE + ADDRESS Address = 065B
122                            s := string("OF")
Addr : 3FED:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FEE: CaseDone Label000D
Addr : 3FEE:             0C  : Casedone      
Addr : 3FEF: Label000F
Addr : 3FEF: PBASE Constant Address of Label0010
Addr : 3FEF:       87 86 5E  : Memory Op Byte PBASE + ADDRESS Address = 065E
125                            s := string("[5~")
Addr : 3FF2:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FF3: CaseDone Label000F
Addr : 3FF3:             0C  : Casedone      
Addr : 3FF4: Label0011
Addr : 3FF4: PBASE Constant Address of Label0012
Addr : 3FF4:       87 86 62  : Memory Op Byte PBASE + ADDRESS Address = 0662
128                            s := string("[6~")
Addr : 3FF7:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FF8: CaseDone Label0011
Addr : 3FF8:             0C  : Casedone      
Addr : 3FF9: Label0013
Addr : 3FF9: PBASE Constant Address of Label0014
Addr : 3FF9:       87 86 66  : Memory Op Byte PBASE + ADDRESS Address = 0666
131                            s := string("[3~")
Addr : 3FFC:             69  : Variable Operation Local Offset - 2 Write
Addr : 3FFD: CaseDone Label0013
Addr : 3FFD:             0C  : Casedone      
Addr : 3FFE: Label0015
Addr : 3FFE: PBASE Constant Address of Label0016
Addr : 3FFE:       87 86 6A  : Memory Op Byte PBASE + ADDRESS Address = 066A
134                            s := string("[2~")
Addr : 4001:             69  : Variable Operation Local Offset - 2 Write
Addr : 4002: CaseDone Label0015
Addr : 4002:             0C  : Casedone      
Addr : 4003: Label0002
151                        escstr(s)
Addr : 4003:             01  : Drop Anchor   
Addr : 4004:             68  : Variable Operation Local Offset - 2 Read
Addr : 4005:          05 0C  : Call Sub 12   
Addr : 4007:             32  : Return        
Addr : 4008: Label0004
Addr : 4008: Data : 5B 44 00                 [D.
Addr : 400B: Label0006
Addr : 400B: Data : 5B 43 00                 [C.
Addr : 400E: Label0008
Addr : 400E: Data : 5B 41 00                 [A.
Addr : 4011: Label000A
Addr : 4011: Data : 5B 42 00                 [B.
Addr : 4014: Label000C
Addr : 4014: Data : 4F 48 00                 OH.
Addr : 4017: Label000E
Addr : 4017: Data : 4F 46 00                 OF.
Addr : 401A: Label0010
Addr : 401A: Data : 5B 35 7E 00              [5~.
Addr : 401E: Label0012
Addr : 401E: Data : 5B 36 7E 00              [6~.
Addr : 4022: Label0014
Addr : 4022: Data : 5B 33 7E 00              [3~.
Addr : 4026: Label0016
Addr : 4026: Data : 5B 32 7E 00              [2~.
|===========================================================================|
Object safe_spi
Object Base is 402C
|===========================================================================|
Object Constants
|===========================================================================|
Object DAT Blocks
|===========================================================================|
4064(0000) 00 00 00 00 | SPI_engine_cog          long 0
4068(0001) 00 00 00 00 | SPI_command             long 0  ' "t", "r", "w", 0 =>done, <0 => error          | unused
406C(0002) 00 00 00 00 | SPI_block_index         long 0  ' which 512-byte block to read/write            | cnt at init
4070(0003) 00 00 00 00 | SPI_buffer_address      long 0  ' where to get/put the data in Hub RAM          | unused
4074(0004)             | ORG 0
4074(0000)             | SPI_engine_entry
4074(0000) 2F F1 BF A0 |         mov ctra,writeMode
4078(0001) 31 F3 BF A0 |         mov ctrb,clockLineMode
407C(0002) 2B ED BF A0 |         mov dira,maskAll
4080(0003) 01 80 FE A4 |         neg user_request,#1
4084(0004) F0 81 3E 08 |         wrlong user_request,par
4088(0005) F1 8B BE A0 |         mov last_time,cnt
408C(0006)             | waiting_for_command
408C(0006) A4 66 FD 5C |         call #handle_time
4090(0007) F0 81 BE 08 |         rdlong user_request,par
4094(0008) 00 80 7E C3 |         cmps user_request,#0 wz,wc
4098(0009) 06 00 78 5C | if_be   jmp #waiting_for_command
409C(000A) 72 80 7E 86 |         cmp user_request,#"r" wz
40A0(000B) 1D 00 68 5C | if_z    jmp #read_ahead
40A4(000C) 77 80 7E 86 |         cmp user_request,#"w" wz
40A8(000D) 2D 00 68 5C | if_z    jmp #write_behind
40AC(000E) 7A 80 7E 86 |         cmp user_request,#"z" wz
40B0(000F) 16 00 68 5C | if_z    jmp #release_card
40B4(0010) 74 80 7E 86 |         cmp user_request,#"t" wz    ' time
40B8(0011) 2E 6F 2A 08 | if_z    wrlong seconds,sdAdr    ' seconds goes into the SD index register
40BC(0012) 2D 71 2A 08 | if_z    wrlong dtime,bufAdr     ' the remainder goes into the buffer address register
40C0(0013) 00 80 FE A0 |         mov user_request,#0
40C4(0014) F0 81 3E 08 |         wrlong user_request,par
40C8(0015) 06 00 7C 5C |         jmp #waiting_for_command
40CC(0016)             | release_card
40CC(0016) 7A 82 FE A0 |         mov user_cmd,#"z"       ' request a release 
40D0(0017) 01 76 FE A4 |         neg lastIndexPlus,#1    ' reset the last block index 
40D4(0018) 01 84 FE A4 |         neg user_idx,#1         ' and make this match it 
40D8(0019) 35 96 FC 5C |         call #handle_command
40DC(001A) 41 81 BE A0 |         mov user_request,user_cmd
40E0(001B) F0 81 3E 08 |         wrlong user_request,par
40E4(001C) 06 00 7C 5C |         jmp #waiting_for_command
40E8(001D)             | read_ahead
40E8(001D) 2E 85 BE 08 |         rdlong user_idx,sdAdr
40EC(001E) 42 7F BE A0 |         mov tmp1,user_idx
40F0(001F) 01 7E FE 80 |         add tmp1,#1
40F4(0020) 3B 7F 3E 86 |         cmp tmp1,lastIndexPlus wz
40F8(0021) 72 78 6A 86 | if_z    cmp lastCommand,#"r" wz
40FC(0022) 25 00 68 5C | if_z    jmp #:get_on_with_it
4100(0023) 72 82 FE A0 |         mov user_cmd,#"r"
4104(0024) 35 96 FC 5C |         call #handle_command
4108(0025)             | :get_on_with_it
4108(0025) 10 78 FD 58 |         movi transfer_long,#%000010_000 'set to wrlong
410C(0026) B4 8A FD 5C |         call #hub_cog_transfer
4110(0027) 41 81 BE A0 |         mov user_request,user_cmd
4114(0028) F0 81 3E 08 |         wrlong user_request,par
4118(0029) 72 82 FE A0 |         mov user_cmd,#"r"
411C(002A) 01 84 FE 80 |         add user_idx,#1
4120(002B) 35 96 FC 5C |         call #handle_command
4124(002C) 06 00 7C 5C |         jmp #waiting_for_command
4128(002D)             | write_behind
4128(002D) 2E 85 BE 08 |         rdlong user_idx,sdAdr
412C(002E) 11 78 FD 58 |         movi transfer_long,#%000010_001 'set to rdlong
4130(002F) B4 8A FD 5C |         call #hub_cog_transfer
4134(0030) 41 81 BE A0 |         mov user_request,user_cmd
4138(0031) F0 81 3E 08 |         wrlong user_request,par
413C(0032) 77 82 FE A0 |         mov user_cmd,#"w"
4140(0033) 35 96 FC 5C |         call #handle_command
4144(0034) 06 00 7C 5C |         jmp #waiting_for_command
4148(0035)             | handle_command
4148(0035) 42 77 3E 86 |         cmp lastIndexPlus,user_idx wz
414C(0036) 3C 83 2A 86 | if_z    cmp user_cmd,lastCommand wz
4150(0037) 42 00 68 5C | if_z    jmp #:execute_block_command
4154(0038) 77 78 7E 86 |         cmp lastCommand,#"w" wz
4158(0039) 5A C4 E8 5C | if_z    call #stop_mb_write
415C(003A) 72 78 7E 86 |         cmp lastCommand,#"r" wz  
4160(003B) 53 AC E8 5C | if_z    call #stop_mb_read
4164(003C) 77 82 7E 86 |         cmp user_cmd,#"w" wz
4168(003D) 57 B2 E8 5C | if_z    call #start_mb_write
416C(003E) 72 82 7E 86 |         cmp user_cmd,#"r" wz
4170(003F) 50 A4 E8 5C | if_z    call #start_mb_read
4174(0040) 7A 82 7E 86 |         cmp user_cmd,#"z" wz
4178(0041) 4C 9E E8 5C | if_z    call #release_DO
417C(0042)             | :execute_block_command
417C(0042) 42 77 BE A0 |         mov lastIndexPlus,user_idx
4180(0043) 01 76 FE 80 |         add lastIndexPlus,#1
4184(0044) 41 79 BE A0 |         mov lastCommand,user_cmd
4188(0045) 77 82 7E 86 |         cmp user_cmd,#"w" wz
418C(0046) F0 48 EA 5C | if_z    call #write_single_block
4190(0047) 72 82 7E 86 |         cmp user_cmd,#"r" wz
4194(0048) C6 DE E9 5C | if_z    call #read_single_block
4198(0049) 7A 82 7E 86 |         cmp user_cmd,#"z" wz
419C(004A) 00 82 EA A0 | if_z    mov user_cmd,#0
41A0(004B)             | handle_command_ret
41A0(004B) 00 00 7C 5C |         ret   
41A4(004C)             | release_DO
41A4(004C) 2A E9 BF 68 |         or outa,maskCS
41A8(004D) 8D 46 FD 5C |         call #in8
41AC(004E) 8D 46 FD 5C |         call #in8
41B0(004F)             | release_DO_ret
41B0(004F) 00 00 7C 5C |         ret
41B4(0050)             | start_mb_read  
41B4(0050) A4 86 FE 58 |         movi block_cmd,#CMD18<<1
41B8(0051) 63 F6 FC 5C |         call #send_SPI_command_fast       
41BC(0052)             | start_mb_read_ret
41BC(0052) 00 00 7C 5C |         ret
41C0(0053)             | stop_mb_read
41C0(0053) 98 86 FE 58 |         movi block_cmd,#CMD12<<1
41C4(0054) 63 F6 FC 5C |         call #send_SPI_command_fast
41C8(0055) 7C 00 FD 5C |         call #busy_fast
41CC(0056)             | stop_mb_read_ret
41CC(0056) 00 00 7C 5C |         ret
41D0(0057)             | start_mb_write  
41D0(0057) B2 86 FE 58 |         movi block_cmd,#CMD25<<1
41D4(0058) 63 F6 FC 5C |         call #send_SPI_command_fast
41D8(0059)             | start_mb_write_ret
41D8(0059) 00 00 7C 5C |         ret
41DC(005A)             | stop_mb_write
41DC(005A) 7C 00 FD 5C |         call #busy_fast
41E0(005B) 10 7E FE A0 |         mov tmp1,#16
41E4(005C)             | :loopity
41E4(005C) 8D 46 FD 5C |         call #in8         
41E8(005D) 5C 7E FE E4 |         djnz tmp1,#:loopity
41EC(005E) FA F9 FF 58 |         movi phsa,#$FD<<1
41F0(005F) 81 18 FD 5C |         call #out8
41F4(0060) 8D 46 FD 5C |         call #in8       ' stuff byte
41F8(0061) 7C 00 FD 5C |         call #busy_fast
41FC(0062)             | stop_mb_write_ret
41FC(0062) 00 00 7C 5C |         ret
4200(0063)             | send_SPI_command_fast
4200(0063) 2B ED BF A0 |         mov dira,maskAll
4204(0064) 2A E9 BF 68 |         or outa,maskCS  
4208(0065) 2A E9 BF 64 |         andn outa,maskCS
420C(0066) 8D 46 FD 5C |         call #in8 
4210(0067) 43 F9 BF A0 |         mov phsa,block_cmd                      ' do which ever block command this is (already in the top 8 bits)
4214(0068) 81 18 FD 5C |         call #out8                               ' write the byte
4218(0069) 42 F9 BF A0 |         mov phsa,user_idx                       ' read in the desired block index
421C(006A) 2C F9 BF 2C |         shl phsa,adrShift                       ' this will multiply by 512 (bytes/sector) for MMC and SD
4220(006B) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
4224(006C) 01 F8 FF 24 |         rol phsa,#1
4228(006D) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
422C(006E) 01 F8 FF 24 |         rol phsa,#1
4230(006F) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
4234(0070) 01 F8 FF 24 |         rol phsa,#1
4238(0071) 81 18 FD 5C |         call #out8                               ' move out the 1st MSB                              '
423C(0072) 8D 46 FD 5C |         call #in8                                ' in8 looks like out8 with $FF
4240(0073) 18 86 FE 28 |         shr block_cmd,#24
4244(0074) 4C 86 7E 86 |         cmp block_cmd,#CMD12 wz
4248(0075) 8D 46 E9 5C | if_z    call #in8                               ' 8 clocks
424C(0076) 09 7E FE A0 |         mov tmp1,#9
4250(0077)             | :cmd_response
4250(0077) 8D 46 FD 5C |         call #in8
4254(0078) 80 7C 7E 63 |         test readback,#$80 wc,wz
4258(0079) 77 7E F2 E4 | if_c    djnz tmp1,#:cmd_response
425C(007A) 3E 83 96 A4 | if_nz   neg user_cmd,readback
4260(007B)             | send_SPI_command_fast_ret
4260(007B) 00 00 7C 5C |         ret    
4264(007C)             | busy_fast
4264(007C) 30 7F BE A0 |         mov tmp1,N_in8_500ms
4268(007D)             | :still_busy
4268(007D) 8D 46 FD 5C |         call #in8
426C(007E) FF 7C 7E 86 |         cmp readback,#$FF wz
4270(007F) 7D 7E D6 E4 | if_nz   djnz tmp1,#:still_busy
4274(0080)             | busy_fast_ret
4274(0080) 00 00 7C 5C |         ret
4278(0081)             | out8
4278(0081) 29 E9 BF 64 |         andn outa,maskDI 
427C(0082) 00 FA FF A0 |         mov phsb,#0
4280(0083) 80 F6 FF 58 |         movi frqb,#%01_0000000        
4284(0084) 01 F8 FF 24 |         rol phsa,#1
4288(0085) 01 F8 FF 24 |         rol phsa,#1
428C(0086) 01 F8 FF 24 |         rol phsa,#1
4290(0087) 01 F8 FF 24 |         rol phsa,#1
4294(0088) 01 F8 FF 24 |         rol phsa,#1
4298(0089) 01 F8 FF 24 |         rol phsa,#1
429C(008A) 01 F8 FF 24 |         rol phsa,#1
42A0(008B) 00 F6 FF A0 |         mov frqb,#0
42A4(008C)             | out8_ret
42A4(008C) 00 00 7C 5C |         ret
42A8(008D)             | in8
42A8(008D) 01 F8 FF A4 |         neg phsa,#1' DI high
42AC(008E) 00 7C FE A0 |         mov readback,#0
42B0(008F) C0 FA FF 58 |         movi phsb,#%011_000000
42B4(0090) 40 F6 FF 58 |         movi frqb,#%001_000000
42B8(0091) F2 51 3E 61 |         test maskDO,ina wc
42BC(0092) 01 7C FE 34 |         rcl readback,#1
42C0(0093) F2 51 3E 61 |         test maskDO,ina wc
42C4(0094) 01 7C FE 34 |         rcl readback,#1
42C8(0095) F2 51 3E 61 |         test maskDO,ina wc
42CC(0096) 01 7C FE 34 |         rcl readback,#1
42D0(0097) F2 51 3E 61 |         test maskDO,ina wc
42D4(0098) 01 7C FE 34 |         rcl readback,#1
42D8(0099) F2 51 3E 61 |         test maskDO,ina wc
42DC(009A) 01 7C FE 34 |         rcl readback,#1
42E0(009B) F2 51 3E 61 |         test maskDO,ina wc
42E4(009C) 01 7C FE 34 |         rcl readback,#1
42E8(009D) F2 51 3E 61 |         test maskDO,ina wc
42EC(009E) 01 7C FE 34 |         rcl readback,#1
42F0(009F) F2 51 3E 61 |         test maskDO,ina wc
42F4(00A0) 00 F6 FF A0 |         mov frqb,#0 ' stop the clock
42F8(00A1) 01 7C FE 34 |         rcl readback,#1
42FC(00A2) 00 F8 FF A0 |         mov phsa,#0 'DI low
4300(00A3)             | in8_ret
4300(00A3) 00 00 7C 5C |         ret
4304(00A4)             | handle_time        
4304(00A4) F1 7F BE A0 |         mov tmp1,cnt            ' get the current timestamp
4308(00A5) 3F 73 BE 80 |         add idle_time,tmp1      ' add the current time to my idle time counter
430C(00A6) 45 73 BE 84 |         sub idle_time,last_time ' subtract the last time from my idle counter (hence delta)    
4310(00A7) 3F 71 BE 80 |         add dtime,tmp1          ' add to my accumulator, 
4314(00A8) 45 71 BE 84 |         sub dtime,last_time     ' and subtract the old (adding delta)
4318(00A9) 3F 8B BE A0 |         mov last_time,tmp1      ' update my "last timestamp"        
431C(00AA) 00 7E FE 08 |         rdlong tmp1,#0          ' what is the clock frequency?
4320(00AB) 3F 71 BE E1 |         cmpsub dtime,tmp1 wc    ' if I have more than a second in my accumulator
4324(00AC) 00 6E FE C8 |         addx seconds,#0         ' then add it to "seconds"
4328(00AD) 3A 73 3E 87 |         cmp idle_time,idle_limit wz,wc
432C(00AE) B3 00 70 5C | if_b    jmp #handle_time_ret    ' don't clear if we haven't hit the limit
4330(00AF) 7A 82 FE A0 |         mov user_cmd,#"z"       ' we can't overdo it, the command handler makes sure
4334(00B0) 01 76 FE A4 |         neg lastIndexPlus,#1    ' reset the last block index 
4338(00B1) 01 84 FE A4 |         neg user_idx,#1         ' and make this match it 
433C(00B2) 35 96 FC 5C |         call #handle_command    ' release the card, but don't mess with the user's request register
4340(00B3)             | handle_time_ret
4340(00B3) 00 00 7C 5C |         ret
4344(00B4)             | hub_cog_transfer
4344(00B4) 32 F3 BF A0 |         mov ctrb,clockXferMode
4348(00B5) 01 F6 FF A0 |         mov frqb,#1 
434C(00B6) 2D 89 BE 08 |         rdlong buf_ptr,bufAdr
4350(00B7) 04 7A FE A0 |         mov ops_left,#4
4354(00B8) 46 79 FD 54 |         movd transfer_long,#speed_buf
4358(00B9)             | four_transfer_passes
4358(00B9) 3F 7F BE 08 |         rdlong tmp1,tmp1
435C(00BA) 20 7E FE A0 |         mov tmp1,#(512 / 4 / 4)
4360(00BB) 44 FB BF A0 |         mov phsb,buf_ptr
4364(00BC)             | transfer_long
4364(00BC) FD 01 BC 08 |         rdlong 0-0,phsb
4368(00BD) 35 79 BD 80 |         add transfer_long,incDest4
436C(00BE) BC 7E FE E4 |         djnz tmp1,#transfer_long
4370(00BF) 36 79 BD 84 |         sub transfer_long,decDestNminus1
4374(00C0) 04 88 FE 80 |         add buf_ptr,#4
4378(00C1) B9 7A FE E4 |         djnz ops_left,#four_transfer_passes
437C(00C2) 00 F6 FF A0 |         mov frqb,#0
4380(00C3) 00 FA FF A0 |         mov phsb,#0
4384(00C4) 31 F3 BF A0 |         mov ctrb,clockLineMode
4388(00C5)             | hub_cog_transfer_ret
4388(00C5) 00 00 7C 5C |         ret
438C(00C6)             | read_single_block
438C(00C6) 46 CD FD 54 |         movd :store_read_long,#speed_buf
4390(00C7) 80 7A FE A0 |         mov ops_left,#128
4394(00C8) 30 7F BE A0 |         mov tmp1,N_in8_500ms
4398(00C9)             | :get_resp
4398(00C9) 8D 46 FD 5C |         call #in8
439C(00CA) FE 7C 7E 86 |         cmp readback,#$FE wz        
43A0(00CB) C9 7E D6 E4 | if_nz   djnz tmp1,#:get_resp
43A4(00CC) 64 82 D6 A4 | if_nz   neg user_cmd,#ERR_ASM_NO_READ_TOKEN  
43A8(00CD) EF 00 54 5C | if_nz   jmp #read_single_block_ret
43AC(00CE) 01 F8 FF A4 |         neg phsa,#1
43B0(00CF) 80 7A FE A0 |         mov ops_left,#128
43B4(00D0)             | :read_loop        
43B4(00D0) 04 7E FE A0 |         mov tmp1,#4
43B8(00D1) C0 FA FF 58 |         movi phsb,#%011_000000
43BC(00D2)             | :in_byte        
43BC(00D2) 40 F6 FF 58 |         movi frqb,#%001_000000
43C0(00D3) F2 51 3E 61 |         test maskDO,ina wc
43C4(00D4) 08 7C FE 34 |         rcl readback,#8
43C8(00D5) F2 51 3E 61 |         test maskDO,ina wc
43CC(00D6) 02 7C FE 70 |         muxc readback,#2
43D0(00D7) F2 51 3E 61 |         test maskDO,ina wc
43D4(00D8) 04 7C FE 70 |         muxc readback,#4
43D8(00D9) F2 51 3E 61 |         test maskDO,ina wc
43DC(00DA) 08 7C FE 70 |         muxc readback,#8
43E0(00DB) F2 51 3E 61 |         test maskDO,ina wc
43E4(00DC) 10 7C FE 70 |         muxc readback,#16
43E8(00DD) F2 51 3E 61 |         test maskDO,ina wc
43EC(00DE) 20 7C FE 70 |         muxc readback,#32
43F0(00DF) F2 51 3E 61 |         test maskDO,ina wc
43F4(00E0) 40 7C FE 70 |         muxc readback,#64
43F8(00E1) F2 51 3E 61 |         test maskDO,ina wc
43FC(00E2) 00 F6 FF A0 |         mov frqb,#0 ' stop the clock
4400(00E3) 80 7C FE 70 |         muxc readback,#128
4404(00E4) D2 7E FE E4 |         djnz tmp1,#:in_byte
4408(00E5) 00 7C FE 3C |         rev readback,#0
440C(00E6)             | :store_read_long
440C(00E6) 3E 01 BC A0 |         mov 0-0,readback       ' due to some counter weirdness, we need this mov
4410(00E7) 33 CD BD 80 |         add :store_read_long,const512
4414(00E8) D0 7A FE E4 |         djnz ops_left,#:read_loop
4418(00E9) 00 F8 FF A0 |         mov phsa,#0
441C(00EA) 8D 46 FD 5C |         call #in8      ' out8 is 2x faster than in8
4420(00EB) 8D 46 FD 5C |         call #in8      ' and I'm not using the CRC anyway
4424(00EC) 8D 46 FD 5C |         call #in8       ' in8 looks like out8($FF)
4428(00ED) 00 72 FE A0 |         mov idle_time,#0
442C(00EE) 00 82 FE A0 |         mov user_cmd,#0               
4430(00EF)             | read_single_block_ret
4430(00EF) 00 00 7C 5C |         ret          
4434(00F0)             | write_single_block               
4434(00F0) 46 ED FD 50 |         movs :write_loop,#speed_buf
4438(00F1) 80 7A FE A0 |         mov ops_left,#128        
443C(00F2) 7C 00 FD 5C |         call #busy_fast 
4440(00F3) F8 F9 FF 58 |         movi phsa,#$FC<<1
4444(00F4) 81 18 FD 5C |         call #out8
4448(00F5) 00 FA FF A0 |         mov phsb,#0             ' make sure my clock accumulator is right
444C(00F6)             | :write_loop
444C(00F6) 46 F9 BF A0 |         mov phsa,speed_buf
4450(00F7) 01 EC FD 80 |         add :write_loop,#1
4454(00F8) 18 F8 FF 24 |         rol phsa,#24            ' move A7 into position, so I can do the swizzled version
4458(00F9) 80 F6 FF 58 |         movi frqb,#%010000000   ' start the clock (remember A7 is already in place)
445C(00FA) 01 F8 FF 24 |         rol phsa,#1             ' A7 is going out, at the end of this instr, A6 is in place
4460(00FB) 01 F8 FF 24 |         rol phsa,#1             ' A5
4464(00FC) 01 F8 FF 24 |         rol phsa,#1             ' A4
4468(00FD) 01 F8 FF 24 |         rol phsa,#1             ' A3
446C(00FE) 01 F8 FF 24 |         rol phsa,#1             ' A2
4470(00FF) 01 F8 FF 24 |         rol phsa,#1             ' A1
4474(0100) 01 F8 FF 24 |         rol phsa,#1             ' A0
4478(0101) 11 F8 FF 24 |         rol phsa,#17            ' B7
447C(0102) 01 F8 FF 24 |         rol phsa,#1             ' B6
4480(0103) 01 F8 FF 24 |         rol phsa,#1             ' B5
4484(0104) 01 F8 FF 24 |         rol phsa,#1             ' B4
4488(0105) 01 F8 FF 24 |         rol phsa,#1             ' B3
448C(0106) 01 F8 FF 24 |         rol phsa,#1             ' B2
4490(0107) 01 F8 FF 24 |         rol phsa,#1             ' B1
4494(0108) 01 F8 FF 24 |         rol phsa,#1             ' B0
4498(0109) 11 F8 FF 24 |         rol phsa,#17            ' C7
449C(010A) 01 F8 FF 24 |         rol phsa,#1             ' C6
44A0(010B) 01 F8 FF 24 |         rol phsa,#1             ' C5
44A4(010C) 01 F8 FF 24 |         rol phsa,#1             ' C4
44A8(010D) 01 F8 FF 24 |         rol phsa,#1             ' C3
44AC(010E) 01 F8 FF 24 |         rol phsa,#1             ' C2
44B0(010F) 01 F8 FF 24 |         rol phsa,#1             ' C1
44B4(0110) 01 F8 FF 24 |         rol phsa,#1             ' C0
44B8(0111) 11 F8 FF 24 |         rol phsa,#17            ' D7
44BC(0112) 01 F8 FF 24 |         rol phsa,#1             ' D6
44C0(0113) 01 F8 FF 24 |         rol phsa,#1             ' D5
44C4(0114) 01 F8 FF 24 |         rol phsa,#1             ' D4
44C8(0115) 01 F8 FF 24 |         rol phsa,#1             ' D3
44CC(0116) 01 F8 FF 24 |         rol phsa,#1             ' D2
44D0(0117) 01 F8 FF 24 |         rol phsa,#1             ' D1
44D4(0118) 01 F8 FF 24 |         rol phsa,#1             ' D0 will be in place _after_ this instruction
44D8(0119) 00 F6 FF A0 |         mov frqb,#0             ' shuts the clock off, _after_ this instruction
44DC(011A) F6 7A FE E4 |         djnz ops_left,#:write_loop
44E0(011B) 8D 46 FD 5C |         call #in8
44E4(011C) 8D 46 FD 5C |         call #in8
44E8(011D) 8D 46 FD 5C |         call #in8
44EC(011E) 1F 7C FE 60 |         and readback,#$1F
44F0(011F) 05 7C 7E 86 |         cmp readback,#5 wz
44F4(0120) 00 82 EA A0 | if_z    mov user_cmd,#0 ' great
44F8(0121) 65 82 D6 A4 | if_nz   neg user_cmd,#ERR_ASM_BLOCK_NOT_WRITTEN ' oops
44FC(0122) 8D 46 FD 5C |         call #in8 
4500(0123) 00 72 FE A0 |         mov idle_time,#0
4504(0124)             | write_single_block_ret
4504(0124) 00 00 7C 5C |         ret
4508(0125) 00 00 00 00 | pinDO         long 0    ' pin is controlled by a counter
450C(0126) 00 00 00 00 | pinCLK        long 0    ' pin is controlled by a counter
4510(0127) 00 00 00 00 | pinDI         long 0    ' pin is controlled by a counter
4514(0128) 00 00 00 00 | maskDO        long 0    ' mask for reading the DO line from the card
4518(0129) 00 00 00 00 | maskDI        long 0    ' mask for setting the pin high while reading  
451C(012A) 00 00 00 00 | maskCS        long 0    ' mask = (1<<pin), and is controlled directly
4520(012B) 00 00 00 00 | maskAll       long 0
4524(012C) 09 00 00 00 | adrShift      long 9    ' will be 0 for SDHC, 9 for MMC & SD
4528(012D) 00 00 00 00 | bufAdr        long 0    ' where in Hub RAM is the buffer to copy to/from?
452C(012E) 00 00 00 00 | sdAdr         long 0    ' where on the SD card does it read/write?
4530(012F) 00 00 00 00 | writeMode     long 0    ' the counter setup in NCO single ended, clocking data out on pinDI
4534(0130) 40 42 0F 00 | N_in8_500ms   long 1_000_000 ' used for timeout checking in PASM
4538(0131) 00 00 00 00 | clockLineMode long 0
453C(0132) 00 00 00 7C | clockXferMode long %11111 << 26
4540(0133) 00 02 00 00 | const512      long 512
4544(0134) 00 04 00 00 | const1024     long 1024
4548(0135) 00 08 00 00 | incDest4      long 4 << 9
454C(0136) 00 FE 00 00 | decDestNminus1 long (512 / 4 - 1) << 9         
4550(0137) 00 00 00 00 | seconds       long 0
4554(0138) 00 00 00 00 | dtime         long 0
4558(0139) 00 00 00 00 | idle_time     long 0
455C(013A) 00 00 00 00 | idle_limit    long 0
4560(013B) FF FF FF FF | lastIndexPlus long -1   ' state handler will check against lastIndexPlus, which will not have been -1
4564(013C) 00 00 00 00 | lastCommand   long 0    ' this will never be the last command.
4568(013D)             | ops_left      res 1     ' used as a counter for bytes, words, longs, whatever (start w/ # byte clocks out)
4568(013E)             | readback      res 1     ' all reading from the card goes through here
4568(013F)             | tmp1          res 1     ' this may get used in all subroutines...don't use except in lowest 
4568(0140)             | user_request  res 1     ' the main command variable, read in from Hub: "r"-read single, "w"-write single
4568(0141)             | user_cmd      res 1     ' used internally to handle actual commands to be executed
4568(0142)             | user_idx      res 1     ' the pointer to the Hub RAM where the data block is/goes
4568(0143)             | block_cmd     res 1     ' one of the SD/MMC command codes, no app-specific allowed
4568(0144)             | buf_ptr       res 1     ' moving pointer to the Hub RAM buffer
4568(0145)             | last_time     res 1     ' tracking the timestamp
4568(0146)             | speed_buf     res 128   ' 512 bytes to be used for read-ahead / write-behind
4568(01C6)             | FIT 496
4568(01C6)             | There are 42 ($02A) Longs left in the cog
|===========================================================================|
|===========================================================================|
Spin Block start with 1 Parameters and 0 Extra Stack Longs. Method 1
PUB start( basepin )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - basepin
|===========================================================================|
92                        return start_explicit( basepin, basepin+1, basepin+2, basepin+3 )
Addr : 4568:             00  : Drop Anchor Push 
Addr : 4569:             64  : Variable Operation Local Offset - 1 Read
Addr : 456A:             64  : Variable Operation Local Offset - 1 Read
Addr : 456B:             36  : Constant 2 $00000001
Addr : 456C:             EC  : Math Op +     
Addr : 456D:             64  : Variable Operation Local Offset - 1 Read
Addr : 456E:          37 00  : Constant Mask Y=0 00000002
Addr : 4570:             EC  : Math Op +     
Addr : 4571:             64  : Variable Operation Local Offset - 1 Read
Addr : 4572:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 4574:             EC  : Math Op +     
Addr : 4575:          05 06  : Call Sub 6    
Addr : 4577:             33  : Return value  
Addr : 4578: Data : 32                       2
|===========================================================================|
Spin Block readblock with 2 Parameters and 0 Extra Stack Longs. Method 2
PUB readblock( block_index, buffer_address )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - block_index
Local Parameter DBASE:0008 - buffer_address
|===========================================================================|
95                        if SPI_engine_cog == 0
Addr : 4579:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 457B:             35  : Constant 1 $00000000
Addr : 457C:             FC  : Math Op ==    
Addr : 457D: JZ Label0002
Addr : 457D:          0A 05  : jz Address = 4584 5
96                          abort ERR_SPI_ENGINE_NOT_RUNNING
Addr : 457F:       39 03 E6  : Constant 2 Bytes - 03 E6 
Addr : 4582:             E7  : Math Op !     
Addr : 4583:             31  : Abort value   
Addr : 4584: Label0002
Addr : 4584: Label0003
97                        if (buffer_address & 3)
Addr : 4584:             68  : Variable Operation Local Offset - 2 Read
Addr : 4585:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 4587:             E8  : Math Op &     
Addr : 4588: JZ Label0004
Addr : 4588:          0A 03  : jz Address = 458D 3
98                          abort ERR_BLOCK_NOT_LONG_ALIGNED
Addr : 458A:          37 61  : Constant Mask Y=97 Decrement Invert FFFFFFFC
Addr : 458C:             31  : Abort value   
Addr : 458D: Label0004
Addr : 458D: Label0005
99                        SPI_block_index := block_index
Addr : 458D:             64  : Variable Operation Local Offset - 1 Read
Addr : 458E:          C5 40  : Memory Op Long PBASE + WRITE Address = 0040
100                        SPI_buffer_address := buffer_address
Addr : 4590:             68  : Variable Operation Local Offset - 2 Read
Addr : 4591:          C5 44  : Memory Op Long PBASE + WRITE Address = 0044
101                        SPI_command := "r"
Addr : 4593:          38 72  : Constant 1 Bytes - 72 
Addr : 4595:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
Addr : 4597: Label0006
102                        repeat while SPI_command == "r"
Addr : 4597:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 4599:          38 72  : Constant 1 Bytes - 72 
Addr : 459B:             FC  : Math Op ==    
Addr : 459C: JZ Label0008
Addr : 459C:          0A 02  : jz Address = 45A0 2
Addr : 459E: Label0007
Addr : 459E: JMP Label0006
Addr : 459E:          04 77  : Jmp 4597 -9   
Addr : 45A0: Label0008
103                        if SPI_command < 0
Addr : 45A0:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45A2:             35  : Constant 1 $00000000
Addr : 45A3:             F9  : Math Op <     
Addr : 45A4: JZ Label0009
Addr : 45A4:          0A 03  : jz Address = 45A9 3
104                          abort SPI_command
Addr : 45A6:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45A8:             31  : Abort value   
Addr : 45A9: Label0009
Addr : 45A9: Label000A
Addr : 45A9:             32  : Return        
|===========================================================================|
Spin Block writeblock with 2 Parameters and 0 Extra Stack Longs. Method 3
PUB writeblock( block_index, buffer_address )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - block_index
Local Parameter DBASE:0008 - buffer_address
|===========================================================================|
107                        if SPI_engine_cog == 0
Addr : 45AA:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 45AC:             35  : Constant 1 $00000000
Addr : 45AD:             FC  : Math Op ==    
Addr : 45AE: JZ Label0002
Addr : 45AE:          0A 05  : jz Address = 45B5 5
108                          abort ERR_SPI_ENGINE_NOT_RUNNING
Addr : 45B0:       39 03 E6  : Constant 2 Bytes - 03 E6 
Addr : 45B3:             E7  : Math Op !     
Addr : 45B4:             31  : Abort value   
Addr : 45B5: Label0002
Addr : 45B5: Label0003
109                        if (buffer_address & 3)
Addr : 45B5:             68  : Variable Operation Local Offset - 2 Read
Addr : 45B6:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 45B8:             E8  : Math Op &     
Addr : 45B9: JZ Label0004
Addr : 45B9:          0A 03  : jz Address = 45BE 3
110                          abort ERR_BLOCK_NOT_LONG_ALIGNED
Addr : 45BB:          37 61  : Constant Mask Y=97 Decrement Invert FFFFFFFC
Addr : 45BD:             31  : Abort value   
Addr : 45BE: Label0004
Addr : 45BE: Label0005
111                        SPI_block_index := block_index
Addr : 45BE:             64  : Variable Operation Local Offset - 1 Read
Addr : 45BF:          C5 40  : Memory Op Long PBASE + WRITE Address = 0040
112                        SPI_buffer_address := buffer_address
Addr : 45C1:             68  : Variable Operation Local Offset - 2 Read
Addr : 45C2:          C5 44  : Memory Op Long PBASE + WRITE Address = 0044
113                        SPI_command := "w"
Addr : 45C4:          38 77  : Constant 1 Bytes - 77 
Addr : 45C6:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
Addr : 45C8: Label0006
114                        repeat while SPI_command == "w"
Addr : 45C8:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45CA:          38 77  : Constant 1 Bytes - 77 
Addr : 45CC:             FC  : Math Op ==    
Addr : 45CD: JZ Label0008
Addr : 45CD:          0A 02  : jz Address = 45D1 2
Addr : 45CF: Label0007
Addr : 45CF: JMP Label0006
Addr : 45CF:          04 77  : Jmp 45C8 -9   
Addr : 45D1: Label0008
115                        if SPI_command < 0
Addr : 45D1:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45D3:             35  : Constant 1 $00000000
Addr : 45D4:             F9  : Math Op <     
Addr : 45D5: JZ Label0009
Addr : 45D5:          0A 03  : jz Address = 45DA 3
116                          abort SPI_command
Addr : 45D7:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45D9:             31  : Abort value   
Addr : 45DA: Label0009
Addr : 45DA: Label000A
Addr : 45DA:             32  : Return        
|===========================================================================|
Spin Block get_seconds with 0 Parameters and 0 Extra Stack Longs. Method 4
PUB get_seconds

Local Parameter DBASE:0000 - Result
|===========================================================================|
119                        if SPI_engine_cog == 0
Addr : 45DB:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 45DD:             35  : Constant 1 $00000000
Addr : 45DE:             FC  : Math Op ==    
Addr : 45DF: JZ Label0002
Addr : 45DF:          0A 05  : jz Address = 45E6 5
120                          abort ERR_SPI_ENGINE_NOT_RUNNING
Addr : 45E1:       39 03 E6  : Constant 2 Bytes - 03 E6 
Addr : 45E4:             E7  : Math Op !     
Addr : 45E5:             31  : Abort value   
Addr : 45E6: Label0002
Addr : 45E6: Label0003
121                        SPI_command := "t"
Addr : 45E6:          38 74  : Constant 1 Bytes - 74 
Addr : 45E8:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
Addr : 45EA: Label0004
122                        repeat while SPI_command == "t"
Addr : 45EA:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 45EC:          38 74  : Constant 1 Bytes - 74 
Addr : 45EE:             FC  : Math Op ==    
Addr : 45EF: JZ Label0006
Addr : 45EF:          0A 02  : jz Address = 45F3 2
Addr : 45F1: Label0005
Addr : 45F1: JMP Label0004
Addr : 45F1:          04 77  : Jmp 45EA -9   
Addr : 45F3: Label0006
124                        return SPI_block_index
Addr : 45F3:          C4 40  : Memory Op Long PBASE + READ Address = 0040
Addr : 45F5:             33  : Return value  
Addr : 45F6: Data : 32                       2
|===========================================================================|
Spin Block get_milliseconds with 0 Parameters and 0 Extra Stack Longs. Method 5
PUB get_milliseconds : ms

Local Parameter DBASE:0000 - Result
|===========================================================================|
127                        if SPI_engine_cog == 0
Addr : 45F7:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 45F9:             35  : Constant 1 $00000000
Addr : 45FA:             FC  : Math Op ==    
Addr : 45FB: JZ Label0002
Addr : 45FB:          0A 05  : jz Address = 4602 5
128                          abort ERR_SPI_ENGINE_NOT_RUNNING
Addr : 45FD:       39 03 E6  : Constant 2 Bytes - 03 E6 
Addr : 4600:             E7  : Math Op !     
Addr : 4601:             31  : Abort value   
Addr : 4602: Label0002
Addr : 4602: Label0003
129                        SPI_command := "t"
Addr : 4602:          38 74  : Constant 1 Bytes - 74 
Addr : 4604:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
Addr : 4606: Label0004
130                        repeat while SPI_command == "t"
Addr : 4606:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 4608:          38 74  : Constant 1 Bytes - 74 
Addr : 460A:             FC  : Math Op ==    
Addr : 460B: JZ Label0006
Addr : 460B:          0A 02  : jz Address = 460F 2
Addr : 460D: Label0005
Addr : 460D: JMP Label0004
Addr : 460D:          04 77  : Jmp 4606 -9   
Addr : 460F: Label0006
132                        ms := SPI_block_index * 1000
Addr : 460F:          C4 40  : Memory Op Long PBASE + READ Address = 0040
Addr : 4611:       39 03 E8  : Constant 2 Bytes - 03 E8 
Addr : 4614:             F4  : Math Op *     
Addr : 4615:             61  : Variable Operation Local Offset - 0 Write
133                        ms += SPI_buffer_address * 1000 / clkfreq
Addr : 4616:          C4 44  : Memory Op Long PBASE + READ Address = 0044
Addr : 4618:       39 03 E8  : Constant 2 Bytes - 03 E8 
Addr : 461B:             F4  : Math Op *     
Addr : 461C:             35  : Constant 1 $00000000
Addr : 461D:             C0  : Memory Op Long POP Address READ 
Addr : 461E:             F6  : Math Op /     
Addr : 461F:          62 4C  : Variable Operation Local Offset - 0 Assign WordMathop +
Addr : 4621:             32  : Return        
|===========================================================================|
Spin Block start_explicit with 4 Parameters and 2 Extra Stack Longs. Method 6
PUB start_explicit( DO, CLK, DI, CS ) : card_type | tmp, i

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - DO
Local Parameter DBASE:0008 - CLK
Local Parameter DBASE:000C - DI
Local Parameter DBASE:0010 - CS
Local Variable  DBASE:0014 - tmp
Local Variable  DBASE:0018 - i
|===========================================================================|
141                        stop
Addr : 4622:             01  : Drop Anchor   
Addr : 4623:          05 08  : Call Sub 8    
149                        waitcnt( 500 + (clkfreq>>8) + cnt )
Addr : 4625:       39 01 F4  : Constant 2 Bytes - 01 F4 
Addr : 4628:             35  : Constant 1 $00000000
Addr : 4629:             C0  : Memory Op Long POP Address READ 
Addr : 462A:          37 02  : Constant Mask Y=2 00000008
Addr : 462C:             E2  : Math Op >>    
Addr : 462D:             EC  : Math Op +     
Addr : 462E:          3F 91  : Register op CNT Read
Addr : 4630:             EC  : Math Op +     
Addr : 4631:             23  : WaitCnt(count)
151                        pinDO := DO
Addr : 4632:             64  : Variable Operation Local Offset - 1 Read
Addr : 4633:       C5 84 DC  : Memory Op Long PBASE + WRITE Address = 04DC
152                        maskDO := |< DO
Addr : 4636:             64  : Variable Operation Local Offset - 1 Read
Addr : 4637:             F3  : Math Op |<    
Addr : 4638:       C5 84 E8  : Memory Op Long PBASE + WRITE Address = 04E8
153                        pinCLK := CLK
Addr : 463B:             68  : Variable Operation Local Offset - 2 Read
Addr : 463C:       C5 84 E0  : Memory Op Long PBASE + WRITE Address = 04E0
154                        pinDI := DI
Addr : 463F:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4640:       C5 84 E4  : Memory Op Long PBASE + WRITE Address = 04E4
155                        maskDI := |< DI
Addr : 4643:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4644:             F3  : Math Op |<    
Addr : 4645:       C5 84 EC  : Memory Op Long PBASE + WRITE Address = 04EC
156                        maskCS := |< CS
Addr : 4648:             70  : Variable Operation Local Offset - 4 Read
Addr : 4649:             F3  : Math Op |<    
Addr : 464A:       C5 84 F0  : Memory Op Long PBASE + WRITE Address = 04F0
157                        adrShift := 9 ' block = 512 * index, and 512 = 1<<9
Addr : 464D:          38 09  : Constant 1 Bytes - 09 
Addr : 464F:       C5 84 F8  : Memory Op Long PBASE + WRITE Address = 04F8
159                        maskAll := maskCS | (|<pinCLK) | maskDI
Addr : 4652:       C4 84 F0  : Memory Op Long PBASE + READ Address = 04F0
Addr : 4655:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 4658:             F3  : Math Op |<    
Addr : 4659:             EA  : Math Op |     
Addr : 465A:       C4 84 EC  : Memory Op Long PBASE + READ Address = 04EC
Addr : 465D:             EA  : Math Op |     
Addr : 465E:       C5 84 F4  : Memory Op Long PBASE + WRITE Address = 04F4
160                        dira |= maskAll  
Addr : 4661:       C4 84 F4  : Memory Op Long PBASE + READ Address = 04F4
Addr : 4664:       3F D6 4A  : Register op DIRA ByteMathop |
162                        outa |= maskAll
Addr : 4667:       C4 84 F4  : Memory Op Long PBASE + READ Address = 04F4
Addr : 466A:       3F D4 4A  : Register op OUTA ByteMathop |
163                        repeat 4096
Addr : 466D:          37 0B  : Constant Mask Y=11 00001000
Addr : 466F: TJZ Label0004
Addr : 466F:          08 0A  : tjz Address = 467B 10
Addr : 4671: Label0002
164                          outa[CLK]~~
Addr : 4671:             68  : Variable Operation Local Offset - 2 Read
Addr : 4672:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
165                          outa[CLK]~
Addr : 4675:             68  : Variable Operation Local Offset - 2 Read
Addr : 4676:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
Addr : 4679: Label0003
Addr : 4679: DJNZ Label0002
Addr : 4679:          09 76  : djnz Address = 4671 -10
Addr : 467B: Label0004
167                        SPI_block_index := cnt
Addr : 467B:          3F 91  : Register op CNT Read
Addr : 467D:          C5 40  : Memory Op Long PBASE + WRITE Address = 0040
169                        tmp~
Addr : 467F:          76 18  : Variable Operation Local Offset - 5 Assign VAR~ Post-clear
170                        repeat i from 0 to 9
Addr : 4681:             35  : Constant 1 $00000000
Addr : 4682:             79  : Variable Operation Local Offset - 6 Write
Addr : 4683: Label0005
171                          if tmp <> 1
Addr : 4683:             74  : Variable Operation Local Offset - 5 Read
Addr : 4684:             36  : Constant 2 $00000001
Addr : 4685:             FB  : Math Op <>    
Addr : 4686: JZ Label0008
Addr : 4686:          0A 3B  : jz Address = 46C3 59
172                            tmp := send_cmd_slow( CMD0, 0, $95 )
Addr : 4688:             00  : Drop Anchor Push 
Addr : 4689:          37 05  : Constant Mask Y=5 00000040
Addr : 468B:             35  : Constant 1 $00000000
Addr : 468C:          38 95  : Constant 1 Bytes - 95 
Addr : 468E:          05 0A  : Call Sub 10   
Addr : 4690:             75  : Variable Operation Local Offset - 5 Write
173                            if (tmp & 4)
Addr : 4691:             74  : Variable Operation Local Offset - 5 Read
Addr : 4692:          37 01  : Constant Mask Y=1 00000004
Addr : 4694:             E8  : Math Op &     
Addr : 4695: JZ Label000A
Addr : 4695:          0A 2C  : jz Address = 46C3 44
175                              if i & 1
Addr : 4697:             78  : Variable Operation Local Offset - 6 Read
Addr : 4698:             36  : Constant 2 $00000001
Addr : 4699:             E8  : Math Op &     
Addr : 469A: JZ Label000C
Addr : 469A:          0A 1F  : jz Address = 46BB 31
177                                repeat 4
Addr : 469C:          37 01  : Constant Mask Y=1 00000004
Addr : 469E: TJZ Label0010
Addr : 469E:          08 05  : tjz Address = 46A5 5
Addr : 46A0: Label000E
178                                  read_32_slow        ' these extra clocks are required for some MMC cards
Addr : 46A0:             01  : Drop Anchor   
Addr : 46A1:          05 0C  : Call Sub 12   
Addr : 46A3: Label000F
Addr : 46A3: DJNZ Label000E
Addr : 46A3:          09 7B  : djnz Address = 46A0 -5
Addr : 46A5: Label0010
179                                send_slow( $FD, 8 )   ' stop token
Addr : 46A5:             01  : Drop Anchor   
Addr : 46A6:          38 FD  : Constant 1 Bytes - FD 
Addr : 46A8:          37 02  : Constant Mask Y=2 00000008
Addr : 46AA:          05 0B  : Call Sub 11   
180                                read_32_slow
Addr : 46AC:             01  : Drop Anchor   
Addr : 46AD:          05 0C  : Call Sub 12   
Addr : 46AF: Label0011
181                                repeat while read_slow <> $FF
Addr : 46AF:             00  : Drop Anchor Push 
Addr : 46B0:          05 0D  : Call Sub 13   
Addr : 46B2:          37 27  : Constant Mask Y=39 Decrement 000000FF
Addr : 46B4:             FB  : Math Op <>    
Addr : 46B5: JZ Label0013
Addr : 46B5:          0A 02  : jz Address = 46B9 2
Addr : 46B7: Label0012
Addr : 46B7: JMP Label0011
Addr : 46B7:          04 76  : Jmp 46AF -10  
Addr : 46B9: Label0013
Addr : 46B9: JMP Label000D
Addr : 46B9:          04 08  : Jmp 46C3 8    
Addr : 46BB: Label000C
184                                send_cmd_slow( CMD12, 0, $61 )           
Addr : 46BB:             01  : Drop Anchor   
Addr : 46BC:          38 4C  : Constant 1 Bytes - 4C 
Addr : 46BE:             35  : Constant 1 $00000000
Addr : 46BF:          38 61  : Constant 1 Bytes - 61 
Addr : 46C1:          05 0A  : Call Sub 10   
Addr : 46C3: Label0014
Addr : 46C3: Label000D
Addr : 46C3: Label000A
Addr : 46C3: Label000B
Addr : 46C3: Label0008
Addr : 46C3: Label0009
Addr : 46C3: Label0006
170                        repeat i from 0 to 9
Addr : 46C3:             35  : Constant 1 $00000000
Addr : 46C4:          38 09  : Constant 1 Bytes - 09 
Addr : 46C6: Repeat i Step Label0005
Addr : 46C6:    7A 02 FF B9  : Variable Operation Local Offset - 6 Assign Repeat-Var loop Address= 4683 -71
Addr : 46CA: Label0007
185                        if tmp <> 1
Addr : 46CA:             74  : Variable Operation Local Offset - 5 Read
Addr : 46CB:             36  : Constant 2 $00000001
Addr : 46CC:             FB  : Math Op <>    
Addr : 46CD: JZ Label0015
Addr : 46CD:          0A 04  : jz Address = 46D3 4
187                          crash( ERR_CARD_NOT_RESET )
Addr : 46CF:             01  : Drop Anchor   
Addr : 46D0:             34  : Constant 0 $FFFFFFFF
Addr : 46D1:          05 09  : Call Sub 9    
Addr : 46D3: Label0015
Addr : 46D3: Label0016
189                        if send_cmd_slow( CMD8, $1AA, $87 ) == 1
Addr : 46D3:             00  : Drop Anchor Push 
Addr : 46D4:          38 48  : Constant 1 Bytes - 48 
Addr : 46D6:       39 01 AA  : Constant 2 Bytes - 01 AA 
Addr : 46D9:          38 87  : Constant 1 Bytes - 87 
Addr : 46DB:          05 0A  : Call Sub 10   
Addr : 46DD:             36  : Constant 2 $00000001
Addr : 46DE:             FC  : Math Op ==    
Addr : 46DF: JZ Label0017
Addr : 46DF:       0A 80 4B  : jz Address = 472D 75
191                          tmp := read_32_slow
Addr : 46E2:             00  : Drop Anchor Push 
Addr : 46E3:          05 0C  : Call Sub 12   
Addr : 46E5:             75  : Variable Operation Local Offset - 5 Write
193                          if (tmp & $1FF) <> $1AA
Addr : 46E6:             74  : Variable Operation Local Offset - 5 Read
Addr : 46E7:          37 28  : Constant Mask Y=40 Decrement 000001FF
Addr : 46E9:             E8  : Math Op &     
Addr : 46EA:       39 01 AA  : Constant 2 Bytes - 01 AA 
Addr : 46ED:             FB  : Math Op <>    
Addr : 46EE: JZ Label0019
Addr : 46EE:          0A 05  : jz Address = 46F5 5
194                            crash( ERR_3v3_NOT_SUPPORTED )
Addr : 46F0:             01  : Drop Anchor   
Addr : 46F1:          37 60  : Constant Mask Y=96 Decrement Invert FFFFFFFE
Addr : 46F3:          05 09  : Call Sub 9    
Addr : 46F5: Label0019
Addr : 46F5: Label001A
Addr : 46F5: Label001B
196                          repeat while send_cmd_slow( ACMD41, |<30, $77 )
Addr : 46F5:             00  : Drop Anchor Push 
Addr : 46F6:          38 E9  : Constant 1 Bytes - E9 
Addr : 46F8:          38 1E  : Constant 1 Bytes - 1E 
Addr : 46FA:             F3  : Math Op |<    
Addr : 46FB:          38 77  : Constant 1 Bytes - 77 
Addr : 46FD:          05 0A  : Call Sub 10   
Addr : 46FF: JZ Label001D
Addr : 46FF:          0A 02  : jz Address = 4703 2
Addr : 4701: Label001C
Addr : 4701: JMP Label001B
Addr : 4701:          04 72  : Jmp 46F5 -14  
Addr : 4703: Label001D
198                          if send_cmd_slow( CMD58, 0, $FD ) <> 0
Addr : 4703:             00  : Drop Anchor Push 
Addr : 4704:          38 7A  : Constant 1 Bytes - 7A 
Addr : 4706:             35  : Constant 1 $00000000
Addr : 4707:          38 FD  : Constant 1 Bytes - FD 
Addr : 4709:          05 0A  : Call Sub 10   
Addr : 470B:             35  : Constant 1 $00000000
Addr : 470C:             FB  : Math Op <>    
Addr : 470D: JZ Label001E
Addr : 470D:          0A 05  : jz Address = 4714 5
199                            crash( ERR_OCR_FAILED )
Addr : 470F:             01  : Drop Anchor   
Addr : 4710:          37 40  : Constant Mask Y=64 Invert FFFFFFFD
Addr : 4712:          05 09  : Call Sub 9    
Addr : 4714: Label001E
Addr : 4714: Label001F
201                          tmp := read_32_slow
Addr : 4714:             00  : Drop Anchor Push 
Addr : 4715:          05 0C  : Call Sub 12   
Addr : 4717:             75  : Variable Operation Local Offset - 5 Write
203                          if tmp & |<30
Addr : 4718:             74  : Variable Operation Local Offset - 5 Read
Addr : 4719:          38 1E  : Constant 1 Bytes - 1E 
Addr : 471B:             F3  : Math Op |<    
Addr : 471C:             E8  : Math Op &     
Addr : 471D: JZ Label0020
Addr : 471D:          0A 09  : jz Address = 4728 9
204                            card_type := type_SDHC
Addr : 471F:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 4721:             61  : Variable Operation Local Offset - 0 Write
205                            adrShift := 0
Addr : 4722:             35  : Constant 1 $00000000
Addr : 4723:       C5 84 F8  : Memory Op Long PBASE + WRITE Address = 04F8
Addr : 4726: JMP Label0021
Addr : 4726:          04 03  : Jmp 472B 3    
Addr : 4728: Label0020
207                            card_type := type_SD
Addr : 4728:          37 00  : Constant Mask Y=0 00000002
Addr : 472A:             61  : Variable Operation Local Offset - 0 Write
Addr : 472B: Label0022
Addr : 472B: Label0021
Addr : 472B: JMP Label0018
Addr : 472B:          04 35  : Jmp 4762 53   
Addr : 472D: Label0017
210                          if send_cmd_slow( ACMD41, 0, $E5 ) < 2
Addr : 472D:             00  : Drop Anchor Push 
Addr : 472E:          38 E9  : Constant 1 Bytes - E9 
Addr : 4730:             35  : Constant 1 $00000000
Addr : 4731:          38 E5  : Constant 1 Bytes - E5 
Addr : 4733:          05 0A  : Call Sub 10   
Addr : 4735:          37 00  : Constant Mask Y=0 00000002
Addr : 4737:             F9  : Math Op <     
Addr : 4738: JZ Label0024
Addr : 4738:          0A 11  : jz Address = 474B 17
212                            card_type := type_SD
Addr : 473A:          37 00  : Constant Mask Y=0 00000002
Addr : 473C:             61  : Variable Operation Local Offset - 0 Write
Addr : 473D: Label0026
213                            repeat while send_cmd_slow( ACMD41, 0, $E5 )
Addr : 473D:             00  : Drop Anchor Push 
Addr : 473E:          38 E9  : Constant 1 Bytes - E9 
Addr : 4740:             35  : Constant 1 $00000000
Addr : 4741:          38 E5  : Constant 1 Bytes - E5 
Addr : 4743:          05 0A  : Call Sub 10   
Addr : 4745: JZ Label0028
Addr : 4745:          0A 02  : jz Address = 4749 2
Addr : 4747: Label0027
Addr : 4747: JMP Label0026
Addr : 4747:          04 74  : Jmp 473D -12  
Addr : 4749: Label0028
Addr : 4749: JMP Label0025
Addr : 4749:          04 0E  : Jmp 4759 14   
Addr : 474B: Label0024
216                            card_type := type_MMC
Addr : 474B:             36  : Constant 2 $00000001
Addr : 474C:             61  : Variable Operation Local Offset - 0 Write
Addr : 474D: Label002A
217                            repeat while send_cmd_slow( CMD1, 0, $F9 )
Addr : 474D:             00  : Drop Anchor Push 
Addr : 474E:          38 41  : Constant 1 Bytes - 41 
Addr : 4750:             35  : Constant 1 $00000000
Addr : 4751:          38 F9  : Constant 1 Bytes - F9 
Addr : 4753:          05 0A  : Call Sub 10   
Addr : 4755: JZ Label002C
Addr : 4755:          0A 02  : jz Address = 4759 2
Addr : 4757: Label002B
Addr : 4757: JMP Label002A
Addr : 4757:          04 74  : Jmp 474D -12  
Addr : 4759: Label002C
Addr : 4759: Label0029
Addr : 4759: Label0025
219                          send_cmd_slow( CMD16, 512, $15 )
Addr : 4759:             01  : Drop Anchor   
Addr : 475A:          38 50  : Constant 1 Bytes - 50 
Addr : 475C:          37 08  : Constant Mask Y=8 00000200
Addr : 475E:          38 15  : Constant 1 Bytes - 15 
Addr : 4760:          05 0A  : Call Sub 10   
Addr : 4762: Label0023
Addr : 4762: Label0018
221                        send_cmd_slow( CMD59, 0, $91 )
Addr : 4762:             01  : Drop Anchor   
Addr : 4763:          38 7B  : Constant 1 Bytes - 7B 
Addr : 4765:             35  : Constant 1 $00000000
Addr : 4766:          38 91  : Constant 1 Bytes - 91 
Addr : 4768:          05 0A  : Call Sub 10   
225                        outa |= maskCS
Addr : 476A:       C4 84 F0  : Memory Op Long PBASE + READ Address = 04F0
Addr : 476D:       3F D4 4A  : Register op OUTA ByteMathop |
228                        writeMode := (%00100 << 26) | (DI << 0)
Addr : 4770:          37 01  : Constant Mask Y=1 00000004
Addr : 4772:          38 1A  : Constant 1 Bytes - 1A 
Addr : 4774:             E3  : Math Op <<    
Addr : 4775:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4776:             35  : Constant 1 $00000000
Addr : 4777:             E3  : Math Op <<    
Addr : 4778:             EA  : Math Op |     
Addr : 4779:       C5 85 04  : Memory Op Long PBASE + WRITE Address = 0504
234                        clockLineMode := (%00100 << 26) | (CLK << 0) ' NCO, 50% duty cycle
Addr : 477C:          37 01  : Constant Mask Y=1 00000004
Addr : 477E:          38 1A  : Constant 1 Bytes - 1A 
Addr : 4780:             E3  : Math Op <<    
Addr : 4781:             68  : Variable Operation Local Offset - 2 Read
Addr : 4782:             35  : Constant 1 $00000000
Addr : 4783:             E3  : Math Op <<    
Addr : 4784:             EA  : Math Op |     
Addr : 4785:       C5 85 0C  : Memory Op Long PBASE + WRITE Address = 050C
236                        N_in8_500ms := clkfreq >> constant(1+2+3)
Addr : 4788:             35  : Constant 1 $00000000
Addr : 4789:             C0  : Memory Op Long POP Address READ 
Addr : 478A:          38 06  : Constant 1 Bytes - 06 
Addr : 478C:             E2  : Math Op >>    
Addr : 478D:       C5 85 08  : Memory Op Long PBASE + WRITE Address = 0508
238                        idle_limit := 125 ' ms, NEVER make this > 1000
Addr : 4790:          38 7D  : Constant 1 Bytes - 7D 
Addr : 4792:       C5 85 30  : Memory Op Long PBASE + WRITE Address = 0530
239                        idle_limit := clkfreq / (1000 / idle_limit) ' convert to counts
Addr : 4795:             35  : Constant 1 $00000000
Addr : 4796:             C0  : Memory Op Long POP Address READ 
Addr : 4797:       39 03 E8  : Constant 2 Bytes - 03 E8 
Addr : 479A:       C4 85 30  : Memory Op Long PBASE + READ Address = 0530
Addr : 479D:             F6  : Math Op /     
Addr : 479E:             F6  : Math Op /     
Addr : 479F:       C5 85 30  : Memory Op Long PBASE + WRITE Address = 0530
241                        bufAdr := @SPI_buffer_address
Addr : 47A2:          C7 44  : Memory Op Long PBASE + ADDRESS Address = 0044
Addr : 47A4:       C5 84 FC  : Memory Op Long PBASE + WRITE Address = 04FC
242                        sdAdr := @SPI_block_index
Addr : 47A7:          C7 40  : Memory Op Long PBASE + ADDRESS Address = 0040
Addr : 47A9:       C5 85 00  : Memory Op Long PBASE + WRITE Address = 0500
243                        SPI_command := 0 ' just make sure it's not 1
Addr : 47AC:             35  : Constant 1 $00000000
Addr : 47AD:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
245                        SPI_engine_cog := cognew( @SPI_engine_entry, @SPI_command ) + 1
Addr : 47AF:             34  : Constant 0 $FFFFFFFF
Addr : 47B0:          C7 48  : Memory Op Long PBASE + ADDRESS Address = 0048
Addr : 47B2:          C7 3C  : Memory Op Long PBASE + ADDRESS Address = 003C
Addr : 47B4:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 47B5:             36  : Constant 2 $00000001
Addr : 47B6:             EC  : Math Op +     
Addr : 47B7:          C5 38  : Memory Op Long PBASE + WRITE Address = 0038
246                        if( SPI_engine_cog == 0 )
Addr : 47B9:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 47BB:             35  : Constant 1 $00000000
Addr : 47BC:             FC  : Math Op ==    
Addr : 47BD: JZ Label002D
Addr : 47BD:          0A 07  : jz Address = 47C6 7
247                          crash( ERR_SPI_ENGINE_NOT_RUNNING )
Addr : 47BF:             01  : Drop Anchor   
Addr : 47C0:       39 03 E6  : Constant 2 Bytes - 03 E6 
Addr : 47C3:             E7  : Math Op !     
Addr : 47C4:          05 09  : Call Sub 9    
Addr : 47C6: Label002D
Addr : 47C6: Label002E
Addr : 47C6: Label002F
248                        repeat while SPI_command <> -1
Addr : 47C6:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 47C8:             34  : Constant 0 $FFFFFFFF
Addr : 47C9:             FB  : Math Op <>    
Addr : 47CA: JZ Label0031
Addr : 47CA:          0A 02  : jz Address = 47CE 2
Addr : 47CC: Label0030
Addr : 47CC: JMP Label002F
Addr : 47CC:          04 78  : Jmp 47C6 -8   
Addr : 47CE: Label0031
250                        dira &= !maskAll
Addr : 47CE:       C4 84 F4  : Memory Op Long PBASE + READ Address = 04F4
Addr : 47D1:             E7  : Math Op !     
Addr : 47D2:       3F D6 48  : Register op DIRA BitMathop &
Addr : 47D5:             32  : Return        
|===========================================================================|
Spin Block release with 0 Parameters and 0 Extra Stack Longs. Method 7
PUB release

Local Parameter DBASE:0000 - Result
|===========================================================================|
259                        if SPI_engine_cog
Addr : 47D6:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 47D8: JZ Label0002
Addr : 47D8:          0A 0D  : jz Address = 47E7 13
260                          SPI_command := "z"
Addr : 47DA:          38 7A  : Constant 1 Bytes - 7A 
Addr : 47DC:          C5 3C  : Memory Op Long PBASE + WRITE Address = 003C
Addr : 47DE: Label0004
261                          repeat while SPI_command == "z"
Addr : 47DE:          C4 3C  : Memory Op Long PBASE + READ Address = 003C
Addr : 47E0:          38 7A  : Constant 1 Bytes - 7A 
Addr : 47E2:             FC  : Math Op ==    
Addr : 47E3: JZ Label0006
Addr : 47E3:          0A 02  : jz Address = 47E7 2
Addr : 47E5: Label0005
Addr : 47E5: JMP Label0004
Addr : 47E5:          04 77  : Jmp 47DE -9   
Addr : 47E7: Label0006
Addr : 47E7: Label0002
Addr : 47E7: Label0003
Addr : 47E7:             32  : Return        
|===========================================================================|
Spin Block stop with 0 Parameters and 0 Extra Stack Longs. Method 8
PUB stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
267                        release
Addr : 47E8:             01  : Drop Anchor   
Addr : 47E9:          05 07  : Call Sub 7    
268                        if SPI_engine_cog
Addr : 47EB:          C4 38  : Memory Op Long PBASE + READ Address = 0038
Addr : 47ED: JZ Label0002
Addr : 47ED:          0A 06  : jz Address = 47F5 6
269                          cogstop( SPI_engine_cog~ - 1 )
Addr : 47EF:       C6 38 98  : Memory Op Long PBASE + ASSIGN Address = 0038 VAR~ Post-clear Push
Addr : 47F2:             36  : Constant 2 $00000001
Addr : 47F3:             ED  : Math Op -     
Addr : 47F4:             21  : CogStop(id)   
Addr : 47F5: Label0002
Addr : 47F5: Label0003
Addr : 47F5:             32  : Return        
|===========================================================================|
Spin Block crash with 1 Parameters and 0 Extra Stack Longs. Method 9
PRI crash( abort_code )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - abort_code
|===========================================================================|
277                        dira &= !maskAll
Addr : 47F6:       C4 84 F4  : Memory Op Long PBASE + READ Address = 04F4
Addr : 47F9:             E7  : Math Op !     
Addr : 47FA:       3F D6 48  : Register op DIRA BitMathop &
279                        abort abort_code
Addr : 47FD:             64  : Variable Operation Local Offset - 1 Read
Addr : 47FE:             31  : Abort value   
Addr : 47FF: Data : 32                       2
|===========================================================================|
Spin Block send_cmd_slow with 3 Parameters and 1 Extra Stack Longs. Method 10
PRI send_cmd_slow( cmd, val, crc ) : reply | time_stamp

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - cmd
Local Parameter DBASE:0008 - val
Local Parameter DBASE:000C - crc
Local Variable  DBASE:0010 - time_stamp
|===========================================================================|
293                        if (cmd & $80)
Addr : 4800:             64  : Variable Operation Local Offset - 1 Read
Addr : 4801:          37 06  : Constant Mask Y=6 00000080
Addr : 4803:             E8  : Math Op &     
Addr : 4804: JZ Label0002
Addr : 4804:          0A 14  : jz Address = 481A 20
295                            cmd &= $7F
Addr : 4806:          37 26  : Constant Mask Y=38 Decrement 0000007F
Addr : 4808:          66 48  : Variable Operation Local Offset - 1 Assign BitMathop &
296                            reply := send_cmd_slow( CMD55, 0, $65 )
Addr : 480A:             00  : Drop Anchor Push 
Addr : 480B:          38 77  : Constant 1 Bytes - 77 
Addr : 480D:             35  : Constant 1 $00000000
Addr : 480E:          38 65  : Constant 1 Bytes - 65 
Addr : 4810:          05 0A  : Call Sub 10   
Addr : 4812:             61  : Variable Operation Local Offset - 0 Write
297                            if (reply > 1)
Addr : 4813:             60  : Variable Operation Local Offset - 0 Read
Addr : 4814:             36  : Constant 2 $00000001
Addr : 4815:             FA  : Math Op >     
Addr : 4816: JZ Label0004
Addr : 4816:          0A 02  : jz Address = 481A 2
298                              return reply  
Addr : 4818:             60  : Variable Operation Local Offset - 0 Read
Addr : 4819:             33  : Return value  
Addr : 481A: Label0004
Addr : 481A: Label0005
Addr : 481A: Label0002
Addr : 481A: Label0003
300                        outa |= maskCS
Addr : 481A:       C4 84 F0  : Memory Op Long PBASE + READ Address = 04F0
Addr : 481D:       3F D4 4A  : Register op OUTA ByteMathop |
301                        outa &= !maskCS
Addr : 4820:       C4 84 F0  : Memory Op Long PBASE + READ Address = 04F0
Addr : 4823:             E7  : Math Op !     
Addr : 4824:       3F D4 48  : Register op OUTA BitMathop &
303                        read_32_slow
Addr : 4827:             01  : Drop Anchor   
Addr : 4828:          05 0C  : Call Sub 12   
305                        send_slow( cmd, 8 )
Addr : 482A:             01  : Drop Anchor   
Addr : 482B:             64  : Variable Operation Local Offset - 1 Read
Addr : 482C:          37 02  : Constant Mask Y=2 00000008
Addr : 482E:          05 0B  : Call Sub 11   
307                        send_slow( val, 32 )   
Addr : 4830:             01  : Drop Anchor   
Addr : 4831:             68  : Variable Operation Local Offset - 2 Read
Addr : 4832:          37 04  : Constant Mask Y=4 00000020
Addr : 4834:          05 0B  : Call Sub 11   
309                        send_slow( crc, 8 )
Addr : 4836:             01  : Drop Anchor   
Addr : 4837:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4838:          37 02  : Constant Mask Y=2 00000008
Addr : 483A:          05 0B  : Call Sub 11   
311                        if cmd == CMD12
Addr : 483C:             64  : Variable Operation Local Offset - 1 Read
Addr : 483D:          38 4C  : Constant 1 Bytes - 4C 
Addr : 483F:             FC  : Math Op ==    
Addr : 4840: JZ Label0006
Addr : 4840:          0A 03  : jz Address = 4845 3
312                          read_slow
Addr : 4842:             01  : Drop Anchor   
Addr : 4843:          05 0D  : Call Sub 13   
Addr : 4845: Label0006
Addr : 4845: Label0007
314                        time_stamp := 9
Addr : 4845:          38 09  : Constant 1 Bytes - 09 
Addr : 4847:             71  : Variable Operation Local Offset - 4 Write
Addr : 4848: Label0008
316                          reply := read_slow
Addr : 4848:             00  : Drop Anchor Push 
Addr : 4849:          05 0D  : Call Sub 13   
Addr : 484B:             61  : Variable Operation Local Offset - 0 Write
Addr : 484C: Label0009
317                        while( reply & $80 ) and ( time_stamp-- )
Addr : 484C:             60  : Variable Operation Local Offset - 0 Read
Addr : 484D:          37 06  : Constant Mask Y=6 00000080
Addr : 484F:             E8  : Math Op &     
Addr : 4850:          72 BE  : Variable Operation Local Offset - 4 Assign VAR-- post-dec Long Push
Addr : 4852:             F0  : Math Op AND   
Addr : 4853: JNZ Label0008
Addr : 4853:          0B 73  : jnz Address = 4848 -13
Addr : 4855: Label000A
Addr : 4855:             32  : Return        
|===========================================================================|
Spin Block send_slow with 2 Parameters and 0 Extra Stack Longs. Method 11
PRI send_slow( value, bits_to_send )

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - bits_to_send
|===========================================================================|
330                        value ><= bits_to_send
Addr : 4856:             68  : Variable Operation Local Offset - 2 Read
Addr : 4857:          66 4F  : Variable Operation Local Offset - 1 Assign LongMathop ><
331                        repeat bits_to_send
Addr : 4859:             68  : Variable Operation Local Offset - 2 Read
Addr : 485A: TJZ Label0004
Addr : 485A:          08 17  : tjz Address = 4873 23
Addr : 485C: Label0002
332                          outa[pinCLK]~
Addr : 485C:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 485F:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
333                          outa[pinDI] := value
Addr : 4862:             64  : Variable Operation Local Offset - 1 Read
Addr : 4863:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 4866:          3D B4  : Register [Bit] op OUTA Write
334                          value >>= 1
Addr : 4868:             36  : Constant 2 $00000001
Addr : 4869:          66 42  : Variable Operation Local Offset - 1 Assign ByteMathop >>
335                          outa[pinCLK]~~
Addr : 486B:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 486E:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
Addr : 4871: Label0003
Addr : 4871: DJNZ Label0002
Addr : 4871:          09 69  : djnz Address = 485C -23
Addr : 4873: Label0004
Addr : 4873:             32  : Return        
|===========================================================================|
Spin Block read_32_slow with 0 Parameters and 0 Extra Stack Longs. Method 12
PRI read_32_slow : r

Local Parameter DBASE:0000 - Result
|===========================================================================|
338                        repeat 4
Addr : 4874:          37 01  : Constant Mask Y=1 00000004
Addr : 4876: TJZ Label0004
Addr : 4876:          08 0B  : tjz Address = 4883 11
Addr : 4878: Label0002
339                          r <<= 8
Addr : 4878:          37 02  : Constant Mask Y=2 00000008
Addr : 487A:          62 43  : Variable Operation Local Offset - 0 Assign ByteMathop <<
340                          r |= read_slow
Addr : 487C:             00  : Drop Anchor Push 
Addr : 487D:          05 0D  : Call Sub 13   
Addr : 487F:          62 4A  : Variable Operation Local Offset - 0 Assign ByteMathop |
Addr : 4881: Label0003
Addr : 4881: DJNZ Label0002
Addr : 4881:          09 75  : djnz Address = 4878 -11
Addr : 4883: Label0004
Addr : 4883:             32  : Return        
|===========================================================================|
Spin Block read_slow with 0 Parameters and 0 Extra Stack Longs. Method 13
PRI read_slow : r

Local Parameter DBASE:0000 - Result
|===========================================================================|
347                        outa[pinDI]~~
Addr : 4884:       C4 84 E4  : Memory Op Long PBASE + READ Address = 04E4
Addr : 4887:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
349                        repeat 8
Addr : 488A:          37 02  : Constant Mask Y=2 00000008
Addr : 488C: TJZ Label0004
Addr : 488C:          08 17  : tjz Address = 48A5 23
Addr : 488E: Label0002
350                          outa[pinCLK]~
Addr : 488E:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 4891:       3D D4 18  : Register [Bit] op OUTA VAR~ Post-clear
351                          outa[pinCLK]~~
Addr : 4894:       C4 84 E0  : Memory Op Long PBASE + READ Address = 04E0
Addr : 4897:       3D D4 1C  : Register [Bit] op OUTA VAR~~ Post-set
352                          r += r + ina[pinDO]
Addr : 489A:             60  : Variable Operation Local Offset - 0 Read
Addr : 489B:       C4 84 DC  : Memory Op Long PBASE + READ Address = 04DC
Addr : 489E:          3D 92  : Register [Bit] op INA Read
Addr : 48A0:             EC  : Math Op +     
Addr : 48A1:          62 4C  : Variable Operation Local Offset - 0 Assign WordMathop +
Addr : 48A3: Label0003
Addr : 48A3: DJNZ Label0002
Addr : 48A3:          09 69  : djnz Address = 488E -23
Addr : 48A5: Label0004
354                        if( (cnt - SPI_block_index) > (clkfreq << 2) )
Addr : 48A5:          3F 91  : Register op CNT Read
Addr : 48A7:          C4 40  : Memory Op Long PBASE + READ Address = 0040
Addr : 48A9:             ED  : Math Op -     
Addr : 48AA:             35  : Constant 1 $00000000
Addr : 48AB:             C0  : Memory Op Long POP Address READ 
Addr : 48AC:          37 00  : Constant Mask Y=0 00000002
Addr : 48AE:             E3  : Math Op <<    
Addr : 48AF:             FA  : Math Op >     
Addr : 48B0: JZ Label0005
Addr : 48B0:          0A 07  : jz Address = 48B9 7
355                          crash( ERR_CARD_BUSY_TIMEOUT )
Addr : 48B2:             01  : Drop Anchor   
Addr : 48B3:       39 03 E7  : Constant 2 Bytes - 03 E7 
Addr : 48B6:             E7  : Math Op !     
Addr : 48B7:          05 09  : Call Sub 9    
Addr : 48B9: Label0005
Addr : 48B9: Label0006
Addr : 48B9:             32  : Return        
|===========================================================================|
Object E555_SPKEngine
Object Base is 48BC
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
Spin Block speakerFrequency with 2 Parameters and 0 Extra Stack Longs. Method 1
PUB speakerFrequency(newFrequency, speakerPinNumber) '' 10 Stack Longs

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - newFrequency
Local Parameter DBASE:0008 - speakerPinNumber
|===========================================================================|
40                        speakerSetup((newFrequency <> -1), speakerPinNumber)
Addr : 48CC:             01  : Drop Anchor   
Addr : 48CD:             64  : Variable Operation Local Offset - 1 Read
Addr : 48CE:             34  : Constant 0 $FFFFFFFF
Addr : 48CF:             FB  : Math Op <>    
Addr : 48D0:             68  : Variable Operation Local Offset - 2 Read
Addr : 48D1:          05 03  : Call Sub 3    
42                        newFrequency := ((newFrequency <# clkfreq) #> 0)
Addr : 48D3:             64  : Variable Operation Local Offset - 1 Read
Addr : 48D4:             35  : Constant 1 $00000000
Addr : 48D5:             C0  : Memory Op Long POP Address READ 
Addr : 48D6:             E5  : Math Op <#    
Addr : 48D7:             35  : Constant 1 $00000000
Addr : 48D8:             E4  : Math Op #>    
Addr : 48D9:             65  : Variable Operation Local Offset - 1 Write
44                        result := 1
Addr : 48DA:             36  : Constant 2 $00000001
Addr : 48DB:             61  : Variable Operation Local Offset - 0 Write
46                        repeat 32
Addr : 48DC:          37 04  : Constant Mask Y=4 00000020
Addr : 48DE: TJZ Label0004
Addr : 48DE:          08 15  : tjz Address = 48F5 21
Addr : 48E0: Label0002
47                          newFrequency <<= 1
Addr : 48E0:             36  : Constant 2 $00000001
Addr : 48E1:          66 43  : Variable Operation Local Offset - 1 Assign ByteMathop <<
48                          result <-= 1
Addr : 48E3:             36  : Constant 2 $00000001
Addr : 48E4:          62 41  : Variable Operation Local Offset - 0 Assign BitMathop -<
49                          if(newFrequency => clkfreq)
Addr : 48E6:             64  : Variable Operation Local Offset - 1 Read
Addr : 48E7:             35  : Constant 1 $00000000
Addr : 48E8:             C0  : Memory Op Long POP Address READ 
Addr : 48E9:             FE  : Math Op =>    
Addr : 48EA: JZ Label0005
Addr : 48EA:          0A 07  : jz Address = 48F3 7
50                            newFrequency -= clkfreq
Addr : 48EC:             35  : Constant 1 $00000000
Addr : 48ED:             C0  : Memory Op Long POP Address READ 
Addr : 48EE:          66 4D  : Variable Operation Local Offset - 1 Assign WordMathop -
51                            result += 1
Addr : 48F0:             36  : Constant 2 $00000001
Addr : 48F1:          62 4C  : Variable Operation Local Offset - 0 Assign WordMathop +
Addr : 48F3: Label0005
Addr : 48F3: Label0006
Addr : 48F3: Label0003
Addr : 48F3: DJNZ Label0002
Addr : 48F3:          09 6B  : djnz Address = 48E0 -21
Addr : 48F5: Label0004
53                        frqa := result~
Addr : 48F5:          62 98  : Variable Operation Local Offset - 0 Assign VAR~ Post-clear Push
Addr : 48F7:          3F BA  : Register op FRQA Write
55                        phsb := 0
Addr : 48F9:             35  : Constant 1 $00000000
Addr : 48FA:          3F BD  : Register op PHSB Write
Addr : 48FC:             32  : Return        
|===========================================================================|
Spin Block speakerVolume with 2 Parameters and 0 Extra Stack Longs. Method 2
PUB speakerVolume(newVolume, speakerPinNumber) '' 10 Stack Longs

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - newVolume
Local Parameter DBASE:0008 - speakerPinNumber
|===========================================================================|
66                        speakerSetup((newVolume <> -1), speakerPinNumber)
Addr : 48FD:             01  : Drop Anchor   
Addr : 48FE:             64  : Variable Operation Local Offset - 1 Read
Addr : 48FF:             34  : Constant 0 $FFFFFFFF
Addr : 4900:             FB  : Math Op <>    
Addr : 4901:             68  : Variable Operation Local Offset - 2 Read
Addr : 4902:          05 03  : Call Sub 3    
68                        frqb := (((100 - ((newVolume <# 100) #> 0)) * constant(posx / 50)) | $7)
Addr : 4904:          38 64  : Constant 1 Bytes - 64 
Addr : 4906:             64  : Variable Operation Local Offset - 1 Read
Addr : 4907:          38 64  : Constant 1 Bytes - 64 
Addr : 4909:             E5  : Math Op <#    
Addr : 490A:             35  : Constant 1 $00000000
Addr : 490B:             E4  : Math Op #>    
Addr : 490C:             ED  : Math Op -     
Addr : 490D: 3B 02 8F 5C 28  : Constant 4 Bytes - 02 8F 5C 28 
Addr : 4912:             F4  : Math Op *     
Addr : 4913:          37 22  : Constant Mask Y=34 Decrement 00000007
Addr : 4915:             EA  : Math Op |     
Addr : 4916:          3F BB  : Register op FRQB Write
Addr : 4918:             32  : Return        
|===========================================================================|
Spin Block speakerSetup with 2 Parameters and 0 Extra Stack Longs. Method 3
PRI speakerSetup(activeOrInactive, speakerPinNumber) ' 5 Stack Longs

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - activeOrInactive
Local Parameter DBASE:0008 - speakerPinNumber
|===========================================================================|
72                        speakerPinNumber := ((speakerPinNumber <# 31) #> 0)
Addr : 4919:             68  : Variable Operation Local Offset - 2 Read
Addr : 491A:          37 24  : Constant Mask Y=36 Decrement 0000001F
Addr : 491C:             E5  : Math Op <#    
Addr : 491D:             35  : Constant 1 $00000000
Addr : 491E:             E4  : Math Op #>    
Addr : 491F:             69  : Variable Operation Local Offset - 2 Write
74                        dira[speakerPinNumber] := activeOrInactive
Addr : 4920:             64  : Variable Operation Local Offset - 1 Read
Addr : 4921:             68  : Variable Operation Local Offset - 2 Read
Addr : 4922:          3D B6  : Register [Bit] op DIRA Write
76                        outa[speakerPinNumber] := false
Addr : 4924:             35  : Constant 1 $00000000
Addr : 4925:             68  : Variable Operation Local Offset - 2 Read
Addr : 4926:          3D B4  : Register [Bit] op OUTA Write
78                        ctra := ((constant(%0_0100 << 26) + speakerPinNumber) & activeOrInactive)
Addr : 4928:          37 1B  : Constant Mask Y=27 10000000
Addr : 492A:             68  : Variable Operation Local Offset - 2 Read
Addr : 492B:             EC  : Math Op +     
Addr : 492C:             64  : Variable Operation Local Offset - 1 Read
Addr : 492D:             E8  : Math Op &     
Addr : 492E:          3F B8  : Register op CTRA Write
80                        ctrb := ((constant(%0_0110 << 26) + speakerPinNumber) & activeOrInactive)
Addr : 4930: 3B 18 00 00 00  : Constant 4 Bytes - 18 00 00 00 
Addr : 4935:             68  : Variable Operation Local Offset - 2 Read
Addr : 4936:             EC  : Math Op +     
Addr : 4937:             64  : Variable Operation Local Offset - 1 Read
Addr : 4938:             E8  : Math Op &     
Addr : 4939:          3F B9  : Register op CTRB Write
Addr : 493B:             32  : Return        
|===========================================================================|
Object Parallax Serial Terminal
Object Base is 493C
|===========================================================================|
Object Constants
|===========================================================================|
|===========================================================================|
VBASE Global Variables
|===========================================================================|
VBASE : 0000 LONG Size 0004 Variable cog
VBASE : 0004 LONG Size 0004 Variable rx_head
VBASE : 0008 LONG Size 0004 Variable rx_tail
VBASE : 000C LONG Size 0004 Variable tx_head
VBASE : 0010 LONG Size 0004 Variable tx_tail
VBASE : 0014 LONG Size 0004 Variable rx_pin
VBASE : 0018 LONG Size 0004 Variable tx_pin
VBASE : 001C LONG Size 0004 Variable rxtx_mode
VBASE : 0020 LONG Size 0004 Variable bit_ticks
VBASE : 0024 LONG Size 0004 Variable buffer_ptr
VBASE : 0028 BYTE Size 0040 Variable rx_buffer
VBASE : 0068 BYTE Size 0040 Variable tx_buffer
VBASE : 00A8 BYTE Size 0032 Variable str_buffer
|===========================================================================|
Object DAT Blocks
|===========================================================================|
49CC(0000)             |                         org
49CC(0000) F0 A9 BC A0 | entry                   mov     t1,par                'get structure address
49D0(0001) 10 A8 FC 80 |                         add     t1,#4 << 2            'skip past heads and tails
49D4(0002) 54 AA BC 08 |                         rdlong  t2,t1                 'get rx_pin
49D8(0003) 01 B2 FC A0 |                         mov     rxmask,#1
49DC(0004) 55 B2 BC 2C |                         shl     rxmask,t2
49E0(0005) 04 A8 FC 80 |                         add     t1,#4                 'get tx_pin
49E4(0006) 54 AA BC 08 |                         rdlong  t2,t1
49E8(0007) 01 BE FC A0 |                         mov     txmask,#1
49EC(0008) 55 BE BC 2C |                         shl     txmask,t2
49F0(0009) 04 A8 FC 80 |                         add     t1,#4                 'get rxtx_mode
49F4(000A) 54 AE BC 08 |                         rdlong  rxtxmode,t1
49F8(000B) 04 A8 FC 80 |                         add     t1,#4                 'get bit_ticks
49FC(000C) 54 B0 BC 08 |                         rdlong  bitticks,t1
4A00(000D) 04 A8 FC 80 |                         add     t1,#4                 'get buffer_ptr
4A04(000E) 54 B4 BC 08 |                         rdlong  rxbuff,t1
4A08(000F) 5A C0 BC A0 |                         mov     txbuff,rxbuff
4A0C(0010) 40 C0 FC 80 |                         add     txbuff,#BUFFER_LENGTH
4A10(0011) 04 AE 7C 62 |                         test    rxtxmode,#%100  wz    'init tx pin according to mode
4A14(0012) 02 AE 7C 61 |                         test    rxtxmode,#%010  wc
4A18(0013) 5F E8 9B 68 |         if_z_ne_c       or      outa,txmask
4A1C(0014) 5F EC AB 68 |         if_z            or      dira,txmask
4A20(0015) 33 C8 FC A0 |                         mov     txcode,#transmit      'initialize ping-pong multitasking
4A24(0016) 64 BC BC 5C | receive                 jmpret  rxcode,txcode         'run chunk of tx code, then return
4A28(0017) 01 AE 7C 62 |                         test    rxtxmode,#%001  wz    'wait for start bit on rx pin
4A2C(0018) F2 B3 3C 61 |                         test    rxmask,ina      wc
4A30(0019) 16 00 64 5C |         if_z_eq_c       jmp     #receive
4A34(001A) 09 B8 FC A0 |                         mov     rxbits,#9             'ready to receive byte
4A38(001B) 58 BA BC A0 |                         mov     rxcnt,bitticks
4A3C(001C) 01 BA FC 28 |                         shr     rxcnt,#1
4A40(001D) F1 BB BC 80 |                         add     rxcnt,cnt                          
4A44(001E) 58 BA BC 80 | :bit                    add     rxcnt,bitticks        'ready next bit period
4A48(001F) 64 BC BC 5C | :wait                   jmpret  rxcode,txcode         'run chunk of tx code, then return
4A4C(0020) 5D A8 BC A0 |                         mov     t1,rxcnt              'check if bit receive period done
4A50(0021) F1 A9 BC 84 |                         sub     t1,cnt
4A54(0022) 00 A8 7C C1 |                         cmps    t1,#0           wc
4A58(0023) 1F 00 4C 5C |         if_nc           jmp     #:wait
4A5C(0024) F2 B3 3C 61 |                         test    rxmask,ina      wc    'receive bit on rx pin
4A60(0025) 01 B6 FC 30 |                         rcr     rxdata,#1
4A64(0026) 1E B8 FC E4 |                         djnz    rxbits,#:bit
4A68(0027) 17 B6 FC 28 |                         shr     rxdata,#32-9          'justify and trim received byte
4A6C(0028) FF B6 FC 60 |                         and     rxdata,#$FF
4A70(0029) 01 AE 7C 62 |                         test    rxtxmode,#%001  wz    'if rx inverted, invert byte
4A74(002A) FF B6 D4 6C |         if_nz           xor     rxdata,#$FF
4A78(002B) F0 AB BC 08 |                         rdlong  t2,par                'save received byte and inc head
4A7C(002C) 5A AA BC 80 |                         add     t2,rxbuff
4A80(002D) 55 B6 3C 00 |                         wrbyte  rxdata,t2
4A84(002E) 5A AA BC 84 |                         sub     t2,rxbuff
4A88(002F) 01 AA FC 80 |                         add     t2,#1
4A8C(0030) 3F AA FC 60 |                         and     t2,#BUFFER_MASK
4A90(0031) F0 AB 3C 08 |                         wrlong  t2,par
4A94(0032) 16 00 7C 5C |                         jmp     #receive              'byte done, receive next byte
4A98(0033) 5E C8 BC 5C | transmit                jmpret  txcode,rxcode         'run chunk of rx code, then return
4A9C(0034) F0 A9 BC A0 |                         mov     t1,par                'check for head <> tail
4AA0(0035) 08 A8 FC 80 |                         add     t1,#2 << 2
4AA4(0036) 54 AA BC 08 |                         rdlong  t2,t1
4AA8(0037) 04 A8 FC 80 |                         add     t1,#1 << 2
4AAC(0038) 54 AC BC 08 |                         rdlong  t3,t1
4AB0(0039) 56 AA 3C 86 |                         cmp     t2,t3           wz
4AB4(003A) 33 00 68 5C |         if_z            jmp     #transmit
4AB8(003B) 60 AC BC 80 |                         add     t3,txbuff             'get byte and inc tail
4ABC(003C) 56 C2 BC 00 |                         rdbyte  txdata,t3
4AC0(003D) 60 AC BC 84 |                         sub     t3,txbuff
4AC4(003E) 01 AC FC 80 |                         add     t3,#1
4AC8(003F) 3F AC FC 60 |                         and     t3,#BUFFER_MASK
4ACC(0040) 54 AC 3C 08 |                         wrlong  t3,t1
4AD0(0041) 00 C3 FC 68 |                         or      txdata,#$100          'ready byte to transmit
4AD4(0042) 02 C2 FC 2C |                         shl     txdata,#2
4AD8(0043) 01 C2 FC 68 |                         or      txdata,#1
4ADC(0044) 0B C4 FC A0 |                         mov     txbits,#11
4AE0(0045) F1 C7 BC A0 |                         mov     txcnt,cnt
4AE4(0046) 04 AE 7C 62 | :bit                    test    rxtxmode,#%100  wz    'output bit on tx pin 
4AE8(0047) 02 AE 7C 61 |                         test    rxtxmode,#%010  wc    'according to mode
4AEC(0048) 01 C2 E0 6C |         if_z_and_c      xor     txdata,#1
4AF0(0049) 01 C2 FC 29 |                         shr     txdata,#1       wc
4AF4(004A) 5F E8 AB 70 |         if_z            muxc    outa,txmask        
4AF8(004B) 5F EC 97 74 |         if_nz           muxnc   dira,txmask
4AFC(004C) 58 C6 BC 80 |                         add     txcnt,bitticks        'ready next cnt
4B00(004D) 5E C8 BC 5C | :wait                   jmpret  txcode,rxcode         'run chunk of rx code, then return
4B04(004E) 63 A8 BC A0 |                         mov     t1,txcnt              'check if bit transmit period done
4B08(004F) F1 A9 BC 84 |                         sub     t1,cnt
4B0C(0050) 00 A8 7C C1 |                         cmps    t1,#0           wc
4B10(0051) 4D 00 4C 5C |         if_nc           jmp     #:wait
4B14(0052) 46 C4 FC E4 |                         djnz    txbits,#:bit          'another bit to transmit?
4B18(0053) 33 00 7C 5C |                         jmp     #transmit             'byte done, transmit next byte
4B1C(0054)             | t1                      res     1
4B1C(0055)             | t2                      res     1
4B1C(0056)             | t3                      res     1
4B1C(0057)             | rxtxmode                res     1
4B1C(0058)             | bitticks                res     1
4B1C(0059)             | rxmask                  res     1
4B1C(005A)             | rxbuff                  res     1
4B1C(005B)             | rxdata                  res     1
4B1C(005C)             | rxbits                  res     1
4B1C(005D)             | rxcnt                   res     1
4B1C(005E)             | rxcode                  res     1
4B1C(005F)             | txmask                  res     1
4B1C(0060)             | txbuff                  res     1
4B1C(0061)             | txdata                  res     1
4B1C(0062)             | txbits                  res     1
4B1C(0063)             | txcnt                   res     1
4B1C(0064)             | txcode                  res     1
|===========================================================================|
|===========================================================================|
Spin Block Start with 1 Parameters and 0 Extra Stack Longs. Method 1
PUB Start(baudrate) : okay

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - baudrate
|===========================================================================|
85                        okay := StartRxTx(31, 30, 0, baudrate)
Addr : 4B1C:             00  : Drop Anchor Push 
Addr : 4B1D:          37 24  : Constant Mask Y=36 Decrement 0000001F
Addr : 4B1F:          38 1E  : Constant 1 Bytes - 1E 
Addr : 4B21:             35  : Constant 1 $00000000
Addr : 4B22:             64  : Variable Operation Local Offset - 1 Read
Addr : 4B23:          05 02  : Call Sub 2    
Addr : 4B25:             61  : Variable Operation Local Offset - 0 Write
86                        waitcnt(clkfreq + cnt)                                'Wait 1 second for PST
Addr : 4B26:             35  : Constant 1 $00000000
Addr : 4B27:             C0  : Memory Op Long POP Address READ 
Addr : 4B28:          3F 91  : Register op CNT Read
Addr : 4B2A:             EC  : Math Op +     
Addr : 4B2B:             23  : WaitCnt(count)
87                        Clear                                                 'Clear display
Addr : 4B2C:             01  : Drop Anchor   
Addr : 4B2D:          05 10  : Call Sub 16   
Addr : 4B2F:             32  : Return        
|===========================================================================|
Spin Block StartRxTx with 4 Parameters and 0 Extra Stack Longs. Method 2
PUB StartRxTx(rxpin, txpin, mode, baudrate) : okay

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - rxpin
Local Parameter DBASE:0008 - txpin
Local Parameter DBASE:000C - mode
Local Parameter DBASE:0010 - baudrate
|===========================================================================|
102                        stop
Addr : 4B30:             01  : Drop Anchor   
Addr : 4B31:          05 03  : Call Sub 3    
103                        longfill(@rx_head, 0, 4)
Addr : 4B33:             47  : Variable Operation Global Offset - 1 Address
Addr : 4B34:             35  : Constant 1 $00000000
Addr : 4B35:          37 01  : Constant Mask Y=1 00000004
Addr : 4B37:             1A  : LongFill(Start, Value, Count)
104                        longmove(@rx_pin, @rxpin, 3)
Addr : 4B38:             57  : Variable Operation Global Offset - 5 Address
Addr : 4B39:             67  : Variable Operation Local Offset - 1 Address
Addr : 4B3A:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 4B3C:             1E  : LongMove(To, From, Count)
105                        bit_ticks := clkfreq / baudrate
Addr : 4B3D:             35  : Constant 1 $00000000
Addr : 4B3E:             C0  : Memory Op Long POP Address READ 
Addr : 4B3F:             70  : Variable Operation Local Offset - 4 Read
Addr : 4B40:             F6  : Math Op /     
Addr : 4B41:          C9 20  : Memory Op Long VBASE + WRITE Address = 0020
106                        buffer_ptr := @rx_buffer
Addr : 4B43:          8B 28  : Memory Op Byte VBASE + ADDRESS Address = 0028
Addr : 4B45:          C9 24  : Memory Op Long VBASE + WRITE Address = 0024
107                        okay := cog := cognew(@entry, @rx_head) + 1
Addr : 4B47:             34  : Constant 0 $FFFFFFFF
Addr : 4B48:       C7 80 90  : Memory Op Long PBASE + ADDRESS Address = 0090
Addr : 4B4B:             47  : Variable Operation Global Offset - 1 Address
Addr : 4B4C:             28  : CogInit(Id, Addr, Ptr) Push
Addr : 4B4D:             36  : Constant 2 $00000001
Addr : 4B4E:             EC  : Math Op +     
Addr : 4B4F:          42 80  : Variable Operation Global Offset - 0 Assign Write Push
Addr : 4B51:             61  : Variable Operation Local Offset - 0 Write
Addr : 4B52:             32  : Return        
|===========================================================================|
Spin Block Stop with 0 Parameters and 0 Extra Stack Longs. Method 3
PUB Stop

Local Parameter DBASE:0000 - Result
|===========================================================================|
112                        if cog
Addr : 4B53:             40  : Variable Operation Global Offset - 0 Read
Addr : 4B54: JZ Label0002
Addr : 4B54:          0A 05  : jz Address = 4B5B 5
113                          cogstop(cog~ - 1)
Addr : 4B56:          42 98  : Variable Operation Global Offset - 0 Assign VAR~ Post-clear Push
Addr : 4B58:             36  : Constant 2 $00000001
Addr : 4B59:             ED  : Math Op -     
Addr : 4B5A:             21  : CogStop(id)   
Addr : 4B5B: Label0002
Addr : 4B5B: Label0003
114                        longfill(@rx_head, 0, 9)
Addr : 4B5B:             47  : Variable Operation Global Offset - 1 Address
Addr : 4B5C:             35  : Constant 1 $00000000
Addr : 4B5D:          38 09  : Constant 1 Bytes - 09 
Addr : 4B5F:             1A  : LongFill(Start, Value, Count)
Addr : 4B60:             32  : Return        
|===========================================================================|
Spin Block Char with 1 Parameters and 0 Extra Stack Longs. Method 4
PUB Char(bytechr)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - bytechr
|===========================================================================|
121                        repeat until (tx_tail <> ((tx_head + 1) & BUFFER_MASK))
Addr : 4B61: Label0002
Addr : 4B61:             50  : Variable Operation Global Offset - 4 Read
Addr : 4B62:             4C  : Variable Operation Global Offset - 3 Read
Addr : 4B63:             36  : Constant 2 $00000001
Addr : 4B64:             EC  : Math Op +     
Addr : 4B65:          37 25  : Constant Mask Y=37 Decrement 0000003F
Addr : 4B67:             E8  : Math Op &     
Addr : 4B68:             FB  : Math Op <>    
Addr : 4B69: JNZ Label0004
Addr : 4B69:          0B 02  : jnz Address = 4B6D 2
Addr : 4B6B: Label0003
Addr : 4B6B: JMP Label0002
Addr : 4B6B:          04 74  : Jmp 4B61 -12  
Addr : 4B6D: Label0004
122                        tx_buffer[tx_head] := bytechr
Addr : 4B6D:             64  : Variable Operation Local Offset - 1 Read
Addr : 4B6E:             4C  : Variable Operation Global Offset - 3 Read
Addr : 4B6F:          99 68  : Memory Op Byte VBASE + POP Index WRITE Address = 0068
123                        tx_head := (tx_head + 1) & BUFFER_MASK
Addr : 4B71:             4C  : Variable Operation Global Offset - 3 Read
Addr : 4B72:             36  : Constant 2 $00000001
Addr : 4B73:             EC  : Math Op +     
Addr : 4B74:          37 25  : Constant Mask Y=37 Decrement 0000003F
Addr : 4B76:             E8  : Math Op &     
Addr : 4B77:             4D  : Variable Operation Global Offset - 3 Write
125                        if rxtx_mode & %1000
Addr : 4B78:             5C  : Variable Operation Global Offset - 7 Read
Addr : 4B79:          37 02  : Constant Mask Y=2 00000008
Addr : 4B7B:             E8  : Math Op &     
Addr : 4B7C: JZ Label0005
Addr : 4B7C:          0A 03  : jz Address = 4B81 3
126                          CharIn
Addr : 4B7E:             01  : Drop Anchor   
Addr : 4B7F:          05 06  : Call Sub 6    
Addr : 4B81: Label0005
Addr : 4B81: Label0006
Addr : 4B81:             32  : Return        
|===========================================================================|
Spin Block Chars with 2 Parameters and 0 Extra Stack Longs. Method 5
PUB Chars(bytechr, count)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - bytechr
Local Parameter DBASE:0008 - count
|===========================================================================|
134                        repeat count
Addr : 4B82:             68  : Variable Operation Local Offset - 2 Read
Addr : 4B83: TJZ Label0004
Addr : 4B83:          08 06  : tjz Address = 4B8B 6
Addr : 4B85: Label0002
135                          Char(bytechr)
Addr : 4B85:             01  : Drop Anchor   
Addr : 4B86:             64  : Variable Operation Local Offset - 1 Read
Addr : 4B87:          05 04  : Call Sub 4    
Addr : 4B89: Label0003
Addr : 4B89: DJNZ Label0002
Addr : 4B89:          09 7A  : djnz Address = 4B85 -6
Addr : 4B8B: Label0004
Addr : 4B8B:             32  : Return        
|===========================================================================|
Spin Block CharIn with 0 Parameters and 0 Extra Stack Longs. Method 6
PUB CharIn : bytechr

Local Parameter DBASE:0000 - Result
|===========================================================================|
141                        repeat while (bytechr := RxCheck) < 0
Addr : 4B8C: Label0002
Addr : 4B8C:             00  : Drop Anchor Push 
Addr : 4B8D:          05 22  : Call Sub 34   
Addr : 4B8F:          62 80  : Variable Operation Local Offset - 0 Assign Write Push
Addr : 4B91:             35  : Constant 1 $00000000
Addr : 4B92:             F9  : Math Op <     
Addr : 4B93: JZ Label0004
Addr : 4B93:          0A 02  : jz Address = 4B97 2
Addr : 4B95: Label0003
Addr : 4B95: JMP Label0002
Addr : 4B95:          04 75  : Jmp 4B8C -11  
Addr : 4B97: Label0004
Addr : 4B97:             32  : Return        
|===========================================================================|
Spin Block Str with 1 Parameters and 0 Extra Stack Longs. Method 7
PUB Str(stringptr)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - stringptr
|===========================================================================|
148                        repeat strsize(stringptr)
Addr : 4B98:             64  : Variable Operation Local Offset - 1 Read
Addr : 4B99:             16  : StrSize(String)
Addr : 4B9A: TJZ Label0004
Addr : 4B9A:          08 08  : tjz Address = 4BA4 8
Addr : 4B9C: Label0002
149                          Char(byte[stringptr++])
Addr : 4B9C:             01  : Drop Anchor   
Addr : 4B9D:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 4B9F:             80  : Memory Op Byte POP Address READ 
Addr : 4BA0:          05 04  : Call Sub 4    
Addr : 4BA2: Label0003
Addr : 4BA2: DJNZ Label0002
Addr : 4BA2:          09 78  : djnz Address = 4B9C -8
Addr : 4BA4: Label0004
Addr : 4BA4:             32  : Return        
|===========================================================================|
Spin Block StrIn with 1 Parameters and 0 Extra Stack Longs. Method 8
PUB StrIn(stringptr)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - stringptr
|===========================================================================|
158                        StrInMax(stringptr, -1)
Addr : 4BA5:             01  : Drop Anchor   
Addr : 4BA6:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BA7:             34  : Constant 0 $FFFFFFFF
Addr : 4BA8:          05 09  : Call Sub 9    
Addr : 4BAA:             32  : Return        
|===========================================================================|
Spin Block StrInMax with 2 Parameters and 0 Extra Stack Longs. Method 9
PUB StrInMax(stringptr, maxcount)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - stringptr
Local Parameter DBASE:0008 - maxcount
|===========================================================================|
168                        repeat while (maxcount--)                                                     'While maxcount not reached
Addr : 4BAB: Label0002
Addr : 4BAB:          6A BE  : Variable Operation Local Offset - 2 Assign VAR-- post-dec Long Push
Addr : 4BAD: JZ Label0004
Addr : 4BAD:          0A 10  : jz Address = 4BBF 16
169                          if (byte[stringptr++] := CharIn) == NL                                      'Get chars until NL
Addr : 4BAF:             00  : Drop Anchor Push 
Addr : 4BB0:          05 06  : Call Sub 6    
Addr : 4BB2:          66 AE  : Variable Operation Local Offset - 1 Assign VAR++ post inc Long Push
Addr : 4BB4:          82 80  : Memory Op Byte POP Address ASSIGN Write Push
Addr : 4BB6:          38 0D  : Constant 1 Bytes - 0D 
Addr : 4BB8:             FC  : Math Op ==    
Addr : 4BB9: JZ Label0005
Addr : 4BB9:          0A 02  : jz Address = 4BBD 2
170                            quit
Addr : 4BBB: JMP Label0004
Addr : 4BBB:          04 02  : Jmp 4BBF 2    
Addr : 4BBD: Label0005
Addr : 4BBD: Label0006
Addr : 4BBD: Label0003
Addr : 4BBD: JMP Label0002
Addr : 4BBD:          04 6C  : Jmp 4BAB -20  
Addr : 4BBF: Label0004
171                        byte[stringptr+(byte[stringptr-1] == NL)]~                                    'Zero terminate string; overwrite NL or append 0 char
Addr : 4BBF:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BC0:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BC1:             36  : Constant 2 $00000001
Addr : 4BC2:             ED  : Math Op -     
Addr : 4BC3:             80  : Memory Op Byte POP Address READ 
Addr : 4BC4:          38 0D  : Constant 1 Bytes - 0D 
Addr : 4BC6:             FC  : Math Op ==    
Addr : 4BC7:             EC  : Math Op +     
Addr : 4BC8:          82 18  : Memory Op Byte POP Address ASSIGN VAR~ Post-clear
Addr : 4BCA:             32  : Return        
|===========================================================================|
Spin Block Dec with 1 Parameters and 2 Extra Stack Longs. Method 10
PUB Dec(value) | i, x

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Variable  DBASE:0008 - i
Local Variable  DBASE:000C - x
|===========================================================================|
178                        x := value == NEGX                                                            'Check for max negative
Addr : 4BCB:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BCC:          37 1E  : Constant Mask Y=30 80000000
Addr : 4BCE:             FC  : Math Op ==    
Addr : 4BCF:             6D  : Variable Operation Local Offset - 3 Write
179                        if value < 0
Addr : 4BD0:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BD1:             35  : Constant 1 $00000000
Addr : 4BD2:             F9  : Math Op <     
Addr : 4BD3: JZ Label0002
Addr : 4BD3:          0A 0A  : jz Address = 4BDF 10
180                          value := ||(value+x)                                                        'If negative, make positive; adjust for max negative
Addr : 4BD5:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BD6:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4BD7:             EC  : Math Op +     
Addr : 4BD8:             E9  : Math Op ||    
Addr : 4BD9:             65  : Variable Operation Local Offset - 1 Write
181                          Char("-")                                                                   'and output sign
Addr : 4BDA:             01  : Drop Anchor   
Addr : 4BDB:          38 2D  : Constant 1 Bytes - 2D 
Addr : 4BDD:          05 04  : Call Sub 4    
Addr : 4BDF: Label0002
Addr : 4BDF: Label0003
183                        i := 1_000_000_000                                                            'Initialize divisor
Addr : 4BDF: 3B 3B 9A CA 00  : Constant 4 Bytes - 3B 9A CA 00 
Addr : 4BE4:             69  : Variable Operation Local Offset - 2 Write
185                        repeat 10                                                                     'Loop for 10 digits
Addr : 4BE5:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4BE7: TJZ Label0006
Addr : 4BE7:          08 2D  : tjz Address = 4C16 45
Addr : 4BE9: Label0004
186                          if value => i                                                               
Addr : 4BE9:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BEA:             68  : Variable Operation Local Offset - 2 Read
Addr : 4BEB:             FE  : Math Op =>    
Addr : 4BEC: JZ Label0007
Addr : 4BEC:          0A 16  : jz Address = 4C04 22
187                            Char(value / i + "0" + x*(i == 1))                                        'If non-zero digit, output digit; adjust for max negative
Addr : 4BEE:             01  : Drop Anchor   
Addr : 4BEF:             64  : Variable Operation Local Offset - 1 Read
Addr : 4BF0:             68  : Variable Operation Local Offset - 2 Read
Addr : 4BF1:             F6  : Math Op /     
Addr : 4BF2:          38 30  : Constant 1 Bytes - 30 
Addr : 4BF4:             EC  : Math Op +     
Addr : 4BF5:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4BF6:             68  : Variable Operation Local Offset - 2 Read
Addr : 4BF7:             36  : Constant 2 $00000001
Addr : 4BF8:             FC  : Math Op ==    
Addr : 4BF9:             F4  : Math Op *     
Addr : 4BFA:             EC  : Math Op +     
Addr : 4BFB:          05 04  : Call Sub 4    
188                            value //= i                                                               'and digit from value
Addr : 4BFD:             68  : Variable Operation Local Offset - 2 Read
Addr : 4BFE:          66 57  : Variable Operation Local Offset - 1 Assign LongMathop //
189                            result~~                                                                  'flag non-zero found
Addr : 4C00:          62 1C  : Variable Operation Local Offset - 0 Assign VAR~~ Post-set
Addr : 4C02: JMP Label0008
Addr : 4C02:          04 0C  : Jmp 4C10 12   
Addr : 4C04: Label0007
190                          elseif result or i == 1
Addr : 4C04:             60  : Variable Operation Local Offset - 0 Read
Addr : 4C05:             68  : Variable Operation Local Offset - 2 Read
Addr : 4C06:             36  : Constant 2 $00000001
Addr : 4C07:             FC  : Math Op ==    
Addr : 4C08:             F2  : Math Op OR    
Addr : 4C09: JZ Label0009
Addr : 4C09:          0A 05  : jz Address = 4C10 5
191                            Char("0")                                                                 'If zero digit (or only digit) output it
Addr : 4C0B:             01  : Drop Anchor   
Addr : 4C0C:          38 30  : Constant 1 Bytes - 30 
Addr : 4C0E:          05 04  : Call Sub 4    
Addr : 4C10: Label0009
Addr : 4C10: Label0008
192                          i /= 10                                                                     'Update divisor
Addr : 4C10:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4C12:          6A 56  : Variable Operation Local Offset - 2 Assign LongMathop /
Addr : 4C14: Label0005
Addr : 4C14: DJNZ Label0004
Addr : 4C14:          09 53  : djnz Address = 4BE9 -45
Addr : 4C16: Label0006
Addr : 4C16:             32  : Return        
|===========================================================================|
Spin Block DecIn with 0 Parameters and 0 Extra Stack Longs. Method 11
PUB DecIn : value

Local Parameter DBASE:0000 - Result
|===========================================================================|
198                        StrInMax(@str_buffer, MAXSTR_LENGTH)
Addr : 4C17:             01  : Drop Anchor   
Addr : 4C18:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C1B:          38 31  : Constant 1 Bytes - 31 
Addr : 4C1D:          05 09  : Call Sub 9    
199                        value := StrToBase(@str_buffer, 10)
Addr : 4C1F:             00  : Drop Anchor Push 
Addr : 4C20:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C23:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4C25:          05 23  : Call Sub 35   
Addr : 4C27:             61  : Variable Operation Local Offset - 0 Write
Addr : 4C28:             32  : Return        
|===========================================================================|
Spin Block Bin with 2 Parameters and 0 Extra Stack Longs. Method 12
PUB Bin(value, digits)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - digits
|===========================================================================|
207                        value <<= 32 - digits
Addr : 4C29:          37 04  : Constant Mask Y=4 00000020
Addr : 4C2B:             68  : Variable Operation Local Offset - 2 Read
Addr : 4C2C:             ED  : Math Op -     
Addr : 4C2D:          66 43  : Variable Operation Local Offset - 1 Assign ByteMathop <<
208                        repeat digits
Addr : 4C2F:             68  : Variable Operation Local Offset - 2 Read
Addr : 4C30: TJZ Label0004
Addr : 4C30:          08 0D  : tjz Address = 4C3F 13
Addr : 4C32: Label0002
209                          Char((value <-= 1) & 1 + "0")
Addr : 4C32:             01  : Drop Anchor   
Addr : 4C33:             36  : Constant 2 $00000001
Addr : 4C34:          66 C1  : Variable Operation Local Offset - 1 Assign BitMathop -< Push
Addr : 4C36:             36  : Constant 2 $00000001
Addr : 4C37:             E8  : Math Op &     
Addr : 4C38:          38 30  : Constant 1 Bytes - 30 
Addr : 4C3A:             EC  : Math Op +     
Addr : 4C3B:          05 04  : Call Sub 4    
Addr : 4C3D: Label0003
Addr : 4C3D: DJNZ Label0002
Addr : 4C3D:          09 73  : djnz Address = 4C32 -13
Addr : 4C3F: Label0004
Addr : 4C3F:             32  : Return        
|===========================================================================|
Spin Block BinIn with 0 Parameters and 0 Extra Stack Longs. Method 13
PUB BinIn : value

Local Parameter DBASE:0000 - Result
|===========================================================================|
215                        StrInMax(@str_buffer, MAXSTR_LENGTH)
Addr : 4C40:             01  : Drop Anchor   
Addr : 4C41:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C44:          38 31  : Constant 1 Bytes - 31 
Addr : 4C46:          05 09  : Call Sub 9    
216                        value := StrToBase(@str_buffer, 2)
Addr : 4C48:             00  : Drop Anchor Push 
Addr : 4C49:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C4C:          37 00  : Constant Mask Y=0 00000002
Addr : 4C4E:          05 23  : Call Sub 35   
Addr : 4C50:             61  : Variable Operation Local Offset - 0 Write
Addr : 4C51:             32  : Return        
|===========================================================================|
Spin Block Hex with 2 Parameters and 0 Extra Stack Longs. Method 14
PUB Hex(value, digits)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - value
Local Parameter DBASE:0008 - digits
|===========================================================================|
224                        value <<= (8 - digits) << 2
Addr : 4C52:          37 02  : Constant Mask Y=2 00000008
Addr : 4C54:             68  : Variable Operation Local Offset - 2 Read
Addr : 4C55:             ED  : Math Op -     
Addr : 4C56:          37 00  : Constant Mask Y=0 00000002
Addr : 4C58:             E3  : Math Op <<    
Addr : 4C59:          66 43  : Variable Operation Local Offset - 1 Assign ByteMathop <<
225                        repeat digits
Addr : 4C5B:             68  : Variable Operation Local Offset - 2 Read
Addr : 4C5C: TJZ Label0004
Addr : 4C5C:          08 1B  : tjz Address = 4C79 27
Addr : 4C5E: Label0002
226                          Char(lookupz((value <-= 4) & $F : "0".."9", "A".."F"))
Addr : 4C5E:             01  : Drop Anchor   
Addr : 4C5F:             35  : Constant 1 $00000000
Addr : 4C60: Constant Address of Label0005
Addr : 4C60:       39 03 39  : Constant 2 Bytes - 03 39 
Addr : 4C63:          37 01  : Constant Mask Y=1 00000004
Addr : 4C65:          66 C1  : Variable Operation Local Offset - 1 Assign BitMathop -< Push
Addr : 4C67:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 4C69:             E8  : Math Op &     
Addr : 4C6A:          38 30  : Constant 1 Bytes - 30 
Addr : 4C6C:          38 39  : Constant 1 Bytes - 39 
Addr : 4C6E:             12  : Range LookUp  
Addr : 4C6F:          38 41  : Constant 1 Bytes - 41 
Addr : 4C71:          38 46  : Constant 1 Bytes - 46 
Addr : 4C73:             12  : Range LookUp  
Addr : 4C74:             0F  : Lookdone      
Addr : 4C75: Label0005
Addr : 4C75:          05 04  : Call Sub 4    
Addr : 4C77: Label0003
Addr : 4C77: DJNZ Label0002
Addr : 4C77:          09 65  : djnz Address = 4C5E -27
Addr : 4C79: Label0004
Addr : 4C79:             32  : Return        
|===========================================================================|
Spin Block HexIn with 0 Parameters and 0 Extra Stack Longs. Method 15
PUB HexIn : value

Local Parameter DBASE:0000 - Result
|===========================================================================|
232                        StrInMax(@str_buffer, MAXSTR_LENGTH)
Addr : 4C7A:             01  : Drop Anchor   
Addr : 4C7B:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C7E:          38 31  : Constant 1 Bytes - 31 
Addr : 4C80:          05 09  : Call Sub 9    
233                        value := StrToBase(@str_buffer, 16)
Addr : 4C82:             00  : Drop Anchor Push 
Addr : 4C83:       8B 80 A8  : Memory Op Byte VBASE + ADDRESS Address = 00A8
Addr : 4C86:          37 03  : Constant Mask Y=3 00000010
Addr : 4C88:          05 23  : Call Sub 35   
Addr : 4C8A:             61  : Variable Operation Local Offset - 0 Write
Addr : 4C8B:             32  : Return        
|===========================================================================|
Spin Block Clear with 0 Parameters and 0 Extra Stack Longs. Method 16
PUB Clear

Local Parameter DBASE:0000 - Result
|===========================================================================|
238                        Char(CS)
Addr : 4C8C:             01  : Drop Anchor   
Addr : 4C8D:          37 03  : Constant Mask Y=3 00000010
Addr : 4C8F:          05 04  : Call Sub 4    
Addr : 4C91:             32  : Return        
|===========================================================================|
Spin Block ClearEnd with 0 Parameters and 0 Extra Stack Longs. Method 17
PUB ClearEnd

Local Parameter DBASE:0000 - Result
|===========================================================================|
243                        Char(CE)
Addr : 4C92:             01  : Drop Anchor   
Addr : 4C93:          38 0B  : Constant 1 Bytes - 0B 
Addr : 4C95:          05 04  : Call Sub 4    
Addr : 4C97:             32  : Return        
|===========================================================================|
Spin Block ClearBelow with 0 Parameters and 0 Extra Stack Longs. Method 18
PUB ClearBelow

Local Parameter DBASE:0000 - Result
|===========================================================================|
248                        Char(CB)
Addr : 4C98:             01  : Drop Anchor   
Addr : 4C99:          38 0C  : Constant 1 Bytes - 0C 
Addr : 4C9B:          05 04  : Call Sub 4    
Addr : 4C9D:             32  : Return        
|===========================================================================|
Spin Block Home with 0 Parameters and 0 Extra Stack Longs. Method 19
PUB Home

Local Parameter DBASE:0000 - Result
|===========================================================================|
253                        Char(HM)
Addr : 4C9E:             01  : Drop Anchor   
Addr : 4C9F:             36  : Constant 2 $00000001
Addr : 4CA0:          05 04  : Call Sub 4    
Addr : 4CA2:             32  : Return        
|===========================================================================|
Spin Block Position with 2 Parameters and 0 Extra Stack Longs. Method 20
PUB Position(x, y)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - x
Local Parameter DBASE:0008 - y
|===========================================================================|
258                        Char(PC)
Addr : 4CA3:             01  : Drop Anchor   
Addr : 4CA4:          37 00  : Constant Mask Y=0 00000002
Addr : 4CA6:          05 04  : Call Sub 4    
259                        Char(x)
Addr : 4CA8:             01  : Drop Anchor   
Addr : 4CA9:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CAA:          05 04  : Call Sub 4    
260                        Char(y)
Addr : 4CAC:             01  : Drop Anchor   
Addr : 4CAD:             68  : Variable Operation Local Offset - 2 Read
Addr : 4CAE:          05 04  : Call Sub 4    
Addr : 4CB0:             32  : Return        
|===========================================================================|
Spin Block PositionX with 1 Parameters and 0 Extra Stack Longs. Method 21
PUB PositionX(x)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - x
|===========================================================================|
264                        Char(PX)
Addr : 4CB1:             01  : Drop Anchor   
Addr : 4CB2:          38 0E  : Constant 1 Bytes - 0E 
Addr : 4CB4:          05 04  : Call Sub 4    
265                        Char(x)
Addr : 4CB6:             01  : Drop Anchor   
Addr : 4CB7:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CB8:          05 04  : Call Sub 4    
Addr : 4CBA:             32  : Return        
|===========================================================================|
Spin Block PositionY with 1 Parameters and 0 Extra Stack Longs. Method 22
PUB PositionY(y)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - y
|===========================================================================|
269                        Char(PY)
Addr : 4CBB:             01  : Drop Anchor   
Addr : 4CBC:          37 23  : Constant Mask Y=35 Decrement 0000000F
Addr : 4CBE:          05 04  : Call Sub 4    
270                        Char(y)
Addr : 4CC0:             01  : Drop Anchor   
Addr : 4CC1:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CC2:          05 04  : Call Sub 4    
Addr : 4CC4:             32  : Return        
|===========================================================================|
Spin Block NewLine with 0 Parameters and 0 Extra Stack Longs. Method 23
PUB NewLine

Local Parameter DBASE:0000 - Result
|===========================================================================|
274                        Char(NL)
Addr : 4CC5:             01  : Drop Anchor   
Addr : 4CC6:          38 0D  : Constant 1 Bytes - 0D 
Addr : 4CC8:          05 04  : Call Sub 4    
275                        Char(LF)
Addr : 4CCA:             01  : Drop Anchor   
Addr : 4CCB:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4CCD:          05 04  : Call Sub 4    
Addr : 4CCF:             32  : Return        
|===========================================================================|
Spin Block LineFeed with 0 Parameters and 0 Extra Stack Longs. Method 24
PUB LineFeed

Local Parameter DBASE:0000 - Result
|===========================================================================|
280                        Char(LF)
Addr : 4CD0:             01  : Drop Anchor   
Addr : 4CD1:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4CD3:          05 04  : Call Sub 4    
Addr : 4CD5:             32  : Return        
|===========================================================================|
Spin Block MoveLeft with 1 Parameters and 0 Extra Stack Longs. Method 25
PUB MoveLeft(x)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - x
|===========================================================================|
285                        repeat x
Addr : 4CD6:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CD7: TJZ Label0004
Addr : 4CD7:          08 07  : tjz Address = 4CE0 7
Addr : 4CD9: Label0002
286                          Char(ML)
Addr : 4CD9:             01  : Drop Anchor   
Addr : 4CDA:          37 21  : Constant Mask Y=33 Decrement 00000003
Addr : 4CDC:          05 04  : Call Sub 4    
Addr : 4CDE: Label0003
Addr : 4CDE: DJNZ Label0002
Addr : 4CDE:          09 79  : djnz Address = 4CD9 -7
Addr : 4CE0: Label0004
Addr : 4CE0:             32  : Return        
|===========================================================================|
Spin Block MoveRight with 1 Parameters and 0 Extra Stack Longs. Method 26
PUB MoveRight(x)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - x
|===========================================================================|
291                        repeat x
Addr : 4CE1:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CE2: TJZ Label0004
Addr : 4CE2:          08 07  : tjz Address = 4CEB 7
Addr : 4CE4: Label0002
292                          Char(MR)
Addr : 4CE4:             01  : Drop Anchor   
Addr : 4CE5:          37 01  : Constant Mask Y=1 00000004
Addr : 4CE7:          05 04  : Call Sub 4    
Addr : 4CE9: Label0003
Addr : 4CE9: DJNZ Label0002
Addr : 4CE9:          09 79  : djnz Address = 4CE4 -7
Addr : 4CEB: Label0004
Addr : 4CEB:             32  : Return        
|===========================================================================|
Spin Block MoveUp with 1 Parameters and 0 Extra Stack Longs. Method 27
PUB MoveUp(y)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - y
|===========================================================================|
297                        repeat y
Addr : 4CEC:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CED: TJZ Label0004
Addr : 4CED:          08 07  : tjz Address = 4CF6 7
Addr : 4CEF: Label0002
298                          Char(MU)
Addr : 4CEF:             01  : Drop Anchor   
Addr : 4CF0:          38 05  : Constant 1 Bytes - 05 
Addr : 4CF2:          05 04  : Call Sub 4    
Addr : 4CF4: Label0003
Addr : 4CF4: DJNZ Label0002
Addr : 4CF4:          09 79  : djnz Address = 4CEF -7
Addr : 4CF6: Label0004
Addr : 4CF6:             32  : Return        
|===========================================================================|
Spin Block MoveDown with 1 Parameters and 0 Extra Stack Longs. Method 28
PUB MoveDown(y)

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - y
|===========================================================================|
303                        repeat y
Addr : 4CF7:             64  : Variable Operation Local Offset - 1 Read
Addr : 4CF8: TJZ Label0004
Addr : 4CF8:          08 07  : tjz Address = 4D01 7
Addr : 4CFA: Label0002
304                          Char(MD)
Addr : 4CFA:             01  : Drop Anchor   
Addr : 4CFB:          38 06  : Constant 1 Bytes - 06 
Addr : 4CFD:          05 04  : Call Sub 4    
Addr : 4CFF: Label0003
Addr : 4CFF: DJNZ Label0002
Addr : 4CFF:          09 79  : djnz Address = 4CFA -7
Addr : 4D01: Label0004
Addr : 4D01:             32  : Return        
|===========================================================================|
Spin Block Tab with 0 Parameters and 0 Extra Stack Longs. Method 29
PUB Tab

Local Parameter DBASE:0000 - Result
|===========================================================================|
309                        Char(TB)
Addr : 4D02:             01  : Drop Anchor   
Addr : 4D03:          38 09  : Constant 1 Bytes - 09 
Addr : 4D05:          05 04  : Call Sub 4    
Addr : 4D07:             32  : Return        
|===========================================================================|
Spin Block Backspace with 0 Parameters and 0 Extra Stack Longs. Method 30
PUB Backspace

Local Parameter DBASE:0000 - Result
|===========================================================================|
314                        Char(BS)
Addr : 4D08:             01  : Drop Anchor   
Addr : 4D09:          37 02  : Constant Mask Y=2 00000008
Addr : 4D0B:          05 04  : Call Sub 4    
Addr : 4D0D:             32  : Return        
|===========================================================================|
Spin Block Beep with 0 Parameters and 0 Extra Stack Longs. Method 31
PUB Beep

Local Parameter DBASE:0000 - Result
|===========================================================================|
319                        Char(BP)
Addr : 4D0E:             01  : Drop Anchor   
Addr : 4D0F:          37 22  : Constant Mask Y=34 Decrement 00000007
Addr : 4D11:          05 04  : Call Sub 4    
Addr : 4D13:             32  : Return        
|===========================================================================|
Spin Block RxCount with 0 Parameters and 0 Extra Stack Longs. Method 32
PUB RxCount : count

Local Parameter DBASE:0000 - Result
|===========================================================================|
325                        count := rx_head - rx_tail
Addr : 4D14:             44  : Variable Operation Global Offset - 1 Read
Addr : 4D15:             48  : Variable Operation Global Offset - 2 Read
Addr : 4D16:             ED  : Math Op -     
Addr : 4D17:             61  : Variable Operation Local Offset - 0 Write
326                        count -= BUFFER_LENGTH*(count < 0)
Addr : 4D18:          37 05  : Constant Mask Y=5 00000040
Addr : 4D1A:             60  : Variable Operation Local Offset - 0 Read
Addr : 4D1B:             35  : Constant 1 $00000000
Addr : 4D1C:             F9  : Math Op <     
Addr : 4D1D:             F4  : Math Op *     
Addr : 4D1E:          62 4D  : Variable Operation Local Offset - 0 Assign WordMathop -
Addr : 4D20:             32  : Return        
|===========================================================================|
Spin Block RxFlush with 0 Parameters and 0 Extra Stack Longs. Method 33
PUB RxFlush

Local Parameter DBASE:0000 - Result
|===========================================================================|
331                        repeat while rxcheck => 0
Addr : 4D21: Label0002
Addr : 4D21:             00  : Drop Anchor Push 
Addr : 4D22:          05 22  : Call Sub 34   
Addr : 4D24:             35  : Constant 1 $00000000
Addr : 4D25:             FE  : Math Op =>    
Addr : 4D26: JZ Label0004
Addr : 4D26:          0A 02  : jz Address = 4D2A 2
Addr : 4D28: Label0003
Addr : 4D28: JMP Label0002
Addr : 4D28:          04 77  : Jmp 4D21 -9   
Addr : 4D2A: Label0004
Addr : 4D2A:             32  : Return        
|===========================================================================|
Spin Block RxCheck with 0 Parameters and 0 Extra Stack Longs. Method 34
PRI RxCheck : bytechr

Local Parameter DBASE:0000 - Result
|===========================================================================|
337                        bytechr~~
Addr : 4D2B:          62 1C  : Variable Operation Local Offset - 0 Assign VAR~~ Post-set
338                        if rx_tail <> rx_head
Addr : 4D2D:             48  : Variable Operation Global Offset - 2 Read
Addr : 4D2E:             44  : Variable Operation Global Offset - 1 Read
Addr : 4D2F:             FB  : Math Op <>    
Addr : 4D30: JZ Label0002
Addr : 4D30:          0A 0B  : jz Address = 4D3D 11
339                          bytechr := rx_buffer[rx_tail]
Addr : 4D32:             48  : Variable Operation Global Offset - 2 Read
Addr : 4D33:          98 28  : Memory Op Byte VBASE + POP Index READ Address = 0028
Addr : 4D35:             61  : Variable Operation Local Offset - 0 Write
340                          rx_tail := (rx_tail + 1) & BUFFER_MASK
Addr : 4D36:             48  : Variable Operation Global Offset - 2 Read
Addr : 4D37:             36  : Constant 2 $00000001
Addr : 4D38:             EC  : Math Op +     
Addr : 4D39:          37 25  : Constant Mask Y=37 Decrement 0000003F
Addr : 4D3B:             E8  : Math Op &     
Addr : 4D3C:             49  : Variable Operation Global Offset - 2 Write
Addr : 4D3D: Label0002
Addr : 4D3D: Label0003
Addr : 4D3D:             32  : Return        
|===========================================================================|
Spin Block StrToBase with 2 Parameters and 2 Extra Stack Longs. Method 35
PRI StrToBase(stringptr, base) : value | chr, index

Local Parameter DBASE:0000 - Result
Local Parameter DBASE:0004 - stringptr
Local Parameter DBASE:0008 - base
Local Variable  DBASE:000C - chr
Local Variable  DBASE:0010 - index
|===========================================================================|
346                        value := index := 0
Addr : 4D3E:             35  : Constant 1 $00000000
Addr : 4D3F:          72 80  : Variable Operation Local Offset - 4 Assign Write Push
Addr : 4D41:             61  : Variable Operation Local Offset - 0 Write
Addr : 4D42: Label0002
347                        repeat until ((chr := byte[stringptr][index++]) == 0)
Addr : 4D42:             64  : Variable Operation Local Offset - 1 Read
Addr : 4D43:          72 AE  : Variable Operation Local Offset - 4 Assign VAR++ post inc Long Push
Addr : 4D45:             90  : Memory Op Byte POP Address POP Index READ 
Addr : 4D46:          6E 80  : Variable Operation Local Offset - 3 Assign Write Push
Addr : 4D48:             35  : Constant 1 $00000000
Addr : 4D49:             FC  : Math Op ==    
Addr : 4D4A: JNZ Label0004
Addr : 4D4A:          0B 23  : jnz Address = 4D6F 35
348                          chr := -15 + --chr & %11011111 + 39*(chr > 56)                              'Make "0"-"9","A"-"F","a"-"f" be 0 - 15, others out of range     
Addr : 4D4C:          38 0E  : Constant 1 Bytes - 0E 
Addr : 4D4E:             E7  : Math Op !     
Addr : 4D4F:          6E B6  : Variable Operation Local Offset - 3 Assign --VAR pre-dec Long Push
Addr : 4D51:          38 DF  : Constant 1 Bytes - DF 
Addr : 4D53:             E8  : Math Op &     
Addr : 4D54:             EC  : Math Op +     
Addr : 4D55:          38 27  : Constant 1 Bytes - 27 
Addr : 4D57:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4D58:          38 38  : Constant 1 Bytes - 38 
Addr : 4D5A:             FA  : Math Op >     
Addr : 4D5B:             F4  : Math Op *     
Addr : 4D5C:             EC  : Math Op +     
Addr : 4D5D:             6D  : Variable Operation Local Offset - 3 Write
349                          if (chr > -1) and (chr < base)                                              'Accumulate valid values into result; ignore others
Addr : 4D5E:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4D5F:             34  : Constant 0 $FFFFFFFF
Addr : 4D60:             FA  : Math Op >     
Addr : 4D61:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4D62:             68  : Variable Operation Local Offset - 2 Read
Addr : 4D63:             F9  : Math Op <     
Addr : 4D64:             F0  : Math Op AND   
Addr : 4D65: JZ Label0005
Addr : 4D65:          0A 06  : jz Address = 4D6D 6
350                            value := value * base + chr                                                  
Addr : 4D67:             60  : Variable Operation Local Offset - 0 Read
Addr : 4D68:             68  : Variable Operation Local Offset - 2 Read
Addr : 4D69:             F4  : Math Op *     
Addr : 4D6A:             6C  : Variable Operation Local Offset - 3 Read
Addr : 4D6B:             EC  : Math Op +     
Addr : 4D6C:             61  : Variable Operation Local Offset - 0 Write
Addr : 4D6D: Label0005
Addr : 4D6D: Label0006
Addr : 4D6D: Label0003
Addr : 4D6D: JMP Label0002
Addr : 4D6D:          04 53  : Jmp 4D42 -45  
Addr : 4D6F: Label0004
351                        if (base == 10) and (byte[stringptr] == "-")                                  'If decimal, address negative sign; ignore otherwise
Addr : 4D6F:             68  : Variable Operation Local Offset - 2 Read
Addr : 4D70:          38 0A  : Constant 1 Bytes - 0A 
Addr : 4D72:             FC  : Math Op ==    
Addr : 4D73:             64  : Variable Operation Local Offset - 1 Read
Addr : 4D74:             80  : Memory Op Byte POP Address READ 
Addr : 4D75:          38 2D  : Constant 1 Bytes - 2D 
Addr : 4D77:             FC  : Math Op ==    
Addr : 4D78:             F0  : Math Op AND   
Addr : 4D79: JZ Label0007
Addr : 4D79:          0A 03  : jz Address = 4D7E 3
352                          value := - value
Addr : 4D7B:             60  : Variable Operation Local Offset - 0 Read
Addr : 4D7C:             E6  : Math Op -     
Addr : 4D7D:             61  : Variable Operation Local Offset - 0 Write
Addr : 4D7E: Label0007
Addr : 4D7E: Label0008
Addr : 4D7E:             32  : Return        
