
	.Z80
	ASEG

	SUBTT	L	COMMON FILE FOR BASIC INTERPRETER
	.SALL	

CONTO	DEFL	15		;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O)
DBLTRN	DEFL	0		;FOR DOUBLE PRECISION TRANSCENDENTALS
	IF2	

	.PRIN	TX	/EXTENDED/


	.PRIN	TX	/LPT/

	.PRIN	TX	/CPM DISK/


	.PRIN	TX	/Z80/

	.PRIN	TX	/FAST/

	.PRIN	TX	/5.0 FEATURES/

	.PRIN	TX	/ANSI COMPATIBLE/
	ENDIF	

CLMWID	DEFL	14	;MAKE COMMA COLUMNS FOURTEEN CHARACTERS
DATPSC	DEFL	128		;NUMBER OF DATA BYTES IN DISK SECTOR
LINLN	DEFL	80		;TERMINAL LINE LENGTH 
LPTLEN	DEFL	132
BUFLEN	DEFL	255		;LONG LINES
NAMLEN	DEFL	40		;MAXIMUM LENGTH NAME -- 3 TO 127

NUMLEV	DEFL	0*20+19+2*5;NUMBER OF STACK LEVELS RESERVED
	;BY AN EXPLICIT CALL TO GETSTK

STRSIZ	DEFL	4

STRSIZ	DEFL	3
NUMTMP	DEFL	3		;NUMBER OF STRING TEMPORARIES

NUMTMP	DEFL	10

MD.RND	DEFL	3	;THE MODE NUMBER FOR RANDOM FILES
MD.SQI	DEFL	1		;THE MODE NUMBER FOR SEQUENTIAL INPUT FILES
	;NEVER WRITTEN INTO A FILE
MD.SQO	DEFL	2		;THE MODE FOR SEQUENTIAL OUTPUT FILES
	;AND PROGRAM FILES
CPMWRM	DEFL	0		;CP/M WARM BOOT ADDR
CPMENT	DEFL	CPMWRM+5	;CP/M BDOS CALL ADDR
	CSEG	
TRUROM	DEFL	0
	PAGE	
	TITLE	DSKCOM - - COMMON ROUTINES FOR DISK BASICS

	EXTRN	CLSFIL,CONINT,DATOFS,DERBFN,DERRPE,ERROR,FILOU3,CHRGTR,CURLIN
	EXTRN	INDSKB,INDSKC,NMLOFS,PRGFIL,SCRTCH,SNERR
	EXTRN	FRMEQL,BUF
	EXTRN	STRLT3,DERFOV
	EXTRN	DATOFC,DERBFM,DIRTMP,DOASIG,DOCNVF,DSCTMP,ERRFDR,FCERR
	EXTRN	FILPT1,FILPTR,FIN,FINBCK,FINPRT,FRCSTR,FRESTR,FRETOP
	EXTRN	FRMEVL,GETBYT,GETSPA,GONE,GTBYTC,GTMPRT,INCHRI,LETCON
	EXTRN	LINKER,LIST,LSTFRE,MAIN,MAXFIL,NEWSTT,NMLOFC,OMERR
	EXTRN	PTRFIL,PTRGET,PUTNEW,READY,RUNC
	EXTRN	SCCPTR

	EXTRN	SAVSTK,STRINI,TXTTAB,VALTYP,VARTAB,VMOVFM,VMOVMF,ENDCON
	EXTRN	GETYPR,SYNCHR,DCOMPR
	PUBLI	C	CLSALL,FILFRM,FILIDX,FILSCN,FIELD,PRGFLI,FILIND
	PUBLI	C	FILINP,FILGET,MKI$,MKS$,MKD$,CVI,CVS,CVD
	PUBLI	C	DLINE,PRGFL2,LRUN,LOAD,PRGFIN,MERGE,DIRDO,SAVE,CLOSE
	PUBLI	C	OKGETM
	PUBLI	C	RSET,LSET
	PUBLI	C	BINPSV
	EXTRN	PROSAV,PROLOD
	EXTRN	PROFLG
; REVISION HISTORY
;4/23/78	PGA	ALLOW # ON CLOSE
;
;8/6/79  PGA	IF ^C ON MBASIC FOO, DONT RETURN TO SYSTEM. SEE 'NOTINI'
;6/27/80	PGA	FIX INPUT#1,D# SO IT USES FINDBL INSTEAD OF FIN
;		AND THUS AVOIDS LOSING SIGNIFICANCE.
;
;%
	SUBTT	L	FILINP AND FILGET -- SCAN A FILE NUMBER AND SETUP PTRFIL

FILINP:	LD	C,MD.SQI;MUST BE SEQUENTIAL INPUT
FILGET:	CP	'#'		;NUMBER SIGN THERE?
	RET	NZ		;NO, NOT DISK READER
	PUSH	BC		;SAVE EXPECTED MODE
	CALL	FILSCN		;READ AND GET POINTER
	POP	DE		;[E]=FILE MODE
	CP	E		;IS IT RIGHT?
	JP	Z,GDFILM	;GOOD FILE MODE
	CP	MD.RND		;ALLOW STUFF WITH RANDOM FILES
	JP	NZ,DERBFM	;IF NOT, "BAD FILE MODE"
GDFILM:
	CALL	SYNCHR
	DEFB	44		;GO PAST THE COMMA
FILSET:	EX	DE,HL		;[D,E]=TEXT POINTER
	LD	H,B		;SETUP PTRFIL
	LD	L,C
	LD	(PTRFIL),HL
	EX	DE,HL		;TEXT POINTER BACK INTO [H,L]
	RET	

	PAGE	
	SUBTT	L	FILSCN, FILFRM, AND FILIDX
;
; AT THIS ENTRY POINT [H,L] IS ASSUMED TO BE THE TEXT POINTER AND
; A FILE NUMBER IS SCANNED
;
FILSCN:	DEC	HL
	CALL	CHRGTR
	CP	'#'		;MAKE NUMBER SIGN OPTIONAL
	CALL	Z,CHRGTR	;BY SKIPPING IT IF THERE
	CALL	FRMEVL		;READ THE FILE NUMBER INTO THE FAC
;
; AT THIS ENTRY POINT THE FAC HAS THE FILE NUMBER IN IT ALREADY
;
FILFRM:	CALL	CONINT		;GET THE FILE NUMBER INTO [A]
;
; AT THIS POINT IT IS ASSUMED THE FILE NUMBER IS IN [A]
; THE FILE NUMBER IS RETURNED IN [E]
; [D] IS SET TO ZERO. [H,L] IS SAVED.
; [B,C] IS SET TO POINT AT THE FILE DATA BLOCK FOR FILE [E]
; [A] GIVE THE MODE OF THE FILE AND ZERO IS SET  IF THE FILE IS
; MODE ZERO (NOT OPEN).
;
FILIDX:	LD	E,A		;GET FILE NUMBER INTO [E]
FILID2:	LD	A,(MAXFIL)	;IS THIS FILE # LEGAL?
	CP	E
	JP	C,DERBFN	;IF NOT, "BAD FILE NUMBER"
	LD	D,0		;SETUP DOUBLE-BYTE OFFSET TO GET
	;POINTER TO FILE DATA BLOCK
	PUSH	HL		;SAVE [H,L]
	LD	HL,FILPTR	;POINT AT POINTER TABLE
	ADD	HL,DE		;ADD ON OFFSET TWICE FOR DOUBLE BYTE
	ADD	HL,DE		;ENTRIES
	LD	C,(HL)		;PICK UP POINTER IN [B,C]
	INC	HL
	LD	B,(HL)
	LD	A,(BC)		;GET MODE OF FILE INTO [A]
	OR	A		;SET ZERO IF FILE NOT OPEN
	POP	HL		;RETRIEVE [H,L]
	RET	

; GETPTR IS CALLED FROM VARPTR(#<EXPRESSION>)
	PUBLI	C	GETPTR
GETPTR:	CALL	FILID2		;INDEX INTO FILE DATA BLOCK
	LD	HL,DATOFC	;POINT TO DATA BLOCK
	CP	MD.RND		;RANDOM FILE?
	JP	NZ,NTFIVD	;NO, USE NOTRRMAL FOOFFSET
	LD	HL,0+FD.DAT##	;YES
NTFIVD:
	ADD	HL,BC		;ADD START OF FILE DATA BLOCK
	EX	DE,HL		;RETURN IN [D,E]
	RET	
	PAGE	

MKI$:	LD	A,2		;VALUE TYPE FOR INTEGER AND NUMBER
	;OF CHARACTERS RESULT WILL NEED
	DEFB	1		;SKIP NEXT TWO BYTES WITH "LXI	B,"
MKS$:	LD	A,4		;VALUE TYPE OF SINGLE PRECISION
	DEFB	1		;SKIP NEXT TWO BYTES
MKD$:	LD	A,8		;VALUE TYPE OF DOUBLE-PRECISION
	PUSH	AF		;SAVE THE NUMBER OF BYTES OF
	;STRING SPACE WE NEED
	CALL	DOCNVF		;CONVERT FAC TO PROPER TYPE
	POP	AF		;GET THE NUMBER OF BYTES NEEDED
	CALL	STRINI		;GET A PLACE FOR THE STRING DATA
	LD	HL,(DSCTMP+1)	;POINT TO THE PLACE TO STORE THE DATA
	CALL	VMOVMF		;MOVE THE FAC VALUE INTO THE STRING CREATION
	JP	FINBCK		;FINISH UP THESE STRING FUNCTIONS

CVI:	LD	A,1		;SET [A] TO BE VALTYP-1
	DEFB	1		;SKIP THE NEXT TWO BYTES WITH "LXI B,"
CVS:	LD	A,3		;ALSO SET [A] TO NUMBER OF CHARACTERS REQUIRED -1
	DEFB	1		;SKIP THE NEXT TWO BYTES
CVD:	LD	A,7		;DOUBLE PRECISION VALUE TYPE -1
	PUSH	AF		;SAVE THE VALTYP
	CALL	FRESTR		;MAKE SURE THE ARGUMENT IS A STRING
	;AND GET A POINTER TO THE DESCRIPTOR
	POP	AF		;GET BACK NUMBER OF CHARACTERS REQUIRED-1
	CP	(HL)		;MAKE SURE THE STRING IS LONGER THAN THAT
	JP	NC,FCERR	;IF NOT, "ILLEGAL FUNCTION CALL"
	INC	A		;[A]=TRUE VALUE TYPE
	INC	HL
	LD	C,(HL)		;[H,L]=POINTER AT STRING DATA
	INC	HL		;TO BE MOVED INTO THE FAC
	LD	H,(HL)
	LD	L,C
	LD	(VALTYP),A	;SETUP VALUE TYPE FOR MOVE
	;AND FOR IDENTIFICATION
	JP	VMOVFM		;MOVE IN THE STRING DATA

	PAGE	
	SUBTT	L	SETUP TO READ A SEQUENTIAL ITEM -- FILIND

FILIND:
	CALL	GETYPR		;SEE IF INPUT IS STRING OR NUMBER
	LD	BC,DOASIG	;RETURN ADDRESS TO SETUP [FAC]
CON1	DEFL	0+(44*256)+32
	LD	DE,CON1		;SETUP TERMINATORS SPACE AND COMMA
	JP	NZ,INPDOR	;IF NUMERIC, GO READ THE FILE
	LD	E,D		;MAKE BOTH TERMINATORS COMMA
	JP	INPDOR		;GO READ THE FILE
	PAGE	
	SUBTT	L	LINE INPUT & READ CODE FOR ITEM FETCHING FROM SEQUENTIAL INPUT FILES

DLINE:	CALL	FILINP	;GET FILE NUMBER SET UP
	CALL	PTRGET		;READ STRING TO STORE INTO
	CALL	FRCSTR		;MAKE SURE IT WAS A STRING
	LD	BC,FINPRT	;RESET TO CONSOLE WHEN DONE READING
	PUSH	BC		;SAVE ON STACK
	PUSH	DE		;SAVE POINTER AT VARIABLE
	LD	BC,LETCON	;GOOD RETURN ADDRESS FOR ASSIGNMENT
	XOR	A		;SET A=0 FOR STRING VALUE TYPE
	LD	D,A		;ZERO OUT BOTH TERMINATORS
	LD	E,A
INPDOR:	PUSH	AF		;SAVE VALUE TYPE
	PUSH	BC		;SAVE RETURN ADDRESS
	PUSH	HL		;SAVE POINTER AT DATA COMING IN
	;A DUMMY POINTER AT BUFMIN
NOTNWT:	CALL	INDSKC		;READ A CHARACTER
	JP	C,DERRPE	;READ PAST END ERROR IF EOF
	CP	' '		;SKIP LEADING SPACES
	JP	NZ,NOTSPC	;EXCEPT FOR LINE INPUT
	INC	D		;CHECK FOR LINEINPUT
	DEC	D
	JP	NZ,NOTNWT	;SKIP ANY NUMBER
NOTSPC:	CP	34		;QUOTED STRING COMING IN?
	JP	NZ,NOTQTE
	LD	B,A		;SAVE THE QUOTE
	LD	A,E		;MUST BE INPUT OF A STRING
	CP	44		;WHICH HAS [E]=44
	LD	A,B		;QUOTE BACK INTO [A]
	JP	NZ,NOTQTE
	LD	D,B		;TERMINATORS ARE QUOTES ONLY
	LD	E,B
	CALL	INDSKC		;READ PAST QUOTATION
	JP	C,QUITSI	;IF EOF, ALL DONE
NOTQTE:
	LD	HL,BUF		;BUFFER FOR DATA
	LD	B,255		;MAXIMUM NUMBER OF CHARACTERS (255)
LOPCRS:	LD	C,A		;SAVE CHARACTER IN [C]
	LD	A,D		;CHECK FOR QUOTED STRING
	CP	34
	LD	A,C		;RESTORE CHARACTER
	JP	Z,NOTQTL	;DON'T IGNORE CR OR STOP ON LF
	CP	13		;CR?
	PUSH	HL		;SAVE DEST PTR. ON STACK
	JP	Z,ICASLF	;EAT LINE FEED IF ONE
	POP	HL		;RESTORE DEST. PTR.
	CP	10		;LF?
	JP	NZ,NOTQTL	;NO, TEST OTHER TERMINATORS
	LD	C,A		;SAVE CURRENT CHAR
	LD	A,E		;GET TERMINATOR 2
	CP	54O		;CHECK FOR COMMA (UNQUOTED STRING)
	LD	A,C		;RESTORE ORIG CHAR
	CALL	NZ,STRCHR	;IF NOT, STORE LF (?)
	CALL	INDSKC		;GET NEXT CHAR
	JP	C,QUITSI	;IF EOF, ALL DONE.
	CP	13		;IS IT A CR?
	JP	NZ,NOTQTL	;IF NOT SEE IF STORE NORMALLY
	LD	A,E		;GET TERMINATOR
	CP	' '		;IS IT NUMERIC INPUT?
	JP	Z,LPCRGT	;IF SO, IGNORE CR, DONT PUT IN BUFFER
	CP	44		;IS IT NON-QUOTED STRING (TERM=,)
	LD	A,13		;GET BACK CR.
	JP	Z,LPCRGT	;IF SO, IGNORE CR.
NOTQTL:	OR	A		;IS CHAR ZERO
	JP	Z,LPCRGT	;ALWAYS IGNORE, AS IT IS TERMINATOR
	;FOR STRLIT (SEE QUIT2B)
	CP	D		;TERMINATOR ONE?
	JP	Z,QUITSI	;STOP THEN
	CP	E		;TERMINATOR TWO?
	JP	Z,QUITSI
	CALL	STRCHR		;SAVE THE CHAR
LPCRGT:	CALL	INDSKC		;READ ANOTHER CHARACTER
	JP	NC,LOPCRS	;IF NOT, CHECK AS TERMINATOR
QUITSI:	PUSH	HL		;SAVE PLACE TO STUFF ZERO
	CP	34		;STOPPED ON QUOTE?
	JP	Z,MORSPC	;DON'T SKIP SPACES THEN
	;BUT DO SKIP FOLLOWING COMMA OR
	;CRLF THOUGH
	CP	' '		;STOPPED ON SPACE?
	JP	NZ,NOSKCR	;NO, DON'T SKIP SPACES
	;OR ANY FOLLOWING COMMAS OR CRLFS EITHER
MORSPC:	CALL	INDSKC		;READ SPACES
	JP	C,NOSKCR	;EOF, ALL DONE.
	CP	' '
	JP	Z,MORSPC
	CP	44		;COMMA?
	JP	Z,NOSKCR	;OK, SKIP IT
	CP	13		;CARRIAGE RETURN?
	JP	NZ,BAKUPT	;BACK UP PAST THIS CHARACTER
ICASLF:
	CALL	INDSKC		;READ ANOTHER
	JP	C,NOSKCR	;EOF, ALL DONE.
	CP	10		;LINE FEED?
	JP	Z,NOSKCR	;OK, SKIP IT TOO
BAKUPT:	LD	HL,(PTRFIL)	;GO TO NUMBER OF CHARATERS
	LD	BC,0+NMLOFS
	ADD	HL,BC
	INC	(HL)		;BACK UP BY INCREMENTING CHARACTER COUNT
NOSKCR:	POP	HL		;GET BACK PLACE TO STORE TERMINATOR
QUIT2B:	LD	(HL),0		;STORE THE TERMINATOR
	LD	HL,BUF-1	;ITEM IS NOW STORED AT THIS POINT +1
	LD	A,E		;WAS IT A NUMERIC INPUT?
	SUB	' '		;IF SO, [E]=" "
	JP	Z,NUMIMK	;USE FIN TO SCAN IT
	EXTRN	STRLT2
	LD	B,D		;SET [B]=44 IF SCANNING UNQUOTED STRING
	LD	D,0
	CALL	STRLT2
	POP	HL		;GET BACK [H,L]
	RET			;DO ASSIGNMENT

NUMIMK:	CALL	GETYPR	;GET TYPE OF NUMERIC VARIABLE BEING READ
	PUSH	AF		;SAVE IT
	CALL	CHRGTR		;READ FIRST CHARACTER
	POP	AF		;RESTORE TYPE OF VARIABLE
	PUSH	AF		;SAVE BACK
	CALL	C,FIN		;SINGLE PRECISION INPUT
	POP	AF		;GET BACK TYPE OF VAR
	EXTRN	FINDBL
	CALL	NC,FINDBL	;DOUBLE PRECISION INPUT
	POP	HL		;GET [H,L]
	RET			;DO THE ASSIGNMENT

STRCHR:	OR	A	;TRYING TO STORE NULL BYTE
	RET	Z		;RETURN, DONT STORE IT
	LD	(HL),A		;STORE THE CHARACTER
	INC	HL
	DEC	B		;128 YET?
	RET	NZ		;MORE SPACE IN BUFFER, RETURN
	POP	BC		;GET RID OF SUPERFLUOUS STACK ENTRY
	JP	QUIT2B		;SPECIAL QUIT

	PAGE	
PRGFLI:	LD	D,MD.SQI	;SEQUENTIAL INPUT MODE
PRGFL2:	XOR	A		;INTERNAL FILE NUMBER IS ALWAYS ZERO
	JP	PRGFIL		;SCAN FILE NAME AND DISK NUMMER
	;AND DO THE RIGHT THING USING MD.KIL
	;AS A FLAG

LRUN:
LRUN2:		:	DB	366Q;SET NON ZERO TO FLAG "RUN" COMMAND
LOAD:	XOR	A		;FLAG ZERO FOR "LOAD"
	PUSH	AF		;SAVE "RUN"/"LOAD" FLAG
	CALL	PRGFLI		;FIND THAT FILE AND SETUP FOR
	;USING INDSKC SUBROUTINE
	LD	A,(MAXFIL)	;SAVE THE NUMBER OF FILES
	LD	(LSTFRE+1),A	;SINCE WE MAKE IT LOOK LIKE ZERO
	;SO ,R OPTION CAN LEAVE FILES
	;OPEN
	DEC	HL		;SEE IF NO RUN OPTION
	CALL	CHRGTR
	JP	Z,NOTRNL	;NO, JUST LOAD
	CALL	SYNCHR
	DEFB	44		;GOTTA HAVE A COMMA
	CALL	SYNCHR
	DEFB	'R'		;ONLY OPTION IS RUN
	JP	NZ,SNERR	;AND THAT BETTER BE THE END
	POP	AF		;GET RID OF "RUN"/"LOAD" FLAG
	PUBLI	C	CHNENT
CHNENT:
	XOR	A		;SO FILES AREN'T CLOSED
	LD	(MAXFIL),A	;PRETEND THERE AREN'T ANY
	DEFB	366O		;FLAG RUN WITH NON-ZERO
NOTRNL:	POP	AF		;FLAG NON-RUN WITH ZERO
	LD	(LSTFRE),A
	LD	HL,DIRTMP
	LD	(HL),0
	LD	(FILPTR),HL	;MESS UP POINTER AT FILE ZERO
	CALL	SCRTCH		;WIPE OUT OLD STUFF
	LD	A,(LSTFRE+1)	;RESTORE MAXFIL
	LD	(MAXFIL),A	;THAT WAS KLUDGED
	LD	HL,(FILPT1)
	LD	(FILPTR),HL	;RESTORE BACK TO NORMAL
	LD	(PTRFIL),HL	;PTRFIL GOT ZEROED SO FIX IT TOO
; BELOW IS FIX (TO LABEL NOTINI) SO THAT IF ^C DURING MBASIC FOO, WONT EXIT TO 
	LD	HL,(CURLIN)	;GET LINE NUMBER
	INC	HL		;SEE IF IN INITIALIZATION
	LD	A,H
	AND	L
	INC	A
	JP	NZ,NOTINI	;NO
	LD	(CURLIN),HL	;SAVE DIRECT LINE NUMBER
NOTINI:
	CALL	INDSKC		;READ THE FIRST CHARACTER
	JP	C,MAIN		;ALL DONE IF NOTHING IN FILE
	CP	254		;IS THIS A PROTECTED FILE?
	JP	NZ,NTPROL	;NO
	LD	(PROFLG),A	;SET PROTECTED FILE
	JP	BINLOD		;DO BINARY LOAD
NTPROL:
	INC	A		;IS IT A BINARY FILE?
	JP	NZ,MAINGO	;NO, SINCE PTRFIL IS NON-ZERO
	;INCHR WILL USE INDSKC INSTEAD OF POLLING
	;THE TERMINAL
	;WHEN EOF IS HIT PTRFIL WILL BE RESTORED
	;AND LSTFRE WILL BE USED AS A FLAG
	;TO INDICATE WHETHER TO RUN THE
	;LOADED PROGRAM
;
; TIME FOR A BINARY LOAD.
; AFTER THE LOAD, THE FILE IS LINKED TOGETHER
; LSTFRE IS USED AS A FLAG WHETHER TO RUN OR NOT
;
BINLOD:	LD	HL,(TXTTAB)	;GET PLACE TO START STORING INTO
LPBLDR:	EX	DE,HL		;SEE IF THERE IS ROOM TO SPARE
	LD	HL,(FRETOP)
	LD	BC,0+65536-86
	ADD	HL,BC
	CALL	DCOMPR
	EX	DE,HL
	JP	C,OUTLOD	;ERROR AND WIPE OUT PARTIAL GARBAGE
	;UNLINKED!! NO ZEROES AT THE END!!
	CALL	INDSKB		;READ THE A DATA BYTE
	;THIS IS SEMI-WEAK SINCE MEMORY
	;IS LEFT IN A BAD BAD STATE
	;IF AN I/O ERROR OCCURS
	LD	(HL),A		;STORE BYTE
	INC	HL		;INCRMENT POINTER
	JP	NC,LPBLDR	;READ THE NEXT CHAR
	LD	(VARTAB),HL	;SAVE END TEMP FOR DECODING
	LD	A,(PROFLG)	;IS THIS A PROTECTED FILE?
	OR	A		;SET CC'S
	CALL	NZ,PROLOD	;TRANSLATE TO GOOD STUFF
	CALL	LINKER		;FIX THE LINKS
	INC	HL		;WHEN LINKER RETURNS, [H,L]
	INC	HL		;POINTS TO DOUBLE ZERO
	LD	(VARTAB),HL	;UPDATE [VARTAB]
	LD	HL,MAXFIL	;ONLY CLOSE FILE ZER0
	LD	A,(HL)
	LD	(LSTFRE+1),A
	LD	(HL),0
	CALL	RUNC		;SETUP ARYTAB, STREND
	LD	A,(LSTFRE+1)	;RESTORE NUMBER OF FILES
	LD	(MAXFIL),A
	EXTRN	CHNFLG,CHNRET
	LD	A,(CHNFLG)	;CHAIN IN PROGRESS
	OR	A		;TEST
	JP	NZ,CHNRET	;YES, GO BACK TO CHAIN CODE
	LD	A,(LSTFRE)	;RUN OR NOT?
	OR	A
	JP	Z,READY
	JP	NEWSTT

PRGFIN:	CALL	FINPRT	;ZERO PTRFIL
	CALL	CLSFIL		;CLOSE FILE ZERO
	JP	GTMPRT		;REFETCH TEXT POINTER
OUTLOD:		:CALL	SCRTCH
	JP	OMERR
MERGE:	POP	BC		;ELIMINATE NEWSTT RETURN
	CALL	PRGFLI		;READ THE NAME AND DISK
	DEC	HL		;MUST END THERE
	CALL	CHRGTR
	JP	Z,OKGETM	;READ THE FILE
	CALL	PRGFIN		;CLOSE OUT TIME
	JP	SNERR		;AND "SYNTAX ERROR"
OKGETM:	XOR	A		;NO RUN OPTION WITH "MERGE"
	LD	(LSTFRE),A	;SET UP THE FLAG
	CALL	INDSKC		;READ FROM [PTRFIL] FILE
	JP	C,MAIN		;GO BACK IF EOF
	INC	A		;IS IT A BINARY FILE??
	JP	Z,DERBFM	;BINARY IS WRONG FILE MODE
MAINGO:	LD	HL,(PTRFIL)	;GET FILE POINTER
	LD	BC,NMLOFC	;POINT TO NUMBER OF CHARS IN BUFFER
	ADD	HL,BC		;BY ADDING OFFSET
	INC	(HL)		;BACK UP FILE BY INCREMENTING COUNT
	JP	MAIN

	PAGE	
	SUBTT	L	DISPATCH FOR DIRECT STATEMENT
;
; MAKE SURE WE'RE NOT READING A FILE IN
;
DIRDO:
	PUSH	HL
	LD	HL,(PTRFIL)
	LD	A,H
	OR	L		;IS PTRFIL ZERO SO NOT FILE READING?
	LD	DE,0+ERRFDR	;"DIRECT STATEMENT IN FILE"
	JP	NZ,ERROR	;NOTE: LXI D, IS USED TO
	;TO MAKE SOURCE CONVERSIONS EASIER
	POP	HL		;GET BACK POINTER AT BUFMIN
	JP	GONE		;EXECUTE DIRECT STATEMENT

	PAGE	
	SUBTT	L	SAVE COMMAND -- ASCII OR BINARY

SAVE:	LD	D,MD.SQO	;ELIMINATE EARLIER VERSION
	;AND CREATE EMPTY FILE
	CALL	PRGFL2		;READ FILE NAME AND DISK NUMBER AND
	;LOOK IT UP
	DEC	HL
	CALL	CHRGTR		;END OF STATEMENT?
	JP	Z,BINSAV	;BINARY SAVE!!
	CALL	SYNCHR
	DEFB	44		;ONLY OPTION IS ",A"
	EXTRN	PROSAV
	CP	'P'		;PROTECTED SAVE?
	JP	Z,PROSAV	;DO IT
	CALL	SYNCHR
	DEFB	'A'		;FOR ASCII SAVE
	JP	LIST		;USE THE LIST CODE TO DO THE OUTPUT
	;CONTROL-CS ARE NOT ALLOWED
	;AND AT THE END PTRFIL IS ZEROED
BINSAV:
	CALL	SCCPTR		;GET RID OF POINTERS BEFORE SAVING
	EXTRN	PROCHK
	CALL	PROCHK		;DONT ALLOW BINARY SAVES OF PROTECTED PROGRAMS
	LD	A,255		;ALWAYS START WITH 255
BINPSV:	CALL	FILOU3		;SEND TO FILE
	LD	HL,(VARTAB)	;GET STOP POINT
	EX	DE,HL		;SAVE IN [D,E]
	LD	HL,(TXTTAB)	;GET START POINT
BSAVLP:	CALL	DCOMPR		;REACHED THE END?
	JP	Z,PRGFIN	;REGET TEXT POINTER AND CLOSE FILE 0
	LD	A,(HL)		;GET LINE DATA
	INC	HL		;POINT AT NEXT DATA
	PUSH	DE		;SAVE LIMIT
	CALL	FILOU3		;SEND CHAR TO FILE
	POP	DE		;RESTORE LIMIT
	JP	BSAVLP		;CONTINUE WITH LINE DATA

	SUBTT	L	DRIVER CODE FOR CLOSE

CLOSE:	LD	BC,CLSFIL;SERVICE ROUTINE ADDRESS
	LD	A,(MAXFIL)	;HIGHEST POSSIBLE ARGUMENT
	;WHICH MEANS DO ALL POSSIBLE
RTALLR:	JP	NZ,RTLOOP	;NOT END OF STATEMENT, SO SCAN ARGUMENTS
	PUSH	HL		;SAVE THE TEXT POINTER
MRALL:	PUSH	BC		;SAVE ROUTINE ADDRESS
	PUSH	AF		;SAVE CURRENT VALUE
	LD	DE,RETALL	;RETURN ADDRESS
	PUSH	DE		;SAVE IT TO COME BACK WITH
	PUSH	BC		;DISPATCH TO SERVICE ROUTINE
	RET	
RETALL:	POP	AF		;GET BACK OLD ARGUMENT
	POP	BC		;GET BACK SERVICE ROUTINE ADDRESS
	DEC	A		;DECREMENT ARGUMENT
	JP	P,MRALL		;LOOP ON MORE VALUES
	POP	HL		;GET BACK THE TEXT POINTER
	RET	

RETRTS:	POP	BC	;GET BACK SERVICE ROUTINE ADDRESS
	POP	HL		;GET BACK THE TEXT POINTER
	LD	A,(HL)		;SEE IF MORE ARGUMENTS
	CP	44		;DELIMITED BY COMMA
	RET	NZ
	CALL	CHRGTR		;READ FIRST CHARACTER OF FORMULA
RTLOOP:	PUSH	BC		;SAVE THE SERVICE ROUTINE ADDRESS
	LD	A,(HL)		;GET POSSBLE "#"
	CP	'#'		;IS IT
	CALL	Z,CHRGTR	;SKIP IT, ITS OPTIONAL
	CALL	GETBYT		;READ THE ARGUMENT
	EX	(SP),HL		;SAVE THE TEXT POINTER ON THE STACK
	;AND SET [H,L]=SERVICE ADDRESS
	PUSH	HL		;SAVE THE SERVICE ADDRESS
	LD	DE,RETRTS	;PUT A RETURN ADDRESS ON THE STACK
	PUSH	DE
	JP	(HL)		;DISPATCH TO DO THE FUNCTION


CLSALL:	PUSH	DE
	PUSH	BC		;SAVE [B,C] FOR STKINI
	XOR	A		;MAKE IT CLOSE ALL DISKS
	CALL	CLOSE
	POP	BC
	POP	DE		;GET BACK [D,E]
	XOR	A		;RETURN WITH [A]=0 AND Z ON
	RET	

	PAGE	
	SUBTT	L	"FIELD" STATEMENT FOR SETTING UP I/O STRINGS
FIELD:	CALL	FILSCN		;GET DATA BLOCK POINTER IN [B,C]
	JP	Z,DERBFN	;"BAD FILE NUMBER" IF FILE NOT OPEN
	SUB	MD.RND		;MAKE SURE ITS A RANDOM FILE
	JP	NZ,DERBFM	;IF NOT, "BAD FILE MODE"
	EXTRN	FD.SIZ,TEMPA,TEMPB,FD.DAT
	EX	DE,HL		;SAVE TEXT POINTER
	LD	HL,0+FD.SIZ	;POINT TO RECORD SIZE
	ADD	HL,BC
	LD	A,(HL)		;GET IT
	INC	HL
	LD	H,(HL)
	LD	L,A
	LD	(TEMPA),HL	;STORE MAX ALLOWED
	LD	HL,0		;ZERO MAX # OF CHARS
	LD	(TEMPB),HL
	LD	A,H		;MAKE [A]=0
	EX	DE,HL		;GET BACK TEXT POINTER
	LD	DE,0+FD.DAT	;POINT TO 5.0 FIELD BUFFER
LOPFLD:	EX	DE,HL		;SAVE TEXT POINTER IN [D,E]
	ADD	HL,BC		;ADD ON DATA POINTER SO [H,L] NOW POINTS
	;AT THE START OF THE DATA
	LD	B,A		;SETUP COUNT OF CHARACTERS PAST BY
	;IN DATA AREA, SO TOTAL IS NEVER GREATER THAN 128
	EX	DE,HL		;TEXT POINTER BACK INTO [H,L]
	;[D,E]=POINTER INTO DATA AREA
	LD	A,(HL)		;MORE "AS"S TO SCAN?
	CP	44		;COMMA STARTS THE CLAUSE
	RET	NZ		;BACK TO NEWSTT IF NOT
	PUSH	DE		;SAVE THE POINTER INTO THE DATA BLOCK
	PUSH	BC		;SAVE [B]=NUMBER OF CHARACTERS ALLOCATED
	CALL	GTBYTC		;READ NUMBER INTO [A] FROM TEXT
	PUSH	AF		;SAVE THIS NUMBER
	CALL	SYNCHR
	DEFB	'A'		;SCAN THE "AS"
	CALL	SYNCHR
	DEFB	'S'
	CALL	PTRGET		;GET A POINTER AT THE STRING DESCRIPTOR
	CALL	FRCSTR		;INTO [D,E]
	POP	AF		;GET THE NUMBER OF CHARACTERS
	POP	BC		;GET THE NUMBER ALREADY USED
	EX	(SP),HL		;SAVE THE TEXT POINTER AND
	;[H,L]=POINTER INTO DATA BLOCK
	LD	C,A		;SAVE # OF CHARACTERS IN [C]
	PUSH	DE		;SAVE [D,E]
	PUSH	HL		;SAVE [H,L]
	LD	HL,(TEMPB)	;GET TOTAL SO FAR
	LD	B,0		;ACCUMULATE COUNT
	ADD	HL,BC
	LD	(TEMPB),HL	;SAVE TOTAL AGAIN
	EX	DE,HL		;TOTAL TO [D,E]
	LD	HL,(TEMPA)	;GET MAX ALLOWED
	CALL	DCOMPR		;IN RANGE?
	JP	C,DERFOV	;NO, GIVE ERROR
	POP	HL		;RESTORE [H,L]
	POP	DE		;RESTORE [D,E]
	EX	DE,HL		;[H,L] POINT AT STRING DESCRIPTOR
	LD	(HL),C		;STORE THE LENGTH
	INC	HL
	LD	(HL),E		;STORE THE POINTER INTO THE DATA BLOCK
	INC	HL
	LD	(HL),D
	POP	HL		;GET BACK THE TEXT POINTER
	IFF	DATPSC-256
	JP	NZ,LOPFLD	;IF TOTAL ADDED UP TO NOT 256, GO BACK FOR MORE
	LD	A,C		;SEE HOW MUCH WE ADDED
	OR	A		;TEST
	RET	NZ
	ENDIF			;JUST ADDED UP TO 256, GIVE SYNTAX ERROR IF MORE
	JP	LOPFLD		;CONTINUE SCANNING "AS" CLAUSES IF MORE
	PAGE	
	SUBTT	L	RANDOM NON-I/O -- LSET/RSET/FIELD

;LSET/RSET stringvar = stringexp
;
; If stringvar points to an I/O buffer, use the string size to
;justify string. If stringvar is a literal, make new var with length
;of literal. If stringvar points to string space, use it. If the
;length of the variable is zero, return the null string. If a copy
;must be created, and stringexp is a temporary, use this space over
;unless length stringvar greater than stringexp.

RSET:	DEFB	366O		;ORI	<STC>
LSET:	SCF			;Set carry if lset
	PUSH	AF		;Save LSET/RSET flag
	CALL	PTRGET		;Get pointer to stringvar
	CALL	FRCSTR		;Must be a string variable
	PUSH	DE		;Save pointer to descriptor
	CALL	FRMEQL		;EAT "=" AND EVALUATE STRINGEXP
	POP	BC		; [B,C] = ptr to descr.
	EX	(SP),HL		;Text ptr on bottom of stack
	PUSH	HL		;LSET/RSET flag next
	PUSH	BC		;Put descr. ptr back on
	CALL	FRESTR		;Error if not string, free temp.
	LD	B,(HL)		;Get length of stringexp
	EX	(SP),HL		; [H,L] = descr. of var,save othr
	LD	A,(HL)		;Get length of stringvar
	LD	C,A		;Save in [C]
	PUSH	BC		;Save lengths of both
	PUSH	HL		;Save descriptor pointer
	PUSH	AF		;PSW zero if was temp.
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;Get ptr to stringvar text
	OR	A		;stringvar null?
	JP	Z,RETCUR	;Yes, don't change
	LD	HL,(TXTTAB)
	CALL	DCOMPR		;Stringvar in disk buffer?
	JP	NC,OLDSTR	;Yes, use it
	LD	HL,(VARTAB)
	CALL	DCOMPR		;stringvar in program(literal)?
	JP	C,OLDSTR	;No, in string space so use it
;Need to make new string for result since stringvar points to a literal.
;If stringexp was a temporary, it has been freed. If the length of
;stringexp is greater than or equal to the length of stringvar, GETSPA
;can be called and no garbage collection can occur so temp. can be reused.
;If stringvar is greater, must get a temp. to point to stringexp if it
;was a temp. , then call GETSPA which in this case can garbage collect.
	LD	E,C
	LD	D,0		;# BYTES TO ALLOCATE FOR RESULT
	EXTRN	STREND
	LD	HL,(STREND)
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(FRETOP)
	CALL	DCOMPR		;WILL GETSPA GARBAGE COLLECT?
	JP	C,MAKDSC	;Yes, better have stringexp temp.
MADESC:	POP	AF
	LD	A,C		;Get length of stringvar
	CALL	GETSPA		;Get space for result
	POP	HL		;Get stringvar descr.
	POP	BC		;Get lengths off stack
	EX	(SP),HL		;Get what we wanted, stringexp descr.
	PUSH	DE
	PUSH	BC
	CALL	FRESTR		;Free temp if any
	POP	BC
	POP	DE
	EX	(SP),HL
	PUSH	BC		;Restore stack to previous state
	PUSH	HL
	INC	HL
	LD	(HL),E
	INC	HL
	LD	(HL),D		;Set pointer to stringvar copy
	PUSH	AF
OLDSTR:	POP	AF
	POP	HL		;Get stringvar descr.
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;Get pointer to text area
	POP	BC		;Get lengths off stack
	POP	HL		;Get pointer to stringexp descr.
	PUSH	DE
	INC	HL
	LD	E,(HL)
	INC	HL
	LD	D,(HL)		;Get ptr to stringexp text
	EX	DE,HL		;Put pointer in [H,L]
	POP	DE
	LD	A,C		;Get length of field(stringvar)
	CP	B
	JP	NC,FILDOK	;Jump if field large enough for result
	LD	B,A		;Save # of bytes to copy
FILDOK:	SUB	B
	LD	C,A		;[C] = # blanks to fill
	POP	AF		;Get LSET/RSET flag
	CALL	NC,BLKFIL	;Fill leading if RSET
	INC	B		;In case zero
COPLOP:	DEC	B		;Decr. # to copy
	JP	Z,LRSTDN	;Done when all copied
	LD	A,(HL)		;Get byte from stringexp
	LD	(DE),A		;Copy to stringvar
	INC	HL
	INC	DE
	JP	COPLOP

RETCUR:	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC		;Get garb off stack
LRSTDN:	CALL	C,BLKFIL	;Fill trailing if LSET
	POP	HL		;Restore text pointer
	RET	

BLKFIL:	LD	A,' '	;Fill with spaces
	INC	C		;In case zero
BLKFL1:	DEC	C		;Decr. # to fill
	RET	Z		;Return when done
	LD	(DE),A		;Store space
	INC	DE
	JP	BLKFL1

; If stringexp was a temporary, create a new temporary to point to
; stringexp since old one was freed. This must be done since GETSPA
; will be called and garbage collection might occur. If stringexp is
; not a temporary, return.

MAKDSC:	POP	AF	;Get temp flag
	POP	HL
	POP	BC
	EX	(SP),HL		;Dig down to stringexp descr.
	EX	DE,HL		;FRETMS wants [D,E]
	JP	NZ,MAKDS1	;Not a temp, don't reallocate
	PUSH	BC
	LD	A,B
	CALL	STRINI		;Make a temp point to stringexp
	CALL	PUTNEW		;Get a temp to point to it
	POP	BC
MAKDS1:	EX	(SP),HL
	PUSH	BC
	PUSH	HL		;Restore stack to previous state
	PUSH	AF
	JP	MADESC
	PAGE	
	SUBTT	L	PROGRAM I/O -- FIXED LENGTH INPUT

; Format:
;		stringvar = INPUT$(#bytes[,[#] file#])
;If no file # is given, characters will be read from the user's
; terminal. No echoing will be done and no editing will be allowed
; (i.e. rubout,@,_,^U are just input as characters).

	PUBLI	C	FIXINP
FIXINP:	CALL	CHRGTR
	CALL	SYNCHR
	DEFB	'$'		;STRING FUNCTION
	CALL	SYNCHR
	DEFB	'('
	CALL	GETBYT		;Get # of bytes to read
	PUSH	DE		;Save # of bytes to read
	LD	A,(HL)
	CP	54O		;Read from disk file?
	JP	NZ,REDTTY	;No, from user's terminal
	CALL	CHRGTR
	CALL	FILSCN		;Set up file #
	CP	MD.SQO		;SEQUENTIAL OUTPUT FILE?
	JP	Z,DERBFM	;THEN BAD FILE MODE
	CALL	FILSET		;SET UP PTRFIL
	XOR	A		;SET ZERO FOR FLAG
REDTTY:	PUSH	AF		;NON ZERO SET IF TERMINAL I/O
	CALL	SYNCHR
	DEFB	')'		;Must have paren
	POP	AF		;Get flag off stack
	EX	(SP),HL		;Save text ptr, [L]=# to read
	PUSH	AF		;Save flag
	LD	A,L
	OR	A		;Read no characters?
	JP	Z,FCERR		;Yes, error
	PUSH	HL		;Save #
	CALL	STRINI		;Get space for string
	EX	DE,HL
	POP	BC		;[C] = # to read
FIXLOP:	POP	AF
	PUSH	AF		;NON-ZERO set if should read from TTY
	JP	Z,DSKCHR	;Read from disk file
	EXTRN	CHARCG
	CALL	CHARCG		;GET CHAR IF ONE
	JP	NZ,CHARCW	;WAS ONE
	CALL	INCHRI		;Read a char from terminal
CHARCW:
;Note : will check flag on interrupt ^c
	CP	3		;Control-C?
	JP	Z,INTCTC	;Yes, stop
PUTCHR:	LD	(HL),A		;Put char into string
	INC	HL
	DEC	C		;Read enough yet?
	JP	NZ,FIXLOP	;No, read more
	POP	AF		;Get flag off stack
	CALL	FINPRT		;Clear PTRFIL
	JP	PUTNEW		;Return string as result
INTCTC:	LD	HL,(SAVSTK)	;GET SAVED STACK POINTER
	LD	SP,HL		;SET [H,L] TO IT
	JP	ENDCON		;STOP PROGRAM

DSKCHR:	CALL	INDSKC	;Get char from file
	JP	C,DERRPE	;If carry, read past EOF
	JP	PUTCHR		;Put char in string
	END	
