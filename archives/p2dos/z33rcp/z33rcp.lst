ZAS Relocating Macro Assembler (v3.05                             page    1
                                                            
                                                            

  0000           
  0000           ; Program:      Z33RCP
  0000           ; Version:      1.0
  0000           ; Description:  Resident Command Package (RCP) for ZCPR33
  0000           ; Author:       Jay Sage
  0000           ; Date:         March 1, 1987
  0000           ; Derivation:   SYSRCP (Richard Conn) and many other contributions
  0000           
  0002 =         version equ     2
  0001 =         subver  equ     1               ; Version 2.1
  0000           
  0000           ; Version 2.1 - 20080212 - P. Betti <pbetti@lpconsul.net>
  0000           ; little changes to include datestamper code in RCP space (if space is available)
  0000           
  0000           ;=============================================================================
  0000           ;
  0000           ;               D E F I N I T I O N S    S E C T I O N
  0000           ;
  0000           ;=============================================================================
  0000           
  0000+                  maclib  common.asm
  0000+          ;
  0000+          ; Here just some common symbol...
  0000+          ;
  0000+          
  0016+=         VERS    EQU     22              ; VERSION 2.2 (CP/M related)
  0000+          ;
  0000+          ; MSIZE EQU     63              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  003C+=         MSIZE   EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0000+          ; MSIZE EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0400+=         RESROOM EQU     1024            ; RESERVED ROOM SPACE BELOW MONITOR (FC00)
  0600+=         BIOSTDS EQU     1536            ; BIOS STANDARD SIZE
  0A00+=         BIOREAS EQU     BIOSTDS+RESROOM ; BIOS REAL SIZE
  0400+=         ZSTDOVR EQU     1024            ; ZCPR STANDARD OVERHEAD SIZE
  0000+=         ZIOPKG  EQU     0               ; ZCPR IO PACKAGE SIZE
  0800+=         ZRESPKG EQU     2048            ; ZCPR RESIDENT CMD PKG SIZE
  0200+=         ZFLOPKG EQU     512             ; ZCPR FLOW CMD PACKAGE SIZE
  01C8+=         ZDSSTSZ EQU     01C8H           ; ZDS Stamper reserved space
  0000+          
  1200+=         EXTRABIAS       EQU     RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG  ; ...
  0000+                  ;
  0000+                  ;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  0000+                  ;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  0000+                  ;
  8E00+=         BIAS    EQU     ((MSIZE-20)*1024)-EXTRABIAS
  C200+=         CCP     EQU     3400H+BIAS      ; BASE OF CCP
  CA06+=         BDOS    EQU     CCP+0806H       ; BASE OF BDOS
  CA00+=         BDOSB   EQU     CCP+0800H       ; BDOS base offset
  D800+=         BIOS    EQU     CCP+1600H       ; BASE OF BIOS
  E200+=         ZBUFBAS EQU     BIOS+BIOREAS    ; BASE OF ZCPR3 BUFFERS
  0000+                  ;
  0000+                  ;       some other equs...
  0000+                  ;
  000D+=         CR      EQU     0DH             ; CARRIAGE RETURN
  000A+=         LF      EQU     0AH             ; LINE FEED;
  000C+=         FF      EQU     0CH             ; FORM FEED (clear screen)
ZAS Relocating Macro Assembler (v3.05                             page    2
                                                            
                                                            

  FFFF+=         TRUE    EQU     -1
  0000+=         FALSE   EQU     0
  0000+          
  0000+=         INTRON  EQU     FALSE           ; Interrupts disabled
  0000+                  ;
  0000+                  ; define which kind of date stamper must be embedded in
  0000+                  ; RCP
  0000+                  ;
  FFFF+=         STMPP2  EQU     TRUE            ; P2DOS date stamper
  0000+=         STMPZS  EQU     FALSE           ; ZSDOS date stamper
  FFFF+=         HASEDS  EQU     (STMPP2+STMPZS) ; set a flag for embedded date stamper
  0000+                  ;
  0000+                  ; path for ZCPR3 used on cold boot
  0000+                  ;
  0024+=         IDISK1  EQU     '$'             ; 1st: current disk, current user
  0024+=         IUSER1  EQU     '$'
  0024+=         IDISK2  EQU     '$'             ; 2nd: current disk, user 15
  000F+=         IUSER2  EQU     15
  0001+=         IDISK3  EQU     'A'-'@'         ; 3rd: disk A, current user
  0024+=         IUSER3  EQU     '$'
  0001+=         IDISK4  EQU     'A'-'@'         ; 4th: disk A, user 15
  000F+=         IUSER4  EQU     15
  0000+          
  0000+          ; COMMON.ASM [EOF]
  0000+                  maclib  sysdef.lib      ; Common logic, sys, ascii defines
  0000+          ;LIBRARY OF COMMONLY USED DEFINITIONS
  0000+          ;Use of this library will make assembly language
  0000+          ;programs easier to read and maintain.
  0000+          ;
  0000+          ;The following definitions were collected by
  0000+          ;simply extracting them from ZCPR3 utilities.
  0000+          ;Please feel free to add to this list and to
  0000+          ;comment on the preferred definition where
  0000+          ;there are several equivalent ones. Bump the
  0000+          ;revision # and send it back for coordination.
  0000+          ;
  0000+          ;Version 1.0 - 31 Jan 1986
  0000+          ;Al Hawley, Z-Node #2, (213) 670-9465
  0000+          
  0000+          ;----------------------------------------------
  0000+          ;Logic Definitions
  0000+          
  0000+          ; FALSE EQU     0               ;these all seem to be
  0000+          ; TRUE  EQU     NOT FALSE       ;..appropriate in
  FFFF+=         YES     EQU     TRUE            ;..different contexts.
  0000+=         NO      EQU     FALSE
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; System Functions
  0000+          ;
  0001+=         RDCONF          EQU     1
  0002+=         WRCONF          EQU     2
  0003+=         RDRF            EQU     3
  0004+=         PUNCHF          EQU     4
  0005+=         LISTF           EQU     5
  0006+=         DIRCONF         EQU     6
ZAS Relocating Macro Assembler (v3.05                             page    3
                                                            
                                                            

  0009+=         PRBUFF          EQU     9
  000A+=         RDBUFF          EQU     10
  000B+=         CONSTF          EQU     11
  000C+=         VERNOF          EQU     12
  000D+=         RESETDKF        EQU     13
  000E+=         LOGINF          EQU     14
  000F+=         OPENF           EQU     15
  0010+=         CLOSEF          EQU     16
  0011+=         SRCHFF          EQU     17
  0012+=         SRCHNF          EQU     18
  0013+=         ERASEF          EQU     19
  0014+=         READF           EQU     20
  0015+=         WRITEF          EQU     21
  0016+=         MAKEF           EQU     22
  0017+=         RENF            EQU     23
  0019+=         INQDISKF        EQU     25
  001A+=         SETDMAF         EQU     26
  001B+=         INQALCF         EQU     27
  001E+=         ATTRF           EQU     30
  001F+=         GETPARMF        EQU     31
  0020+=         SGUSERF         EQU     32
  00FF+=         GETF            EQU     0FFH            ;get user area e-reg value
  0023+=         COMPSZF         EQU     35
  0024+=         SETRRF          EQU     36
  0000+          
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; System Addresses
  0000+          ;
  0000+=         OS$BASE EQU     000H            ;system base..
  0800+=         CCPLEN  EQU     800H            ;..and 'CCP' length in bytes.
  0000+=         WBOOT   EQU     OS$BASE+0
  0003+=         IOBYTE  EQU     OS$BASE+03H
  0004+=         UDFLAG  EQU     OS$BASE+04H
  0000+          ;BDOS   EQU     OS$BASE+05H
  0000+          
  005C+=         FCB     EQU     OS$BASE+5CH
  005C+=         TFCB    EQU     OS$BASE+5CH
  005C+=         FCB1    EQU     OS$BASE+5CH     ;preferred (AEH)
  0000+          
  006C+=         FCB2    EQU     OS$BASE+6CH
  0000+          
  0068+=         FCBEXT  EQU     FCB+12
  007C+=         FCBRNO  EQU     FCB+32
  0000+          
  0080+=         TBUF    EQU     OS$BASE+80H
  0080+=         TBUFF   EQU     OS$BASE+80H
  0000+          
  0100+=         TPA     EQU     OS$BASE+100H
  0000+          
  0000+          ;----------------------------------------------
  0000+          ; ASCII Definitions
  0000+          ;
  0001+=         CTRLA   EQU     'A'-'@'
  0003+=         CTRLC   EQU     'C'-'@'         ;..control-C..
  0004+=         CTRLD   EQU     'D'-'@'
ZAS Relocating Macro Assembler (v3.05                             page    4
                                                            
                                                            

  0005+=         CTRLE   EQU     'E'-'@'
  0006+=         CTRLF   EQU     'F'-'@'
  000B+=         CTRLK   EQU     'K'-'@'
  0012+=         CTRLR   EQU     'R'-'@'
  0013+=         CTRLS   EQU     'S'-'@'         ;..XOFF..
  0018+=         CTRLX   EQU     'X'-'@'
  001A+=         CTRLZ   EQU     'Z'-'@'
  0008+=         BS      EQU     08H             ;..backspace..
  0009+=         TAB     EQU     09H             ;..tab..
  0000+          ;LF     EQU     0AH             ;..linefeed..
  0000+          ;FF     EQU     0CH             ;..formfeed..
  0000+          ;CR     EQU     0DH             ;..carriage return..
  0018+=         CAN     EQU     18H             ;..cancel..
  001A+=         EOF     EQU     1Ah             ;..End-of-file
  001A+=         EOFCHAR EQU     1AH             ;..end-of-file..
  001B+=         ESC     EQU     1BH             ;..escape character.
  0020+=         SPC     EQU     20H             ;..space
  0000+          
  0000+          ;----------------------------------------------
  0000+          ;for TCAP screen functions
  0000+          ;
  0001+=         DIM     EQU     1               ;for highlighting use
  0002+=         BRIGHT  EQU     2               ;opposite of dim
  001A+=         CL      EQU     CTRLZ           ;clear screen, home cursor
  0005+=         CRUP    EQU     CTRLE           ;cursor up
  0018+=         CRDN    EQU     CTRLX           ;cursor down
  0013+=         CURSL   EQU     CTRLS           ;cursor left
  0004+=         CURSR   EQU     CTRLD           ;cursor right
  0000+          
  0000+                  maclib  z3base.lib      ; Defines ZCPR system addresses
  0000+          ; Z3BASE - Dynamic Configuration
  0000+          ;
  0000+          ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000+          ; distribution and duplication permitted for non-commercial purposes only.
  0000+          ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000+          ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000+          ; conjunction with any hardware or software product, is expressly prohibited
  0000+          ; unless authorized in writing by Echelon.
  0000+          ;
  0000+          ; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  0000+          ; for Z-Com.  All segment addresses are automatically derived when the
  0000+          ; CCP equate is set.  The benefit of this is that reconfiguration of the
  0000+          ; system after initial installation is greatly eased.
  0000+          ;
  0000+          ; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  0000+          ; previous version of Z3BASE can be used to assemble the Z33 Command
  0000+          ; Processor.  No new symbols are needed.  So, if you have an existing
  0000+          ; Z3BASE, go ahead and use it.
  0000+          ;
  0000+          ; Instructions:
  0000+          ;
  0000+          ; The user should first design the ZCPR3 memory usage using the chart
  0000+          ; below.  (Echelon recommends the chart be filled out, even though it is
  0000+          ; not read by the assembler, so that your system will be self-documenting.)
  0000+          ; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  0000+          ; and change the SEGn equates which follow in the file to ensure that the
ZAS Relocating Macro Assembler (v3.05                             page    5
                                                            
                                                            

  0000+          ; system segments and buffers are placed at the proper addresses.
  0000+          ;
  0000+          ; This file has been customized for use with AMPRO hard disk systems.  The
  0000+          ; target configuration has support for hard disks up to 49 Meg, extended
  0000+          ; IOP support, and 28-entry NDR.
  0000+          ;
  0000+          ;****************************************************************
  0000+          ;*                                                              *
  0000+          ;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System          *
  0000+          ;*                                                              *
  0000+          ;*      Segments:                                               *
  0000+          ;*                                                              *
  0000+          ;*      Segment         Function                                *
  0000+          ;*      -------         --------                                *
  0000+          ;*      ZSDOS           ZSDOS 1.1                               *
  0000+          ;*      CBIOSZ          ZDS BIOS with additional                *
  0000+          ;*                      ZCPR3 initialization routines           *
  0000+          ;*      ZCPR3           Echelon Z80 Command Processor           *
  0000+          ;*                      Replacement, Version 3.3 (ZCPR3)        *
  0000+          ;*      *.ENV           All Environment Descriptors             *
  0000+          ;*      *.FCP           All Flow Command Packages               *
  0000+          ;*      *.NDR           All Named Directory Definition Files    *
  0000+          ;*      *.RCP           All Resident Command Packages           *
  0000+          ;*      *.IOP           All Input/Output Packages               *
  0000+          ;*                                                              *
  0000+          ;*                                                              *
  0000+          ;* Memory Map of System (for CCP EQU 0BC00H):                   *
  0000+          ;*                                                              *
  0000+          ;*      Address Range     Size  Function                        *
  0000+          ;*      -------------   ------- --------                        *
  0000+          ;*          0 -   FF    256 b   Standard CP/M Buffers except    *
  0000+          ;*        100 - C2FF    ~48 K   Transient Program Area          *
  0000+          ;*       C200 - C9FF      2 K   ZCPR 3.3 Command Processor      *
  0000+          ;*       CA00 - D7FF    3.5 K   ZSDOS                           *
  0000+          ;*       D800 - E1FF    2.5 K   BIOS with disk buffers          *
  0000+          ;*       E200 - E9FF      2 K   Resident Command Package        *
  0000+          ;*       0000 - 0000    1.5 K   Input/Output Package            *
  0000+          ;*       EA00 - EBFF     .5 K   Flow Command Package            *
  0000+          ;*       EC00 - ECFF    256 b   Environment Descriptor          *
  0000+          ;*                              Bytes 00H-7FH:  Z3 Parameters   *
  0000+          ;*                              Bytes 80H-FFH:  Z3 TCAP         *
  0000+          ;*       ED00 - ED7F    128 b   ZCPR3 Shell Stack               *
  0000+          ;*       ED80 - EDCF     80 b   ZCPR3 Message Buffers           *
  0000+          ;*       EDD0 - EDF3     36 b   ZCPR3 External FCB              *
  0000+          ;*       EDF4 - EDFE     11 b   ZCPR3 External Path             *
  0000+          ;*       EDFF             1 b   Wheel Byte                      *
  0000+          ;*       EE00 - EEFF    256 B   Memory-Based Named Directory    *
  0000+          ;*       EF00 - EFCF    208 B   Multiple Command Line Buffer    *
  0000+          ;*       EFD0 - EFFF     48 b   ZCPR3 External Stack            *
  0000+          ;****************************************************************
  0000+          
  0000+          ; include       macro   filename
  0000+          ;
  0000+          ;        if     zas
  0000+          ;       .in             filename
  0000+          ;        else   ;slr assembler
ZAS Relocating Macro Assembler (v3.05                             page    6
                                                            
                                                            

  0000+          ;       include filename
  0000+          ;        endif  ;zas
  0000+          ;
  0000+          ;        endm
  0000+          
  0000+          ; FALSE equ     0
  0000+          ; TRUE  equ     NOT FALSE
  0000+          
  0021+=         Z3REV   EQU     33      ; ZCPR3 REV NUMBER
  0000+          ; MSIZE EQU     54      ; SIZE OF CPM SYSTEM
  0000+          
  0000+=         BASE    EQU     0
  0000+          
  0000+          ; CCP   EQU     0BC00H  ; ZCPR3 COMMAND PROCESSOR
  0000+          
  E200+=         SEG1    EQU     ZBUFBAS ; where the things starts
  0000+          
  0000+          ;
  0000+          ; RCP definition.  Set RCPS to 0 to eliminate RCP
  0000+          ;
  0000+          
  0010+=         RCPS    EQU     16              ; 16 128-byte Blocks (2K bytes)
  0000+          
  0000+                   IF     RCPS NE 0
  E200+=         RCP     EQU     SEG1            ; RESIDENT COMMAND PACKAGE
  0000+                   ELSE
  0000+          RCP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG2    EQU     SEG1+(RCPS*128)
  0000+          
  0000+          ;
  0000+          ; IOP definition.  Set IOPS to 0 to eliminate IOP
  0000+          ;
  0000+          ; IOPS  EQU     12              ; 12 128-byte Blocks (1.5K bytes)
  0000+=         IOPS    EQU     0               ; 12 128-byte Blocks (1.5K bytes)
  0000+          
  0000+                   IF     IOPS NE 0
  0000+          IOP     EQU     SEG2            ; REDIRECTABLE I/O PACKAGE
  0000+                   ELSE
  0000+=         IOP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG3    EQU     SEG2+(IOPS*128)
  0000+          
  0000+          ;
  0000+          ; FCP definition.  Set FCPS to 0 to eliminate FCP
  0000+          ;
  0000+          
  0004+=         FCPS    EQU     4       ; 4 128-byte Blocks (0.5K bytes)
  0000+          
  0000+                   IF     FCPS NE 0
  EA00+=         FCP     EQU     SEG3
  0000+                   ELSE
  0000+          FCP     EQU     0
  0000+                   ENDIF
ZAS Relocating Macro Assembler (v3.05                             page    7
                                                            
                                                            

  0000+          
  E838+=         ZDSSTPR EQU     (FCP-ZDSSTSZ)   ; Z80 Darkstar P2DOS Stamper
  0000+          
  EC00+=         SEG10   EQU     SEG3+(FCPS*128)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
  0000+          ; Echelon recommends you work this out so that your ENV begins at address
  0000+          ; FE00h, but this is only a recommendation and not mandatory.
  0000+          ;
  0000+          
  EC00+=         Z3ENV   EQU     SEG10   ; ENVIRONMENT DESCRIPTORS
  0002+=         Z3ENVS  EQU     2       ; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
  0000+          
  ED00+=         SEG4    EQU     SEG10+(Z3ENVS*128)
  0000+          
  0000+          ;
  0000+          ; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
  0000+          ;
  0000+          
  0004+=         SHSTKS  EQU     4       ; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
  0020+=         SHSIZE  EQU     32      ; SIZE OF A SHELL STACK ENTRY
  0000+                                  ;   (STACK SIZE = SHSTKS * SHSIZE)
  0000+                   IF SHSTKS NE 0
  ED00+=         SHSTK   EQU     SEG4
  0000+                   ELSE
  0000+          SHSTK   EQU     0
  0000+                   ENDIF
  0000+          
  ED80+=         SEG5    EQU     SEG4+(SHSTKS*SHSIZE)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
  0000+          ;
  ED80+=         Z3MSG   EQU     SEG5            ; ZCPR3 MESSAGE BUFFER
  0000+          
  EDD0+=         SEG6    EQU     SEG5+80
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDD0+=         EXTFCB  EQU     SEG6            ; ZCPR3 EXTERNAL FCB
  0000+          
  EDF4+=         SEG7    EQU     SEG6+36
  0000+          
  0000+          ;
  0000+          ; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
  0000+          ; used with this Z3BASE.LIB file.
  0000+          ;
  0000+          
  EDF4+=         EXPATH  EQU     SEG7            ; EXTERNAL PATH
  0005+=         EXPATHS EQU     5               ; 5 2-byte Path Elements
  0000+                                          ;  (PATH SIZE = EXPATHS*2 + 1)
  0000+          
  EDFF+=         SEG8    EQU     SEG7+(EXPATHS*2)+1
ZAS Relocating Macro Assembler (v3.05                             page    8
                                                            
                                                            

  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDFF+=         Z3WHL   EQU     SEG8            ; WHEEL BYTE ADDRESS
  0000+          
  EE00+=         SEG9    EQU     SEG8+1
  0000+          
  0000+          ;
  0000+          ; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
  0000+          ; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
  0000+          ; equate below.
  0000+          ;
  001C+=         Z3NDIRS EQU     28              ; 28 18-byte Named Directory Elements permitted
  0000+                                          ;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
  0000+                   IF     Z3NDIRS NE 0
  EE00+=         Z3NDIR  EQU     SEG9            ; ZCPR3 NAMED DIRECTORY AREA
  0000+                   ELSE
  0000+          Z3NDIR  EQU     0
  0000+                   ENDIF
  0000+          
  EF00+=         SEG11   EQU     SEG9+256        ; add 512 for 28-entry NDR
  0000+                                          ; add 256 for 14-entry NDR ("standard")
  0000+                                          ; add 0 if Z3NDIRS is set to 0
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EF00+=         Z3CL    EQU     SEG11   ; ZCPR3 COMMAND LINE BUFFER
  00D0+=         Z3CLS   EQU     208     ; SIZE OF COMMAND LINE BUFFER
  0000+          
  EFD0+=         SEG12   EQU     SEG11+Z3CLS
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EFD0+=         EXTSTK  EQU     SEG12   ; ZCPR3 EXTERNAL STACK
  0000+          
  0000+          ; end of Z3BASE.LIB
  0000+          
  0000+                  maclib  z33defn.lib     ; Defines offsets in Z33 command processor
  0000+          
  0000+          ; Definitions for offsets in ZCPR33 code
  0000+          
  0005+=         OFFVERS         EQU     5       ; Offset to version byte
  0006+=         OFFOPT          EQU     6       ; Offset to first option byte
  0010+=         OFFPARSE        EQU     16      ; Offset to entry point to REPARSE
  0016+=         OFFSCAN         EQU     22      ; Offset to entry point for SCAN
  0019+=         OFFCMD          EQU     25      ; Offset to command table
  0000+          
  0000+          ; Offset in message buffer for new data
  0000+          
  002F+=         OFFCDRV         EQU     2FH     ; Current drive
ZAS Relocating Macro Assembler (v3.05                             page    9
                                                            
                                                            

  002E+=         OFFCUSR         EQU     2EH
  002D+=         OFFSRUN         EQU     2DH     ; SUBMIT running flag
  002C+=         OFFXSUB         EQU     2CH     ; XSUB input redirection flag
  0000+          
  0000+          ; Bit positions and offsets within option bytes of various options
  0000+          
  0000+=         OBADDUECP       EQU     0
  0007+=         BBADDUECP       EQU     7
  0000+          
  0000+=         OROOTONLY       EQU     0
  0006+=         BROOTONLY       EQU     6
  0000+          
  0000+=         ONDRENV         EQU     0
  0005+=         BNDRENV         EQU     5
  0000+          
  0000+=         OFCPENV         EQU     0
  0004+=         BFCPENV         EQU     4
  0000+          
  0000+=         ORCPENV         EQU     0
  0003+=         BRCPENV         EQU     3
  0000+          
  0000+=         OINCLENV        EQU     0
  0002+=         BINCLENV        EQU     2
  0000+          
  0000+=         OADUENV         EQU     0
  0001+=         BADUENV         EQU     1
  0000+          
  0000+=         ODUENV          EQU     0
  0000+=         BDUENV          EQU     0
  0000+          
  0001+=         OHIGHUSER       EQU     1
  0007+=         BHIGHUSER       EQU     7
  0000+          
  0001+=         ODRVPREFIX      EQU     1
  0006+=         BDRVPREFIX      EQU     6
  0000+          
  0001+=         OSCANCUR        EQU     1
  0005+=         BSCANCUR        EQU     5
  0000+          
  0001+=         OINCLDIR        EQU     1
  0004+=         BINCLDIR        EQU     4
  0000+          
  0001+=         OINCLDU         EQU     1
  0003+=         BINCLDU         EQU     3
  0000+          
  0001+=         ODUFIRST        EQU     1
  0002+=         BDUFIRST        EQU     2
  0000+          
  0001+=         OACCPTDIR       EQU     1
  0001+=         BACCPTDIR       EQU     1
  0000+          
  0001+=         OACCPTDU        EQU     1
  0000+=         BACCPTDU        EQU     0
  0000+          
  0002+=         OPWCHECK                EQU     2
  0006+=         BPWCHECK                EQU     6
ZAS Relocating Macro Assembler (v3.05                             page   10
                                                            
                                                            

  0000+          
  0002+=         OPWNOECHO       EQU     2
  0005+=         BPWNOECHO       EQU     5
  0000+          
  0002+=         OWDU            EQU     2
  0004+=         BWDU            EQU     4
  0000+          
  0002+=         OWPASS          EQU     2
  0003+=         BWPASS          EQU     3
  0000+          
  0002+=         OWPREFIX        EQU     2
  0002+=         BWPREFIX        EQU     2
  0000+          
  0002+=         OFASTECP        EQU     2
  0001+=         BFASTECP        EQU     1
  0000+          
  0002+=         OSKIPPATH       EQU     2
  0000+=         BSKIPPATH       EQU     0
  0000+          
  0003+=         OSHELLIF        EQU     3
  0007+=         BSHELLIF        EQU     7
  0000+          
  0003+=         OATTSYS         EQU     3
  0006+=         BATTSYS         EQU     6
  0000+          
  0003+=         OATTDIR         EQU     3
  0005+=         BATTDIR         EQU     5
  0000+          
  0003+=         OATTCHK         EQU     3
  0004+=         BATTCHK         EQU     4
  0000+          
  0003+=         OSUBECHO        EQU     3
  0003+=         BSUBECHO        EQU     3
  0000+          
  0003+=         OSUBQUIET       EQU     3
  0002+=         BSUBQUIET       EQU     2
  0000+          
  0003+=         OSUBCLUE        EQU     3
  0001+=         BSUBCLUE        EQU     1
  0000+          
  0003+=         OSUBON          EQU     3
  0000+=         BSUBON          EQU     0
  0000+          
  0000+          
  0000+                  maclib  z33rcp.lib      ; Defines command options
  0000+          
  0000+          ; Z33RCP.LIB
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       M I S C E L A N E O U S    D E F I N I T I O N S
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          ;zas    equ     true            ; Set TRUE for ZAS assembler, FALSE for
ZAS Relocating Macro Assembler (v3.05                             page   11
                                                            
                                                            

  0000+                                          ; SLR assemblers.  For other assemblers the
  0000+                                          ; code in Z33RCP.Z80 will have to be changed
  0000+                                          ; to eliminate include directives.
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       R C P    I D E N T I F I C A T I O N
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0041+=         rcpid   equ     'A'             ; Identifies option set selected
  0000+          
  0000+          idstring macro
  0000+                  db      'RCP'           ; Name of Z33RCP module
  0000+          ;       db      ' '
  0000+          ;       db      version + '0'   ; Main version number
  0000+          ;       db      '.'
  0000+          ;       db      subver + '0'    ; Subversion number
  0000+          ;       db      rcpid           ; User's ID character from Z33RCP.LIB
  0000+                  db      0               ; End of name string
  0000+                   endm
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       C O M M A N D S    I N C L U D E D
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  FFFF+=         CLSON   EQU     yes             ; CLS   clear screen
  0000+=         CPON    EQU     no              ; CP    copy file
  FFFF+=         DIRON   EQU     yes             ; DIR   disk directory
  0000+=         ECHOON  EQU     no              ; ECHO  send text to screen or printer
  FFFF+=         ERAON   EQU     yes             ; ERA   erase files
  FFFF+=         LTON    EQU     yes             ; TYPE  display file on console
  0000+=         LISTON  DEFL    no              ; LIST  send file to printer (if LTON also)
  0000+=         NOTEON  EQU     no              ; NOTE  command-line comment
  0000+=         PEEKON  EQU     no              ; PEEK  view memory
  0000+=         POKEON  EQU     no              ; POKE  set memory
  0000+=         PORTON  EQU     no              ; PORT  view and set I/O ports
  FFFF+=         PROTON  EQU     yes             ; PROT  set file attributes
  0000+=         REGON   EQU     no              ; REG   set and display user registers
  0000+=         RENON   EQU     no              ; REN   rename files
  FFFF+=         RESON   EQU     yes             ; R     reset disk system
  FFFF+=         SPACEON EQU     yes             ; SP    show space remaining on disk
  0000+=         TSTON   EQU     no              ; TST   test for program error
  FFFF+=         WHLON   EQU     yes             ; WHL   set of clear wheel status
  0000+=         WHLQON  EQU     no              ; WHLQ  wheel query (if WHLON)
  FFFF+=         ZDSSON  EQU     yes             ; ZDS Date Stamper (included if we have space...)
  0000+          
  0000+=         liston  defl    liston and lton ; LIST allowed only if TYPE is enabled
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       W H E E L    R E S T R I C T I O N S
ZAS Relocating Macro Assembler (v3.05                             page   12
                                                            
                                                            

  0000+          ;
  0000+          ;=============================================================================
  0000+          
  FFFF+=         wcp     equ     yes             ; CP
  0000+=         wdir    equ     no              ; DIR
  FFFF+=         wera    equ     yes             ; ERA
  FFFF+=         wlist   equ     yes             ; LIST
  FFFF+=         wpeek   equ     yes             ; PEEK
  FFFF+=         wpoke   equ     yes             ; POKE
  FFFF+=         wport   equ     yes             ; PORT
  FFFF+=         wprot   equ     yes             ; PROT
  FFFF+=         wreg    equ     yes             ; REG
  FFFF+=         wren    equ     yes             ; REN
  FFFF+=         wtype   equ     yes             ; TYPE
  0000+=         whrc    equ     no              ; H
  0000+=         wwhlq   equ     no              ; WHLQ
  0000+          
  FFFF+=         wheel   defl    wcp or wdir or wera or wlist or wpeek or wpoke or wport
  FFFF+=         wheel   defl    wheel or wprot or wreg or wren or wtype or whrc or wwhlq
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       C O M M A N D     O P T I O N S
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          
  0000+          ; 'H' command
  0000+          
  0000+          ; This command displays a list of the resident commands implemented in the
  0000+          ; system.  FCP, CPR, and RCP commands can be displayed.  The basic command is
  0000+          ; not optional; it is always included.
  0000+          
  FFFF+=         listcpr         equ     yes     ; Include list of CPR-resident commands in
  0000+                                          ; display (highly recommended)
  0000+          
  FFFF+=         listfcp         equ     yes     ; Include list of FCP-resident commands in
  0000+                                          ; display (recommended if there is room)
  0000+          
  FFFF+=         noshow          equ     yes     ; Suppress listing commands that are wheel-
  0000+                                          ; restricted unless wheel byte is set (i.e.,
  0000+                                          ; don't show commands that won't run)
  0000+          
  0005+=         cmdsline        equ     5       ; Number of commands on each line of display
  0000+          
  0008+=         cmdspace        equ     8       ; Space in display for each command name
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'CLR' command
  0000+          
  0000+          ; This command clears the console screen.  It can either use a fixed string
  0000+          ; (for shorter code if the same terminal is always used) or use the TCAP
  0000+          ; entry for automatic adaptation to any terminal.
ZAS Relocating Macro Assembler (v3.05                             page   13
                                                            
                                                            

  0000+          
  FFFF+=         CLSTCAP         EQU     TRUE    ; Use TCAP for clear-screen string
  0000+          
  0000+          ; If CLSTCAP is not enabled, then the string below must be provided and
  0000+          ; it must end with a character with the high bit set
  0000+          
  0000+                   if     not clstcap
  0000+          clsstr   macro
  0000+                  db      'Z'-'@'+80h      ; Control-Z to clear screen
  0000+                   endm
  0000+                   endif  ;not clstcap
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'CP' command
  0000+          
  0000+          ; This command copies a single file.  The destination file can have a different
  0000+          ; name from the source file.  Set the size of the memory buffer in K below (do
  0000+          ; not change the second definition).  The copy buffer is placed at the top of
  0000+          ; the TPA, where it will generally not interfere with subsequent use of the GO
  0000+          ; command to rerun a program loaded in the TPA.
  0000+          
  0010+=         cpblocks        defl    16              ; Size of copy buffer in K
  0000+          
  0080+=         cpblocks        defl    cpblocks * 8    ; Convert to number of records
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'DIR' command
  0000+          
  0000+          ; This command displays a sorted listing of the files in a directory.  The
  0000+          ; file name buffer is allocated at the top of the TPA so as not to modify
  0000+          ; any program loaded in low memory.  Consequently, the size of the buffer
  0000+          ; must be set in advance.
  0000+          
  0100+=         maxdirs         equ     256     ; Maximum number of names in directory buffer
  0000+          
  FFFF+=         nosys           equ     yes     ; suppress 'A' and 'S' options if wheel off
  0000+          
  FFFF+=         slashchk        equ     yes     ; allow "DIR /S" or "DIR /A" formats (costs
  0000+                                          ; about 12 bytes)
  0000+          
  0041+=         allflag         equ     'A'     ; Option character for showing
  0000+                                          ; all file (both SYS and DIR)
  0053+=         sysflag         equ     'S'     ; Option character for showing
  0000+                                          ; SYS files only
  FFFF+=         sortnt          equ     yes     ; Sort file by name then type
  FFFF+=         wide            equ     yes     ; Make display for 80-column screen
  007C+=         fence           equ     '|'     ; Character to use as fence between columns
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'ECHO' command
ZAS Relocating Macro Assembler (v3.05                             page   14
                                                            
                                                            

  0000+          
  0000+          ; This command sends characters to the console or list device.  If ECHOLST is
  0000+          ; enabled, then code is included for sending characters to the LST device.
  0000+          ; Characters normally go the the console device and are normally upper or lower
  0000+          ; case depending on the setting of UPCASE.  The command line can have special
  0000+          ; command sequences to toggle the case of the output and to change the
  0000+          ; destination between the console and printer.  Any other character following
  0000+          ; the command character will be sent as is.  For the normal setting of the
  0000+          ; equates below (upcase/yes, cmdchar/%, prtchar/P, crtchar/C, lcasech/>,
  0000+          ; and ucasech/<) an example command line would be:
  0000+          ;       A0:ROOT>ECHO T%>HIS IS A TEST^M^J^IDONE%PONE, TWO, %<THREE
  0000+          ; The following text would be echoed to the console (inlcuding carriage return,
  0000+          ; linefeed, and tab characters, '|' indicates the left margin):
  0000+          ;       |This is a test
  0000+          ;       |       done
  0000+          ; The string "one, two, THREE" would be sent to the printer.
  0000+          
  0000+=         echolst         equ     no      ; Allow sending characters to LST device
  0000+          
  FFFF+=         upcase          equ     yes     ; Initial case of output
  0000+          
  0025+=         cmdchar         equ     '%'     ; Character to flag case change
  0000+          
  0050+=         prtchar         equ     'P'     ; Character to start sending output to
  0000+                                          ; the printer (must be upper case)
  0043+=         crtchar         equ     'C'     ; Character to start sending output to
  0000+                                          ; the CRT (must be upper case)
  003C+=         ucasechar       equ     '<'     ; Character after CASECHAR that toggles
  0000+                                          ; subsequent output to upper case
  003E+=         lcasechar       equ     '>'     ; Character after CASECHAR that toggles
  0000+                                          ; subsequent output to lower case
  0000+          
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; 'LIST' and 'TYPE' commands
  0000+          
  FFFF+=         pgdflt          equ     yes     ; Default to paging of console output
  0000+          
  0050+=         pgdflg          equ     'P'     ; Character to toggle paging status
  0000+          
  0000+          ;++++++++++ following value should be obtained from ENV
  0000+          
  0018+=         nlines          equ     24      ; Number of lines on console screen
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; PEEK COMMAND
  0000+          
  FFFF+=         peekhdr equ     yes             ; If yes, label the columns in the display with
  0000+                                          ; the low hex digit of the address
  0000+          
  FFFF+=         peekbdr equ     yes             ; If yes, include a line of hyphens under the
  0000+                                          ; column headers
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   15
                                                            
                                                            

  FFFF+=         peekchk equ     yes             ; If yes, the ending address will be tested to
  0000+                                          ; prevent overflow past FFFF (costs 5 bytes)
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; POKE COMMAND
  0000+          
  FFFF+=         POKEQ   EQU     TRUE            ;SET TRUE TO SUPPRESS CONSOLE MESSAGE TO SAVE
  0000+                                          ;CODE AND/OR IMPROVE SECURITY
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Register command
  0000+          
  FFFF+=         SETERR          EQU     TRUE    ;copy new reg value to pgm error flag
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; DISK RESET COMMAND
  0000+          
  FFFF+=         RESMSG          EQU     TRUE    ;print disk reset message
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; DISK SPACE COMMAND
  0000+          
  FFFF+=         DIRSP           EQU     TRUE    ;show space after dir
  FFFF+=         erasp           equ     true    ;show space after era
  FFFF+=         CPSP            EQU     TRUE    ;show space after cp
  0000+          
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; ERROR TESTING COMMAND
  0000+          
  FFFF+=         TESTM80         EQU     TRUE
  0000+=         TESTF80         EQU     FALSE
  0000+          
  0000+          ; Equates for addresses where error counts are kept by the programs to be
  0000+          ; tested for M80/F80, version 3.44
  0000+          
  0000+                   if     testm80
  3CED+=         m80f    equ     03cedh          ; Addr of word with fatal error count (m80)
  3CEF+=         m80w    equ     03cefh          ; Addr of word with warning error count (m80)
  0000+                   endif  ;testm80
  0000+          
  0000+                   if     testf80
  0000+          f80f    equ     001c1h          ; Addr of word with fatal error count (f80)
  0000+          f80w    equ     002adh          ; Addr of word with warning error count (f80)
  0000+                   endif  ;testf80
  0000+          
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   16
                                                            
                                                            

  0000+          ;----------------------------------------
  0000+          
  0000+          ; Wheel commands
  0000+          
  0000+=         whlquiet        equ     no      ; If yes, don't report wheel state with WHL cmd
  0000+          
  0000+          WPASS           MACRO
  0000+                          DB      'SYSTEM  '
  0000+                          ENDM
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command dispatch table
  0000+          
  0004+=         cmdsize equ     4               ; Length of each command name
  0000+          
  0000+          ;++++++++++ delete next line after changing Z33 and Z33MAC.LIB
  0000+          
  0004+=         nchars  equ     cmdsize
  0000+          
  0000+          cmdtbl  macro
  0000+                  command CLS,    clson,  false,  cls
  0000+                  command CP,     cpon,   wcp,    copy
  0000+                  command DIR,    diron,  wdir,   dir
  0000+                  command ECHO,   echoon, false,  echo
  0000+                  command ERA,    eraon,  wera,   era
  0000+                  command H,      true,   whrc,   clist
  0000+                  command LIST,   liston, wlist,  list
  0000+                  command NOTE,   noteon, false,  note
  0000+                  command P,      peekon, wpeek,  peek
  0000+                  command POKE,   pokeon, wpoke,  poke
  0000+                  command PORT,   porton, wport,  port
  0000+                  command PROT,   proton, wprot,  att
  0000+                  command R,      reson,  false,  reset
  0000+                  command REG,    regon,  wreg,   register
  0000+                  command REN,    renon,  wren,   ren
  0000+                  command SP,     spaceon,false,  space
  0000+                  command TST,    tston,  false,  testerr
  0000+                  command TYPE,   lton,   wtype,  type
  0000+                  command WHL,    whlon,  false,  whl
  0000+                  command WHLQ,   whlqon, wwhlq,  whlmsg
  0000+          
  0000+                   endm
  0000+          
  0000+                  maclib  z33mac.lib      ; Macros
  0000+          
  0000+          ; Z33MAC.LIB : Macros for use with ZCPR33
  0000+          
  0000+          ; General purpose macros
  0000+          
  0000+          PUTREG   MACRO
  0000+                  PUSH    HL              ; Save registers in order
  0000+                  PUSH    DE
  0000+                  PUSH    BC
  0000+                   ENDM
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   17
                                                            
                                                            

  0000+          GETREG   MACRO
  0000+                  POP     BC              ; Restore registers in order
  0000+                  POP     DE
  0000+                  POP     HL
  0000+                   ENDM
  0000+          
  0000+          SWAP     MACRO
  0000+                  RRCA                    ; Exchange nibbles
  0000+                  RRCA
  0000+                  RRCA
  0000+                  RRCA
  0000+                   ENDM
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for forming option bytes
  0000+          
  0000+          ; This macro generates a byte with bits corresponding to up to 8 option
  0000+          ; flags.  The bits are filled in the order of the parameters and are right
  0000+          ; justified in the byte.
  0000+          
  0000+          OPTFLAG MACRO   F1,F2,F3,F4,F5,F6,F7,F8
  0000+          
  0000+          FLAG    DEFL    0               ;; initial value
  0000+          
  0000+                  IRP     TEMP,<F1,F2,F3,F4,F5,F6,F7,F8>
  0000+          
  0000+                   IF     NOT NUL TEMP
  0000+          FLAG    DEFL    FLAG SHL 1
  0000+                   IF     TEMP
  0000+          FLAG    DEFL    FLAG OR 1
  0000+                   ENDIF  ;;temp
  0000+                   ENDIF  ;;not nul temp
  0000+          
  0000+                   ENDM                   ;; irp
  0000+          
  0000+                  DEFB    LOW FLAG
  0000+          
  0000+                   ENDM                   ;; optflag
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for directory scanning
  0000+          
  0000+          ; This macro resolves the command token for possible directory references.
  0000+          ; FORM1 and FORM2 can each be either "DU" or "DIR".  FORM2 can also be null.
  0000+          ; The two forms are scanned for in the indicated order.
  0000+          
  0000+          ; This macro preserves the pointer to the FCB in DE and to the next
  0000+          ; character in the line in HL.  On return, the FCB pointer has been restored,
  0000+          ; and the command string pointer is still on the stack.  The routines DUSCAN
  0000+          ; and DIRSCAN are called as needed.
  0000+          
  0000+          RESOLVE MACRO   FORM1,FORM2
  0000+          
  0000+                  LOCAL   RESOLVED
ZAS Relocating Macro Assembler (v3.05                             page   18
                                                            
                                                            

  0000+          
  0000+                  PUSH    HL              ; Save pointer to command string
  0000+                  PUSH    DE              ; Save pointer to FCB
  0000+                  CALL    FORM1&SCAN      ; Scan for the first directory form
  0000+          
  0000+                   IF     NOT NUL FORM2
  0000+          
  0000+                  JR      Z,GOTIT         ; Resolved successfully, so jump ahead
  0000+          
  0000+                  POP     DE              ; Restore pointers for use by second call
  0000+                  POP     HL
  0000+                  PUSH    HL              ; Save them again
  0000+                  PUSH    DE
  0000+                  CALL    FORM2&SCAN      ; Scan for the second directory form
  0000+          
  0000+                   ENDIF  ;not nul form2
  0000+          
  0000+          GOTIT:
  0000+                  POP     DE              ; Restore pointer to FCB
  0000+          
  0000+                   ENDM   ;resolve
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command table entry definition macro
  0000+          
  0000+          ; Macro to form an entry for one command in the table.  The first parameter is
  0000+          ; the name to be used for the command (no quotes); the second parameter is the
  0000+          ; flag that indicates whether or not the command is to be enabled; the third
  0000+          ; parameter is the wheel control flag; and the last parameter is the jump
  0000+          ; address to the code that carries out the command.  The command names are
  0000+          ; automatically padded out to the correct length (they will be truncated and
  0000+          ; an error message will result if a command name is too long).  The characters
  0000+          ; in the command name are automatically converted to upper case.
  0000+          
  0000+          COMMAND MACRO CMDNAME,ENABLEFLAG,WHEELFLAG,ADDRESS
  0000+          
  0000+                   IF     ENABLEFLAG      ;; Generate command only if enabled
  0000+          
  0000+          WHLMASK DEFL    WHEELFLAG       ;; Initialize variables
  0000+          COUNT   DEFL    CMDSIZE         ;; Initialize to size of each command name
  0000+          
  0000+                  IRPC    CHAR,CMDNAME    ;; Repeat over letters in command name
  0000+          
  0000+          COUNT   DEFL    COUNT - 1       ;; Count down characters in name
  0000+          
  0000+                   IF     [ COUNT LT CMDSIZE ]
  0000+          
  0000+                          ;; If character is lower case, convert to upper case
  0000+          
  0000+                   IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ] + 80H
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ]
ZAS Relocating Macro Assembler (v3.05                             page   19
                                                            
                                                            

  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ELSE   ;;NOT LOWER CASE
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    '&CHAR' + 80H   ;; IF CONTROLLED BY WHEEL, SET HIGH BIT
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    '&CHAR'         ;; IF NOT RESTRICTED, LEAVE HIGH BIT CLEAR
  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ENDIF  ;;LOWER CASE
  0000+          
  0000+                   ENDIF  ;;[ COUNT LT CMDSIZE ]
  0000+          
  0000+          WHLMASK DEFL    FALSE           ;; TURN OFF HIGH-BIT SETTING AFTER FIRST CHAR
  0000+          
  0000+                  ENDM    ;IRPC
  0000+          
  0000+                          ;; PAD COMMAND NAME WITH BLANKS
  0000+          
  0000+                   IF     [ COUNT GT CMDSIZE ]    ;; IF WE UNDERFLOWED
  0000+                  *** COMMAND NAME "&CMDNAME" IS TOO LONG / TRUNCATED ***
  0000+                   ELSE
  0000+                  REPT    COUNT
  0000+                  DEFB    ' '
  0000+                  ENDM
  0000+                   ENDIF  ;[ COUNT GT CMDSIZE ]
  0000+          
  0000+                  DW      ADDRESS         ;; DISPATCH ADDRESS FOR COMMAND
  0000+          
  0000+                   ENDIF  ;ENABLE
  0000+          
  0000+                  ENDM    ;COMMAND
  0000+          
  0000+          ; End Z33MAC.LIB
  0000+          
  0000+          
  0000           
  0000           ; Macro to define include directives for either ZAS or SLR assemblers.  For
  0000           ; other assemblers that do support file inclusion, modify the macro to specify
  0000           ; the correct directive.  For assemblers that do not support file inclusion,
  0000           ; a text editor will have to be used to read in the actual contents of each
  0000           ; file in place of the include statement.
  0000           
  0000           include macro   filename
  0000           
  0000                    if     zas
  0000                   .in             filename
  0000                    else   ;slr assembler
  0000                   $include        filename&.lib
  0000                    endif  ;zas
  0000           
  0000                    endm
  0000           
  0000           ;=============================================================================
  0000           ;
ZAS Relocating Macro Assembler (v3.05                             page   20
                                                            
                                                            

  0000           ;       E N T R Y    C O D E    S E C T I O N
  0000           ;
  0000           ;=============================================================================
  0000           
  E200                   org     rcp             ; From Z3BASE.LIB
  E200           
  E200 5A33524350        db      'Z3RCP'         ; Package ID
  E205           
  E205           
  E205           ;----------------------------------------
  E205           
  E205           ; Command table
  E205           
  E205 04                db      cmdsize         ; Length of each command name
  E206                   cmdtbl                  ; Dispatch table from Z33RCP.LIB
  E206                   command CLS,    clson,  false,  cls
  E206           
  E206                    IF     clson
  E206           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E206           
  E206                   IRPC    CHAR,CLS
  E206           
  E206           COUNT   DEFL    COUNT - 1
  E206           
  E206                    IF     [ COUNT LT CMDSIZE ]
  E206           
  E206           
  E206                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E206                    ELSE
  E206                   DEFB    [ '&CHAR' AND 5FH ]
  E206                    ENDIF
  E206           
  E206                    ELSE
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    '&CHAR' + 80H
  E206                    ELSE
  E206                   DEFB    '&CHAR'
  E206                    ENDIF
  E206           
  E206                    ENDIF
  E206           
  E206                    ENDIF
  E206           
  E206           WHLMASK DEFL    FALSE
  E206           
  E206                   ENDM    ;IRPC
  E206           
  0003 =         COUNT   DEFL    COUNT - 1
  E206           
  E206                    IF     [ COUNT LT CMDSIZE ]
ZAS Relocating Macro Assembler (v3.05                             page   21
                                                            
                                                            

  E206           
  E206           
  E206                    IF     [ 'C' GE 'a' ] AND [ 'C' LE 'z' ]
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    [ 'C' AND 5FH ] + 80H
  E206                    ELSE
  E206                   DEFB    [ 'C' AND 5FH ]
  E206                    ENDIF
  E206           
  E206                    ELSE
  E206           
  E206                    IF     WHLMASK
  E206                   DEFB    'C' + 80H
  E206                    ELSE
  E206 43                DEFB    'C'
  E207                    ENDIF
  E207           
  E207                    ENDIF
  E207           
  E207                    ENDIF
  E207           
  0000 =         WHLMASK DEFL    FALSE
  E207           
  E207           
  0002 =         COUNT   DEFL    COUNT - 1
  E207           
  E207                    IF     [ COUNT LT CMDSIZE ]
  E207           
  E207           
  E207                    IF     [ 'L' GE 'a' ] AND [ 'L' LE 'z' ]
  E207           
  E207                    IF     WHLMASK
  E207                   DEFB    [ 'L' AND 5FH ] + 80H
  E207                    ELSE
  E207                   DEFB    [ 'L' AND 5FH ]
  E207                    ENDIF
  E207           
  E207                    ELSE
  E207           
  E207                    IF     WHLMASK
  E207                   DEFB    'L' + 80H
  E207                    ELSE
  E207 4C                DEFB    'L'
  E208                    ENDIF
  E208           
  E208                    ENDIF
  E208           
  E208                    ENDIF
  E208           
  0000 =         WHLMASK DEFL    FALSE
  E208           
  E208           
  0001 =         COUNT   DEFL    COUNT - 1
  E208           
  E208                    IF     [ COUNT LT CMDSIZE ]
ZAS Relocating Macro Assembler (v3.05                             page   22
                                                            
                                                            

  E208           
  E208           
  E208                    IF     [ 'S' GE 'a' ] AND [ 'S' LE 'z' ]
  E208           
  E208                    IF     WHLMASK
  E208                   DEFB    [ 'S' AND 5FH ] + 80H
  E208                    ELSE
  E208                   DEFB    [ 'S' AND 5FH ]
  E208                    ENDIF
  E208           
  E208                    ELSE
  E208           
  E208                    IF     WHLMASK
  E208                   DEFB    'S' + 80H
  E208                    ELSE
  E208 53                DEFB    'S'
  E209                    ENDIF
  E209           
  E209                    ENDIF
  E209           
  E209                    ENDIF
  E209           
  0000 =         WHLMASK DEFL    FALSE
  E209           
  E209                   ENDM    ;IRPC
  E209           
  E209           
  E209                    IF     [ COUNT GT CMDSIZE ]
  E209                   *** COMMAND NAME "CLS" IS TOO LONG / TRUNCATED ***
  E209                    ELSE
  E209                   REPT    COUNT
  E209                   DEFB    ' '
  E209                   ENDM
  E209 20                DEFB    ' '
  E20A                   ENDM
  E20A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E20A           
  E20A AEE2              DW      cls
  E20C           
  E20C                    ENDIF  ;ENABLE
  E20C           
  E20C                   ENDM    ;COMMAND
  E20C                   command CP,     cpon,   wcp,    copy
  E20C           
  E20C                    IF     cpon
  E20C           
  E20C           WHLMASK DEFL    wcp
  E20C           COUNT   DEFL    CMDSIZE
  E20C           
  E20C                   IRPC    CHAR,CP
  E20C           
  E20C           COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
ZAS Relocating Macro Assembler (v3.05                             page   23
                                                            
                                                            

  E20C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E20C                    ELSE
  E20C                   DEFB    [ '&CHAR' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    '&CHAR' + 80H
  E20C                    ELSE
  E20C                   DEFB    '&CHAR'
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C           WHLMASK DEFL    FALSE
  E20C           
  E20C                   ENDM    ;IRPC
  E20C           
  E20C           
  E20C                    IF     [ COUNT GT CMDSIZE ]
  E20C                   *** COMMAND NAME "CP" IS TOO LONG / TRUNCATED ***
  E20C                    ELSE
  E20C                   REPT    COUNT
  E20C                   DEFB    ' '
  E20C                   ENDM
  E20C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E20C           
  E20C                   DW      copy
  E20C           
  E20C                    ENDIF  ;ENABLE
  E20C           
  E20C                   ENDM    ;COMMAND
  E20C                   command DIR,    diron,  wdir,   dir
  E20C           
  E20C                    IF     diron
  E20C           
  0000 =         WHLMASK DEFL    wdir
  0004 =         COUNT   DEFL    CMDSIZE
  E20C           
  E20C                   IRPC    CHAR,DIR
  E20C           
  E20C           COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
  E20C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
ZAS Relocating Macro Assembler (v3.05                             page   24
                                                            
                                                            

  E20C                    ELSE
  E20C                   DEFB    [ '&CHAR' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    '&CHAR' + 80H
  E20C                    ELSE
  E20C                   DEFB    '&CHAR'
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C                    ENDIF
  E20C           
  E20C           WHLMASK DEFL    FALSE
  E20C           
  E20C                   ENDM    ;IRPC
  E20C           
  0003 =         COUNT   DEFL    COUNT - 1
  E20C           
  E20C                    IF     [ COUNT LT CMDSIZE ]
  E20C           
  E20C           
  E20C                    IF     [ 'D' GE 'a' ] AND [ 'D' LE 'z' ]
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    [ 'D' AND 5FH ] + 80H
  E20C                    ELSE
  E20C                   DEFB    [ 'D' AND 5FH ]
  E20C                    ENDIF
  E20C           
  E20C                    ELSE
  E20C           
  E20C                    IF     WHLMASK
  E20C                   DEFB    'D' + 80H
  E20C                    ELSE
  E20C 44                DEFB    'D'
  E20D                    ENDIF
  E20D           
  E20D                    ENDIF
  E20D           
  E20D                    ENDIF
  E20D           
  0000 =         WHLMASK DEFL    FALSE
  E20D           
  E20D           
  0002 =         COUNT   DEFL    COUNT - 1
  E20D           
  E20D                    IF     [ COUNT LT CMDSIZE ]
  E20D           
  E20D           
  E20D                    IF     [ 'I' GE 'a' ] AND [ 'I' LE 'z' ]
  E20D           
  E20D                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   25
                                                            
                                                            

  E20D                   DEFB    [ 'I' AND 5FH ] + 80H
  E20D                    ELSE
  E20D                   DEFB    [ 'I' AND 5FH ]
  E20D                    ENDIF
  E20D           
  E20D                    ELSE
  E20D           
  E20D                    IF     WHLMASK
  E20D                   DEFB    'I' + 80H
  E20D                    ELSE
  E20D 49                DEFB    'I'
  E20E                    ENDIF
  E20E           
  E20E                    ENDIF
  E20E           
  E20E                    ENDIF
  E20E           
  0000 =         WHLMASK DEFL    FALSE
  E20E           
  E20E           
  0001 =         COUNT   DEFL    COUNT - 1
  E20E           
  E20E                    IF     [ COUNT LT CMDSIZE ]
  E20E           
  E20E           
  E20E                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E20E           
  E20E                    IF     WHLMASK
  E20E                   DEFB    [ 'R' AND 5FH ] + 80H
  E20E                    ELSE
  E20E                   DEFB    [ 'R' AND 5FH ]
  E20E                    ENDIF
  E20E           
  E20E                    ELSE
  E20E           
  E20E                    IF     WHLMASK
  E20E                   DEFB    'R' + 80H
  E20E                    ELSE
  E20E 52                DEFB    'R'
  E20F                    ENDIF
  E20F           
  E20F                    ENDIF
  E20F           
  E20F                    ENDIF
  E20F           
  0000 =         WHLMASK DEFL    FALSE
  E20F           
  E20F                   ENDM    ;IRPC
  E20F           
  E20F           
  E20F                    IF     [ COUNT GT CMDSIZE ]
  E20F                   *** COMMAND NAME "DIR" IS TOO LONG / TRUNCATED ***
  E20F                    ELSE
  E20F                   REPT    COUNT
  E20F                   DEFB    ' '
  E20F                   ENDM
ZAS Relocating Macro Assembler (v3.05                             page   26
                                                            
                                                            

  E20F 20                DEFB    ' '
  E210                   ENDM
  E210                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E210           
  E210 55E3              DW      dir
  E212           
  E212                    ENDIF  ;ENABLE
  E212           
  E212                   ENDM    ;COMMAND
  E212                   command ECHO,   echoon, false,  echo
  E212           
  E212                    IF     echoon
  E212           
  E212           WHLMASK DEFL    false
  E212           COUNT   DEFL    CMDSIZE
  E212           
  E212                   IRPC    CHAR,ECHO
  E212           
  E212           COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ '&CHAR' AND 5FH ]
  E212                    ENDIF
  E212           
  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    '&CHAR' + 80H
  E212                    ELSE
  E212                   DEFB    '&CHAR'
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212           WHLMASK DEFL    FALSE
  E212           
  E212                   ENDM    ;IRPC
  E212           
  E212           
  E212                    IF     [ COUNT GT CMDSIZE ]
  E212                   *** COMMAND NAME "ECHO" IS TOO LONG / TRUNCATED ***
  E212                    ELSE
  E212                   REPT    COUNT
  E212                   DEFB    ' '
  E212                   ENDM
  E212                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E212           
ZAS Relocating Macro Assembler (v3.05                             page   27
                                                            
                                                            

  E212                   DW      echo
  E212           
  E212                    ENDIF  ;ENABLE
  E212           
  E212                   ENDM    ;COMMAND
  E212                   command ERA,    eraon,  wera,   era
  E212           
  E212                    IF     eraon
  E212           
  FFFF =         WHLMASK DEFL    wera
  0004 =         COUNT   DEFL    CMDSIZE
  E212           
  E212                   IRPC    CHAR,ERA
  E212           
  E212           COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ '&CHAR' AND 5FH ]
  E212                    ENDIF
  E212           
  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    '&CHAR' + 80H
  E212                    ELSE
  E212                   DEFB    '&CHAR'
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212                    ENDIF
  E212           
  E212           WHLMASK DEFL    FALSE
  E212           
  E212                   ENDM    ;IRPC
  E212           
  0003 =         COUNT   DEFL    COUNT - 1
  E212           
  E212                    IF     [ COUNT LT CMDSIZE ]
  E212           
  E212           
  E212                    IF     [ 'E' GE 'a' ] AND [ 'E' LE 'z' ]
  E212           
  E212                    IF     WHLMASK
  E212                   DEFB    [ 'E' AND 5FH ] + 80H
  E212                    ELSE
  E212                   DEFB    [ 'E' AND 5FH ]
  E212                    ENDIF
  E212           
ZAS Relocating Macro Assembler (v3.05                             page   28
                                                            
                                                            

  E212                    ELSE
  E212           
  E212                    IF     WHLMASK
  E212 C5                DEFB    'E' + 80H
  E213                    ELSE
  E213                   DEFB    'E'
  E213                    ENDIF
  E213           
  E213                    ENDIF
  E213           
  E213                    ENDIF
  E213           
  0000 =         WHLMASK DEFL    FALSE
  E213           
  E213           
  0002 =         COUNT   DEFL    COUNT - 1
  E213           
  E213                    IF     [ COUNT LT CMDSIZE ]
  E213           
  E213           
  E213                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E213           
  E213                    IF     WHLMASK
  E213                   DEFB    [ 'R' AND 5FH ] + 80H
  E213                    ELSE
  E213                   DEFB    [ 'R' AND 5FH ]
  E213                    ENDIF
  E213           
  E213                    ELSE
  E213           
  E213                    IF     WHLMASK
  E213                   DEFB    'R' + 80H
  E213                    ELSE
  E213 52                DEFB    'R'
  E214                    ENDIF
  E214           
  E214                    ENDIF
  E214           
  E214                    ENDIF
  E214           
  0000 =         WHLMASK DEFL    FALSE
  E214           
  E214           
  0001 =         COUNT   DEFL    COUNT - 1
  E214           
  E214                    IF     [ COUNT LT CMDSIZE ]
  E214           
  E214           
  E214                    IF     [ 'A' GE 'a' ] AND [ 'A' LE 'z' ]
  E214           
  E214                    IF     WHLMASK
  E214                   DEFB    [ 'A' AND 5FH ] + 80H
  E214                    ELSE
  E214                   DEFB    [ 'A' AND 5FH ]
  E214                    ENDIF
  E214           
ZAS Relocating Macro Assembler (v3.05                             page   29
                                                            
                                                            

  E214                    ELSE
  E214           
  E214                    IF     WHLMASK
  E214                   DEFB    'A' + 80H
  E214                    ELSE
  E214 41                DEFB    'A'
  E215                    ENDIF
  E215           
  E215                    ENDIF
  E215           
  E215                    ENDIF
  E215           
  0000 =         WHLMASK DEFL    FALSE
  E215           
  E215                   ENDM    ;IRPC
  E215           
  E215           
  E215                    IF     [ COUNT GT CMDSIZE ]
  E215                   *** COMMAND NAME "ERA" IS TOO LONG / TRUNCATED ***
  E215                    ELSE
  E215                   REPT    COUNT
  E215                   DEFB    ' '
  E215                   ENDM
  E215 20                DEFB    ' '
  E216                   ENDM
  E216                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E216           
  E216 B3E3              DW      era
  E218           
  E218                    ENDIF  ;ENABLE
  E218           
  E218                   ENDM    ;COMMAND
  E218                   command H,      true,   whrc,   clist
  E218           
  E218                    IF     true
  E218           
  0000 =         WHLMASK DEFL    whrc
  0004 =         COUNT   DEFL    CMDSIZE
  E218           
  E218                   IRPC    CHAR,H
  E218           
  E218           COUNT   DEFL    COUNT - 1
  E218           
  E218                    IF     [ COUNT LT CMDSIZE ]
  E218           
  E218           
  E218                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E218                    ELSE
  E218                   DEFB    [ '&CHAR' AND 5FH ]
  E218                    ENDIF
  E218           
  E218                    ELSE
  E218           
ZAS Relocating Macro Assembler (v3.05                             page   30
                                                            
                                                            

  E218                    IF     WHLMASK
  E218                   DEFB    '&CHAR' + 80H
  E218                    ELSE
  E218                   DEFB    '&CHAR'
  E218                    ENDIF
  E218           
  E218                    ENDIF
  E218           
  E218                    ENDIF
  E218           
  E218           WHLMASK DEFL    FALSE
  E218           
  E218                   ENDM    ;IRPC
  E218           
  0003 =         COUNT   DEFL    COUNT - 1
  E218           
  E218                    IF     [ COUNT LT CMDSIZE ]
  E218           
  E218           
  E218                    IF     [ 'H' GE 'a' ] AND [ 'H' LE 'z' ]
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    [ 'H' AND 5FH ] + 80H
  E218                    ELSE
  E218                   DEFB    [ 'H' AND 5FH ]
  E218                    ENDIF
  E218           
  E218                    ELSE
  E218           
  E218                    IF     WHLMASK
  E218                   DEFB    'H' + 80H
  E218                    ELSE
  E218 48                DEFB    'H'
  E219                    ENDIF
  E219           
  E219                    ENDIF
  E219           
  E219                    ENDIF
  E219           
  0000 =         WHLMASK DEFL    FALSE
  E219           
  E219                   ENDM    ;IRPC
  E219           
  E219           
  E219                    IF     [ COUNT GT CMDSIZE ]
  E219                   *** COMMAND NAME "H" IS TOO LONG / TRUNCATED ***
  E219                    ELSE
  E219                   REPT    COUNT
  E219                   DEFB    ' '
  E219                   ENDM
  E219 20                DEFB    ' '
  E21A 20                DEFB    ' '
  E21B 20                DEFB    ' '
  E21C                   ENDM
  E21C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21C           
ZAS Relocating Macro Assembler (v3.05                             page   31
                                                            
                                                            

  E21C 41E2              DW      clist
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command LIST,   liston, wlist,  list
  E21E           
  E21E                    IF     liston
  E21E           
  E21E           WHLMASK DEFL    wlist
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,LIST
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "LIST" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      list
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   32
                                                            
                                                            

  E21E                   ENDM    ;COMMAND
  E21E                   command NOTE,   noteon, false,  note
  E21E           
  E21E                    IF     noteon
  E21E           
  E21E           WHLMASK DEFL    false
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,NOTE
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "NOTE" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      note
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command P,      peekon, wpeek,  peek
  E21E           
  E21E                    IF     peekon
ZAS Relocating Macro Assembler (v3.05                             page   33
                                                            
                                                            

  E21E           
  E21E           WHLMASK DEFL    wpeek
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,P
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "P" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      peek
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command POKE,   pokeon, wpoke,  poke
  E21E           
  E21E                    IF     pokeon
  E21E           
  E21E           WHLMASK DEFL    wpoke
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   34
                                                            
                                                            

  E21E                   IRPC    CHAR,POKE
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "POKE" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      poke
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command PORT,   porton, wport,  port
  E21E           
  E21E                    IF     porton
  E21E           
  E21E           WHLMASK DEFL    wport
  E21E           COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,PORT
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
ZAS Relocating Macro Assembler (v3.05                             page   35
                                                            
                                                            

  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  E21E           
  E21E                    IF     [ COUNT GT CMDSIZE ]
  E21E                   *** COMMAND NAME "PORT" IS TOO LONG / TRUNCATED ***
  E21E                    ELSE
  E21E                   REPT    COUNT
  E21E                   DEFB    ' '
  E21E                   ENDM
  E21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E21E           
  E21E                   DW      port
  E21E           
  E21E                    ENDIF  ;ENABLE
  E21E           
  E21E                   ENDM    ;COMMAND
  E21E                   command PROT,   proton, wprot,  att
  E21E           
  E21E                    IF     proton
  E21E           
  FFFF =         WHLMASK DEFL    wprot
  0004 =         COUNT   DEFL    CMDSIZE
  E21E           
  E21E                   IRPC    CHAR,PROT
  E21E           
  E21E           COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
ZAS Relocating Macro Assembler (v3.05                             page   36
                                                            
                                                            

  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ '&CHAR' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    '&CHAR' + 80H
  E21E                    ELSE
  E21E                   DEFB    '&CHAR'
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E                    ENDIF
  E21E           
  E21E           WHLMASK DEFL    FALSE
  E21E           
  E21E                   ENDM    ;IRPC
  E21E           
  0003 =         COUNT   DEFL    COUNT - 1
  E21E           
  E21E                    IF     [ COUNT LT CMDSIZE ]
  E21E           
  E21E           
  E21E                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E21E           
  E21E                    IF     WHLMASK
  E21E                   DEFB    [ 'P' AND 5FH ] + 80H
  E21E                    ELSE
  E21E                   DEFB    [ 'P' AND 5FH ]
  E21E                    ENDIF
  E21E           
  E21E                    ELSE
  E21E           
  E21E                    IF     WHLMASK
  E21E D0                DEFB    'P' + 80H
  E21F                    ELSE
  E21F                   DEFB    'P'
  E21F                    ENDIF
  E21F           
  E21F                    ENDIF
  E21F           
  E21F                    ENDIF
  E21F           
  0000 =         WHLMASK DEFL    FALSE
  E21F           
  E21F           
  0002 =         COUNT   DEFL    COUNT - 1
  E21F           
  E21F                    IF     [ COUNT LT CMDSIZE ]
  E21F           
  E21F           
ZAS Relocating Macro Assembler (v3.05                             page   37
                                                            
                                                            

  E21F                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E21F           
  E21F                    IF     WHLMASK
  E21F                   DEFB    [ 'R' AND 5FH ] + 80H
  E21F                    ELSE
  E21F                   DEFB    [ 'R' AND 5FH ]
  E21F                    ENDIF
  E21F           
  E21F                    ELSE
  E21F           
  E21F                    IF     WHLMASK
  E21F                   DEFB    'R' + 80H
  E21F                    ELSE
  E21F 52                DEFB    'R'
  E220                    ENDIF
  E220           
  E220                    ENDIF
  E220           
  E220                    ENDIF
  E220           
  0000 =         WHLMASK DEFL    FALSE
  E220           
  E220           
  0001 =         COUNT   DEFL    COUNT - 1
  E220           
  E220                    IF     [ COUNT LT CMDSIZE ]
  E220           
  E220           
  E220                    IF     [ 'O' GE 'a' ] AND [ 'O' LE 'z' ]
  E220           
  E220                    IF     WHLMASK
  E220                   DEFB    [ 'O' AND 5FH ] + 80H
  E220                    ELSE
  E220                   DEFB    [ 'O' AND 5FH ]
  E220                    ENDIF
  E220           
  E220                    ELSE
  E220           
  E220                    IF     WHLMASK
  E220                   DEFB    'O' + 80H
  E220                    ELSE
  E220 4F                DEFB    'O'
  E221                    ENDIF
  E221           
  E221                    ENDIF
  E221           
  E221                    ENDIF
  E221           
  0000 =         WHLMASK DEFL    FALSE
  E221           
  E221           
  0000 =         COUNT   DEFL    COUNT - 1
  E221           
  E221                    IF     [ COUNT LT CMDSIZE ]
  E221           
  E221           
ZAS Relocating Macro Assembler (v3.05                             page   38
                                                            
                                                            

  E221                    IF     [ 'T' GE 'a' ] AND [ 'T' LE 'z' ]
  E221           
  E221                    IF     WHLMASK
  E221                   DEFB    [ 'T' AND 5FH ] + 80H
  E221                    ELSE
  E221                   DEFB    [ 'T' AND 5FH ]
  E221                    ENDIF
  E221           
  E221                    ELSE
  E221           
  E221                    IF     WHLMASK
  E221                   DEFB    'T' + 80H
  E221                    ELSE
  E221 54                DEFB    'T'
  E222                    ENDIF
  E222           
  E222                    ENDIF
  E222           
  E222                    ENDIF
  E222           
  0000 =         WHLMASK DEFL    FALSE
  E222           
  E222                   ENDM    ;IRPC
  E222           
  E222           
  E222                    IF     [ COUNT GT CMDSIZE ]
  E222                   *** COMMAND NAME "PROT" IS TOO LONG / TRUNCATED ***
  E222                    ELSE
  E222                   REPT    COUNT
  E222                   DEFB    ' '
  E222                   ENDM
  E222                   ENDM
  E222                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E222           
  E222 E1E4              DW      att
  E224           
  E224                    ENDIF  ;ENABLE
  E224           
  E224                   ENDM    ;COMMAND
  E224                   command R,      reson,  false,  reset
  E224           
  E224                    IF     reson
  E224           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E224           
  E224                   IRPC    CHAR,R
  E224           
  E224           COUNT   DEFL    COUNT - 1
  E224           
  E224                    IF     [ COUNT LT CMDSIZE ]
  E224           
  E224           
  E224                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E224           
  E224                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   39
                                                            
                                                            

  E224                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E224                    ELSE
  E224                   DEFB    [ '&CHAR' AND 5FH ]
  E224                    ENDIF
  E224           
  E224                    ELSE
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    '&CHAR' + 80H
  E224                    ELSE
  E224                   DEFB    '&CHAR'
  E224                    ENDIF
  E224           
  E224                    ENDIF
  E224           
  E224                    ENDIF
  E224           
  E224           WHLMASK DEFL    FALSE
  E224           
  E224                   ENDM    ;IRPC
  E224           
  0003 =         COUNT   DEFL    COUNT - 1
  E224           
  E224                    IF     [ COUNT LT CMDSIZE ]
  E224           
  E224           
  E224                    IF     [ 'R' GE 'a' ] AND [ 'R' LE 'z' ]
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    [ 'R' AND 5FH ] + 80H
  E224                    ELSE
  E224                   DEFB    [ 'R' AND 5FH ]
  E224                    ENDIF
  E224           
  E224                    ELSE
  E224           
  E224                    IF     WHLMASK
  E224                   DEFB    'R' + 80H
  E224                    ELSE
  E224 52                DEFB    'R'
  E225                    ENDIF
  E225           
  E225                    ENDIF
  E225           
  E225                    ENDIF
  E225           
  0000 =         WHLMASK DEFL    FALSE
  E225           
  E225                   ENDM    ;IRPC
  E225           
  E225           
  E225                    IF     [ COUNT GT CMDSIZE ]
  E225                   *** COMMAND NAME "R" IS TOO LONG / TRUNCATED ***
  E225                    ELSE
  E225                   REPT    COUNT
  E225                   DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   40
                                                            
                                                            

  E225                   ENDM
  E225 20                DEFB    ' '
  E226 20                DEFB    ' '
  E227 20                DEFB    ' '
  E228                   ENDM
  E228                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E228           
  E228 C7E2              DW      reset
  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command REG,    regon,  wreg,   register
  E22A           
  E22A                    IF     regon
  E22A           
  E22A           WHLMASK DEFL    wreg
  E22A           COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,REG
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  E22A           
  E22A                    IF     [ COUNT GT CMDSIZE ]
  E22A                   *** COMMAND NAME "REG" IS TOO LONG / TRUNCATED ***
  E22A                    ELSE
  E22A                   REPT    COUNT
  E22A                   DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   41
                                                            
                                                            

  E22A                   ENDM
  E22A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22A           
  E22A                   DW      register
  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command REN,    renon,  wren,   ren
  E22A           
  E22A                    IF     renon
  E22A           
  E22A           WHLMASK DEFL    wren
  E22A           COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,REN
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  E22A           
  E22A                    IF     [ COUNT GT CMDSIZE ]
  E22A                   *** COMMAND NAME "REN" IS TOO LONG / TRUNCATED ***
  E22A                    ELSE
  E22A                   REPT    COUNT
  E22A                   DEFB    ' '
  E22A                   ENDM
  E22A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22A           
  E22A                   DW      ren
ZAS Relocating Macro Assembler (v3.05                             page   42
                                                            
                                                            

  E22A           
  E22A                    ENDIF  ;ENABLE
  E22A           
  E22A                   ENDM    ;COMMAND
  E22A                   command SP,     spaceon,false,  space
  E22A           
  E22A                    IF     spaceon
  E22A           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E22A           
  E22A                   IRPC    CHAR,SP
  E22A           
  E22A           COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ '&CHAR' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    '&CHAR' + 80H
  E22A                    ELSE
  E22A                   DEFB    '&CHAR'
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A                    ENDIF
  E22A           
  E22A           WHLMASK DEFL    FALSE
  E22A           
  E22A                   ENDM    ;IRPC
  E22A           
  0003 =         COUNT   DEFL    COUNT - 1
  E22A           
  E22A                    IF     [ COUNT LT CMDSIZE ]
  E22A           
  E22A           
  E22A                    IF     [ 'S' GE 'a' ] AND [ 'S' LE 'z' ]
  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    [ 'S' AND 5FH ] + 80H
  E22A                    ELSE
  E22A                   DEFB    [ 'S' AND 5FH ]
  E22A                    ENDIF
  E22A           
  E22A                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   43
                                                            
                                                            

  E22A           
  E22A                    IF     WHLMASK
  E22A                   DEFB    'S' + 80H
  E22A                    ELSE
  E22A 53                DEFB    'S'
  E22B                    ENDIF
  E22B           
  E22B                    ENDIF
  E22B           
  E22B                    ENDIF
  E22B           
  0000 =         WHLMASK DEFL    FALSE
  E22B           
  E22B           
  0002 =         COUNT   DEFL    COUNT - 1
  E22B           
  E22B                    IF     [ COUNT LT CMDSIZE ]
  E22B           
  E22B           
  E22B                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E22B           
  E22B                    IF     WHLMASK
  E22B                   DEFB    [ 'P' AND 5FH ] + 80H
  E22B                    ELSE
  E22B                   DEFB    [ 'P' AND 5FH ]
  E22B                    ENDIF
  E22B           
  E22B                    ELSE
  E22B           
  E22B                    IF     WHLMASK
  E22B                   DEFB    'P' + 80H
  E22B                    ELSE
  E22B 50                DEFB    'P'
  E22C                    ENDIF
  E22C           
  E22C                    ENDIF
  E22C           
  E22C                    ENDIF
  E22C           
  0000 =         WHLMASK DEFL    FALSE
  E22C           
  E22C                   ENDM    ;IRPC
  E22C           
  E22C           
  E22C                    IF     [ COUNT GT CMDSIZE ]
  E22C                   *** COMMAND NAME "SP" IS TOO LONG / TRUNCATED ***
  E22C                    ELSE
  E22C                   REPT    COUNT
  E22C                   DEFB    ' '
  E22C                   ENDM
  E22C 20                DEFB    ' '
  E22D 20                DEFB    ' '
  E22E                   ENDM
  E22E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E22E           
  E22E D8E2              DW      space
ZAS Relocating Macro Assembler (v3.05                             page   44
                                                            
                                                            

  E230           
  E230                    ENDIF  ;ENABLE
  E230           
  E230                   ENDM    ;COMMAND
  E230                   command TST,    tston,  false,  testerr
  E230           
  E230                    IF     tston
  E230           
  E230           WHLMASK DEFL    false
  E230           COUNT   DEFL    CMDSIZE
  E230           
  E230                   IRPC    CHAR,TST
  E230           
  E230           COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ '&CHAR' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    '&CHAR' + 80H
  E230                    ELSE
  E230                   DEFB    '&CHAR'
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230           WHLMASK DEFL    FALSE
  E230           
  E230                   ENDM    ;IRPC
  E230           
  E230           
  E230                    IF     [ COUNT GT CMDSIZE ]
  E230                   *** COMMAND NAME "TST" IS TOO LONG / TRUNCATED ***
  E230                    ELSE
  E230                   REPT    COUNT
  E230                   DEFB    ' '
  E230                   ENDM
  E230                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E230           
  E230                   DW      testerr
  E230           
  E230                    ENDIF  ;ENABLE
  E230           
  E230                   ENDM    ;COMMAND
ZAS Relocating Macro Assembler (v3.05                             page   45
                                                            
                                                            

  E230                   command TYPE,   lton,   wtype,  type
  E230           
  E230                    IF     lton
  E230           
  FFFF =         WHLMASK DEFL    wtype
  0004 =         COUNT   DEFL    CMDSIZE
  E230           
  E230                   IRPC    CHAR,TYPE
  E230           
  E230           COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ '&CHAR' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    '&CHAR' + 80H
  E230                    ELSE
  E230                   DEFB    '&CHAR'
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230                    ENDIF
  E230           
  E230           WHLMASK DEFL    FALSE
  E230           
  E230                   ENDM    ;IRPC
  E230           
  0003 =         COUNT   DEFL    COUNT - 1
  E230           
  E230                    IF     [ COUNT LT CMDSIZE ]
  E230           
  E230           
  E230                    IF     [ 'T' GE 'a' ] AND [ 'T' LE 'z' ]
  E230           
  E230                    IF     WHLMASK
  E230                   DEFB    [ 'T' AND 5FH ] + 80H
  E230                    ELSE
  E230                   DEFB    [ 'T' AND 5FH ]
  E230                    ENDIF
  E230           
  E230                    ELSE
  E230           
  E230                    IF     WHLMASK
  E230 D4                DEFB    'T' + 80H
  E231                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   46
                                                            
                                                            

  E231                   DEFB    'T'
  E231                    ENDIF
  E231           
  E231                    ENDIF
  E231           
  E231                    ENDIF
  E231           
  0000 =         WHLMASK DEFL    FALSE
  E231           
  E231           
  0002 =         COUNT   DEFL    COUNT - 1
  E231           
  E231                    IF     [ COUNT LT CMDSIZE ]
  E231           
  E231           
  E231                    IF     [ 'Y' GE 'a' ] AND [ 'Y' LE 'z' ]
  E231           
  E231                    IF     WHLMASK
  E231                   DEFB    [ 'Y' AND 5FH ] + 80H
  E231                    ELSE
  E231                   DEFB    [ 'Y' AND 5FH ]
  E231                    ENDIF
  E231           
  E231                    ELSE
  E231           
  E231                    IF     WHLMASK
  E231                   DEFB    'Y' + 80H
  E231                    ELSE
  E231 59                DEFB    'Y'
  E232                    ENDIF
  E232           
  E232                    ENDIF
  E232           
  E232                    ENDIF
  E232           
  0000 =         WHLMASK DEFL    FALSE
  E232           
  E232           
  0001 =         COUNT   DEFL    COUNT - 1
  E232           
  E232                    IF     [ COUNT LT CMDSIZE ]
  E232           
  E232           
  E232                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  E232           
  E232                    IF     WHLMASK
  E232                   DEFB    [ 'P' AND 5FH ] + 80H
  E232                    ELSE
  E232                   DEFB    [ 'P' AND 5FH ]
  E232                    ENDIF
  E232           
  E232                    ELSE
  E232           
  E232                    IF     WHLMASK
  E232                   DEFB    'P' + 80H
  E232                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   47
                                                            
                                                            

  E232 50                DEFB    'P'
  E233                    ENDIF
  E233           
  E233                    ENDIF
  E233           
  E233                    ENDIF
  E233           
  0000 =         WHLMASK DEFL    FALSE
  E233           
  E233           
  0000 =         COUNT   DEFL    COUNT - 1
  E233           
  E233                    IF     [ COUNT LT CMDSIZE ]
  E233           
  E233           
  E233                    IF     [ 'E' GE 'a' ] AND [ 'E' LE 'z' ]
  E233           
  E233                    IF     WHLMASK
  E233                   DEFB    [ 'E' AND 5FH ] + 80H
  E233                    ELSE
  E233                   DEFB    [ 'E' AND 5FH ]
  E233                    ENDIF
  E233           
  E233                    ELSE
  E233           
  E233                    IF     WHLMASK
  E233                   DEFB    'E' + 80H
  E233                    ELSE
  E233 45                DEFB    'E'
  E234                    ENDIF
  E234           
  E234                    ENDIF
  E234           
  E234                    ENDIF
  E234           
  0000 =         WHLMASK DEFL    FALSE
  E234           
  E234                   ENDM    ;IRPC
  E234           
  E234           
  E234                    IF     [ COUNT GT CMDSIZE ]
  E234                   *** COMMAND NAME "TYPE" IS TOO LONG / TRUNCATED ***
  E234                    ELSE
  E234                   REPT    COUNT
  E234                   DEFB    ' '
  E234                   ENDM
  E234                   ENDM
  E234                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E234           
  E234 FCE3              DW      type
  E236           
  E236                    ENDIF  ;ENABLE
  E236           
  E236                   ENDM    ;COMMAND
  E236                   command WHL,    whlon,  false,  whl
  E236           
ZAS Relocating Macro Assembler (v3.05                             page   48
                                                            
                                                            

  E236                    IF     whlon
  E236           
  0000 =         WHLMASK DEFL    false
  0004 =         COUNT   DEFL    CMDSIZE
  E236           
  E236                   IRPC    CHAR,WHL
  E236           
  E236           COUNT   DEFL    COUNT - 1
  E236           
  E236                    IF     [ COUNT LT CMDSIZE ]
  E236           
  E236           
  E236                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E236                    ELSE
  E236                   DEFB    [ '&CHAR' AND 5FH ]
  E236                    ENDIF
  E236           
  E236                    ELSE
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    '&CHAR' + 80H
  E236                    ELSE
  E236                   DEFB    '&CHAR'
  E236                    ENDIF
  E236           
  E236                    ENDIF
  E236           
  E236                    ENDIF
  E236           
  E236           WHLMASK DEFL    FALSE
  E236           
  E236                   ENDM    ;IRPC
  E236           
  0003 =         COUNT   DEFL    COUNT - 1
  E236           
  E236                    IF     [ COUNT LT CMDSIZE ]
  E236           
  E236           
  E236                    IF     [ 'W' GE 'a' ] AND [ 'W' LE 'z' ]
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    [ 'W' AND 5FH ] + 80H
  E236                    ELSE
  E236                   DEFB    [ 'W' AND 5FH ]
  E236                    ENDIF
  E236           
  E236                    ELSE
  E236           
  E236                    IF     WHLMASK
  E236                   DEFB    'W' + 80H
  E236                    ELSE
  E236 57                DEFB    'W'
  E237                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   49
                                                            
                                                            

  E237           
  E237                    ENDIF
  E237           
  E237                    ENDIF
  E237           
  0000 =         WHLMASK DEFL    FALSE
  E237           
  E237           
  0002 =         COUNT   DEFL    COUNT - 1
  E237           
  E237                    IF     [ COUNT LT CMDSIZE ]
  E237           
  E237           
  E237                    IF     [ 'H' GE 'a' ] AND [ 'H' LE 'z' ]
  E237           
  E237                    IF     WHLMASK
  E237                   DEFB    [ 'H' AND 5FH ] + 80H
  E237                    ELSE
  E237                   DEFB    [ 'H' AND 5FH ]
  E237                    ENDIF
  E237           
  E237                    ELSE
  E237           
  E237                    IF     WHLMASK
  E237                   DEFB    'H' + 80H
  E237                    ELSE
  E237 48                DEFB    'H'
  E238                    ENDIF
  E238           
  E238                    ENDIF
  E238           
  E238                    ENDIF
  E238           
  0000 =         WHLMASK DEFL    FALSE
  E238           
  E238           
  0001 =         COUNT   DEFL    COUNT - 1
  E238           
  E238                    IF     [ COUNT LT CMDSIZE ]
  E238           
  E238           
  E238                    IF     [ 'L' GE 'a' ] AND [ 'L' LE 'z' ]
  E238           
  E238                    IF     WHLMASK
  E238                   DEFB    [ 'L' AND 5FH ] + 80H
  E238                    ELSE
  E238                   DEFB    [ 'L' AND 5FH ]
  E238                    ENDIF
  E238           
  E238                    ELSE
  E238           
  E238                    IF     WHLMASK
  E238                   DEFB    'L' + 80H
  E238                    ELSE
  E238 4C                DEFB    'L'
  E239                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   50
                                                            
                                                            

  E239           
  E239                    ENDIF
  E239           
  E239                    ENDIF
  E239           
  0000 =         WHLMASK DEFL    FALSE
  E239           
  E239                   ENDM    ;IRPC
  E239           
  E239           
  E239                    IF     [ COUNT GT CMDSIZE ]
  E239                   *** COMMAND NAME "WHL" IS TOO LONG / TRUNCATED ***
  E239                    ELSE
  E239                   REPT    COUNT
  E239                   DEFB    ' '
  E239                   ENDM
  E239 20                DEFB    ' '
  E23A                   ENDM
  E23A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E23A           
  E23A 94E5              DW      whl
  E23C           
  E23C                    ENDIF  ;ENABLE
  E23C           
  E23C                   ENDM    ;COMMAND
  E23C                   command WHLQ,   whlqon, wwhlq,  whlmsg
  E23C           
  E23C                    IF     whlqon
  E23C           
  E23C           WHLMASK DEFL    wwhlq
  E23C           COUNT   DEFL    CMDSIZE
  E23C           
  E23C                   IRPC    CHAR,WHLQ
  E23C           
  E23C           COUNT   DEFL    COUNT - 1
  E23C           
  E23C                    IF     [ COUNT LT CMDSIZE ]
  E23C           
  E23C           
  E23C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  E23C           
  E23C                    IF     WHLMASK
  E23C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  E23C                    ELSE
  E23C                   DEFB    [ '&CHAR' AND 5FH ]
  E23C                    ENDIF
  E23C           
  E23C                    ELSE
  E23C           
  E23C                    IF     WHLMASK
  E23C                   DEFB    '&CHAR' + 80H
  E23C                    ELSE
  E23C                   DEFB    '&CHAR'
  E23C                    ENDIF
  E23C           
  E23C                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   51
                                                            
                                                            

  E23C           
  E23C                    ENDIF
  E23C           
  E23C           WHLMASK DEFL    FALSE
  E23C           
  E23C                   ENDM    ;IRPC
  E23C           
  E23C           
  E23C                    IF     [ COUNT GT CMDSIZE ]
  E23C                   *** COMMAND NAME "WHLQ" IS TOO LONG / TRUNCATED ***
  E23C                    ELSE
  E23C                   REPT    COUNT
  E23C                   DEFB    ' '
  E23C                   ENDM
  E23C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  E23C           
  E23C                   DW      whlmsg
  E23C           
  E23C                    ENDIF  ;ENABLE
  E23C           
  E23C                   ENDM    ;COMMAND
  E23C           
  E23C                    endm
  E23C 00                db      0               ; Marks end of command jump table
  E23D           
  E23D           
  E23D           ;----------------------------------------
  E23D           
  E23D           ; Name of RCP
  E23D           
  E23D           ; This block allows the 'H' command and/or the SHOW utility to display a name
  E23D           ; and version number for this RCP as well as the commands that are supported.
  E23D           
  E23D           rcpname:
  E23D                   idstring                ; From macro in Z33RCP.LIB
  E23D 524350            db      'RCP'           ; Name of Z33RCP module
  E240           ;       db      ' '
  E240           ;       db      version + '0'   ; Main version number
  E240           ;       db      '.'
  E240           ;       db      subver + '0'    ; Subversion number
  E240           ;       db      rcpid           ; User's ID character from Z33RCP.LIB
  E240 00                db      0               ; End of name string
  E241                    endm
  E241           
  E241           ; Include only those code sections that are required.
  E241           
  E241+                  include rcph            ; 'H'   help (command list) command
ZAS Relocating Macro Assembler (v3.05                             page   52
                                                            
                                                            

  E241+                  page
  E241+          
  E241+          ; RCP-H.Z80     'H' Command
  E241+          
  E241+          ;=============================================================================
  E241+          ;
  E241+          ;       H E L P    C O M M A N D
  E241+          ;
  E241+          ;=============================================================================
  E241+          
  E241+          ; This command displays a list of all resident commands that are supported,
  E241+          ; including those in the CPR (command processor), RCP, and FCP.
  E241+          
  E241+          clist:
  E241+          
  E241+          ; Print the FCP-resident command names
  E241+          
  E241+                   if     listfcp
  E241+          
  E241+2A12EC            ld      hl,(z3env+12h)  ; Get FCP address
  E244+7C                ld      a,h             ; See if implemented
  E245+B5                or      l
  E246+280E              jr      z,nofcp
  E248+          
  E248+110500            ld      de,5
  E24B+19                add     hl,de
  E24C+          
  E24C+CD0FE6            call    print           ; Print header for FCP
  E24F+0A                db      lf
  E250+4643D0            db      'FC','P'+80h
  E253+CD6FE2            call    cmdlist         ; Display list of commands
  E256+          
  E256+          nofcp:
  E256+          
  E256+                   endif  ;listfcp
  E256+          
  E256+          ; Print the CPR-resident command names
  E256+          
  E256+                   if     listcpr
  E256+          
  E256+CD0FE6            call    print           ; Print "CPR"
  E259+0A                db      lf
  E25A+4350D2            db      'CP','R'+80h
  E25D+2119C2            ld      hl,ccp+offcmd   ; Point to command table in CPR
  E260+CD6FE2            call    cmdlist         ; Display the list of commands
  E263+          
  E263+                   endif  ;listcpr
  E263+          
  E263+          ; Print the RCP-resident command names
  E263+          
  E263+CD1FE6            call    crlf            ; Skip a line
  E266+213DE2            ld      hl,rcpname      ; Print RCP name
  E269+CD15E6            call    printhl
  E26C+2105E2            ld      hl,rcp+5        ; Point to RCP command table
  E26F+                                          ; Fall through to CMDLIST
  E26F+          
ZAS Relocating Macro Assembler (v3.05                             page   53
                                                            
                                                            

  E26F+          ;----------------------------------------
  E26F+          
  E26F+          ; Subroutine to display list of commands in a command table (code above
  E26F+          ; falls through to this routine -- do not move it).  The commands are
  E26F+          ; displayed 5 per line with 8 character spaces allowed for each command
  E26F+          ; (subject to equates below).
  E26F+          
  E26F+          cmdlist:
  E26F+CD1FE6            call    crlf            ; Start with new line
  E272+5E                ld      e,(hl)          ; Get size of each command name into DE
  E273+1600              ld      d,0
  E275+23                inc     hl              ; Point to name of first command
  E276+0E05              ld      c,cmdsline      ; Set names-per-line value
  E278+          
  E278+          cmdlist1:
  E278+7E                ld      a,(hl)          ; Get first character of the command name
  E279+B7                or      a               ; See if it is null
  E27A+2007              jr      nz,cmdlist1a    ; If not, continue
  E27C+3E05              ld      a,cmdsline      ; See if we are already on a new line
  E27E+B9                cp      c
  E27F+C41FE6            call    nz,crlf         ; If not, skip a line
  E282+C9                ret
  E283+          
  E283+          cmdlist1a:
  E283+                   if     noshow          ; Option to suppress wheel-limited cmds
  E283+17                rla                     ; Shift high bit of name into carry bit
  E284+3009              jr      nc,cmdlist2     ; If not restricted, go on
  E286+3AFFED            ld      a,(z3whl)       ; Otherwise, check wheel byte
  E289+B7                or      a
  E28A+2003              jr      nz,cmdlist2     ; If wheel set, continue as usual
  E28C+19                add     hl,de           ; Otherwise skip this command
  E28D+181B              jr      cmdlist5
  E28F+                   endif
  E28F+          
  E28F+          ; Print leading spaces between names
  E28F+          
  E28F+          cmdlist2:
  E28F+3E08              ld      a,cmdspace      ; Spacing between command names
  E291+93                sub     e               ; Less length of each command name
  E292+47                ld      b,a
  E293+3E20              ld      a,' '
  E295+          cmdlist3:
  E295+CDFEE5            call    conout
  E298+10FB              djnz    cmdlist3
  E29A+          
  E29A+          ; Print name of command
  E29A+          
  E29A+43                ld      b,e             ; Length of each name into B
  E29B+          cmdlist4:
  E29B+7E                ld      a,(hl)          ; Get command name character
  E29C+CDFEE5            call    conout
  E29F+23                inc     hl              ; Point to next
  E2A0+10F9              djnz    cmdlist4
  E2A2+          
  E2A2+0D                dec     c               ; Decrement count of names on this line
  E2A3+2005              jr      nz,cmdlist5     ; Branch if room for more names
ZAS Relocating Macro Assembler (v3.05                             page   54
                                                            
                                                            

  E2A5+CD1FE6            call    crlf            ; Otherwise, end this line and
  E2A8+0E05              ld      c,cmdsline      ; ..reset count for another line of commands
  E2AA+          
  E2AA+          ; Skip to next command name
  E2AA+          
  E2AA+          cmdlist5:
  E2AA+23                inc     hl              ; Skip jump vector
  E2AB+23                inc     hl
  E2AC+18CA              jr      cmdlist1        ; Back to process next name
  E2AE+          
  E2AE+          ; End RCP-H.Z80
  E2AE+          
  E2AE           
  E2AE                    if     clson
  E2AE+                  include rcpcls          ; 'CLS' clear screen command
ZAS Relocating Macro Assembler (v3.05                             page   55
                                                            
                                                            

  E2AE+                  page
  E2AE+          
  E2AE+          ; RCP-CLS.Z80   'CLS' Command
  E2AE+          
  E2AE+          ;=============================================================================
  E2AE+          ;
  E2AE+          ;               C L E A R    S C R E E N    C O M M A N D
  E2AE+          ;
  E2AE+          ;=============================================================================
  E2AE+          
  E2AE+          ; Command:      CLS
  E2AE+          ; Function:     To clear the CRT screen
  E2AE+          ; Comments:     The setting of the CLSTCAP equate determines whether this
  E2AE+          ;               command uses the TCAP information or not.  If not, it uses the
  E2AE+          ;               clear-screen string passed in macro CLSSTR.  That string should
  E2AE+          ;               end with the high bit set.
  E2AE+          
  E2AE+          cls:
  E2AE+                   if     clstcap         ; If using TCAP for clear screen string
  E2AE+          
  E2AE+3A80EC            ld      a,(z3env+80h)   ; Get beginning of tcap
  E2B1+FE21              cp      ' '+1           ; See if blank
  E2B3+300C              jr      nc,cls1         ; If not, go to clear screen code
  E2B5+CD0FE6            call    print           ; If blank, then give error message
  E2B8+204E6F2054        db      ' No TCA','P'+80h
  E2C0+C9                ret
  E2C1+          
  E2C1+2197EC    cls1:   ld      hl,z3env+97h    ; Point to beginning of clear screen string
  E2C4+C315E6            jp      printhl         ; Display it
  E2C7+          
  E2C7+                   else                   ; Not using tcap
  E2C7+          
  E2C7+                  call    print
  E2C7+                  clsstr                  ; String from Z33RCP.LIB
  E2C7+                  ret
  E2C7+          
  E2C7+                   endif  ;clstcap
  E2C7+          
  E2C7+          ; End RCP-CLS.Z80
  E2C7+          
  E2C7                    endif  ;clson
  E2C7           
  E2C7                    if     reson
  E2C7+                  include rcpr            ; 'R'   disk reset command
ZAS Relocating Macro Assembler (v3.05                             page   56
                                                            
                                                            

  E2C7+                  page
  E2C7+          
  E2C7+          ; RCP-R.Z80     'R' command
  E2C7+          
  E2C7+          ;=============================================================================
  E2C7+          ;
  E2C7+          ;       D I S K    R E S E T    C O M M A N D
  E2C7+          ;
  E2C7+          ;=============================================================================
  E2C7+          
  E2C7+          ; Command:      RESET
  E2C7+          ; Function:     Reset the disk system
  E2C7+          ; Comments:     ZRDOS does not require a disk system reset when disks are
  E2C7+          ;               changed, but directory programs will not show the correct
  E2C7+          ;               size if this is not done.  It is also good practice.  Since
  E2C7+          ;               no warm boot performed, the disk in drive A need not have the
  E2C7+          ;               operating system on it.
  E2C7+          
  E2C7+          reset:
  E2C7+0E0D              ld      c,13            ; Disk reset BDOS function
  E2C9+          
  E2C9+                   if     resmsg          ; If displaying a reset message
  E2C9+CD06CA            call    bdos            ; Reset disk system
  E2CC+CD0FE6            call    print           ; Report action
  E2CF+72657365F4        db      'rese','t'+80h
  E2D4+C9                ret
  E2D5+                   else                   ; No reset message
  E2D5+                  jp      bdos            ; Call bdos and return
  E2D5+                   endif  ;resmsg
  E2D5+          
  E2D5+          ; End RCP-R.Z80
  E2D5+          
  E2D5                    endif  ;reson
  E2D5           
  E2D5                    if     tston
  E2D5                   include rcptst          ; 'TST' error test command
  E2D5                    endif  ;tston
  E2D5           
  E2D5                    if     spaceon
  E2D5+                  include rcpsp           ; 'SP'  space on disk command
ZAS Relocating Macro Assembler (v3.05                             page   57
                                                            
                                                            

  E2D5+                  page
  E2D5+          
  E2D5+          ; RCP-SP.Z80    'SP' Command
  E2D5+          
  E2D5+          ;=============================================================================
  E2D5+          ;
  E2D5+          ;       D I S K    S P A C E    C O M M A N D
  E2D5+          ;
  E2D5+          ;=============================================================================
  E2D5+          
  E2D5+          ; Command:      SP
  E2D5+          ; Function:     Shows space remaining on designated drive
  E2D5+          ; Syntax:       SP [DIR:|DU:]
  E2D5+          ; Comments:     This code can be called by several other RCP commands so that
  E2D5+          ;               they can show the space remaining on the disk after their
  E2D5+          ;               operation.
  E2D5+          
  E2D5+                   if     [erasp or cpsp or dirsp]
  E2D5+          crspace:                        ; Used to call space after other subroutines
  E2D5+CD1FE6            call    crlf            ; Start new line
  E2D8+                   endif  ;[erasp or cpsp or dirsp]
  E2D8+          
  E2D8+          space:
  E2D8+3A5C00            ld      a,(fcb1)        ; Determine requested drive
  E2DB+B7                or      a               ; If drive explicitly selected
  E2DC+2006              jr      nz,space1       ; ..then skip
  E2DE+          
  E2DE+0E19              ld      c,25            ; BDOS get current drive function
  E2E0+CD06CA            call    bdos
  E2E3+3C                inc     a               ; Shift to range 1..16
  E2E4+          
  E2E4+          space1:
  E2E4+3D                dec     a               ; Shift to range 0..15
  E2E5+5F                ld      e,a             ; Save in E for selecting disk below
  E2E6+C641              add     'A'             ; Convert to letter and
  E2E8+323CE3            ld      (seldrv),a      ;   save in message string below
  E2EB+0E0E              ld      c,14            ; BDOS select disk function
  E2ED+CD06CA            call    bdos            ; Not needed if no drive selected, but smallest
  E2F0+                                          ; ..possible code size this way.
  E2F0+          
  E2F0+          ; Here we extract the following disk parameter information from the disk
  E2F0+          ; parameter block (DPB):
  E2F0+          ;       BLKSHF: block shift factor (1 byte)
  E2F0+          ;       BLKMAX: max number of blocks on disk (2 bytes)
  E2F0+          
  E2F0+          dparams:
  E2F0+0E1F              ld      c,31            ; BDOS get disk parameters function
  E2F2+CD06CA            call    bdos
  E2F5+23                inc     hl              ; Advance to block shift factor byte
  E2F6+23                inc     hl
  E2F7+7E                ld      a,(hl)          ; Get value and
  E2F8+3226E3            ld      (blkshf),a      ; ..save it in code below
  E2FB+23                inc     hl              ; Advance to max block number word
  E2FC+23                inc     hl
  E2FD+23                inc     hl
  E2FE+5E                ld      e,(hl)          ; Get value into HL
ZAS Relocating Macro Assembler (v3.05                             page   58
                                                            
                                                            

  E2FF+23                inc     hl
  E300+56                ld      d,(hl)
  E301+13                inc     de              ; Add 1 for max number of blocks
  E302+          
  E302+          ; Compute amount of free space left on disk
  E302+          
  E302+          dfree:
  E302+0E1B              ld      c,27            ; BDOS get allocation vector function
  E304+D5                push    de              ; Save BLKMAX value
  E305+CD06CA            call    bdos            ; Get allocation vector into HL
  E308+44                ld      b,h             ; Copy allocation vector to BC
  E309+4D                ld      c,l
  E30A+E1                pop     hl              ; Restore MAXBLK value to HL
  E30B+110000            ld      de,0            ; Inititialize count of free blocks
  E30E+          
  E30E+          ; At this point we have
  E30E+          ;       BC = allocation vector address
  E30E+          ;       DE = free block count
  E30E+          ;       HL = number of blocks on disk
  E30E+          
  E30E+          free1:
  E30E+C5                push    bc              ; Save allocation address
  E30F+0A                ld      a,(bc)          ; Get bit pattern of allocation byte
  E310+0608              ld      b,8             ; Set to process 8 blocks
  E312+          free2:
  E312+17                rla                     ; Rotate allocated block bit into carry flag
  E313+3801              jr      c,free3         ; If set (bit=1), block is allocated
  E315+13                inc     de              ; If not set, block is not allocated, so
  E316+                                          ; ..increment free block count
  E316+          free3:
  E316+4F                ld      c,a             ; Save remaining allocation bits in C
  E317+2B                dec     hl              ; Count down number of blocks on disk
  E318+7D                ld      a,l             ; See if we are down to zero
  E319+B4                or      h
  E31A+2807              jr      z,free4         ; Branch if no more blocks to check
  E31C+79                ld      a,c             ; Get back current allocation bit pattern
  E31D+10F3              djnz    free2           ; Loop through 8 bits
  E31F+C1                pop     bc              ; Get pointer to allocation vector
  E320+03                inc     bc              ; Point to next allocation byte
  E321+18EB              jr      free1           ; Continue by processing next allocation byte
  E323+          
  E323+          free4:
  E323+C1                pop     bc              ; Clean up stack
  E324+EB                ex      de,hl           ; Free block count to HL
  E326+=         blkshf  equ     $+1             ; Pointer for in-the-code modification
  E325+3E00              ld      a,0             ; Get block shift factor
  E327+D603              sub     3               ; Convert to log base 2 of K per block
  E329+2804              jr      z,free6         ; Done if single density (1k per block)
  E32B+          
  E32B+          ; Convert for blocks of more than 1K each
  E32B+          
  E32B+          free5:
  E32B+29                add     hl,hl
  E32C+3D                dec     a
  E32D+20FC              jr      nz,free5
  E32F+          
ZAS Relocating Macro Assembler (v3.05                             page   59
                                                            
                                                            

  E32F+          ; At this point HL = amount of free space on disk in K
  E32F+          
  E32F+          free6:
  E32F+CD0FE6            call    print
  E332+2053706163        db      ' Space on '
  E33C+00        seldrv: db      0               ; Modified above to contain drive letter
  E33D+3AA0              db      ':',[' '+80h]
  E33F+          
  E33F+          ; Display decimal value of HL
  E33F+          
  E33F+0600              ld      b,0             ; Initialize count of digits already printed
  E341+111027            ld      de,10000        ; Divisor in DE
  E344+CDE9E5            call    decdsp          ; Print digit (or space if leading '0')
  E347+11E803            ld      de,1000
  E34A+CDE9E5            call    decdsp
  E34D+CDD9E5            call    decdsp3         ; Display hundreds, tens, and units
  E350+3E4B              ld      a,'K'
  E352+C3FEE5            jp      conout          ; Final return from space routine
  E355+          
  E355+          ; End RCP-SP.Z80
  E355+          
  E355                    endif  ;spaceon
  E355           
  E355                    if     diron
  E355+                  include rcpdir          ; 'DIR' directory command
ZAS Relocating Macro Assembler (v3.05                             page   60
                                                            
                                                            

  E355+                  page
  E355+          
  E355+          ; RCP-DIR.Z80   'DIR' Command
  E355+          
  E355+          ;=============================================================================
  E355+          ;
  E355+          ;       D I R E C T O R Y    D I S P L A Y    C O M M A N D
  E355+          ;
  E355+          ;=============================================================================
  E355+          
  E355+          ; Command:      DIR
  E355+          ; Function:     Display a directory of the files on disk
  E355+          ; Syntax:       DIR <afn>       Displays the DIR files
  E355+          ;               DIR <afn> S     Displays the SYS files
  E355+          ;               DIR <afn> A     Display both DIR and SYS files
  E355+          ;               DIR /S          Equivalent to DIR *.* S
  E355+          ;               DIR /A          Equivalent to DIR *.* A
  E355+          
  E355+          dir:
  E355+CD38E6            call    retsave         ; Save return address and set stack
  E358+          
  E358+          ; See if FCB should be made wild (all '?')
  E358+          
  E358+215D00            ld      hl,fcb1+1       ; Point to file name in FCP
  E35B+7E                ld      a,(hl)          ; Get first character of filename
  E35C+          
  E35C+                   if     slashchk        ; Allow "DIR /S" and "DIR /A" formats
  E35C+FE2F              cp      '/'             ; If name does not start with '/'
  E35E+2008              jr      nz,dir01        ; ..branch and process normally
  E360+23                inc     hl              ; Point to second character
  E361+7E                ld      a,(hl)          ; Get option character after slash
  E362+326D00            ld      (fcb2+1),a      ; ..and put it into second FCB
  E365+2B                dec     hl              ; Back to first character
  E366+3E20              ld      a,' '           ; Simulate empty FCB
  E368+                   endif  ;slashchk
  E368+          
  E368+          dir01:
  E368+060B              ld      b,11            ; Prepare to fill FCB name and type with '?'
  E36A+FE20              cp      ' '             ; See if no file spec given
  E36C+3E3F              ld      a,'?'           ; Get ready to fill with '?'
  E36E+CC9AE6            call    z,fillp         ; ..carry out fill
  E371+          
  E371+                   if     nosys           ; Suppress-SYS-file-if-no-wheel option
  E371+3AFFED            ld      a,(z3whl)       ; Get wheel byte
  E374+B7                or      a
  E375+280E              jr      z,dirnly        ; If wheel off, ignore options
  E377+                   endif
  E377+          
  E377+3A6D00            ld      a,(fcb2+1)      ; Get first char of 2nd file name
  E37A+0601              ld      b,1             ; Set for both dir and sys files
  E37C+FE41              cp      allflag         ; SYS and DIR flag specifier?
  E37E+2807              jr      z,dirpr         ; Got system specifier
  E380+05                dec     b               ; B=0 for sys files only
  E381+FE53              cp      sysflag         ; SYS only?
  E383+2802              jr      z,dirpr
  E385+          
ZAS Relocating Macro Assembler (v3.05                             page   61
                                                            
                                                            

  E385+0680      dirnly: ld      b,80h           ; Must be dir-only selection
  E387+          
  E387+          ; DIRECTORY PRINT ROUTINE; ON ENTRY, B REG IS SET AS FOLLOWS:
  E387+          ;       0 FOR ONLY SYSTEM FILES, 80H FOR ONLY DIR FILES, 1 FOR BOTH
  E387+          ;
  E387+          dirpr:
  E387+78                ld      a,b             ; Get systst flag
  E388+CD4BE7            call    getdir          ; Load and sort directory
  E38B+CAD5E6            jp      z,prfnf         ; Print no file message
  E38E+1E04              ld      e,4             ; Count down to 0
  E390+          ;
  E390+          ; ENTRY PRINT LOOP; ON ENTRY, HL PTS TO FILES SELECTED (TERMINATED BY 0)
  E390+          ;       AND E IS ENTRY COUNTER
  E390+          ;
  E390+          dir3:
  E390+7E                ld      a,(hl)          ; Check for done
  E391+B7                or      a
  E392+                   if     dirsp and spaceon
  E392+CA40E6            jp      z,spaexit       ; Show space when done
  E395+                   else
  E395+                  jp      z,exit          ; Exit if done
  E395+                   endif                  ; Dirsp and spaceon
  E395+7B                ld      a,e             ; Get entry counter
  E396+B7                or      a               ; Output <crlf> if 4 entries printed in line
  E397+2006              jr      nz,dir3a        ; Continue
  E399+CD1FE6            call    crlf            ; New line
  E39C+1E04              ld      e,4             ; Reset entry count
  E39E+7B                ld      a,e             ; Get entry count
  E39F+FE04      dir3a   cp      4               ; First entry?
  E3A1+2807              jr      z,dir4
  E3A3+CD0FE6            call    print
  E3A6+          ;
  E3A6+                   if     wide
  E3A6+          ;
  E3A6+2020              db      '  '            ; 2 spaces
  E3A8+7C                db      fence           ; Then fence char
  E3A9+A0                db      ' '+80h         ; Then 1 more space
  E3AA+          ;
  E3AA+                   else
  E3AA+          ;
  E3AA+                  db      ' '             ; Space
  E3AA+                  db      fence+80h       ; Then fence char
  E3AA+          ;
  E3AA+                   endif                  ; Wide
  E3AA+          ;
  E3AA+          dir4:
  E3AA+CDEDE6            call    prfn            ; Print file name
  E3AD+CD9FE6            call    break           ; Check for abort
  E3B0+1D                dec     e               ; Decrement entry counter
  E3B1+18DD              jr      dir3
  E3B3+          
  E3B3+          ; End RCP-DIR.Z80
  E3B3+          
  E3B3                    endif  ;diron
  E3B3           
  E3B3                    if     eraon
ZAS Relocating Macro Assembler (v3.05                             page   62
                                                            
                                                            

  E3B3+                  include rcpera          ; 'ERA' erase command
ZAS Relocating Macro Assembler (v3.05                             page   63
                                                            
                                                            

  E3B3+                  page
  E3B3+          
  E3B3+          ; RCP-ERA.Z80   'ERA' Command
  E3B3+          
  E3B3+          ;=============================================================================
  E3B3+          ;
  E3B3+          ;               E R A S E    C O M M A N D
  E3B3+          ;
  E3B3+          ;=============================================================================
  E3B3+          
  E3B3+          ;Command: ERA
  E3B3+          ;Function:  Erase files
  E3B3+          ;Forms:
  E3B3+          ;       ERA <afn>       Erase Specified files and print their names
  E3B3+          ;       ERA <afn> I     Erase Specified files and print their names, but ask
  E3B3+          ;                               for verification before Erase is done
  E3B3+          
  E3B3+          era:
  E3B3+CD38E6            call    retsave
  E3B6+3A6D00            ld      a,(fcb2+1)      ; Get eraflg if it's there
  E3B9+32D5E3            ld      (eraflg),a      ; Save it as a flag
  E3BC+3E01              ld      a,1             ; Dir files only
  E3BE+CD4BE7            call    getdir          ; Load directory of files
  E3C1+CAD5E6            jp      z,prfnf         ; Abort if no files
  E3C4+          ;
  E3C4+          ; MAIN ERASE LOOP
  E3C4+          ;
  E3C4+          era1:
  E3C4+CD9FE6            call    break           ; See if user wants to stop
  E3C7+E5                push    hl              ; Save ptr to file
  E3C8+CDEDE6            call    prfn            ; Print its name
  E3CB+2226E8            ld      (nxtfile),hl    ; Save ptr to next file
  E3CE+E1                pop     hl              ; Get ptr to this file
  E3CF+CD4EE6            call    rotest          ; Test file pted to by hl for r/o
  E3D2+201B              jr      nz,era3
  E3D5+=         eraflg  equ     $+1             ; Address of flag
  E3D4+3E00              ld      a,0             ; 2nd byte is flag
  E3D6+FE49              cp      'I'             ; Is it an inspect option?
  E3D8+2005              jr      nz,era2         ; Skip prompt if it is not
  E3DA+CD67E6            call    eraq            ; Erase?
  E3DD+2010              jr      nz,era3         ; Skip if not
  E3DF+          era2:
  E3DF+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E3E2+060B              ld      b,11            ; 11 bytes
  E3E4+CDCEE6            call    blkmov
  E3E7+CD8AE6            call    initfcb1        ; Init fcb
  E3EA+0E13              ld      c,19            ; Delete file
  E3EC+CD06CA            call    bdos
  E3EF+          era3:
  E3EF+2A26E8            ld      hl,(nxtfile)    ; Hl pts to next file
  E3F2+7E                ld      a,(hl)          ; Get char
  E3F3+B7                or      a               ; Done?
  E3F4+                   if     erasp and spaceon
  E3F4+CA40E6            jp      z,spaexit
  E3F7+                   else
  E3F7+                  jp      z,exit
ZAS Relocating Macro Assembler (v3.05                             page   64
                                                            
                                                            

  E3F7+                   endif                  ; Erasp and spaceon
  E3F7+CD1FE6            call    crlf            ; New line
  E3FA+18C8              jr      era1
  E3FC+          
  E3FC+          ; End RCP-ERA.Z80
  E3FC+          
  E3FC                    endif  ;eraon
  E3FC           
  E3FC                    if     lton
  E3FC+                  include rcplt           ; 'LIST' and 'TYPE' commands
ZAS Relocating Macro Assembler (v3.05                             page   65
                                                            
                                                            

  E3FC+                  page
  E3FC+          
  E3FC+          ; RCP-LT.Z80
  E3FC+          
  E3FC+          ;=============================================================================
  E3FC+          ;
  E3FC+          ;       L I S T    A N D    T Y P E    C O M M A N D S
  E3FC+          ;
  E3FC+          ;=============================================================================
  E3FC+          
  E3FC+          ;Command: LIST
  E3FC+          ;Function:  Print out specified file on the LST: Device
  E3FC+          ;Forms:
  E3FC+          ;       LIST <afn>      Print file (NO Paging)
  E3FC+          ;Notes:
  E3FC+          ;       The flags which apply to TYPE do not take effect with LIST
  E3FC+          
  E3FC+                   if     liston
  E3FC+          list:
  E3FC+          ;
  E3FC+          ; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
  E3FC+          
  E3FC+          
  E3FC+                  call    retsave
  E3FC+                  ld      a,0ffh          ; Turn on printer flag
  E3FC+                  jr      type0
  E3FC+                   endif  ;liston
  E3FC+          
  E3FC+          ;Command: TYPE
  E3FC+          ;Function:  Print out specified file on the CON: Device
  E3FC+          ;Forms:
  E3FC+          ;       TYPE <afn>      Print file
  E3FC+          ;       TYPE <afn> P    Print file with paging flag
  E3FC+          ;Notes:
  E3FC+          ;       The flag PGDFLG defines the letter which toggles the paging
  E3FC+          ;               facility (P in the forms section above)
  E3FC+          ;       The flag PGDFLT determines if TYPE is to page by default
  E3FC+          ;               (PGDFLT=TRUE if TYPE pages by default); combined with
  E3FC+          ;               PGDFLG, the following events occur --
  E3FC+          ;                       If PGDFLT = TRUE, PGDFLG turns OFF paging
  E3FC+          ;                       If PGDFLT = FALSE, PGDFLG turns ON paging
  E3FC+          ;
  E3FC+          type:
  E3FC+          ;
  E3FC+          ; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
  E3FC+          ;
  E3FC+          ;
  E3FC+CD38E6            call    retsave
  E3FF+AF                xor     a               ; Turn off printer flag
  E400+          ;
  E400+          ; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
  E400+          ;
  E400+          type0:
  E400+                   if     liston
  E400+                  ld      (prflg),a       ; Set flag
  E400+                   endif                  ; Liston
ZAS Relocating Macro Assembler (v3.05                             page   66
                                                            
                                                            

  E400+          
  E400+3A6D00            ld      a,(fcb2+1)      ; Get page flag
  E403+32B0E4            ld      (pgflg),a       ; Save it as a flag
  E406+3E01              ld      a,1             ; Select dir files
  E408+CD4BE7            call    getdir          ; Allow ambiguous files (HL points to buffer)
  E40B+CAD5E6            jp      z,prfnf         ; No files
  E40E+1813              jr      typex2
  E410+          
  E410+                                          ; Entry point for successive files
  E410+          typex:
  E410+2A26E8            ld      hl,(nxtfile)    ; Get ptr to next file
  E413+7E                ld      a,(hl)          ; Any files?
  E414+B7                or      a
  E415+CA43E6            jp      z,exit
  E418+          
  E418+                   if     liston
  E418+                  ld      a,(prflg)       ; Check for list output
  E418+                  or      a               ; 0=type
  E418+                  jr      z,typex1
  E418+                  ld      a,cr            ; Bol on printer
  E418+                  call    lcout
  E418+                  ld      a,ff            ; Form feed the printer
  E418+                  call    lcout
  E418+                  jr      typex2
  E418+                   endif                  ; Liston
  E418+          
  E418+          typex1:
  E418+          ;       LDA     PAGCNT          ; If we've just done so,
  E418+E5                push    hl
  E419+2A14E7            ld      hl,(pagcnt)
  E41C+7E                ld      a,(hl)
  E41D+E1                pop     hl
  E41E+FE16              cp      nlines-2        ; Don't type another
  E420+C4BEE4            call    nz,pagebreak    ; Page break message
  E423+          typex2:
  E423+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E426+060B              ld      b,11            ; 11 bytes
  E428+CDCEE6            call    blkmov
  E42B+2226E8            ld      (nxtfile),hl    ; Set ptr to next file
  E42E+CD8AE6            call    initfcb1        ; Init fcb1
  E431+0E0F              ld      c,15            ; Open file
  E433+CD06CA            call    bdos
  E436+3C                inc     a               ; Set error flag
  E437+CAD5E6            jp      z,prfnf         ; Abort if error
  E43A+          ;       MVI     A,NLINES-2      ; Set line count
  E43A+          ;       STA     PAGCNT
  E43A+2A14E7            ld      hl,(pagcnt)
  E43D+3616              ld      (hl),nlines-2
  E43F+3E0D              ld      a,cr            ; New line
  E441+CD98E4            call    lcout
  E444+3E0A              ld      a,lf
  E446+CD98E4            call    lcout
  E449+018000            ld      bc,080h         ; Set char position and tab count
  E44C+                                          ; (b=0=tab, c=080h=char position)
  E44C+          ;
  E44C+          ;  MAIN LOOP FOR LOADING NEXT BLOCK
ZAS Relocating Macro Assembler (v3.05                             page   67
                                                            
                                                            

  E44C+          ;
  E44C+          type2:
  E44C+79                ld      a,c             ; Get char count
  E44D+FE80              cp      80h
  E44F+3812              jr      c,type3
  E451+          ;       PUSH    H               ; Read next block
  E451+C5                push    bc
  E452+115C00            ld      de,fcb1         ; Pt to fcb
  E455+0E14              ld      c,20            ; Read record
  E457+CD06CA            call    bdos
  E45A+B7                or      a               ; Set flags
  E45B+C1                pop     bc
  E45C+          ;       POP     H
  E45C+20B2              jr      nz,typex        ; End of file?
  E45E+0E00              ld      c,0             ; Set char count
  E460+218000            ld      hl,tbuff        ; Pt to first char
  E463+          ;
  E463+          ;  MAIN LOOP FOR PRINTING CHARS IN TBUFF
  E463+          ;
  E463+          type3:
  E463+7E                ld      a,(hl)          ; Get next char
  E464+E67F              and     7fh             ; Mask out msb
  E466+FE1A              cp      1ah             ; End of file (^z)?
  E468+28A6              jr      z,typex         ; Next file if so
  E46A+          ;
  E46A+          ; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
  E46A+          ;
  E46A+FE0D              cp      cr              ; Reset tab count?
  E46C+280E              jr      z,type4
  E46E+FE0A              cp      lf              ; Reset tab count?
  E470+280A              jr      z,type4
  E472+FE09              cp      tab             ; Tab?
  E474+280D              jr      z,type5
  E476+          ;
  E476+          ;  OUTPUT CHAR AND INCREMENT CHAR COUNT
  E476+          ;
  E476+CD98E4            call    lcout           ; Output char
  E479+04                inc     b               ; Increment tab count
  E47A+1812              jr      type6
  E47C+          ;
  E47C+          ;  OUTPUT <CR> OR <LF> AND RESET TAB COUNT
  E47C+          ;
  E47C+          type4:
  E47C+CD98E4            call    lcout           ; Output <cr> or <lf>
  E47F+0600              ld      b,0             ; Reset tab counter
  E481+180B              jr      type6
  E483+          ;
  E483+          ;  TABULATE
  E483+          ;
  E483+          type5:
  E483+3E20              ld      a,' '           ; <sp>
  E485+CD98E4            call    lcout
  E488+04                inc     b               ; Incr pos count
  E489+78                ld      a,b
  E48A+E607              and     7
  E48C+20F5              jr      nz,type5
ZAS Relocating Macro Assembler (v3.05                             page   68
                                                            
                                                            

  E48E+          ;
  E48E+          ; CONTINUE PROCESSING
  E48E+          ;
  E48E+          type6:
  E48E+0C                inc     c               ; Increment char count
  E48F+23                inc     hl              ; Pt to next char
  E490+CD9FE6            call    break           ; Check for abort
  E493+CA10E4            jp      z,typex         ; Skip
  E496+18B4              jr      type2
  E498+          ;
  E498+          ; SEND OUTPUT TO LST: OR CON:, AS PER THE FLAG
  E498+          ;   RETURN WITH Z IF ABORT
  E498+          ;
  E498+          lcout:
  E498+E5                push    hl              ; Save regs
  E499+C5                push    bc
  E49A+5F                ld      e,a             ; Char in e
  E49B+0E02              ld      c,2             ; Output to con:
  E49D+                   if     liston
  E49D+          prflg   equ     $+1             ; Pointer for in-the-code modification
  E49D+                  ld      a,0             ; 2nd byte is the print flag
  E49D+                  or      a               ; 0=type
  E49D+                  jr      z,lc1
  E49D+                  ld      c,5             ; Output to lst:
  E49D+                   endif                  ; Liston
  E49D+          
  E49D+          lc1:
  E49D+D5                push    de              ; Save char
  E49E+CD06CA            call    bdos            ; Output char in e
  E4A1+D1                pop     de              ; Get char
  E4A2+7B                ld      a,e
  E4A3+FE0A              cp      lf
  E4A5+2014              jr      nz,lc2
  E4A7+                   if     liston
  E4A7+                  ld      a,(prflg)       ; Output to lst:?
  E4A7+                  or      a               ; Nz = yes
  E4A7+                  jr      nz,lc2
  E4A7+                   endif                  ; Liston
  E4A7+          ;
  E4A7+          ; CHECK FOR PAGING
  E4A7+          ;
  E4A7+          ;       LXI     H,PAGCNT        ; Count down
  E4A7+2A14E7            ld      hl,(pagcnt)
  E4AA+35                dec     (hl)
  E4AB+200E              jr      nz,lc2          ; Jump if not end of page
  E4AD+3616              ld      (hl),nlines-2   ; Refill counter
  E4B0+=         pgflg   equ     $+1             ; Pointer to in-the-code buffer
  E4AF+3E00              ld      a,0             ; 2nd byte is the paging flag
  E4B1+FE50              cp      pgdflg          ; Page default override option wanted?
  E4B3+          ;
  E4B3+                   if     pgdflt          ; If paging is default
  E4B3+          ;
  E4B3+2806              jr      z,lc2           ; Pgdflg means no paging
  E4B5+          ;
  E4B5+                   else
  E4B5+          ;
ZAS Relocating Macro Assembler (v3.05                             page   69
                                                            
                                                            

  E4B5+                  jr      nz,lc2          ; Pgdflg means page
  E4B5+          ;
  E4B5+                   endif                  ; Pgdflt
  E4B5+          ;
  E4B5+CDBEE4            call    pagebreak       ; Print page break message
  E4B8+CA10E4            jp      z,typex         ; Z to skip
  E4BB+          lc2:
  E4BB+C1                pop     bc              ; Restore regs
  E4BC+E1                pop     hl
  E4BD+C9                ret
  E4BE+          ;
  E4BE+          ; PRINT PAGE BREAK MESSAGE AND GET USER INPUT
  E4BE+          ;   ABORT IF ^C, RZ IF ^X
  E4BE+          ;
  E4BE+          pagebreak:
  E4BE+E5                push    hl              ; Save hl
  E4BF+CD0FE6            call    print
  E4C2+0D0A205479        db      cr,lf,' Typing',' '+80h
  E4CC+215D00            ld      hl,fcb1+1       ; Print file name
  E4CF+CDEDE6            call    prfn
  E4D2+CD47E6            call    dash            ; Print dash
  E4D5+CD25E6            call    conin           ; Get input
  E4D8+E1                pop     hl              ; Restore hl
  E4D9+F5                push    af
  E4DA+CD1FE6            call    crlf            ; New line
  E4DD+F1                pop     af
  E4DE+C3B0E6            jp      break1
  E4E1+          ;
  E4E1+          ; End RCP-LT.Z80
  E4E1+          
  E4E1                    endif  ;lton
  E4E1           
  E4E1                    if     renon
  E4E1                   include rcpren          ; 'REN' rename command
  E4E1                    endif  ;renon
  E4E1           
  E4E1                    if     proton
  E4E1+                  include rcpprot         ; 'PROT' file attribute setting command
ZAS Relocating Macro Assembler (v3.05                             page   70
                                                            
                                                            

  E4E1+                  page
  E4E1+          
  E4E1+          ; RCP-PROT.Z80
  E4E1+          
  E4E1+          ;Section 5F
  E4E1+          ;Command: PROT
  E4E1+          ;Function:  To set the attributes of a file (R/O and SYS)
  E4E1+          ;
  E4E1+          ;Form:
  E4E1+          ;       PROT afn RSI
  E4E1+          ;If either R or S are omitted, the file is made R/W or DIR, resp;
  E4E1+          ;R and S may be in any order.  If I is present, Inspection is enabled.
  E4E1+          
  E4E1+          att:
  E4E1+CD38E6            call    retsave
  E4E4+AF                xor     a               ; Set no inspect
  E4E5+325DE5            ld      (inspect),a
  E4E8+210000            ld      hl,0            ; Set r/o and sys attributes off
  E4EB+116D00            ld      de,fcb2+1       ; Pt to attributes
  E4EE+0603              ld      b,3             ; 3 chars max
  E4F0+          att1:
  E4F0+1A                ld      a,(de)          ; Get char
  E4F1+13                inc     de              ; Pt to next
  E4F2+FE49              cp      'I'             ; Inspect?
  E4F4+280C              jr      z,atti
  E4F6+FE52              cp      'R'             ; Set r/o?
  E4F8+280D              jr      z,attr
  E4FA+FE53              cp      'S'             ; Set sys?
  E4FC+280D              jr      z,atts
  E4FE+          att2:
  E4FE+10F0              djnz    att1
  E500+180D              jr      att3
  E502+          atti:
  E502+325DE5            ld      (inspect),a     ; Set flag
  E505+18F7              jr      att2
  E507+          attr:
  E507+2680              ld      h,80h           ; Set r/o bit
  E509+18F3              jr      att2
  E50B+          atts:
  E50B+2E80              ld      l,80h           ; Set sys bit
  E50D+18EF              jr      att2
  E50F+          att3:
  E50F+2270E5            ld      (fatt),hl       ; Save file attributes
  E512+3E01              ld      a,1             ; Select dir and sys files
  E514+CD4BE7            call    getdir          ; Load directory
  E517+CAD5E6            jp      z,prfnf         ; No file error
  E51A+180B              jr      att5
  E51C+          att4:
  E51C+2A26E8            ld      hl,(nxtfile)    ; Pt to next file
  E51F+7E                ld      a,(hl)          ; End of list?
  E520+B7                or      a
  E521+CA43E6            jp      z,exit
  E524+CD1FE6            call    crlf            ; New line
  E527+          att5:
  E527+CD9FE6            call    break           ; Check for possible abort
  E52A+E5                push    hl              ; Save ptr to current file
ZAS Relocating Macro Assembler (v3.05                             page   71
                                                            
                                                            

  E52B+CDEDE6            call    prfn            ; Print its name
  E52E+2226E8            ld      (nxtfile),hl    ; Save ptr to next file
  E531+CD0FE6            call    print
  E534+2053657420        db      ' Set to R','/'+80h
  E53E+2A70E5            ld      hl,(fatt)       ; Get attributes
  E541+0E57              ld      c,'W'           ; Assume r/w
  E543+7C                ld      a,h             ; Get r/o bit
  E544+B7                or      a
  E545+2802              jr      z,att6
  E547+0E4F              ld      c,'O'           ; Set r/o
  E549+          att6:
  E549+79                ld      a,c             ; Get char
  E54A+CDFEE5            call    conout
  E54D+7D                ld      a,l             ; Get sys flag
  E54E+B7                or      a               ; Set flag
  E54F+280B              jr      z,att7
  E551+CD0FE6            call    print
  E554+20616E6420        db      ' and SY','S'+80h
  E55C+          att7:
  E55D+=         inspect equ     $+1             ; Ptr for in-the-code modification
  E55C+3E00              ld      a,0             ; Get inspect flag
  E55E+B7                or      a               ; Z=no
  E55F+E1                pop     hl              ; Get ptr to current file
  E560+2805              jr      z,att8
  E562+CD72E6            call    eraq1           ; Ask for y/n
  E565+20B5              jr      nz,att4         ; Advance to next file if not y
  E567+          att8:
  E567+115D00            ld      de,fcb1+1       ; Copy into fcb1
  E56A+060B              ld      b,11            ; 11 bytes
  E56C+CDCEE6            call    blkmov
  E570+=         fatt    equ     $+1             ; Ptr for in-the-code modification
  E56F+210000            ld      hl,0            ; Get attributes
  E572+1B                dec     de              ; Pt to sys byte
  E573+1B                dec     de
  E574+7D                ld      a,l             ; Get sys flag
  E575+CD87E5            call    attset          ; Set attribute correctly
  E578+1B                dec     de              ; Pt to r/o byte
  E579+7C                ld      a,h             ; Get r/o flag
  E57A+CD87E5            call    attset
  E57D+115C00            ld      de,fcb1         ; Pt to fcb
  E580+0E1E              ld      c,30            ; Set attributes
  E582+CD06CA            call    bdos
  E585+1895              jr      att4
  E587+          attset:
  E587+B7                or      a               ; 0=clear attribute
  E588+2805              jr      z,attst1
  E58A+1A                ld      a,(de)          ; Get byte
  E58B+F680              or      80h             ; Set attribute
  E58D+12                ld      (de),a
  E58E+C9                ret
  E58F+          attst1:
  E58F+1A                ld      a,(de)          ; Get byte
  E590+E67F              and     7fh             ; Clear attribute
  E592+12                ld      (de),a
  E593+C9                ret
  E594+          ;
ZAS Relocating Macro Assembler (v3.05                             page   72
                                                            
                                                            

  E594+          ; End RCP-PROT.Z80
  E594+          
  E594                    endif  ;proton
  E594           
  E594                    if     cpon
  E594                   include rcpcp           ; 'CP'  file copying command
  E594                    endif  ;cpon
  E594           
  E594                    if     peekon or pokeon or porton
  E594                   include rcpiom          ; 'PEEK', 'POKE', 'PORT' commands
  E594                    endif  ;peekon or pokeon or porton
  E594           
  E594                    if     regon
  E594                   include rcpreg          ; 'REG' register operation commands
  E594                    endif  ;regon
  E594           
  E594                    if     whlon
  E594+                  include rcpwhl          ; 'WHL' and 'WHLQ' commands
ZAS Relocating Macro Assembler (v3.05                             page   73
                                                            
                                                            

  E594+                  page
  E594+          ;
  E594+          ;Section 5K
  E594+          ;Command: WHL/WHLQ
  E594+          ;Function:  Set the Wheel Byte on or off
  E594+          ;
  E594+          ;If WHLQUIET equate is true, then RCP does not report wheel status with WHL
  E594+          ;command.
  E594+          ;
  E594+          ;Form:
  E594+          ;       WHL             -- turn Wheel Byte OFF
  E594+          ;       WHL password    -- turn Wheel Byte ON if password is correct
  E594+          ;                          no change if password is wrong
  E594+          ;       WHLQ            -- find out status of Wheel Byte
  E594+          
  E594+          whl:
  E594+215D00            ld      hl,fcb1+1       ; Pt to first char
  E597+7E                ld      a,(hl)          ; Get it
  E598+FE20              cp      ' '             ; Turn byte off if no password
  E59A+280E              jr      z,whloff
  E59C+11D1E5            ld      de,whlpass
  E59F+0608              ld      b,8             ; Check 8 chars
  E5A1+CD09E8            call    comp            ; Compare
  E5A4+2008              jr      nz,whlmsg1
  E5A6+          
  E5A6+          ; TURN ON WHEEL BYTE
  E5A6+          
  E5A6+3EFF              ld      a,0ffh          ; Turn on wheel byte
  E5A8+1801              jr      whlset
  E5AA+          
  E5AA+          ; TURN OFF WHEEL BYTE
  E5AA+          
  E5AA+          whloff:
  E5AA+AF                xor     a               ; Turn off wheel byte
  E5AB+          whlset:
  E5AB+32FFED            ld      (z3whl),a       ; Set wheel byte and print message
  E5AE+          
  E5AE+          whlmsg1:
  E5AE+                   if     whlquiet
  E5AE+                  ret
  E5AE+                   endif
  E5AE+          
  E5AE+          ; PRINT WHEEL BYTE MESSAGE
  E5AE+          
  E5AE+                   if     [not whlquiet] or whlqon
  E5AE+          
  E5AE+          whlmsg:
  E5AE+CD0FE6            call    print
  E5B1+2057686565        db      ' Wheel Byte',' '+80h
  E5BD+3AFFED            ld      a,(z3whl)       ; Get wheel byte
  E5C0+B7                or      a               ; Zero is off
  E5C1+2806              jr      z,offm
  E5C3+CD0FE6            call    print
  E5C6+4FCE              db      'O','N'+80h
  E5C8+C9                ret
  E5C9+          offm:
ZAS Relocating Macro Assembler (v3.05                             page   74
                                                            
                                                            

  E5C9+CD0FE6            call    print
  E5CC+4F46C6            db      'OF','F'+80h
  E5CF+C9                ret
  E5D0+          
  E5D0+                   endif  ;[not whlquiet] or whlqon
  E5D0+          
  E5D0+          
  E5D0+          ; WHEEL PASSWORD DEFINED FROM SYSRCP.LIB FILE
  E5D0+          
  E5D0+1A                db      'Z'-'@'         ; Leading ^z to block attempt to type rcp file
  E5D1+          whlpass:
  E5D1+                  wpass                   ; Use macro
  E5D1+5359535445                DB      'SYSTEM  '
  E5D9+                          ENDM
  E5D9+          ;
  E5D9+          ; End RCP-WHL.Z80
  E5D9+          
  E5D9                    endif  ;whlon
  E5D9           
  E5D9                    if     echoon
  E5D9                   include rcpecho         ; 'ECHO' command
  E5D9                    endif  ;echoon
  E5D9           
  E5D9+                  include rcpsubs         ; File of subroutines
ZAS Relocating Macro Assembler (v3.05                             page   75
                                                            
                                                            

  E5D9+                  page
  E5D9+          
  E5D9+          ; RCPSUBS.Z80   Subroutines for Z33RCP.Z80
  E5D9+          
  E5D9+          
  E5D9+          ;-----------------------------------------------------------------------------
  E5D9+          
  E5D9+          ; Display decimal digit routines
  E5D9+          
  E5D9+          ;--------------------
  E5D9+          
  E5D9+          ; Display hundreds, tens, and units digits (assumes flag in B has been set)
  E5D9+          
  E5D9+                   if     regon or spaceon
  E5D9+          
  E5D9+          decdsp3:
  E5D9+116400            ld      de,100          ; Display hundreds
  E5DC+CDE9E5            call    decdsp
  E5DF+1E0A              ld      e,10            ; Display tens
  E5E1+CDE9E5            call    decdsp
  E5E4+7D                ld      a,l             ; Get remaining units value
  E5E5+C630              add     '0'             ; Convert to character
  E5E7+1815              jr      conout          ; Print it and return
  E5E9+          
  E5E9+          ;--------------------
  E5E9+          
  E5E9+          ; Routine to print any single digit
  E5E9+          
  E5E9+          ; Actually, this routine displays the value of HL divided by DE and leaves the
  E5E9+          ; remainder in HL.  In computing the character to display, it assumes that the
  E5E9+          ; result of the division will be a decimal digit.  If the result is zero, the
  E5E9+          ; value in the B register, which is the number of digits already printed, is
  E5E9+          ; checked.  If it is zero, a space is printed instead of a leading '0'.  If it
  E5E9+          ; is not zero, the '0' is printed.  Whenever any digit (not a space) is
  E5E9+          ; printed, the value in B is incremented.
  E5E9+          
  E5E9+          decdsp:
  E5E9+0E2F              ld      c,'0'-1         ; Initialize digit count
  E5EB+AF                xor     a               ; Clear carry flag
  E5EC+          
  E5EC+          decdsp1:
  E5EC+0C                inc     c               ; Pre-increment the digit
  E5ED+ED52              sbc     hl,de           ; Subtract DE from HL
  E5EF+30FB              jr      nc,decdsp1
  E5F1+          
  E5F1+19                add     hl,de           ; Add back in to produce remainder
  E5F2+79                ld      a,c             ; Get decimal digit
  E5F3+FE30              cp      '0'             ; Check for leading 0
  E5F5+2005              jr      nz,decdsp2      ; If not 0, proceed to display it
  E5F7+78                ld      a,b             ; Digit printed already?
  E5F8+B7                or      a
  E5F9+3E20              ld      a,' '           ; Possible space for calling routine to print
  E5FB+C8                ret     z               ; If no digit printed, return zero flag set
  E5FC+          decdsp2:
  E5FC+04                inc     b               ; Indicate digit printed
  E5FD+79                ld      a,c             ; Else print real digit
ZAS Relocating Macro Assembler (v3.05                             page   76
                                                            
                                                            

  E5FE+                                          ; Fall through to CONOUT
  E5FE+          
  E5FE+                   endif  ;regon or spaceon
  E5FE+          
  E5FE+          ;-----------------------------------------------------------------------------
  E5FE+          
  E5FE+          ;  Console Output Routine
  E5FE+          
  E5FE+          conout:
  E5FE+                  putreg                  ; Save all register except AF
  E5FE+E5                PUSH    HL              ; Save registers in order
  E5FF+D5                PUSH    DE
  E600+C5                PUSH    BC
  E601+                   ENDM
  E601+F5                push    af              ; Save AF, too
  E602+E67F              and     7fh             ; Mask out MSB
  E604+5F                ld      e,a             ; Transfer character to E
  E605+0E02              ld      c,2             ; BDOS conout function number
  E607+CD06CA            call    bdos
  E60A+F1                pop     af
  E60B+                  getreg                  ; Restore registers
  E60B+C1                POP     BC              ; Restore registers in order
  E60C+D1                POP     DE
  E60D+E1                POP     HL
  E60E+                   ENDM
  E60E+          note:                           ; Use this RET for NOTE command
  E60E+C9                ret
  E60F+          
  E60F+          ;-----------------------------------------------------------------------------
  E60F+          
  E60F+          ; String printing routines
  E60F+          
  E60F+          ;--------------------
  E60F+          
  E60F+          ; Print string following call (terminated with null or character with the
  E60F+          ; high bit set)
  E60F+          
  E60F+          print:
  E60F+E3                ex      (sp),hl         ; Get address
  E610+CD15E6            call    printhl
  E613+E3                ex      (sp),hl         ; Put address
  E614+C9                ret
  E615+          
  E615+          ;--------------------
  E615+          
  E615+          ; Print string pointed to by HL (terminated with null or character with the
  E615+          ; high bit set)
  E615+          
  E615+          printhl:
  E615+7E                ld      a,(hl)          ; Get next character
  E616+23                inc     hl              ; Point to following one
  E617+B7                or      a               ; See if null terminator
  E618+C8                ret     z               ; If so, we are done
  E619+CDFEE5            call    conout          ; Display the character
  E61C+F8                ret     m               ; We are done if MSB is set (negative number)
  E61D+18F6              jr      printhl         ; Back for more
ZAS Relocating Macro Assembler (v3.05                             page   77
                                                            
                                                            

  E61F+          
  E61F+          ;-----------------------------------------------------------------------------
  E61F+          
  E61F+          ;  OUTPUT NEW LINE TO CON:
  E61F+          
  E61F+          crlf:
  E61F+CD0FE6            call    print
  E622+0D8A              db      cr,lf+80h
  E624+C9                ret
  E625+          
  E625+          ; CONSOLE INPUT
  E625+          
  E625+                   if     eraon or lton or proton or renon or cpon
  E625+          
  E625+          conin:
  E625+E5                push    hl              ; Save regs
  E626+D5                push    de
  E627+C5                push    bc
  E628+0E01              ld      c,1             ; Input
  E62A+CD06CA            call    bdos
  E62D+C1                pop     bc              ; Get regs
  E62E+D1                pop     de
  E62F+E1                pop     hl
  E630+E67F              and     7fh             ; Mask msb
  E632+FE61              cp      61h
  E634+D8                ret     c
  E635+E65F              and     5fh             ; To upper case
  E637+C9                ret
  E638+          
  E638+                   endif                  ; Eraon or lton or proton or renon or cpon
  E638+          
  E638+          ; SAVE RETURN ADDRESS
  E638+          
  E638+          retsave:
  E638+D1                pop     de              ; Get return address
  E639+E1                pop     hl              ; Get return address to zcpr3
  E63A+2244E6            ld      (z3ret),hl      ; Save it
  E63D+E5                push    hl              ; Put return address to zcpr3 back
  E63E+D5                push    de              ; Put return address back
  E63F+C9                ret
  E640+          
  E640+                   if     spaceon and [dirsp or cpsp or erasp]
  E640+          spaexit:
  E640+CDD5E2            call    crspace         ; Show space remaining
  E643+                   endif                  ; Spaceon and [dirsp or cpsp or erasp]
  E643+          
  E643+          ; EXIT TO ZCPR3
  E643+          
  E643+          exit:
  E644+=         z3ret   equ     $+1             ; Pointer to in-the-code modification
  E643+210000            ld      hl,0            ; Return address
  E646+E9                jp      (hl)            ; Goto zcpr3
  E647+          
  E647+          
  E647+          ; PRINT A DASH
  E647+          
ZAS Relocating Macro Assembler (v3.05                             page   78
                                                            
                                                            

  E647+                   if     lton or peekon
  E647+          dash:
  E647+CD0FE6            call    print
  E64A+202DA0            db      ' -',' '+80h
  E64D+C9                ret
  E64E+          
  E64E+                   endif                  ; Lton or peekon
  E64E+          
  E64E+          ; PRINT ADDRESS MESSAGE
  E64E+          ;   PRINT ADDRESS IN DE
  E64E+          
  E64E+                   if     peekon or pokeon
  E64E+                   if     not pokeq
  E64E+          adrat:
  E64E+                  call    print
  E64E+                  db      ' at',' '+80h
  E64E+                  ld      a,d             ; Print high
  E64E+                  call    pahc
  E64E+                  ld      a,e             ; Print low
  E64E+                  jp      pahc
  E64E+          
  E64E+                   endif                  ; Not pokeq
  E64E+                   endif                  ; Peekon or pokeon
  E64E+          
  E64E+          ; EXTRACT HEXADECIMAL NUMBER FROM LINE PTED TO BY HL
  E64E+          ;   RETURN WITH VALUE IN DE AND HL PTING TO OFFENDING CHAR
  E64E+          
  E64E+                   if     peekon or pokeon or porton
  E64E+          
  E64E+          hexnum:
  E64E+                  ld      de,0            ; De=accumulated value
  E64E+                  ld      b,5             ; B=char count
  E64E+          hnum1:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  cp      ' '+1           ; Done?
  E64E+                  ret     c               ; Return if space or less
  E64E+                  inc     hl              ; Pt to next
  E64E+                  sub     '0'             ; Convert to binary
  E64E+                  jr      c,numerr        ; Return and done if error
  E64E+                  cp      10              ; 0-9?
  E64E+                  jr      c,hnum2
  E64E+                  sub     7               ; A-f?
  E64E+                  cp      10h             ; Error?
  E64E+                  jr      nc,numerr
  E64E+          hnum2:
  E64E+                  ld      c,a             ; Digit in c
  E64E+                  ld      a,d             ; Get accumulated value
  E64E+                  rlca                    ; Exchange nybbles
  E64E+                  rlca
  E64E+                  rlca
  E64E+                  rlca
  E64E+                  and     0f0h            ; Mask out low nybble
  E64E+                  ld      d,a
  E64E+                  ld      a,e             ; Switch low-order nybbles
  E64E+                  rlca
  E64E+                  rlca
ZAS Relocating Macro Assembler (v3.05                             page   79
                                                            
                                                            

  E64E+                  rlca
  E64E+                  rlca
  E64E+                  ld      e,a             ; High nybble of e=new high of e,
  E64E+                                          ; Low nybble of e=new low of d
  E64E+                  and     0fh             ; Get new low of d
  E64E+                  or      d               ; Mask in high of d
  E64E+                  ld      d,a             ; New high byte in d
  E64E+                  ld      a,e
  E64E+                  and     0f0h            ; Mask out low of e
  E64E+                  or      c               ; Mask in new low
  E64E+                  ld      e,a             ; New low byte in e
  E64E+                  djnz    hnum1           ; Count down
  E64E+                  ret
  E64E+          
  E64E+          ; NUMBER ERROR
  E64E+          
  E64E+          numerr:
  E64E+                  call    print
  E64E+                  db      ' Num','?'+80h
  E64E+                  jp      exit
  E64E+          
  E64E+          ; SKIP TO NEXT NON-BLANK
  E64E+          
  E64E+          sksp:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  inc     hl              ; Pt to next
  E64E+                  cp      ' '             ; Skip spaces
  E64E+                  jr      z,sksp
  E64E+                  dec     hl              ; Pt to good char
  E64E+                  or      a               ; Set eol flag
  E64E+                  ret
  E64E+          
  E64E+                   endif                  ; Peekon or pokeon or porton
  E64E+          
  E64E+          ;-----------------------------------------------------------------------------
  E64E+          
  E64E+          ; Test File in FCB for unambiguity and existence, ask user to delete if so
  E64E+          ;   Return with Z flag set if R/O or no permission to delete
  E64E+          
  E64E+                   if     renon or cpon
  E64E+          extest:
  E64E+                  call    ambchk          ; Ambiguous file names not allowed
  E64E+                  call    searf           ; Look for specified file
  E64E+                  jr      z,exok          ; Ok if not found
  E64E+                  call    getsbit         ; Position into dir
  E64E+                  inc     de              ; Pt to file name
  E64E+                  ex      de,hl           ; Hl pts to file name
  E64E+                  push    hl              ; Save ptr to file name
  E64E+                  call    prfn            ; Print file name
  E64E+                  pop     hl
  E64E+                  call    rotest          ; Check for r/o
  E64E+                  jr      nz,exer
  E64E+                  call    eraq            ; Erase?
  E64E+                  jr      nz,exer         ; Restart as error if no
  E64E+                  ld      de,fcb1         ; Pt to fcb1
  E64E+                  ld      c,19            ; Delete file
ZAS Relocating Macro Assembler (v3.05                             page   80
                                                            
                                                            

  E64E+                  call    bdos
  E64E+          exok:
  E64E+                  xor     a
  E64E+                  dec     a               ; Nz = ok
  E64E+                  ret
  E64E+          exer:
  E64E+                  xor     a               ; Error flag - file is r/o or no permission
  E64E+                  ret
  E64E+          
  E64E+          
  E64E+          ; CHECK FOR AMBIGUOUS FILE NAME IN FCB1
  E64E+          ;   RETURN Z IF SO
  E64E+          
  E64E+          ambchk:
  E64E+                  ld      hl,fcb1+1       ; Pt to fcb
  E64E+          
  E64E+          ; CHECK FOR AMBIGUOUS FILE NAME PTED TO BY HL
  E64E+          
  E64E+          ambchk1:
  E64E+                  push    hl
  E64E+                  ld      b,11            ; 11 bytes
  E64E+          amb1:
  E64E+                  ld      a,(hl)          ; Get char
  E64E+                  and     7fh             ; Mask
  E64E+                  cp      '?'
  E64E+                  jr      z,amb2
  E64E+                  inc     hl              ; Pt to next
  E64E+                  djnz    amb1
  E64E+                  dec     b               ; Set nz flag
  E64E+                  pop     de
  E64E+                  ret
  E64E+          amb2:
  E64E+                  pop     hl              ; Pt to file name
  E64E+                  call    prfn
  E64E+                  call    print
  E64E+                  db      ' is AF','N'+80h
  E64E+                  jp      exit
  E64E+          
  E64E+                   endif                  ; Renon or cpon
  E64E+          
  E64E+          ; TEST FILE PTED TO BY HL FOR R/O
  E64E+          ;       NZ IF R/O
  E64E+          
  E64E+                   if     renon or cpon or eraon
  E64E+          
  E64E+          rotest:
  E64E+E5                push    hl              ; Advance to r/o byte
  E64F+010800            ld      bc,8            ; Pt to 9th byte
  E652+09                add     hl,bc
  E653+7E                ld      a,(hl)          ; Get it
  E654+E680              and     80h             ; Mask bit
  E656+F5                push    af
  E657+2160E6            ld      hl,romsg
  E65A+C415E6            call    nz,printhl      ; Print if nz
  E65D+F1                pop     af              ; Get flag
  E65E+E1                pop     hl              ; Get ptr
ZAS Relocating Macro Assembler (v3.05                             page   81
                                                            
                                                            

  E65F+C9                ret
  E660+          romsg:
  E660+2069732052        db      ' is R/','O'+80h
  E667+          
  E667+          ;  CHECK USER TO SEE IF HE APPROVES ERASE OF FILE
  E667+          ;       RETURN WITH Z IF YES
  E667+          
  E667+          eraq:
  E667+CD0FE6            call    print
  E66A+202D204572        db      ' - Eras','e'+80h
  E672+                   endif                  ; Renon or cpon or eraon
  E672+          
  E672+                   if     renon or cpon or eraon or proton
  E672+          eraq1:
  E672+CD0FE6            call    print
  E675+2028592F4E        db      ' (Y/N/Q)?',' '+80h
  E67F+CD25E6            call    conin           ; Get response
  E682+FE51              cp      'Q'             ; Quit command?
  E684+CA43E6            jp      z,exit
  E687+FE59              cp      'Y'             ; Key on yes
  E689+C9                ret
  E68A+          
  E68A+                   endif                  ; Renon or cpon or eraon or proton
  E68A+          
  E68A+          ; INIT FCB1, RETURN WITH DE PTING TO FCB1
  E68A+          
  E68A+                   if     eraon or lton or cpon
  E68A+          initfcb1:
  E68A+215C00            ld      hl,fcb1         ; Pt to fcb
  E68D+          initfcb2:
  E68D+E5                push    hl              ; Save ptr
  E68E+010C00            ld      bc,12           ; Pt to first byte
  E691+09                add     hl,bc
  E692+0618              ld      b,24            ; Zero 24 bytes
  E694+AF                xor     a               ; Zero fill
  E695+CD9AE6            call    fillp           ; Fill memory
  E698+D1                pop     de              ; Pt to fcb
  E699+C9                ret
  E69A+          
  E69A+                   endif                  ; Eraon or lton or cpon
  E69A+          
  E69A+                   if     eraon or lton or cpon or diron
  E69A+          
  E69A+          fillp:
  E69A+77                ld      (hl),a          ; Store byte
  E69B+23                inc     hl              ; Pt to next
  E69C+10FC              djnz    fillp           ; Count down
  E69E+C9                ret
  E69F+          
  E69F+                   endif                  ; Eraon or lton or cpon or diron
  E69F+          
  E69F+          
  E69F+          ;  CHECK FOR USER INPUT; IF ^C, RETURN WITH Z
  E69F+          
  E69F+                   if     diron or lton or eraon or proton or peekon
  E69F+          
ZAS Relocating Macro Assembler (v3.05                             page   82
                                                            
                                                            

  E69F+          break:
  E69F+E5                push    hl              ; Save regs
  E6A0+D5                push    de
  E6A1+C5                push    bc
  E6A2+0E0B              ld      c,11            ; Console status check
  E6A4+CD06CA            call    bdos
  E6A7+B7                or      a
  E6A8+0E01              ld      c,1             ; Get char if any
  E6AA+C406CA            call    nz,bdos
  E6AD+C1                pop     bc              ; Restore regs
  E6AE+D1                pop     de
  E6AF+E1                pop     hl
  E6B0+FE03      break1: cp      ctrlc           ; Check for abort
  E6B2+CA43E6            jp      z,exit          ; Exit
  E6B5+FE18              cp      ctrlx           ; Skip?
  E6B7+C9                ret
  E6B8+                   endif                  ; Diron or lton or eraon or proton or peekon
  E6B8+          
  E6B8+          ; AFTER A SEARCH, RETURN NZ SET IF DESIRED TYPE OF FILE FOUND, Z IF NOT
  E6B8+          ;   THIS ALGORITHM LOOKS AT THE SYSTEM BIT OF THE LOCATED FILE; THIS
  E6B8+          ;   BIT IS SET TO 1 IF THE FILE IS A SYSTEM FILE AND 0 IF NOT A SYSTEM
  E6B8+          ;   FILE.  THE FOLLOWING EXCLUSIVE OR MASKS ARE APPLIED TO RETURN Z OR NZ
  E6B8+          ;   AS REQUIRED BY THE CALLING PROGRAM:
  E6B8+          ;
  E6B8+          ;       SYSTEM BYTE: X 0 0 0  0 0 0 0   (AFTER 80H MASK, X=1 IF SYS, 0 IF DIR)
  E6B8+          ;
  E6B8+          ;       SYS-ONLY   : 0 0 0 0  0 0 0 0   (XOR 0 = 0 if X=0, = 80H if X=1)
  E6B8+          ;       DIR-ONLY   : 1 0 0 0  0 0 0 0   (XOR 80H = 80h if X=0, = 0 if X=1)
  E6B8+          ;       BOTH       : 0 0 0 0  0 0 0 1   (XOR 1 = 81H or 1H, NZ in both cases)
  E6B8+          
  E6B8+                   if     diron or eraon or lton or proton or cpon or renon
  E6B8+          
  E6B8+          getsbit:
  E6B8+3D                dec     a               ; Adjust to returned value
  E6B9+0F                rrca                    ; Convert number to offset into tbuff
  E6BA+0F                rrca
  E6BB+0F                rrca
  E6BC+E660              and     60h
  E6BE+118000            ld      de,tbuff        ; Pt to buffer
  E6C1+83                add     a,e             ; Add entry offset to base addr
  E6C2+5F                ld      e,a             ; Result in e
  E6C3+D5                push    de              ; Save ptr in de
  E6C4+C60A              add     10              ; Add offset of 10 to pt to system byte
  E6C6+5F                ld      e,a             ; Set address
  E6C7+1A                ld      a,(de)          ; Get byte
  E6C8+D1                pop     de              ; Get ptr in de
  E6C9+E680              and     80h             ; Look at only system bit
  E6CC+=         systst  equ     $+1             ; In-the-code variable
  E6CB+EE00              xor     0               ; If systst=0, sys only; if systst=80h, dir
  E6CD+                                          ; Only; if systst=1, both sys and dir
  E6CD+C9                ret                     ; Nz if ok, z if not ok
  E6CE+          
  E6CE+          
  E6CE+          ; COPY HL TO DE FOR B BYTES
  E6CE+          
  E6CE+          blkmov:
ZAS Relocating Macro Assembler (v3.05                             page   83
                                                            
                                                            

  E6CE+7E                ld      a,(hl)          ; Get
  E6CF+12                ld      (de),a          ; Put
  E6D0+23                inc     hl              ; Pt to next
  E6D1+13                inc     de
  E6D2+10FA              djnz    blkmov          ; Loop
  E6D4+C9                ret
  E6D5+          
  E6D5+          
  E6D5+          ;  PRINT FILE NOT FOUND MESSAGE
  E6D5+          
  E6D5+          prfnf:
  E6D5+CD0FE6            call    print
  E6D8+204E6F2046        db      ' No File','s'+80h
  E6E1+C343E6            jp      exit
  E6E4+          
  E6E4+          ; LOG INTO USER AREA CONTAINED IN FCB1
  E6E4+          
  E6E4+          logusr:
  E6E4+3A6900            ld      a,(fcb1+13)     ; Get user number
  E6E7+          setusr:
  E6E7+5F                ld      e,a
  E6E8+0E20              ld      c,32            ; Use bdos fct
  E6EA+C306CA            jp      bdos
  E6ED+          
  E6ED+          
  E6ED+          ;  PRINT FILE NAME PTED TO BY HL
  E6ED+          
  E6ED+          prfn:
  E6ED+CD0FE6            call    print           ; Leading space
  E6F0+A0                db      ' '+80h
  E6F1+0608              ld      b,8             ; 8 chars
  E6F3+CDFCE6            call    prfn1
  E6F6+CD0FE6            call    print
  E6F9+AE                db      '.'+80h         ; Dot
  E6FA+0603              ld      b,3             ; 3 chars
  E6FC+          prfn1:
  E6FC+7E                ld      a,(hl)          ; Get char
  E6FD+23                inc     hl              ; Pt to next
  E6FE+CDFEE5            call    conout          ; Print char
  E701+10F9              djnz    prfn1           ; Count down
  E703+C9                ret
  E704+          
  E704+          
  E704+          ; SEARCH FOR FIRST
  E704+          
  E704+          searf:
  E704+C5                push    bc              ; Save counter
  E705+E5                push    hl              ; Save hl
  E706+0E11              ld      c,17            ; Search for first function
  E708+          searf1:
  E708+115C00            ld      de,fcb1         ; Pt to fcb
  E70B+CD06CA            call    bdos
  E70E+3C                inc     a               ; Set zero flag for error return
  E70F+E1                pop     hl              ; Get hl
  E710+C1                pop     bc              ; Get counter
  E711+C9                ret
ZAS Relocating Macro Assembler (v3.05                             page   84
                                                            
                                                            

  E712+          
  E712+                   endif                  ; Diron or eraon or lton or proton or cpon or renon
  E712+          
  E712+          ;-----------------------------------------------------------------------------
  E712+          
  E712+          ; Define buffers as high as possible in TPA for the following groups
  E712+          ; of commands:
  E712+          ;       COPY                            needs SRCFCB and CBUFF
  E712+          ;       LIST/TYPE                       needs PAGCNT and DIRBUF
  E712+          ;       ERA, PROT, and DIR commands.    needs DIRBUF
  E712+          ; If DIRBUF is defined, its value is in HL on return from this code.  The DE
  E712+          ; register pair is not changed by the code, but the BC pair is affected.
  E712+          
  FFFF+=         dirbufon equ    lton or diron or eraon or proton
  E712+          
  E712+                   if     dirbufon
  E712+0000      dirbuf: ds      2               ; Address for directory buffer
  E714+                   endif  ;dirbufon
  E714+          
  E714+                   if     cpon
  E714+          srcfcb: ds      2               ; Address of source file FCB (CBUFF address
  E714+                                          ; ..is in the code)
  E714+                   endif  ;cpon
  E714+          
  E714+                   if     lton
  E714+0000      pagcnt: ds      2               ; Address for page counter
  E716+                   endif  ;lton
  E716+          
  E716+          
  E716+                   if     cpon or lton or eraon or proton or diron
  E716+          
  E716+          define:
  E716+D5                push    de
  E717+2A07CA            ld      hl,(bdos+1)     ; Get bottom of BDOS
  E71A+EB                ex      de,hl           ; ..into DE
  E71B+2A0100            ld      hl,(1)          ; Get BIOS warmboot address into HL
  E71E+01FDE9            ld      bc,-[0e00h+800h+3] ; Offset to command processor address
  E721+09                add     hl,bc
  E722+          
  E722+          ; Now we have to compare and pick the lower address as the top of TPA
  E722+          
  E722+E5                push    hl              ; Save CPR address while comparing
  E723+AF                xor     a               ; Clear the carry flag
  E724+ED52              sbc     hl,de           ; Compute (CPR-BDOS)
  E726+E1                pop     hl              ; Restore CPR address
  E727+3801              jr      c,define1       ; Branch if BDOS address is higher (use CPR)
  E729+EB                ex      de,hl           ; Otherwise use BDOS address
  E72A+          define1:
  E72A+          
  E72A+                   if     lton
  E72A+2B                dec     hl              ; Put PAGCNT in first free byte at top of TPA
  E72B+2214E7            ld      (pagcnt),hl
  E72E+                   endif  ;lton
  E72E+          
  E72E+                   if     cpon
  E72E+                  ld      de,-36          ; Calculate place for SRCFCB for copy command
ZAS Relocating Macro Assembler (v3.05                             page   85
                                                            
                                                            

  E72E+                  add     hl,de
  E72E+                  ld      (srcfcb),hl
  E72E+                    if    dirbufon
  E72E+                  push    hl              ; Save if needed below
  E72E+                    endif ;dirbufon
  E72E+                  ld      de,-[cpblocks*128] ; CBUFF can use same space as DIRBUF
  E72E+                  add     hl,de
  E72E+                  ld      (cbuff),hl
  E72E+                    if    dirbufon
  E72E+                  pop     hl
  E72E+                    endif ;dirbufon
  E72E+                   endif  ;cpon
  E72E+          
  E72E+                   if     dirbufon
  E72E+1100F5            ld      de,-[maxdirs*11] ; Space for directory buffer
  E731+19                add     hl,de
  E732+2212E7            ld      (dirbuf),hl
  E735+                   endif
  E735+          
  E735+D1                pop     de
  E736+C9                ret
  E737+          
  E737+                   endif  ;cpon or dirbufon
  E737+          
  E737+          ;-----------------------------------------------------------------------------
  E737+          
  E737+          ; SEARCH FOR NEXT
  E737+          
  E737+                   if     diron or eraon or lton or proton
  E737+          
  E737+          searn:
  E737+C5                push    bc              ; Save counter
  E738+E5                push    hl              ; Save hl
  E739+0E12              ld      c,18            ; Search for next function
  E73B+18CB              jr      searf1
  E73D+          
  E73D+          ; LOAD DIRECTORY AND SORT IT
  E73D+          ;   ON INPUT, A=SYSTST FLAG (0=SYS, 1=DIR, 80H=BOTH)
  E73D+          ;   DIRECTORY IS LOADED INTO BUFFER AT TOP OF TPA
  E73D+          ;   RETURN WITH ZERO SET IF NO MATCH AND HL PTS TO 1ST ENTRY IF MATCH
  E73D+          
  E73D+          direrr:
  E73D+CD0FE6            call    print
  E740+444952204F        db      'DIR Ovf','l'+80h
  E748+C343E6            jp      exit
  E74B+          
  E74B+          getdir:
  E74B+32CCE6            ld      (systst),a      ; Set system test flag
  E74E+CDE4E6            call    logusr          ; Log into user area of fcb1
  E751+          
  E751+CD16E7            call    define          ; Define buffer addresses
  E754+3600              ld      (hl),0          ; Set empty
  E756+010000            ld      bc,0            ; Set counter
  E759+CD04E7            call    searf           ; Look for match
  E75C+C8                ret     z               ; Return if not found
  E75D+          
ZAS Relocating Macro Assembler (v3.05                             page   86
                                                            
                                                            

  E75D+          ;  STEP 1:  LOAD DIRECTORY
  E75D+          
  E75D+          gd1:
  E75D+C5                push    bc              ; Save counter
  E75E+CDB8E6            call    getsbit         ; Check for system ok
  E761+C1                pop     bc
  E762+2816              jr      z,gd2           ; Not ok, so skip
  E764+C5                push    bc              ; Save counter
  E765+13                inc     de              ; Pt to file name
  E766+EB                ex      de,hl           ; Hl pts to file name, de pts to buffer
  E767+060B              ld      b,11            ; Copy 11 bytes
  E769+CDCEE6            call    blkmov          ; Do copy
  E76C+C1                pop     bc              ; Get counter
  E76D+03                inc     bc              ; Increment counter
  E76E+21FF00            ld      hl,maxdirs-1    ; See if count equals or exceeds MAXDIRS
  E771+78                ld      a,b             ; Check high bytes
  E772+94                sub     a,h
  E773+3804              jr      c,gd1a          ; If carry set, we are OK
  E775+79                ld      a,c             ; Check low bytes
  E776+95                sub     a,l
  E777+30C4              jr      nc,direrr       ; If no carry, jump to error message
  E779+          gd1a:
  E779+EB                ex      de,hl           ; Hl pts to next buffer location
  E77A+          gd2:
  E77A+CD37E7            call    searn           ; Look for next
  E77D+20DE              jr      nz,gd1
  E77F+3600              ld      (hl),0          ; Store ending 0
  E781+2A12E7            ld      hl,(dirbuf)     ; Pt to dir buffer
  E784+7E                ld      a,(hl)          ; Check for empty
  E785+B7                or      a
  E786+C8                ret     z
  E787+          
  E787+          ;  STEP 2:  SORT DIRECTORY
  E787+          
  E787+E5                push    hl              ; Save ptr to dirbuf for return
  E788+CD8FE7            call    diralpha        ; Sort
  E78B+E1                pop     hl
  E78C+AF                xor     a               ; Set nz flag for ok
  E78D+3D                dec     a
  E78E+C9                ret
  E78F+          
  E78F+          
  E78F+          ;  DIRALPHA -- ALPHABETIZES DIRECTORY IN DIRBUF; BC CONTAINS
  E78F+          ;       THE NUMBER OF FILES IN THE DIRECTORY
  E78F+          
  E78F+          diralpha:
  E78F+          
  E78F+          ;  SHELL SORT --
  E78F+          ;    THIS SORT ROUTINE IS ADAPTED FROM "SOFTWARE TOOLS"
  E78F+          ;    BY KERNIGAN AND PLAUGHER, PAGE 106.  COPYRIGHT, 1976, ADDISON-WESLEY.
  E78F+          
  E78F+60                ld      h,b             ; Hl=bc=file count
  E790+69                ld      l,c
  E791+22B2E7            ld      (n),hl          ; Set "N"
  E794+2299E7            ld      (gap),hl        ; Set initial gap to n for first division by 2
  E797+          
ZAS Relocating Macro Assembler (v3.05                             page   87
                                                            
                                                            

  E797+          ;  FOR (GAP = N/2; GAP > 0; GAP = GAP/2)
  E797+          srtl0:
  E797+B7                or      a               ; Clear carry
  E799+=         gap     equ     $+1             ; Pointer for in-the-code modification
  E798+210000            ld      hl,0            ; Get previous gap
  E79B+7C                ld      a,h             ; Rotate right to divide by 2
  E79C+1F                rra
  E79D+67                ld      h,a
  E79E+7D                ld      a,l
  E79F+1F                rra
  E7A0+6F                ld      l,a
  E7A1+          
  E7A1+          ;  TEST FOR ZERO
  E7A1+B4                or      h
  E7A2+C8                ret     z               ; Done with sort if gap = 0
  E7A3+          
  E7A3+2299E7            ld      (gap),hl        ; Set value of gap
  E7A6+22AAE7            ld      (ii),hl         ; Set ii=gap for following loop
  E7A9+          
  E7A9+          ;  FOR (II = GAP + 1; II <= N; II = II + 1)
  E7A9+          srtl1:
  E7AA+=         ii      equ     $+1             ; Pointer for in-the-code modification
  E7A9+210000            ld      hl,0            ; Add 1 to ii
  E7AC+23                inc     hl
  E7AD+22AAE7            ld      (ii),hl
  E7B0+          
  E7B0+          ;  TEST FOR II <= N
  E7B0+EB                ex      de,hl           ; Ii is in de
  E7B2+=         n       equ     $+1             ; Pointer for in-the-code modification
  E7B1+210000            ld      hl,0            ; Number of items to sort
  E7B4+7D                ld      a,l             ; Compare by subtraction
  E7B5+93                sub     a,e
  E7B6+7C                ld      a,h
  E7B7+9A                sbc     a,d             ; Carry set means ii > n
  E7B8+38DD              jr      c,srtl0         ; Don't do for loop if ii > n
  E7BA+          
  E7BA+EB                ex      de,hl           ; Set jj = ii initially for first subtraction of gap
  E7BB+22C3E7            ld      (jj),hl
  E7BE+          
  E7BE+          ;  FOR (JJ = II - GAP; JJ > 0; JJ = JJ - GAP)
  E7BE+          srtl2:
  E7BE+2A99E7            ld      hl,(gap)        ; Get gap
  E7C1+EB                ex      de,hl           ; In de
  E7C3+=         jj      equ     $+1             ; Pointer for in-the-code modification
  E7C2+210000            ld      hl,0            ; Get jj
  E7C5+7D                ld      a,l             ; Compute jj - gap
  E7C6+93                sub     a,e
  E7C7+6F                ld      l,a
  E7C8+7C                ld      a,h
  E7C9+9A                sbc     a,d
  E7CA+67                ld      h,a
  E7CB+22C3E7            ld      (jj),hl         ; Jj = jj - gap
  E7CE+38D9              jr      c,srtl1         ; If carry from subtractions, jj < 0 and abort
  E7D0+B5                or      l               ; Jj=0?
  E7D1+          
  E7D1+28D6              jr      z,srtl1         ; If zero, jj=0 and abort
ZAS Relocating Macro Assembler (v3.05                             page   88
                                                            
                                                            

  E7D3+          
  E7D3+          ;  SET JG = JJ + GAP
  E7D3+EB                ex      de,hl           ; Jj in de
  E7D4+2A99E7            ld      hl,(gap)        ; Get gap
  E7D7+19                add     hl,de           ; Jj + gap
  E7D8+22E5E7            ld      (jg),hl         ; Jg = jj + gap
  E7DB+          
  E7DB+          ;  IF (V(JJ) <= V(JG))
  E7DB+CDFFE7            call    icompare        ; J in de, jg in hl
  E7DE+          
  E7DE+          ;  ... THEN BREAK
  E7DE+38C9              jr      c,srtl1
  E7E0+          
  E7E0+          ;  ... ELSE EXCHANGE
  E7E0+2AC3E7            ld      hl,(jj)         ; Swap jj, jg
  E7E3+EB                ex      de,hl
  E7E5+=         jg      equ     $+1             ; Pointer for in-the-code modification
  E7E4+210000            ld      hl,0
  E7E7+CDECE7            call    iswap           ; Jj in de, jg in hl
  E7EA+          
  E7EA+          ;  END OF INNER-MOST FOR LOOP
  E7EA+18D2              jr      srtl2
  E7EC+          
  E7EC+          
  E7EC+          ;  SWAP (Exchange) the elements whose indexes are in HL and DE
  E7EC+          
  E7EC+          iswap:
  E7EC+CD17E8            call    ipos            ; Compute position from index
  E7EF+EB                ex      de,hl
  E7F0+CD17E8            call    ipos            ; Compute 2nd element position from index
  E7F3+060B              ld      b,11            ; 11 bytes to flip
  E7F5+                   endif                  ; Diron or eraon or lton or proton
  E7F5+          
  E7F5+                   if     diron or eraon or lton or proton or renon
  E7F5+          iswap1:
  E7F5+1A                ld      a,(de)          ; Get bytes
  E7F6+4E                ld      c,(hl)
  E7F7+77                ld      (hl),a          ; Put bytes
  E7F8+79                ld      a,c
  E7F9+12                ld      (de),a
  E7FA+23                inc     hl              ; Pt to next
  E7FB+13                inc     de
  E7FC+10F7              djnz    iswap1
  E7FE+C9                ret
  E7FF+                   endif                  ; Diron or eraon or lton or proton or renon
  E7FF+          
  E7FF+                   if     diron or eraon or lton or proton
  E7FF+          
  E7FF+          ;  ICOMPARE compares the entry pointed to by the pointer pointed to by HL
  E7FF+          ;    with that pointed to by DE (1st level indirect addressing); on entry,
  E7FF+          ;    HL and DE contain the numbers of the elements to compare (1, 2, ...);
  E7FF+          ;    on exit, Carry Set means ((DE)) < ((HL)), Zero Set means ((HL)) = ((DE)),
  E7FF+          ;    and Non-Zero and No-Carry means ((DE)) > ((HL))
  E7FF+          
  E7FF+          icompare:
  E7FF+CD17E8            call    ipos            ; Get position of first element
ZAS Relocating Macro Assembler (v3.05                             page   89
                                                            
                                                            

  E802+EB                ex      de,hl
  E803+CD17E8            call    ipos            ; Get position of 2nd element
  E806+EB                ex      de,hl
  E807+          
  E807+          ;  COMPARE DIR ENTRY PTED TO BY HL WITH THAT PTED TO BY DE;
  E807+          ;       NO NET EFFECT ON HL, DE; RET W/CARRY SET MEANS DE<HL
  E807+          ;       RET W/ZERO SET MEANS DE=HL
  E807+          
  E807+                   if     not sortnt      ; Type and name?
  E807+          
  E807+          ;  COMPARE BY FILE TYPE AND FILE NAME
  E807+          
  E807+                  push    hl
  E807+                  push    de
  E807+                  ld      bc,8            ; Pt to ft (8 bytes)
  E807+                  add     hl,bc
  E807+                  ex      de,hl
  E807+                  add     hl,bc
  E807+                  ex      de,hl           ; De, hl now pt to their ft's
  E807+                  ld      b,3             ; 3 bytes
  E807+                  call    comp            ; Compare ft's
  E807+                  pop     de
  E807+                  pop     hl
  E807+                  ret     nz              ; Continue if complete match
  E807+                  ld      b,8             ; 8 bytes
  E807+          ; FALL THROUGH TO COMP
  E807+          
  E807+                   else                   ; Name and type
  E807+          
  E807+          ;  COMPARE BY FILE NAME AND FILE TYPE
  E807+          
  E807+060B              ld      b,11            ; Compare fn, ft and fall thru to comp
  E809+          
  E809+                   endif                  ; Not sortnt
  E809+                   endif                  ; Diron or eraon or lton or proton
  E809+          
  E809+                   if     diron or eraon or lton or proton or cpon or whlon
  E809+          
  E809+          ;  COMP COMPARES DE W/HL FOR B BYTES; RET W/CARRY IF DE<HL
  E809+          ;       MSB IS DISREGARDED
  E809+          
  E809+          comp:
  E809+7E                ld      a,(hl)          ; Get (hl)
  E80A+E67F              and     7fh             ; Mask msb
  E80C+4F                ld      c,a             ; In c
  E80D+1A                ld      a,(de)          ; Compare
  E80E+E67F              and     7fh             ; Mask msb
  E810+B9                cp      c
  E811+C0                ret     nz
  E812+23                inc     hl              ; Pt to next
  E813+13                inc     de
  E814+10F3              djnz    comp            ; Count down
  E816+C9                ret
  E817+          
  E817+                   endif                  ; Diron or eraon or lton or proton or cpon or
  E817+                                          ; whlon
ZAS Relocating Macro Assembler (v3.05                             page   90
                                                            
                                                            

  E817+          
  E817+                   if     diron or eraon or lton or proton
  E817+          
  E817+          ;  Compute physical position of element whose index is in HL; on exit, HL
  E817+          ; is the physical address of this element; Indexes are 1..N
  E817+          
  E817+          ipos:
  E817+2B                dec     hl              ; We want HL=(HL-1)*11+(DIRBUF)
  E818+44                ld      b,h             ; Bc=hl
  E819+4D                ld      c,l
  E81A+29                add     hl,hl           ; Hl=hl*2
  E81B+29                add     hl,hl           ; Hl=hl*4
  E81C+09                add     hl,bc           ; Hl=hl*5
  E81D+29                add     hl,hl           ; Hl=hl*10
  E81E+09                add     hl,bc           ; Hl=hl*11
  E81F+44                ld      b,h             ; Move offset into BC
  E820+4D                ld      c,l
  E821+2A12E7            ld      hl,(dirbuf)
  E824+09                add     hl,bc
  E825+C9                ret
  E826+          
  E826+                   endif                  ; Diron or eraon or lton or proton
  E826+          
  E826+          ; End RCPSUBS.Z80
  E826+          
  E826           
  E826           ;
  E826           ; Date Buffers
  E826           ;
  E826                    if     eraon or lton or proton
  E826           
  E826           nxtfile:
  E826 0000              ds      2               ; Ptr to next file in list
  E828           
  E828                    endif                  ; Eraon or lton or proton
  E828           
  E828                   if      zdsson          ; p2dos datestamper
  E828                    if     STMPP2
  E828+                    include p2d
  E828+          ;       TITLE   "CP/M+ (P2DOS) Time for ZSDOS"
  E828+          ;===============================================================;
  E828+          ;  P2D - ZSDOS Driver for P2DOS (CP/M Plus compatible) Stamps   ;
  E828+          ;---------------------------------------------------------------;
  E828+          ; Copyright (C) 1988  by Harold F. Bower and Cameron W. Cotrill ;
  E828+          ;---------------------------------------------------------------;
  E828+          ; Portions of this code were derived from code written by       ;
  E828+          ;        H.A.J. Ten Brugge                                      ;
  E828+          ;                                                               ;
  E828+          ; FUNCTION:   To convert from DateStamper(tm) "type"  date/time ;
  E828+          ; string  to  the  5-byte date/time  string required for P2DOS. ;
  E828+          ; This code provides the time functions for ZSDOS to operate in ;
  E828+          ; a P2DOS (CP/M Plus compatible) type Date/Time stamping mode.  ;
  E828+          ;                                                               ;
  E828+          ; Universal Time String     :   YY MM DD HH MM SS  (all BCD)    ;
  E828+          ;                                                               ;
  E828+          ; CP/M+ (P2DOS) Time String :   nnnn HH MM SS                   ;
ZAS Relocating Macro Assembler (v3.05                             page   91
                                                            
                                                            

  E828+          ;    nnnn = binary number of days since start (1 = 1 Jan 1978)  ;
  E828+          ;                               HH MM SS = time in BCD          ;
  E828+          ;                                                               ;
  E828+          ; Version:                                                      ;
  E828+          ;       1.0 - Initial Release                   16 Sep 88       ;
  E828+          ;===============================================================;
  E828+          
  E828+          ; VER   EQU     11              ; Initial Release
  E828+          
  E828+          ; FALSE EQU     0
  E828+          ; TRUE  EQU     NOT FALSE
  E828+          
  E828+          ;       MACLIB  RSXFLAG         ; Get the definition of RSX equate flag
  E828+                                          ; TRUE=Assemble as RSX, FALSE=Hi-memory module
  E828+                                          ;== ALSO VERSION DEPENDENT ADDRESSES
  0016+=         TIMOFF  EQU     0016H           ; Time Vector group offset
  0018+=         LSTOFF  EQU     0018H           ; Stamp Last Accessed routine addr
  001A+=         CREOFF  EQU     001AH           ; Stamp Create Time routine addr
  001C+=         MODOFF  EQU     001CH           ; Stamp Modify Time routine addr
  001E+=         GSTOFF  EQU     001EH           ; Get Stamp routine addr
  0020+=         SSTOFF  EQU     0020H           ; Set Stamp routine addr
  E828+          
  E828+          ; DOSID EQU     'S'             ; ID tag for ZSDOS
  E828+          ; DOSVER        EQU     11H             ; ZSDOS version number for this module
  E828+          ;       PAGE
  E828+          
  E838+                  ORG     (FCP-ZDSSTSZ)   ; We are at the top of the RCP area
  E838+          
  E838+C344E8            JP      STAMPC          ; jump table to make stuffs easy in zsdos...
  E83B+C348E8            JP      STAMPU
  E83E+C368E8            JP      GSTAMP
  E841+C379E8            JP      PSTAMP
  E844+          
  E844+          ;===============================================================+
  E844+          ; Stamp CREATE/UPDATE Time Field in T&D. (Extracted from PZDOS) |
  E844+          ; ------------------------                                      |
  E844+          ;   Read the Real Time Clock via SGSTIM vector in Universal     |
  E844+          ;   format to buffer, convert to CP/M+ (P2DOS) format, and      |
  E844+          ;   move to appropriate field in DIR Buffer.                    |
  E844+          ;---------------------------------------------------------------|
  E844+          ; Enter: A = Directory Offset (0, 20H, 40H) of subject file     |
  E844+          ;       BC = Address of WRFCB routine in ZSDOS                  |
  E844+          ;       DE = Pointer to DIR Buffer.  (Offset in A)              |
  E844+          ;                                                               |
  E844+          ; Exit : A = 1 if OK, Else A = 0FFH if error.  Flags undefined  |
  E844+          ;                                                               |
  E844+          ; Effects: Current DMA Buffer altered                           |
  E844+          ;===============================================================+
  E844+          
  E844+          
  E844+2E00      STAMPC: LD      L,0             ; Set to Create field in Stamp
  E846+1802              JR      STTIM           ; ..and join common code
  E848+          
  E848+          ;.....
  E848+2E04      STAMPU: LD      L,4             ; Set to Update field in Stamp
  E84A+CDD1E9    STTIM:  CALL    SETREC          ; Use DE offset to rec in A.  Save L in E
ZAS Relocating Macro Assembler (v3.05                             page   92
                                                            
                                                            

  E84D+4B                LD      C,E             ; Move Create/Update offset to C (B=0)
  E84E+09                ADD     HL,BC           ; Destination of 4-byte T&D now in HL
  E84F+11F9E9            LD      DE,DSTIME       ; Set address to read time
  E852+E5                PUSH    HL              ; ..save destination addr
  E853+D5                PUSH    DE              ; ..and source addr
  E854+48                LD      C,B             ; Set C=0 for Clock Read
  E855+2A16CA            LD      HL,(BDOSB+TIMOFF)       ; Clock driver address
  E858+225CE8            LD      (CACLDR),HL     ; set call addr
  E85C+=         CACLDR  EQU     $+1             ; where to place clock driver address
  E85B+CD0000            CALL    0               ; Push
  E85E+          ;       CALL    RWCLK           ; Read the clock module
  E85E+D1                POP     DE              ; Restore source addr
  E85F+E1                POP     HL              ; ..and destination addr
  E860+3D                DEC     A               ; Was the clock read Ok? (1-->0 if Ok)
  E861+2030              JR      NZ,NOTIM0       ; ..jump Error exit if Not
  E863+CD96E8            CALL    U2PTIM          ; Cv Univ. time at (DE) to CP/M+ time at (HL)
  E866+1821              JR      WRFCB0          ; Write FCB, Set return flags and exit
  E868+          
  E868+          ;===============================================================+
  E868+          ; Get File Stamps in Universal Format                           |
  E868+          ; ---------------                                               |
  E868+          ;   Read the Create and Update Stamps and convert to Universal  |
  E868+          ;   format in the proper fields at the specified address.  Null |
  E868+          ;   the Last Access Time field.                                 |
  E868+          ;---------------------------------------------------------------|
  E868+          ; Enter: A = Directory Offset (0, 20H, 40H) of subject file     |
  E868+          ;       DE = Pointer to DIR Buffer.  (Offset in A)              |
  E868+          ;       HL = DMA Address to receive 15 byte Stamp frame         |
  E868+          ;                                                               |
  E868+          ; Exit : A = 1 if OK, Else A = 0FFH if error.  Flags undefined  |
  E868+          ;                                                               |
  E868+          ; Effects : DMA Buffer contains the 15-byte frame if successful |
  E868+          ;===============================================================+
  E868+          
  E868+CDD1E9    GSTAMP: CALL    SETREC          ; Calculate T&D address (HL saved in DE)
  E86B+CD3BE9            CALL    P2UTIM          ; Convert P-tim at (HL) to U-tim at (DE)
  E86E+0605              LD      B,5             ; Zero Last Access field for this type
  E870+12        GSLOOP: LD      (DE),A          ; ..by poking a zero..(A=0 from P2UTIM)
  E871+13                INC     DE
  E872+10FC              DJNZ    GSLOOP          ; ..in each location
  E874+CD3BE9            CALL    P2UTIM          ; Convert Modified field (P@HL to U@DE)
  E877+1815              JR      OKRET           ; Set OK return status
  E879+          
  E879+          ;===============================================================+
  E879+          ; Put File Stamps in Universal Format                           |
  E879+          ; ---------------                                               |
  E879+          ;   Convert Create and Update Time fields from Universal format |
  E879+          ;   to CP/M+ (P2DOS) form and insert in DIRectory buffer.  Call |
  E879+          ;   WRFCB routine to write Directory on exit.                   |
  E879+          ;---------------------------------------------------------------|
  E879+          ; Enter: A = Directory Offset (0, 20H, 40H) of subject file     |
  E879+          ;       BC = Address of WRFCB Routine in ZSDOS                  |
  E879+          ;       DE = Pointer to DIR Buffer.  (Offset in A)              |
  E879+          ;       HL = DMA Address containing 15 byte Stamp frame         |
  E879+          ;                                                               |
  E879+          ; Exit : A = 1 if OK, Else A = 0FFH if error.  Flags undefined  |
ZAS Relocating Macro Assembler (v3.05                             page   93
                                                            
                                                            

  E879+          ;                                                               |
  E879+          ; Effects : Addressed DIR buffer updated on disk if successful  |
  E879+          ;===============================================================+
  E879+          
  E879+CDD1E9    PSTAMP: CALL    SETREC          ; Calculate the Stamp area addr for file
  E87C+                                          ; DE-->DMA buff, HL-->P2DOS Create field
  E87C+CD96E8            CALL    U2PTIM          ; Convert Create field to destination
  E87F+2012              JR      NZ,NOTIM0       ; ..error exit if invalid date
  E881+13                INC     DE              ; Advance to Update field
  E882+13                INC     DE
  E883+13                INC     DE
  E884+13                INC     DE
  E885+13                INC     DE
  E886+CD96E8            CALL    U2PTIM          ; Convert Update field to destination
  E889+2008      WRFCB0: JR      NZ,NOTIM0       ; ..error exit if invalid date
  E88B+CD0000    WRFCB:  CALL    $-$             ; Address set on entry
  E88E+3E01      OKRET:  LD      A,1             ; Else set OK flags and return
  E890+C9                RET
  E891+          
  E891+          ;.....
  E891+          
  E891+F1        NOTIM:  POP     AF              ; Clear the stack
  E892+F1        NO$TD:  POP     AF
  E893+F6FF      NOTIM0: OR      0FFH            ; ..and set error flags
  E895+C9                RET                     ; Back to caller
  E896+          
  E896+          ;---------------------------------------------------------------;
  E896+          ; Convert Universal T&D to addrsd buffer in CP/M+ (P2DOS) form. ;
  E896+          ;                                                               ;
  E896+          ; Enter: DE = Address of start of Universal T&D string          ;
  E896+          ;        HL = Address of buffer to receive CP/M+ (P2DOS) T&D    ;
  E896+          ; Exit :  A = 0, Zero Flag Set (Z), Time string set if Ok..     ;
  E896+          ;         A = FF, Zero Reset (NZ), Time string unchanged on Err ;
  E896+          ;        DE --> Seconds byte in Universal field (Not moved)     ;
  E896+          ;        HL --> Seconds byte in CP/M+ (P2DOS) field (Not filled);
  E896+          ; Uses : All primary registers.                                 ;
  E896+          ;---------------------------------------------------------------;
  E896+          
  E896+E5        U2PTIM: PUSH    HL              ; Save destination address
  E897+1A                LD      A,(DE)          ; Get BCD Year
  E898+47                LD      B,A             ; ..to B
  E899+13                INC     DE              ; Advance to Month
  E89A+1A                LD      A,(DE)          ; Get BCD Month
  E89B+B0                OR      B               ; Is it Invalid (YY=MM=00)?
  E89C+285C              JR      Z,NODATE        ; ..jump to error exit if Invalid stamp
  E89E+78                LD      A,B             ; Get BCD Year again from B
  E89F+CDB0E9            CALL    BCDHEX          ; Convert year to Binary
  E8A2+FE4E              CP      78              ; Is it 20th Century?
  E8A4+3002              JR      NC,YR19         ; ..jump if so
  E8A6+C664              ADD     A,100           ; Else move to 21st Century
  E8A8+016C07    YR19:   LD      BC,1900         ; Set base century
  E8AB+81                ADD     A,C             ; Add current year to Base
  E8AC+4F                LD      C,A
  E8AD+3E00              LD      A,00
  E8AF+88                ADC     A,B
  E8B0+47                LD      B,A
ZAS Relocating Macro Assembler (v3.05                             page   94
                                                            
                                                            

  E8B1+1A                LD      A,(DE)          ; Get BCD Month
  E8B2+13                INC     DE
  E8B3+CDB0E9            CALL    BCDHEX          ; ..convert to Binary
  E8B6+67                LD      H,A
  E8B7+1A                LD      A,(DE)          ; Get Day
  E8B8+13                INC     DE              ; Point to U-Hours
  E8B9+D5                PUSH    DE              ; ..and save addr on stack
  E8BA+CDB0E9            CALL    BCDHEX          ; ..convert Day to Binary
  E8BD+6F                LD      L,A             ; Day to L (binary)
  E8BE+          
  E8BE+          ; Check validity of day, month, year.  (CHKDAT..From DATE.ASM)
  E8BE+          ; Enter:  L = binary day
  E8BE+          ;         H = binary month
  E8BE+          ;        BC = binary year
  E8BE+          
  E8BE+7C                LD      A,H             ; Month must be..
  E8BF+3D                DEC     A               ; Convert valid Month to 0-11 range
  E8C0+FE0C              CP      12              ; Is it a valid Month?
  E8C2+3039              JR      NC,BADDAT       ; ..jump error if invalid
  E8C4+E5                PUSH    HL              ; Save year
  E8C5+5F                LD      E,A
  E8C6+1600              LD      D,0
  E8C8+21EDE9            LD      HL,DM           ; Set lookup table for months
  E8CB+19                ADD     HL,DE
  E8CC+56                LD      D,(HL)          ; Get days in this month
  E8CD+E1                POP     HL
  E8CE+FE01              CP      1               ; Is this February? (2-1)
  E8D0+CCAAE9            CALL    Z,LEAPYR        ; ..check for leap year if so
  E8D3+2001              JR      NZ,CHKDT0       ; ..jump if not
  E8D5+14                INC     D               ; else make 29 days
  E8D6+7D        CHKDT0: LD      A,L             ; Check for day within range
  E8D7+3D                DEC     A               ; Have day > 0, check for <= max day
  E8D8+BA                CP      D
  E8D9+3022              JR      NC,BADDAT       ; ..anything else is error
  E8DB+          
  E8DB+          ; Calculate 16-bit Binary Date since 1978 in Days
  E8DB+          ; Entry: BC = Year (1978..2077) (really works til 2157)
  E8DB+          ;         H = Month (1..12)
  E8DB+          ;         L = Days (1..31)
  E8DB+          ; Exit : DE = Days      First day (0001H) : Su 01 Jan 1978
  E8DB+          ;                       Last day  (8EADH) :    31 Dec 2077
  E8DB+          ;                  Real Last day  (FFFFH) : Su 05 Jun 2157
  E8DB+          
  E8DB+E5                PUSH    HL              ; Save Month (H) and Day (L)
  E8DC+2600              LD      H,0             ; Null out Month leaving just days
  E8DE+EB                EX      DE,HL           ; ..move to DE
  E8DF+69                LD      L,C             ; Move current Year to HL
  E8E0+60                LD      H,B
  E8E1+01BA07            LD      BC,1978         ; Start with base year in BC
  E8E4+B7        DAYS0:  OR      A
  E8E5+ED42              SBC     HL,BC           ; Is this the starting year?
  E8E7+09                ADD     HL,BC
  E8E8+2820              JR      Z,DAYS1         ; ..jump if so
  E8EA+E5                PUSH    HL
  E8EB+216D01            LD      HL,365          ; Add days in non-leap year
  E8EE+19                ADD     HL,DE           ; ..to total days count in DE
ZAS Relocating Macro Assembler (v3.05                             page   95
                                                            
                                                            

  E8EF+EB                EX      DE,HL           ; ...and put new Days total in DE
  E8F0+E1                POP     HL
  E8F1+CDAAE9            CALL    LEAPYR          ; Is this a Leap year?
  E8F4+03                INC     BC              ; ..(advance to next year)
  E8F5+20ED              JR      NZ,DAYS0        ; ..loop if not Leap Year
  E8F7+13                INC     DE              ; Else add a day
  E8F8+18EA              JR      DAYS0           ; ..then loop
  E8FA+          
  E8FA+          ; Error routines.  Set destination P2Dos field to all Zeros
  E8FA+          
  E8FA+13        NODATE: INC     DE              ; Advance source ptr for same routine
  E8FB+13                INC     DE
  E8FC+3E                DEFB    03EH            ; ..fall thru to 2nd POP with LD  A,0D1H
  E8FD+          
  E8FD+D1        BADDAT: POP     DE              ; Restore Universal string (--> Hrs)
  E8FE+E1                POP     HL              ; Restore Destination Addr for P2DOS Date
  E8FF+0604              LD      B,4             ; Fill Destination field with Nulls
  E901+AF        BADDA1: XOR     A
  E902+77        BLOOP:  LD      (HL),A
  E903+23                INC     HL
  E904+10FC              DJNZ    BLOOP           ; ..loop til filled
  E906+13                INC     DE              ; ..Advance to Exit pointer conditions
  E907+13                INC     DE
  E908+3D                DEC     A               ; Set error Flags (A=FF, Zero Clear (NZ))
  E909+C9                RET
  E90A+          
  E90A+          ; DE=Binary Day total (Year & Day only).  Mo & Da on stack, BC=Current Year
  E90A+          
  E90A+E1        DAYS1:  POP     HL              ; Restore Month & Day
  E90B+EB                EX      DE,HL           ; Binary date to HL, Mo & Day to DE
  E90C+E5                PUSH    HL              ; ..and save Binary date
  E90D+21EDE9            LD      HL,DM           ; Address days-of-month table
  E910+1E01              LD      E,1
  E912+7A        DAYS2:  LD      A,D             ; Check for matching month
  E913+BB                CP      E
  E914+2816              JR      Z,DAYS4         ; ..exit when match
  E916+7E                LD      A,(HL)          ; Get days in this month
  E917+E3                EX      (SP),HL         ; Put table on stack, Binary date to HL
  E918+85                ADD     A,L             ; Add this month's days to Cum Binary Date
  E919+6F                LD      L,A
  E91A+3E00              LD      A,00
  E91C+8C                ADC     A,H
  E91D+67                LD      H,A
  E91E+7B                LD      A,E             ; Check this month
  E91F+FE02              CP      2               ; ..for Feb
  E921+CCAAE9            CALL    Z,LEAPYR        ; If so, Is it a Leap Year?
  E924+2001              JR      NZ,DAYS3A       ; ..jump if Not Leap Year and/or Not Feb
  E926+23                INC     HL              ; Else bump Cum Bin Date by 29 Feb
  E927+E3        DAYS3A: EX      (SP),HL         ; Put Cum Bin date to stack, Mo Table to HL
  E928+23                INC     HL              ; Point to next month
  E929+1C                INC     E               ; Bump index counter
  E92A+18E6              JR      DAYS2           ; ..and loop
  E92C+          
  E92C+C1        DAYS4:  POP     BC              ; Exit here..Put Cum Binary Date to BC
  E92D+D1                POP     DE              ; Restore Universal string (--> Hrs)
  E92E+E1                POP     HL              ; ..and Destination addr from stack
ZAS Relocating Macro Assembler (v3.05                             page   96
                                                            
                                                            

  E92F+71                LD      (HL),C          ; Put binary date in string
  E930+23                INC     HL
  E931+70                LD      (HL),B
  E932+23        SAVEM:  INC     HL
  E933+EB                EX      DE,HL           ; Pointers to correct regs
  E934+EDA0              LDI                     ; Move BCD Hours..
  E936+EDA0              LDI                     ; ..and BCD Minutes
  E938+EB                EX      DE,HL           ; Restore regs for exit conditions
  E939+AF                XOR     A               ; Set OK flags and return
  E93A+C9                RET
  E93B+          
  E93B+          ;---------------------------------------------------------------;
  E93B+          ; Convert CP/M+ (P2DOS) Time to Universal Time string           ;
  E93B+          ;                                                               ;
  E93B+          ; Enter: HL = Points to CP/M+ (P2DOS) T&D entry                 ;
  E93B+          ;        DE = Addr of destination Universal T&D entry           ;
  E93B+          ; Exit :  A = 0, Zero Flag Set (Z) Dest Date conv if OK, else.. ;
  E93B+          ;         A = FF, Zero Clear (NZ) Dest Nulled if Error          ;
  E93B+          ;        HL --> Seconds byte of Source P2DOS T&D (Not moved)    ;
  E93B+          ;        DE --> Seconds byte of Dest Universal T&D (Not filled) ;
  E93B+          ; Uses : All primaty registers.                                 ;
  E93B+          ;---------------------------------------------------------------;
  E93B+          
  E93B+D5        P2UTIM: PUSH    DE              ; Save Universal T&D address on stack
  E93C+5E                LD      E,(HL)          ; Get binary date to DE
  E93D+23                INC     HL
  E93E+56                LD      D,(HL)
  E93F+23                INC     HL
  E940+EB                EX      DE,HL           ; Put Binary Day/date in HL, P2Dos ptr in DE
  E941+7C                LD      A,H             ; Check for valid entry
  E942+B5                OR      L               ; Is date present?
  E943+2008              JR      NZ,P2UTI0       ; ..jump if Not Null entry
  E945+E1                POP     HL              ; Get Universal T&D Dest addr back
  E946+0605              LD      B,5
  E948+CD01E9            CALL    BADDA1          ; ..and null the U-Time field
  E94B+EB                EX      DE,HL           ; Put ptrs in correct regs
  E94C+C9                RET                     ; ..and return to caller
  E94D+          
  E94D+D5        P2UTI0: PUSH    DE              ; Save P2D Time pointer (--> Min)
  E94E+01BA07            LD      BC,1978         ; Beginning year
  E951+116D01    DMJ0:   LD      DE,365          ; Set days in normal year
  E954+CDAAE9            CALL    LEAPYR          ; ..check for leap year
  E957+2001              JR      NZ,DMJ1         ; ..jump if not
  E959+13                INC     DE
  E95A+B7        DMJ1:   OR      A               ; When # of days left..
  E95B+ED52              SBC     HL,DE           ; ..is less than days in year..
  E95D+3805              JR      C,DMJ2          ; ..year is in HL, so exit
  E95F+2803              JR      Z,DMJ2          ; ...or her if last day of Year
  E961+03                INC     BC              ; Bump starting year
  E962+18ED              JR      DMJ0            ; ..and back for another try
  E964+          
  E964+          ; When get here, binary year is in BC, remaining days in HL
  E964+          
  E964+19        DMJ2:   ADD     HL,DE           ; Compensate for above underflow
  E965+3E01              LD      A,1             ; Start with month # 1 (Jan)
  E967+1600              LD      D,0             ; ..prepare for 16-bit math
ZAS Relocating Macro Assembler (v3.05                             page   97
                                                            
                                                            

  E969+E5                PUSH    HL              ; Save days remaining
  E96A+21EDE9            LD      HL,DM           ; ..and address month table
  E96D+5E        DMJ3:   LD      E,(HL)          ; Get days in current Mo to E
  E96E+FE02              CP      2               ; Is it Feb?
  E970+CCAAE9            CALL    Z,LEAPYR        ; ..Check for leap year if Feb
  E973+2001              JR      NZ,DMJ4         ; Jump if not leap year
  E975+1C                INC     E               ; ..else compensate
  E976+E3        DMJ4:   EX      (SP),HL         ; Swap pointer (HL) with Days Remaining (stk)
  E977+B7                OR      A
  E978+ED52              SBC     HL,DE           ; Subtract days in Month from Remaining days
  E97A+3807              JR      C,DMJ5          ; ..Exit if we've gone too far
  E97C+2805              JR      Z,DMJ5          ; ...or just far enough (last day of month)
  E97E+E3                EX      (SP),HL
  E97F+23                INC     HL              ; Point to next month in table
  E980+3C                INC     A               ; ..bump month counter
  E981+18EA              JR      DMJ3            ; ..and Try again
  E983+          
  E983+          ; Arrive here with Binary year on Stack Top, Relative month in A (Jan = 1),
  E983+          ;   Days in that month in E, and binary year in BC.
  E983+          
  E983+19        DMJ5:   ADD     HL,DE           ; Compensate for underflow
  E984+E3                EX      (SP),HL         ; ..and put back on stack
  E985+E1                POP     HL              ; Restore Day in L
  E986+CDBEE9            CALL    BINBCD          ; Convert Month (in A) to BCD
  E989+60                LD      H,B             ; ..moving Year to HL
  E98A+47                LD      B,A
  E98B+7D                LD      A,L             ; Convert Day
  E98C+69                LD      L,C
  E98D+CDBEE9            CALL    BINBCD          ; ..to BCD
  E990+4F                LD      C,A
  E991+116400            LD      DE,100          ; Subtract centuries, one by one..
  E994+B7        DMJ7A:  OR      A
  E995+ED52              SBC     HL,DE
  E997+30FB              JR      NC,DMJ7A        ; ..until we go too far
  E999+19                ADD     HL,DE           ; Then correct for underflow
  E99A+7D                LD      A,L             ; Get Years (tens and ones)
  E99B+CDBEE9            CALL    BINBCD          ; ..to BCD
  E99E+          
  E99E+D1                POP     DE              ; Restore P2D Time Pointer (--> Min)
  E99F+E1                POP     HL              ; Get Universal time string addr
  E9A0+77                LD      (HL),A          ; Store Years..
  E9A1+23                INC     HL
  E9A2+70                LD      (HL),B          ; ..Months
  E9A3+23                INC     HL
  E9A4+71                LD      (HL),C          ; ..Days
  E9A5+CD32E9            CALL    SAVEM           ; Store Hours and Minutes & Set flags
  E9A8+EB                EX      DE,HL           ; Put U-tim exit addr in DE
  E9A9+C9                RET                     ; ..and finish up elsewhere
  E9AA+          
  E9AA+          ;.....
  E9AA+          ; Calculate Leap Year correction (xxxxxx00B for Leap Years)
  E9AA+          ; Enter: BC = Binary year
  E9AA+          ; Exit :  Z = 1 (set (Z)) Correction necessary
  E9AA+          ;         Z = 0 (clear (NZ)) No correction needed
  E9AA+          
  E9AA+CB41      LEAPYR: BIT     0,C             ; Get lower part of date
ZAS Relocating Macro Assembler (v3.05                             page   98
                                                            
                                                            

  E9AC+C0                RET     NZ              ; ..return if not Leap year
  E9AD+CB49              BIT     1,C             ; Test other bit
  E9AF+C9                RET                     ; ..and return
  E9B0+          
  E9B0+          ;.....
  E9B0+          ; Convert BCD to HEX
  E9B0+          ; Enter: A = BCD digit to be converted
  E9B0+          ; Exit : A = HEX (binary) conversion
  E9B0+          ;                All registers preserved
  E9B0+          
  E9B0+B7        BCDHEX: OR      A
  E9B1+C8                RET     Z               ; Zero is same
  E9B2+C5                PUSH    BC              ; Save register
  E9B3+0600              LD      B,0             ; Set counter
  E9B5+04        BCDHX0: INC     B               ; Bump counter
  E9B6+D601              SUB     1               ; Count down BCD..
  E9B8+27                DAA
  E9B9+20FA              JR      NZ,BCDHX0       ; ..til all gone
  E9BB+78                LD      A,B
  E9BC+C1                POP     BC
  E9BD+C9                RET
  E9BE+          
  E9BE+          ;.....
  E9BE+          ; Convert byte in A register to two packed BCD digits.
  E9BE+          
  E9BE+C5        BINBCD: PUSH    BC              ; Affect only A register
  E9BF+06FF              LD      B,0FFH          ; Preset counter
  E9C1+04        BINBCL: INC     B               ; Bump output count
  E9C2+D60A              SUB     10
  E9C4+30FB              JR      NC,BINBCL       ; Loop bumping counter til no more 10s
  E9C6+C60A              ADD     A,10            ; ..correct for underflow
  E9C8+4F                LD      C,A             ; Save low nybble here for a while
  E9C9+78                LD      A,B             ; ..and bring hi one here..
  E9CA+87                ADD     A,A             ; Move it into position
  E9CB+87                ADD     A,A
  E9CC+87                ADD     A,A
  E9CD+87                ADD     A,A
  E9CE+81                ADD     A,C             ; Add in Low nybble
  E9CF+C1                POP     BC              ; Restore regs
  E9D0+C9                RET
  E9D1+          
  E9D1+          ;---------------------------------------------------------------+
  E9D1+          ; Calculate offset within T&D Record if one exists.             ;
  E9D1+          ;                                                               ;
  E9D1+          ; Enter: A = Sector Pointer (0,20H,40H,60H)                     ;
  E9D1+          ;       BC = Points to the ZSDOS WRFCB routine                  ;
  E9D1+          ;       DE = Points to Directory Sector Buffer                  ;
  E9D1+          ; Exit : A = 0, Zero Flag Set (Z), If Ok, else A <> 0, (NZ)     ;
  E9D1+          ;       HL = First byte of Create Date for record if OK         ;
  E9D1+          ; Uses : HL (Entry DE), AF, BC.  Entry HL preserved in DE       ;
  E9D1+          ;---------------------------------------------------------------+
  E9D1+          
  E9D1+ED438CE8  SETREC: LD      (WRFCB+1),BC    ; Save Directory Write Routine address
  E9D5+EB                EX      DE,HL           ; DIR sector to HL for adr calcs
  E9D6+016000            LD      BC,060H         ; Offset to T&D Fields
  E9D9+09                ADD     HL,BC
ZAS Relocating Macro Assembler (v3.05                             page   99
                                                            
                                                            

  E9DA+4F                LD      C,A             ; ..Sector pointer to register
  E9DB+7E                LD      A,(HL)          ; Get byte
  E9DC+D621              SUB     21H             ; Is TimeStamping present?
  E9DE+C292E8            JP      NZ,NO$TD        ; ..quit here if not
  E9E1+79                LD      A,C             ; Restore Sector pointer from storage
  E9E2+0F                RRCA                    ; Shift 2 times
  E9E3+0F                RRCA
  E9E4+4F                LD      C,A             ; ..save temporarily
  E9E5+0F                RRCA                    ; Shift 2 more times
  E9E6+0F                RRCA
  E9E7+81                ADD     A,C             ; ..and add in again
  E9E8+4F                LD      C,A             ; Set for offset (C=0,10,20)
  E9E9+09                ADD     HL,BC           ; Add offset
  E9EA+23                INC     HL              ; ..and bump to Create Time Start
  E9EB+AF                XOR     A               ; Set good return status
  E9EC+C9                RET
  E9ED+          
  E9ED+          ;===================================================;
  E9ED+          ;===|           D A T A     A R E A             |===;
  E9ED+          ;===================================================;
  E9ED+          ; Put in CSEG to make single module
  E9ED+          
  E9ED+          ;.....
  E9ED+          ; Days-in-Month table
  E9ED+          
  E9ED+1F1C1F1E1FDM:     DEFB    31,28,31,30,31,30,31,31,30,31,30,31
  E9F9+          
  E9F9+          ;.....
  E9F9+          ; Time/Date String in Universal Format
  E9F9+          
  E9F9+0000000000DSTIME: DEFB    0,0,0,0,0,0
  E9FF+          
  E9FF+          ;******************************************************************
  E9FF+          ; Clock Driver for ZSDOS
  E9FF+          ;
  E9FF+          ; This routine interfaces the ZSDOS Time interface to a physical
  E9FF+          ; clock driver routine.  The ZSDOS interface is:
  E9FF+          ;
  E9FF+          ;       Entry conditions:
  E9FF+          ;               C  = Read/Write Code (1=Write, 0=Read)
  E9FF+          ;               DE = Address to Put/Set Time
  E9FF+          ;
  E9FF+          ; The Error return code on Clock Set is overwritten during instal-
  E9FF+          ; lation if a ZSDOS clock driver (with two jumps) is detected, with
  E9FF+          ; a relative jump to the clock set vector.  This short routine also
  E9FF+          ; places the time address in the HL registers to be compatible with
  E9FF+          ; DateStamper clock specifications.
  E9FF+          ;******************************************************************
  E9FF+          
  E9FF+          ; RWCLK:        EX      DE,HL           ; Set registers for DS clock interface
  E9FF+          ;       LD      A,C
  E9FF+          ;       OR      A               ; Read (0) or Write (<>0)
  E9FF+          ;       JR      Z,CLK           ; Read clock if Zero..
  E9FF+          ;
  E9FF+          ; ; The following Error Return code is overwritten if ZSDOS clock added
  E9FF+          ;
ZAS Relocating Macro Assembler (v3.05                             page  100
                                                            
                                                            

  E9FF+          ;       XOR     A               ; Set error return
  E9FF+          ;       DEC     A
  E9FF+          ;       RET
  E9FF+          
  E9FF+          ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E9FF+          ;               C l o c k     D r i v e r
  E9FF+          ;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  E9FF+          ; Actual clock driver or vector to external routine added here
  E9FF+          
  E9FF+          ; CLK:
  E9FF+          
  E9FF+          ; TOP   EQU     $
  E9FF+          ;
  E9FF+          ;       END
  E9FF                    endif
  E9FF                    if     STMPZS
  E9FF                     include zds
  E9FF                    endif
  E9FF                   endif   ; zdsson
  E9FF           
  E9FF           ; SIZE ERROR TEST
  E9FF           
  E9FF                    if     [ $ gt [ rcp + rcps*128 ] ]
  E9FF                   ***  RCP is too large  ***
  E9FF                    endif
  E9FF           
  E9FF           
  E9FF           ; End of Z33RCP.Z80
  E9FF           
  E9FF                   end

**** Symbol table ****
ALLFLAG         0041 ATT             E4E1 ATT1            E4F0
ATT2            E4FE ATT3            E50F ATT4            E51C
ATT5            E527 ATT6            E549 ATT7            E55C
ATT8            E567 ATTI            E502 ATTR            E507
ATTRF           001E ATTS            E50B ATTSET          E587
ATTST1          E58F BACCPTDIR       0001 BACCPTDU        0000
BADDA1          E901 BADDAT          E8FD BADUENV         0001
BASE            0000 BATTCHK         0004 BATTDIR         0005
BATTSYS         0006 BBADDUECP       0007 BCDHEX          E9B0
BCDHX0          E9B5 BDOS            CA06 BDOSB           CA00
BDRVPREFIX      0006 BDUENV          0000 BDUFIRST        0002
BFASTECP        0001 BFCPENV         0004 BHIGHUSER       0007
BIAS            8E00 BINBCD          E9BE BINBCL          E9C1
BINCLDIR        0004 BINCLDU         0003 BINCLENV        0002
BIOREAS         0A00 BIOS            D800 BIOSTDS         0600
BLKMOV          E6CE BLKSHF          E326 BLOOP           E902
BNDRENV         0005 BPWCHECK        0006 BPWNOECHO       0005
BRCPENV         0003 BREAK           E69F BREAK1          E6B0
BRIGHT          0002 BROOTONLY       0006 BS              0008
BSCANCUR        0005 BSHELLIF        0007 BSKIPPATH       0000
BSUBCLUE        0001 BSUBECHO        0003 BSUBON          0000
BSUBQUIET       0002 BWDU            0004 BWPASS          0003
BWPREFIX        0002 CACLDR          E85C CAN             0018
CCP             C200 CCPLEN          0800 CHKDT0          E8D6
ZAS Relocating Macro Assembler (v3.05                             page  101
                                                            
                                                            

CL              001A CLIST           E241 CLOSEF          0010
CLS             E2AE CLS1            E2C1 CLSON           FFFF
CLSTCAP         FFFF CMDCHAR         0025 CMDLIST         E26F
CMDLIST1        E278 CMDLIST1A       E283 CMDLIST2        E28F
CMDLIST3        E295 CMDLIST4        E29B CMDLIST5        E2AA
CMDSIZE         0004 CMDSLINE        0005 CMDSPACE        0008
CMDTBL          FD11 COMMAND         F727 COMP            E809
COMPSZF         0023 CONIN           E625 CONOUT          E5FE
CONSTF          000B COUNT           0001 CPBLOCKS        0080
CPON            0000 CPSP            FFFF CR              000D
CRDN            0018 CREOFF          001A CRLF            E61F
CRSPACE         E2D5 CRTCHAR         0043 CRUP            0005
CTRLA           0001 CTRLC           0003 CTRLD           0004
CTRLE           0005 CTRLF           0006 CTRLK           000B
CTRLR           0012 CTRLS           0013 CTRLX           0018
CTRLZ           001A CURSL           0013 CURSR           0004
DASH            E647 DAYS0           E8E4 DAYS1           E90A
DAYS2           E912 DAYS3A          E927 DAYS4           E92C
DECDSP          E5E9 DECDSP1         E5EC DECDSP2         E5FC
DECDSP3         E5D9 DEFINE          E716 DEFINE1         E72A
DFREE           E302 DIM             0001 DIR             E355
DIR01           E368 DIR3            E390 DIR3A           E39F
DIR4            E3AA DIRALPHA        E78F DIRBUF          E712
DIRBUFON        FFFF DIRCONF         0006 DIRERR          E73D
DIRNLY          E385 DIRON           FFFF DIRPR           E387
DIRSP           FFFF DM              E9ED DMJ0            E951
DMJ1            E95A DMJ2            E964 DMJ3            E96D
DMJ4            E976 DMJ5            E983 DMJ7A           E994
DPARAMS         E2F0 DSTIME          E9F9 ECHOLST         0000
ECHOON          0000 EOF             001A EOFCHAR         001A
ERA             E3B3 ERA1            E3C4 ERA2            E3DF
ERA3            E3EF ERAFLG          E3D5 ERAON           FFFF
ERAQ            E667 ERAQ1           E672 ERASEF          0013
ERASP           FFFF ESC             001B EXIT            E643
EXPATH          EDF4 EXPATHS         0005 EXTFCB          EDD0
EXTRABIAS       1200 EXTSTK          EFD0 FALSE           0000
FATT            E570 FCB             005C FCB1            005C
FCB2            006C FCBEXT          0068 FCBRNO          007C
FCP             EA00 FCPS            0004 FENCE           007C
FF              000C FILLP           E69A FREE1           E30E
FREE2           E312 FREE3           E316 FREE4           E323
FREE5           E32B FREE6           E32F GAP             E799
GD1             E75D GD1A            E779 GD2             E77A
GETDIR          E74B GETF            00FF GETPARMF        001F
GETREG          FA2F GETSBIT         E6B8 GSLOOP          E870
GSTAMP          E868 GSTOFF          001E HASEDS          FFFF
ICOMPARE        E7FF IDISK1          0024 IDISK2          0024
IDISK3          0001 IDISK4          0001 IDSTRING        FE05
II              E7AA INCLUDE         F4BA INITFCB1        E68A
INITFCB2        E68D INQALCF         001B INQDISKF        0019
INSPECT         E55D INTRON          0000 IOBYTE          0003
IOP             0000 IOPS            0000 IPOS            E817
ISWAP           E7EC ISWAP1          E7F5 IUSER1          0024
IUSER2          000F IUSER3          0024 IUSER4          000F
JG              E7E5 JJ              E7C3 LC1             E49D
LC2             E4BB LCASECHAR       003E LCOUT           E498
ZAS Relocating Macro Assembler (v3.05                             page  102
                                                            
                                                            

LEAPYR          E9AA LF              000A LISTCPR         FFFF
LISTF           0005 LISTFCP         FFFF LISTON          0000
LOGINF          000E LOGUSR          E6E4 LSTOFF          0018
LTON            FFFF M80F            3CED M80W            3CEF
MAKEF           0016 MAXDIRS         0100 MODOFF          001C
MSIZE           003C N               E7B2 NCHARS          0004
NLINES          0018 NO              0000 NO$TD           E892
NODATE          E8FA NOFCP           E256 NOSHOW          FFFF
NOSYS           FFFF NOTE            E60E NOTEON          0000
NOTIM           E891 NOTIM0          E893 NXTFILE         E826
OACCPTDIR       0001 OACCPTDU        0001 OADUENV         0000
OATTCHK         0003 OATTDIR         0003 OATTSYS         0003
OBADDUECP       0000 ODRVPREFIX      0001 ODUENV          0000
ODUFIRST        0001 OFASTECP        0002 OFCPENV         0000
OFFCDRV         002F OFFCMD          0019 OFFCUSR         002E
OFFM            E5C9 OFFOPT          0006 OFFPARSE        0010
OFFSCAN         0016 OFFSRUN         002D OFFVERS         0005
OFFXSUB         002C OHIGHUSER       0001 OINCLDIR        0001
OINCLDU         0001 OINCLENV        0000 OKRET           E88E
ONDRENV         0000 OPENF           000F OPTFLAG         F9BA
OPWCHECK        0002 OPWNOECHO       0002 ORCPENV         0000
OROOTONLY       0000 OS$BASE         0000 OSCANCUR        0001
OSHELLIF        0003 OSKIPPATH       0002 OSUBCLUE        0003
OSUBECHO        0003 OSUBON          0003 OSUBQUIET       0003
OWDU            0002 OWPASS          0002 OWPREFIX        0002
P2UTI0          E94D P2UTIM          E93B PAGCNT          E714
PAGEBREAK       E4BE PEEKBDR         FFFF PEEKCHK         FFFF
PEEKHDR         FFFF PEEKON          0000 PGDFLG          0050
PGDFLT          FFFF PGFLG           E4B0 POKEON          0000
POKEQ           FFFF PORTON          0000 PRBUFF          0009
PRFN            E6ED PRFN1           E6FC PRFNF           E6D5
PRINT           E60F PRINTHL         E615 PROTON          FFFF
PRTCHAR         0050 PSTAMP          E879 PUNCHF          0004
PUTREG          FA6E RCP             E200 RCPID           0041
RCPNAME         E23D RCPS            0010 RDBUFF          000A
RDCONF          0001 RDRF            0003 READF           0014
REGON           0000 RENF            0017 RENON           0000
RESET           E2C7 RESETDKF        000D RESMSG          FFFF
RESOLVE         F8F9 RESON           FFFF RESROOM         0400
RETSAVE         E638 ROMSG           E660 ROTEST          E64E
SAVEM           E932 SEARF           E704 SEARF1          E708
SEARN           E737 SEG1            E200 SEG10           EC00
SEG11           EF00 SEG12           EFD0 SEG2            EA00
SEG3            EA00 SEG4            ED00 SEG5            ED80
SEG6            EDD0 SEG7            EDF4 SEG8            EDFF
SEG9            EE00 SELDRV          E33C SETDMAF         001A
SETERR          FFFF SETREC          E9D1 SETRRF          0024
SETUSR          E6E7 SGUSERF         0020 SHSIZE          0020
SHSTK           ED00 SHSTKS          0004 SLASHCHK        FFFF
SORTNT          FFFF SPACE           E2D8 SPACE1          E2E4
SPACEON         FFFF SPAEXIT         E640 SPC             0020
SRCHFF          0011 SRCHNF          0012 SRTL0           E797
SRTL1           E7A9 SRTL2           E7BE SSTOFF          0020
STAMPC          E844 STAMPU          E848 STMPP2          FFFF
STMPZS          0000 STTIM           E84A SUBVER          0001
SWAP            F9F0 SYSFLAG         0053 SYSTST          E6CC
ZAS Relocating Macro Assembler (v3.05                             page  103
                                                            
                                                            

TAB             0009 TBUF            0080 TBUFF           0080
TESTF80         0000 TESTM80         FFFF TFCB            005C
TIMOFF          0016 TPA             0100 TRUE            FFFF
TSTON           0000 TYPE            E3FC TYPE0           E400
TYPE2           E44C TYPE3           E463 TYPE4           E47C
TYPE5           E483 TYPE6           E48E TYPEX           E410
TYPEX1          E418 TYPEX2          E423 U2PTIM          E896
UCASECHAR       003C UDFLAG          0004 UPCASE          FFFF
VERNOF          000C VERS            0016 VERSION         0002
WBOOT           0000 WCP             FFFF WDIR            0000
WERA            FFFF WHEEL           FFFF WHL             E594
WHLMASK         0000 WHLMSG          E5AE WHLMSG1         E5AE
WHLOFF          E5AA WHLON           FFFF WHLPASS         E5D1
WHLQON          0000 WHLQUIET        0000 WHLSET          E5AB
WHRC            0000 WIDE            FFFF WLIST           FFFF
WPASS           FD2A WPEEK           FFFF WPOKE           FFFF
WPORT           FFFF WPROT           FFFF WRCONF          0002
WREG            FFFF WREN            FFFF WRFCB           E88B
WRFCB0          E889 WRITEF          0015 WTYPE           FFFF
WWHLQ           0000 YES             FFFF YR19            E8A8
Z3CL            EF00 Z3CLS           00D0 Z3ENV           EC00
Z3ENVS          0002 Z3MSG           ED80 Z3NDIR          EE00
Z3NDIRS         001C Z3RET           E644 Z3REV           0021
Z3WHL           EDFF ZBUFBAS         E200 ZDSSON          FFFF
ZDSSTPR         E838 ZDSSTSZ         01C8 ZFLOPKG         0200
ZIOPKG          0000 ZRESPKG         0800 ZSTDOVR         0400
3CL            EF00 Z3CLS           00D0 Z3ENV           EC00
Z3ENVS          0002 Z3MSG           ED80 Z3NDIR          E