
	.Z80
	ASEG

; *  SYSTEM SEGMENT:  SYS.RCP
; *  SYSTEM:  ARIES-1
; *  CUSTOMIZED BY:  RICHARD CONN
;
; *
; *  PROGRAM:  SYSRCP.ASM
; *  AUTHOR:  RICHARD CONN
; *  VERSION:  1.0
; *  DATE:  3 FEB 84
; *  PREVIOUS VERSIONS:  NONE
; *
VERSION	EQU	10
;
; *
; *	SYSRCP is a resident command processor for ZCPR3.  As with
; * all resident command processors, SYSRCP performs the following functions:
; *
; *		1.  Assuming that the EXTFCB contains the name of the
; *			command, SYSRCP looks to see if the first character
; *			of the file name field in the EXTFCB is a question
; *			mark; if so, it returns with the Zero Flag Set and
; *			HL pointing to the internal routine which prints
; *			its list of commands
; *		2.  The resident command list in SYSRCP is scanned for
; *			the entry contained in the file name field of
; *			EXTFCB; if found, SYSRCP returns with the Zero Flag
; *			Set and HL pointing to the internal routine which
; *			implements the function; if not found, SYSRCP returns
; *			with the Zero Flag Reset (NZ)
; *
;
; *
; *  Global Library which Defines Addresses for SYSRCP
; *
; 	MACLIB	Z3BASE	; USE BASE ADDRESSES
; 	MACLIB	SYSRCP	; USE SYSRCP HEADER
include	../z3base.lib	; use base addresses
include sysrcp.lib		; use sysrcp header

;
CTRLC	EQU	'C'-'@'
TAB	EQU	09H
; LF	EQU	0AH
FF	EQU	0CH
; CR	EQU	0DH
CTRLX	EQU	'X'-'@'
;
WBOOT	EQU	BASE+0000H	;CP/M WARM BOOT ADDRESS
UDFLAG	EQU	BASE+0004H	;USER NUM IN HIGH NYBBLE, DISK IN LOW
; BDOS	EQU	BASE+0005H	;BDOS FUNCTION CALL ENTRY PT
TFCB	EQU	BASE+005CH	;DEFAULT FCB BUFFER
FCB1	EQU	TFCB		;1st and 2nd FCBs
FCB2	EQU	TFCB+16
TBUFF	EQU	BASE+0080H	;DEFAULT DISK I/O BUFFER
TPA	EQU	BASE+0100H	;BASE OF TPA
DIRBUF	EQU	BASE+4000H	;DIR BUFFER (MANY ENTRIES PERMITTED)
PAGCNT	EQU	DIRBUF-100H	;PAGE COUNT BUFFER
OLDFCB	EQU	PAGCNT+1	;OLD FCB BUFFER
CPBLOCKS EQU	32		;USE 4K FOR BUFFERING OF COPY
;
; $-MACRO 		;FIRST TURN OFF THE EXPANSIONS
;
; MACROS TO PROVIDE Z80 EXTENSIONS
;   MACROS INCLUDE:
;
;	JR	- JUMP RELATIVE
;	JR	C,- JUMP RELATIVE IF CARRY
;	JRNC	- JUMP RELATIVE IF NO CARRY
;	JRZ	- JUMP RELATIVE IF ZERO
;	JRNZ	- JUMP RELATIVE IF NO ZERO
;	DJNZ	- DECREMENT B AND JUMP RELATIVE IF NO ZERO
;
;	@GENDD MACRO USED FOR CHECKING AND GENERATING
;	8-BIT JUMP RELATIVE DISPLACEMENTS
;
; @GENDD	MACRO	?DD	;;USED FOR CHECKING RANGE OF 8-BIT DISPLACEMENTS
; 	IF (?DD GT 7FH) AND (?DD LT 0FF80H)
; 	DB	100H,?DD	;Displacement Range Error on Jump Relative
; 	ELSE
; 	DB	?DD
; 	ENDIF		;;RANGE ERROR
; 	ENDM
; ;
; ;
; ; Z80 MACRO EXTENSIONS
; ;
; JR	MACRO	?N	;;JUMP RELATIVE
; 	IF	I8080	;;8080/8085
; 	JMP	?N
; 	ELSE		;;Z80
; 	DB	18H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; ;
; JR	C,MACRO	?N	;;JUMP RELATIVE ON CARRY
; 	IF	I8080	;;8080/8085
; 	JC	?N
; 	ELSE		;;Z80
; 	DB	38H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; ;
; JRNC	MACRO	?N	;;JUMP RELATIVE ON NO CARRY
; 	IF	I8080	;;8080/8085
; 	JNC	?N
; 	ELSE		;;Z80
; 	DB	30H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; ;
; JRZ	MACRO	?N	;;JUMP RELATIVE ON ZERO
; 	IF	I8080	;;8080/8085
; 	JZ	?N
; 	ELSE		;;Z80
; 	DB	28H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; ;
; JRNZ	MACRO	?N	;;JUMP RELATIVE ON NO ZERO
; 	IF	I8080	;;8080/8085
; 	JNZ	?N
; 	ELSE		;;Z80
; 	DB	20H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; ;
; DJNZ	MACRO	?N	;;DECREMENT B AND JUMP RELATIVE ON NO ZERO
; 	IF	I8080	;;8080/8085
; 	DCR	B
; 	JNZ	?N
; 	ELSE		;;Z80
; 	DB	10H
; 	@GENDD	?N-$-1
; 	ENDIF		;;I8080
; 	ENDM
; *
; *  SYSTEM Entry Point
; *
	ORG	RCP		; passed for Z3BASE

	DEFB	'Z3RCP'		; Flag for Package Loader
; *
; *  **** COMMAND TABLE FOR RCP ****
; *	THIS TABLE IS RCP-DEPENDENT!
; *
; *	THE COMMAND NAME TABLE IS STRUCTURED AS FOLLOWS:
; *
; *	CTABLE:
; *		DB	'CMNDNAME'	; Table Record Structure is
; *		DW	CMNDADDRESS	; 8 Chars for Name and 2 Bytes for Adr
; *		...
; *		DB	0	; End of Table
; *
CNSIZE	EQU	4		; NUMBER OF CHARS IN COMMAND NAME
	DEFB	CNSIZE		; size of text entries
CTAB:
	DEFB	'H   '		; Help for RCP
	DEFW	CLIST
CTAB1:
;
	IF	CPON
	DEFB	'CP  '		; Copy
	DEFW	COPY
	ENDIF			;CPON
;
	IF	DIRON
	DEFB	'DIR '		; Directory
	DEFW	DIR
	ENDIF			;DIRON
;
	IF	ECHOON
	DEFB	'ECHO'		; Echo
	DEFW	ECHO
	ENDIF
;
	IF	ERAON
	DEFB	'ERA '		; Erase
	DEFW	ERA
	ENDIF			;ERAON
;
	IF	LTON AND LISTON
	DEFB	'LIST'		; List
	DEFW	LISTC
	ENDIF			;LTON AND LISTON
;
	IF	NOTEON
	DEFB	'NOTE'		; Note-Comment-NOP Command
	DEFW	NOTE
	ENDIF
;
	IF	PEEKON
	DEFB	'P   '		; Peek into Memory
	DEFW	PEEK
	ENDIF			;PEEKON
;
	IF	POKEON
	DEFB	'POKE'		; Poke Values into Memory
	DEFW	POKE
	ENDIF			;POKEON
;
	IF	PROTON
	DEFB	'PROT'		; Protection Codes
	DEFW	ATT
	ENDIF			;PROTON
;
	IF	REGON
	DEFB	'REG '		; Register Command
	DEFW	REGCMD
	ENDIF			;RSETON
;
	IF	RENON
	DEFB	'REN '		; Rename
	DEFW	REN
	ENDIF			;RENON
;
	IF	LTON
	DEFB	'TYPE'		; Type
	DEFW	TYPE
	ENDIF			;LTON
;
	IF	WHLON
	DEFB	'WHL '		; Wheel
	DEFW	WHL
	DEFB	'WHLQ'		; Wheel Query
	DEFW	WHLMSG
	ENDIF			;WHLON
;
	DEFB	0
;
;  BANNER NAME OF RCP
;
RCP$NAME:
	DEFB	'SYS '
	DEFB	(VERSION/10)+'0','.',(VERSION MOD 10)+'0'
	DEFB	RCPID
	DEFB	0

;
;  COMMAND LIST ROUTINE
;
CLIST:
	LD	HL,RCP$NAME	; print RCP Name
	CALL	PRINT1
	LD	HL,CTAB1	; print table entries
	LD	C,1		; set count for new line
CLIST1:
	LD	A,(HL)		; done?
	OR	A
	RET	Z
	DEC	C		; count down
	JR	NZ,CLIST1A
	CALL	CRLF		; new line
	LD	C,4		; set count
CLIST1A:
	LD	DE,ENTRYNAME	; copy command name into message buffer
	LD	B,CNSIZE	; number of chars
CLIST2:
	LD	A,(HL)		; copy
	LD	(DE),A
	INC	HL		; pt to next
	INC	DE
	DEC	B
	JP	NZ,CLIST2
	INC	HL		; skip to next entry
	INC	HL
	PUSH	HL		; save ptr
	LD	HL,ENTRYMSG	; print message
	CALL	PRINT1
	POP	HL		; get ptr
	JP	CLIST1
;
;  CONSOLE OUTPUT ROUTINE
;
CONOUT:
	PUSH	HL		; save regs
	PUSH	DE
	PUSH	BC
	PUSH	AF
	AND	7FH		; mask MSB
	LD	E,A		; char in E
	LD	C,2		; output
	CALL	BDOS
	POP	AF		; get regs
	POP	BC
	POP	DE
	POP	HL
;
;  This simple return doubles for the NOTE Command (NOP) and CONOUT Exit
;  NOTE Command: NOTE any text
;
NOTE:
	RET
;
;  PRINT STRING (TERMINATED IN 0 OR MSB SET) AT RETURN ADDRESS
;
PRINT:
	EX	(SP),HL		; get address
	CALL	PRINT1
	EX	(SP),HL		; put address
	RET
;
;  PRINT STRING (TERMINATED IN 0 OR MSB SET) PTED TO BY HL
;
PRINT1:
	LD	A,(HL)		; done?
	INC	HL		; pt to next
	OR	A		; 0 terminator
	RET	Z
	CALL	CONOUT		; print char
	RET	M		; MSB terminator
	JP	PRINT1
;
;  CLIST MESSAGES
;
ENTRYMSG:
	DEFB	'  '		; command name prefix
ENTRYNAME:
	DEFS	CNSIZE		; command name
	DEFB	0		; terminator

;
;  **** RCP ROUTINES ****
;  ALL CODE FROM HERE ON IS RCP-DEPENDENT!
;

;
;Section 5A
;Command: DIR
;Function:  To display a directory of the files on disk
;Forms:
;	DIR <afn>	Displays the DIR files
;	DIR <afn> S	Displays the SYS files
;	DIR <afn> A	Display both DIR and SYS files
;Notes:
;	The flag SYSFLG defines the letter used to display both DIR and
;		SYS files (A in the above Forms section)
;	The flag SOFLG defines the letter used to display only the SYS
;		files (S in the above Forms section)
;	The flag WIDE determines if the file names are spaced further
;		apart (WIDE=TRUE) for 80-col screens
;	The flag FENCE defines the character used to separate the file
;		names
;
	IF	DIRON
DIR:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WDIR
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE		;SAVE RET ADDRESS AND SET STACK
	LD	HL,FCB1+1	;MAKE FCB WILD (ALL '?') IF NO FILENAME.TYP
	LD	A,(HL)		;GET FIRST CHAR OF FILENAME.TYP
	CP	' '		;IF <SP>, ALL WILD
	CALL	Z,FILLQ
	LD	A,(FCB2+1)	;GET FIRST CHAR OF 2ND FILE NAME
	LD	B,80H		;PREPARE FOR DIR-ONLY SELECTION
	CP	' '		;ANY FLAG?
	JR	Z,DIRPR		;THERE IS NO FLAG, SO DIR ONLY
	LD	B,1		;SET FOR BOTH DIR AND SYS FILES
	CP	SYSFLG		;SYSTEM AND DIR FLAG SPECIFIER?
	JR	Z,DIRPR		;GOT SYSTEM SPECIFIER
	CP	SOFLG		;SYS ONLY?
	JR	NZ,DIRPR
	DEC	B		;B=0 FOR SYS FILES ONLY
;
	ENDIF			;DIRON
;
; DIRECTORY PRINT ROUTINE; ON ENTRY, B REG IS SET AS FOLLOWS:
;	0 FOR ONLY SYSTEM FILES, 80H FOR ONLY DIR FILES, 1 FOR BOTH
;
	IF	DIRON OR ERAON OR LTON OR PROTON OR CPON OR RENON
DIRPR:
	LD	A,B		;GET SYSTST FLAG
	CALL	GETDIR		;LOAD AND SORT DIRECTORY
	JP	Z,PRFNF		;PRINT NO FILE MESSAGE
	LD	E,4		;COUNT DOWN TO 0
;
; ENTRY PRINT LOOP; ON ENTRY, HL PTS TO FILES SELECTED (TERMINATED BY 0)
;	AND E IS ENTRY COUNTER
;
DIR3:
	LD	A,(HL)		;CHECK FOR DONE
	OR	A
	JP	Z,EXIT		;EXIT IF DONE
	LD	A,E		;GET ENTRY COUNTER
	OR	A		;OUTPUT <CRLF> IF 4 ENTRIES PRINTED IN LINE
	CALL	Z,DIRCRLF	;NEW LINE
	LD	A,E		;GET ENTRY COUNT
	CP	4		;FIRST ENTRY?
	JR	Z,DIR4
	CALL	PRINT
;
	IF	WIDE
;
	DEFB	'  '		;2 SPACES
	DEFB	FENCE		;THEN FENCE CHAR
	DEFB	' '+80H		;THEN 1 MORE SPACE
;
	ELSE
;
	DEFB	' '		;SPACE
	DEFB	FENCE+80H	;THEN FENCE CHAR
;
	ENDIF			;WIDE
;
DIR4:
	CALL	PRFN		;PRINT FILE NAME
	CALL	BREAK		;CHECK FOR ABORT
	DEC	E		;DECREMENT ENTRY COUNTER
	JR	DIR3
;
; CRLF FOR DIR ROUTINE
;
DIRCRLF:
	PUSH	AF		;DON'T AFFECT PSW
	CALL	CRLF		;NEW LINE
	POP	AF
	LD	E,4		;RESET ENTRY COUNTER
	RET
;
; AFTER A SEARCH, RETURN NZ SET IF DESIRED TYPE OF FILE FOUND, Z IF NOT
;   THIS ALGORITHM LOOKS AT THE SYSTEM BIT OF THE LOCATED FILE; THIS
;   BIT IS SET TO 1 IF THE FILE IS A SYSTEM FILE AND 0 IF NOT A SYSTEM
;   FILE.  THE FOLLOWING EXCLUSIVE OR MASKS ARE APPLIED TO RETURN Z OR NZ
;   AS REQUIRED BY THE CALLING PROGRAM:
;
;	SYSTEM BYTE: X 0 0 0  0 0 0 0   (AFTER 80H MASK, X=1 IF SYS, 0 IF DIR)
;
;	SYS-ONLY   : 0 0 0 0  0 0 0 0   (XOR 0 = 0 if X=0, = 80H if X=1)
;	DIR-ONLY   : 1 0 0 0  0 0 0 0   (XOR 80H = 80h if X=0, = 0 if X=1)
;	BOTH       : 0 0 0 0  0 0 0 1   (XOR 1 = 81H or 1H, NZ in both cases)
;
GETSBIT:
	DEC	A		;ADJUST TO RETURNED VALUE
	RRCA			;CONVERT NUMBER TO OFFSET INTO TBUFF
	RRCA
	RRCA
	AND	60H
	LD	C,A		;OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
	LD	DE,TBUFF	;PT TO BUFFER
	LD	A,E		;BASE ADDRESS IN A
	ADD	A,C		;ADD IN ENTRY OFFSET
	LD	E,A		;RESULT IN E
	PUSH	DE		;SAVE PTR IN DE
	ADD	A,10		;ADD OFFSET OF 10 TO PT TO SYSTEM BYTE
	LD	E,A		;SET ADDRESS
	LD	A,(DE)		;GET BYTE
	POP	DE		;GET PTR IN DE
	AND	80H		;LOOK AT ONLY SYSTEM BIT
SYSTST	EQU	$+1		;IN-THE-CODE VARIABLE
	XOR	0		; IF SYSTST=0, SYS ONLY; IF SYSTST=80H, DIR
	; ONLY; IF SYSTST=1, BOTH SYS AND DIR
	RET			;NZ IF OK, Z IF NOT OK
;
; FILL FCB @HL WITH '?'
;
FILLQ:
	LD	B,11		;NUMBER OF CHARS IN FN & FT
	LD	A,'?'		;STORE '?'
FILLP:
	LD	(HL),A		;STORE BYTE
	INC	HL		;PT TO NEXT
	DJNZ	FILLP		;COUNT DOWN
	RET
;
; LOAD DIRECTORY AND SORT IT
;   ON INPUT, A=SYSTST FLAG (0=SYS, 1=DIR, 80H=BOTH)
;   DIRECTORY IS LOADED INTO DIRBUF
;   RETURN WITH ZERO SET IF NO MATCH AND HL PTS TO 1ST ENTRY IF MATCH
;
GETDIR:
	LD	(SYSTST),A	; SET SYSTEM TEST FLAG
	CALL	LOGUSR		; LOG INTO USER AREA OF FCB1
	LD	HL,DIRBUF	; PT TO DIR BUFFER
	LD	(HL),0		; SET EMPTY
	LD	BC,0		; SET COUNTER
	CALL	SEARF		; LOOK FOR MATCH
	RET	Z		; RETURN IF NOT FOUND
;
;  STEP 1:  LOAD DIRECTORY
;
GD1:
	PUSH	BC		; SAVE COUNTER
	CALL	GETSBIT		; CHECK FOR SYSTEM OK
	POP	BC
	JR	Z,GD2		; NOT OK, SO SKIP
	PUSH	BC		; SAVE COUNTER
	INC	DE		; PT TO FILE NAME
	EX	DE,HL		; HL PTS TO FILE NAME, DE PTS TO BUFFER
	LD	B,11		; COPY 11 BYTES
	LDIR			; DO COPY
	EX	DE,HL		; HL PTS TO NEXT BUFFER LOCATION
	POP	BC		; GET COUNTER
	INC	BC		; INCREMENT COUNTER
GD2:
	CALL	SEARN		; LOOK FOR NEXT
	JR	NZ,GD1
	LD	(HL),0		; STORE ENDING 0
	LD	HL,DIRBUF	; PT TO DIR BUFFER
	LD	A,(HL)		; CHECK FOR EMPTY
	OR	A
	RET	Z
;
;  STEP 2:  SORT DIRECTORY
;
	PUSH	HL		; SAVE PTR TO DIRBUF FOR RETURN
	CALL	DIRALPHA	; SORT
	POP	HL
	XOR	A		; SET NZ FLAG FOR OK
	DEC	A
	RET

;*
;*  DIRALPHA -- ALPHABETIZES DIRECTORY IN DIRBUF; BC CONTAINS
;*	THE NUMBER OF FILES IN THE DIRECTORY
;*
DIRALPHA:
	LD	A,B		; ANY FILES?
	OR	C
	RET	Z
	LD	H,B		; HL=BC=FILE COUNT
	LD	L,C
	LD	(N),HL		; SET "N"
;*
;*  SHELL SORT --
;*    THIS SORT ROUTINE IS ADAPTED FROM "SOFTWARE TOOLS"
;*    BY KERNIGAN AND PLAUGHER, PAGE 106.  COPYRIGHT, 1976, ADDISON-WESLEY.
;*  ON ENTRY, BC=NUMBER OF ENTRIES
;*
N	EQU	$+1		; POINTER FOR IN-THE-CODE MODIFICATION
	LD	HL,0		; NUMBER OF ITEMS TO SORT
	LD	(GAP),HL	; SET INITIAL GAP TO N FOR FIRST DIVISION BY 2

;*  FOR (GAP = N/2; GAP > 0; GAP = GAP/2)
SRTL0:
	OR	A		; CLEAR CARRY
GAP	EQU	$+1		; POINTER FOR IN-THE-CODE MODIFICATION
	LD	HL,0		; GET PREVIOUS GAP
	LD	A,H		; ROTATE RIGHT TO DIVIDE BY 2
	RRA
	LD	H,A
	LD	A,L
	RRA
	LD	L,A

;*  TEST FOR ZERO
	OR	H
	RET	Z		; DONE WITH SORT IF GAP = 0

	LD	(GAP),HL	; SET VALUE OF GAP
	LD	(IPT),HL	; SET I=GAP FOR FOLLOWING LOOP

;*  FOR (I = GAP + 1; I <= N; I = I + 1)
SRTL1:
IPT	EQU	$+1		; POINTER FOR IN-THE-CODE MODIFICATION
	LD	HL,0		; ADD 1 TO I
	INC	HL
	LD	(IPT),HL

;*  TEST FOR I <= N
	EX	DE,HL		; I IS IN DE
	LD	HL,(N)		; GET N
	LD	A,L		; COMPARE BY SUBTRACTION
	SUB	E
	LD	A,H
	SBC	A,D		; CARRY SET MEANS I > N
	JR	C,SRTL0		; DON'T DO FOR LOOP IF I > N

	LD	HL,(IPT)	; SET J = I INITIALLY FOR FIRST SUBTRACTION OF GAP
	LD	(J),HL

;*  FOR (J = I - GAP; J > 0; J = J - GAP)
SRTL2:
	LD	HL,(GAP)	; GET GAP
	EX	DE,HL		; ... IN DE
J	EQU	$+1		; POINTER FOR IN-THE-CODE MODIFICATION
	LD	HL,0		; GET J
	LD	A,L		; COMPUTE J - GAP
	SUB	E
	LD	L,A
	LD	A,H
	SBC	A,D
	LD	H,A
	LD	(J),HL		; J = J - GAP
	JR	C,SRTL1		; IF CARRY FROM SUBTRACTIONS, J < 0 AND ABORT
	LD	A,H		; J=0?
	OR	L
	JR	Z,SRTL1		; IF ZERO, J=0 AND ABORT

;*  SET JG = J + GAP
	EX	DE,HL		; J IN DE
	LD	HL,(GAP)	; GET GAP
	ADD	HL,DE		; J + GAP
	LD	(JG),HL		; JG = J + GAP

;*  IF (V(J) <= V(JG))
	CALL	ICOMPARE	; J IN DE, JG IN HL

;*  ... THEN BREAK
	JR	C,SRTL1

;*  ... ELSE EXCHANGE
	LD	HL,(J)		; SWAP J, JG
	EX	DE,HL
JG	EQU	$+1		; POINTER FOR IN-THE-CODE MODIFICATION
	LD	HL,0
	CALL	ISWAP		; J IN DE, JG IN HL

;*  END OF INNER-MOST FOR LOOP
	JR	SRTL2

;*
;*  SWAP (Exchange) the elements whose indexes are in HL and DE
;*
ISWAP:
	CALL	IPOS		; COMPUTE POSITION FROM INDEX
	EX	DE,HL
	CALL	IPOS		; COMPUTE 2ND ELEMENT POSITION FROM INDEX
	LD	B,11		; 11 BYTES TO FLIP
ISWAP1:
	LD	A,(DE)		; GET BYTES
	LD	C,(HL)
	LD	(HL),A		; PUT BYTES
	LD	A,C
	LD	(DE),A
	INC	HL		; PT TO NEXT
	INC	DE
	DJNZ	ISWAP1
	RET
;*
;*  ICOMPARE compares the entry pointed to by the pointer pointed to by HL
;*    with that pointed to by DE (1st level indirect addressing); on entry,
;*    HL and DE contain the numbers of the elements to compare (1, 2, ...);
;*    on exit, Carry Set means ((DE)) < ((HL)), Zero Set means ((HL)) = ((DE)),
;*    and Non-Zero and No-Carry means ((DE)) > ((HL))
;*
ICOMPARE:
	CALL	IPOS		; GET POSITION OF FIRST ELEMENT
	EX	DE,HL
	CALL	IPOS		; GET POSITION OF 2ND ELEMENT
	EX	DE,HL
;*
;*  COMPARE DIR ENTRY PTED TO BY HL WITH THAT PTED TO BY DE;
;*	NO NET EFFECT ON HL, DE; RET W/CARRY SET MEANS DE<HL
;*	RET W/ZERO SET MEANS DE=HL
;*
	IF	NOT SORTNT	; TYPE AND NAME?
;*
;*  COMPARE BY FILE TYPE AND FILE NAME
;*
	PUSH	HL
	PUSH	DE
	LD	BC,8		; PT TO FT (8 BYTES)
	ADD	HL,BC
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL		; DE, HL NOW PT TO THEIR FT'S
	LD	B,3		; 3 BYTES
	CALL	COMP		; COMPARE FT'S
	POP	DE
	POP	HL
	RET	NZ		; CONTINUE IF COMPLETE MATCH
	LD	B,8		; 8 BYTES
	JR	COMP		; COMPARE FN'S
;
	ELSE			; NAME AND TYPE
;*
;*  COMPARE BY FILE NAME AND FILE TYPE
;*
	LD	B,11		; COMPARE FN, FT AND FALL THRU TO COMP
;*
;*  COMP COMPARES DE W/HL FOR B BYTES; RET W/CARRY IF DE<HL
;*	MSB IS DISREGARDED
;*
COMP:
	LD	A,(HL)		; GET (HL)
	AND	7FH		; MASK MSB
	LD	C,A		; ... IN C
	LD	A,(DE)		; COMPARE
	AND	7FH		; MASK MSB
	CP	C
	RET	NZ
	INC	HL		; PT TO NEXT
	INC	DE
	DJNZ	COMP		; COUNT DOWN
	RET
;
	ENDIF			; NOT SORTNT
;*
;*  Compute physical position of element whose index is in HL; on exit, HL
;* is the physical address of this element; Indexes are 1..N
;*
IPOS:
	DEC	HL		; HL=(HL-1)*11+DIRBUF
	LD	B,H		; BC=HL
	LD	C,L
	ADD	HL,HL		; HL=HL*2
	ADD	HL,HL		; HL=HL*4
	ADD	HL,BC		; HL=HL*5
	ADD	HL,HL		; HL=HL*10
	ADD	HL,BC		; HL=HL*11
	LD	BC,DIRBUF	; ADD IN DIRBUF
	ADD	HL,BC
	RET
;
	ENDIF			;DIRON OR ERAON OR LTON OR PROTON OR CPON OR RENON
;
;Section 5B
;Command: ERA
;Function:  Erase files
;Forms:
;	ERA <afn>	Erase Specified files and print their names
;	ERA <afn> I	Erase Specified files and print their names, but ask
;				for verification before Erase is done
;
	IF	ERAON
ERA:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WERA
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	LD	A,(FCB2+1)	;GET ERAFLG IF IT'S THERE
	LD	(ERAFLG),A	;SAVE IT AS A FLAG
	LD	A,1		;DIR FILES ONLY
	CALL	GETDIR		;LOAD DIRECTORY OF FILES
	JP	Z,PRFNF		;ABORT IF NO FILES
;
; MAIN ERASE LOOP
;
ERA1:
	PUSH	HL		;SAVE PTR TO FILE
	CALL	PRFN		;PRINT ITS NAME
	LD	(NXTFILE),HL	;SAVE PTR TO NEXT FILE
	POP	HL		;GET PTR TO THIS FILE
	CALL	ROTEST		;TEST FILE PTED TO BY HL FOR R/O
	JR	NZ,ERA3
ERAFLG	EQU	$+1		;ADDRESS OF FLAG
	LD	A,0		;2ND BYTE IS FLAG
	CP	'I'		;IS IT AN INSPECT OPTION?
	JR	NZ,ERA2		;SKIP PROMPT IF IT IS NOT
	CALL	ERAQ		;ERASE?
	JR	NZ,ERA3		;SKIP IF NOT
ERA2:
	LD	DE,FCB1+1	;COPY INTO FCB1
	LD	B,11		;11 BYTES
	LDIR
	CALL	INITFCB1	;INIT FCB
	LD	C,19		;DELETE FILE
	CALL	BDOS
ERA3:
	LD	HL,(NXTFILE)	;HL PTS TO NEXT FILE
	LD	A,(HL)		;GET CHAR
	OR	A		;DONE?
	JP	Z,EXIT
	CALL	CRLF		;NEW LINE
	JR	ERA1
;
	ENDIF			;ERAON
;
;Section 5C
;Command: LIST
;Function:  Print out specified file on the LST: Device
;Forms:
;	LIST <afn>	Print file (NO Paging)
;Notes:
;	The flags which apply to TYPE do not take effect with LIST
;
	IF	LTON
LISTC:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WLIST
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	LD	A,0FFH		;TURN ON PRINTER FLAG
	JR	TYPE0
;
;Section 5D
;Command: TYPE
;Function:  Print out specified file on the CON: Device
;Forms:
;	TYPE <afn>	Print file
;	TYPE <afn> P	Print file with paging flag
;Notes:
;	The flag PGDFLG defines the letter which toggles the paging
;		facility (P in the forms section above)
;	The flag PGDFLT determines if TYPE is to page by default
;		(PGDFLT=TRUE if TYPE pages by default); combined with
;		PGDFLG, the following events occur --
;			If PGDFLT = TRUE, PGDFLG turns OFF paging
;			If PGDFLT = FALSE, PGDFLG turns ON paging
;
TYPE:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WTYPE
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	XOR	A		;TURN OFF PRINTER FLAG
;
; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
;
TYPE0:
	LD	(PRFLG),A	;SET FLAG
	LD	A,(FCB2+1)	;GET PAGE FLAG
	LD	(PGFLG),A	;SAVE IT AS A FLAG
	LD	A,1		;SELECT DIR FILES
	CALL	GETDIR		;ALLOW AMBIGUOUS FILES
	JP	Z,PRFNF		;NO FILES
	LD	(NXTFILE),HL	;SET PTR TO NEXT FILE
	JR	TYPEX2
TYPEX:
	LD	HL,(NXTFILE)	;GET PTR TO NEXT FILE
	LD	A,(HL)		;ANY FILES?
	OR	A
	JP	Z,EXIT
	LD	A,(PRFLG)	;CHECK FOR LIST OUTPUT
	OR	A		;0=TYPE
	JR	Z,TYPEX1
	LD	A,CR		;BOL ON PRINTER
	CALL	LCOUT
	LD	A,FF		;FORM FEED THE PRINTER
	CALL	LCOUT
	JR	TYPEX2
TYPEX1:
	CALL	PAGEBREAK	;PAGE BREAK MESSAGE
TYPEX2:
	LD	DE,FCB1+1	;COPY INTO FCB1
	LD	B,11		;11 BYTES
	LDIR
	LD	(NXTFILE),HL	;SET PTR TO NEXT FILE
	CALL	INITFCB1	;INIT FCB1
	LD	C,15		;OPEN FILE
	CALL	BDOS
	INC	A		;SET ERROR FLAG
	JP	Z,PRFNF		;ABORT IF ERROR
	LD	A,NLINES-2	;SET LINE COUNT
	LD	(PAGCNT),A
	LD	A,CR		;NEW LINE
	CALL	LCOUT
	LD	A,LF
	CALL	LCOUT
	LD	BC,080H		;SET CHAR POSITION AND TAB COUNT
	;  (B=0=TAB, C=080H=CHAR POSITION)
;
;  MAIN LOOP FOR LOADING NEXT BLOCK
;
TYPE2:
	LD	A,C		;GET CHAR COUNT
	CP	80H
	JR	C,TYPE3
	PUSH	HL		;READ NEXT BLOCK
	PUSH	BC
	LD	DE,FCB1		;PT TO FCB
	LD	C,20		;READ RECORD
	CALL	BDOS
	OR	A		;SET FLAGS
	POP	BC
	POP	HL
	JR	NZ,TYPE7		;END OF FILE?
	LD	C,0		;SET CHAR COUNT
	LD	HL,TBUFF	;PT TO FIRST CHAR
;
;  MAIN LOOP FOR PRINTING CHARS IN TBUFF
;
TYPE3:
	LD	A,(HL)		;GET NEXT CHAR
	AND	7FH		;MASK OUT MSB
	CP	1AH		;END OF FILE (^Z)?
	JR	Z,TYPE7		;NEXT FILE IF SO
;
; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
;
	CP	CR		;RESET TAB COUNT?
	JR	Z,TYPE4
	CP	LF		;RESET TAB COUNT?
	JR	Z,TYPE4
	CP	TAB		;TAB?
	JR	Z,TYPE5
;
;  OUTPUT CHAR AND INCREMENT CHAR COUNT
;
	CALL	LCOUT		;OUTPUT CHAR
	JP	Z,TYPEX		;SKIP
	INC	B		;INCREMENT TAB COUNT
	JR	TYPE6
;
;  OUTPUT <CR> OR <LF> AND RESET TAB COUNT
;
TYPE4:
	CALL	LCOUT		;OUTPUT <CR> OR <LF>
	JP	Z,TYPEX		;SKIP
	LD	B,0		;RESET TAB COUNTER
	JR	TYPE6
;
;  TABULATE
;
TYPE5:
	LD	A,' '		;<SP>
	CALL	LCOUT
	JP	Z,TYPEX		;SKIP
	INC	B		;INCR POS COUNT
	LD	A,B
	AND	7
	JR	NZ,TYPE5
;
; CONTINUE PROCESSING
;
TYPE6:
	INC	C		;INCREMENT CHAR COUNT
	INC	HL		;PT TO NEXT CHAR
	CALL	BREAK		;CHECK FOR ABORT
	JP	Z,TYPEX		;SKIP
	JR	TYPE2
TYPE7:
	LD	DE,FCB1		;CLOSE FILE
	LD	C,16		;BDOS FUNCTION
	CALL	BDOS
	JP	TYPEX
;
; SEND OUTPUT TO LST: OR CON:, AS PER THE FLAG
;   RETURN WITH Z IF ABORT
;
LCOUT:
	PUSH	HL		;SAVE REGS
	PUSH	DE
	PUSH	BC
	LD	E,A		;CHAR IN E
	LD	C,2		;OUTPUT TO CON:
PRFLG	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;2ND BYTE IS THE PRINT FLAG
	OR	A		;0=TYPE
	JR	Z,LC1
	LD	C,5		;OUTPUT TO LST:
LC1:
	PUSH	DE		;SAVE CHAR
	CALL	BDOS		;OUTPUT CHAR IN E
	POP	DE		;GET CHAR
	LD	A,E
	CP	LF
	JR	NZ,LC2
	LD	A,(PRFLG)	;OUTPUT TO LST:?
	OR	A		;NZ = YES
	JR	NZ,LC2
;
; CHECK FOR PAGING
;
	LD	HL,PAGCNT	;COUNT DOWN
	DEC	(HL)
	JR	NZ,LC2		;JUMP IF NOT END OF PAUSE
	LD	(HL),NLINES-2	;REFILL COUNTER
PGFLG	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER
	LD	A,0		;2ND BYTE IS THE PAGING FLAG
	CP	PGDFLG		;PAGE DEFAULT OVERRIDE OPTION WANTED?
;
	IF	PGDFLT		;IF PAGING IS DEFAULT
;
	JR	Z,LC2		;PGDFLG MEANS NO PAGING
;
	ELSE
;
	JR	NZ,LC2		;PGDFLG MEANS PAGE
;
	ENDIF			;PGDFLT
;
	CALL	PAGEBREAK	;PRINT PAGE BREAK MESSAGE
	JR	LC3		;Z TO SKIP
LC2:
	XOR	A		;SET OK
	DEC	A		;NZ=OK
LC3:
	POP	BC		;RESTORE REGS
	POP	DE
	POP	HL
	RET
;
; PRINT PAGE BREAK MESSAGE AND GET USER INPUT
;   ABORT IF ^C, RZ IF ^X
;
PAGEBREAK:
	PUSH	HL		;SAVE HL
	CALL	PRINT
	DEFB	CR,LF,' Typing',' '+80H
	LD	HL,FCB1+1	;PRINT FILE NAME
	CALL	PRFN
	CALL	DASH		;PRINT DASH
	CALL	CONIN		;GET INPUT
	POP	HL		;RESTORE HL
	PUSH	AF
	CALL	CRLF		;NEW LINE
	POP	AF
	CP	CTRLC		;^C
	JP	Z,EXIT
	CP	CTRLX		;SKIP?
	RET
;
	ENDIF			;LTON
;
;Section 5E
;Command: REN
;Function:  To change the name of an existing file
;Forms:
;	REN <New ufn>=<Old ufn>	Perform function
;
	IF	RENON
REN:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WREN
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
;
;
; STEP 1:  CHECK FOR FILE 2 BEING AMBIGUOUS
;
	LD	HL,FCB2+1	;CAN'T BE AMBIGUOUS
	CALL	AMBCHK1
;
; STEP 2:  LOG INTO USER AREA
;
	CALL	LOGUSR		;LOG INTO USER AREA OF FCB1
;
; STEP 3:  SEE IF NEW FILE ALREADY EXISTS
;   EXTEST PERFORMS A NUMBER OF CHECKS:
;     1) AMBIGUITY
;     2) R/O
;     3) IF FILE EXISTS AND NOT R/O, PERMISSION TO DELETE
;
	CALL	EXTEST
	JP	Z,EXIT		;R/O OR NO PERMISSION
;
; STEP 4:  EXCHANGE FILE NAME FIELDS FOR RENAME
;
	LD	HL,FCB1		;EXCHANGE NAMES ONLY
	PUSH	HL		;SAVE PTR
	INC	HL
	LD	DE,FCB2+1
	LD	B,11		;11 BYTES
REN1:
	LD	A,(DE)		;GET OLD
	LD	C,A
	LD	A,(HL)
	LD	(DE),A		;PUT NEW
	LD	(HL),C
	INC	HL		;PT TO NEXT
	INC	DE
	DJNZ	REN1
;
; STEP 5:  SEE IF OLD FILE IS R/O
;
	CALL	SEARF		;LOOK FOR FILE
	JP	Z,PRFNF
	CALL	GETSBIT		;GET PTR TO ENTRY IN TBUFF
	EX	DE,HL		;HL PTS TO ENTRY
	INC	HL		;PT TO FN
	CALL	ROTEST		;SEE IF FILE IS R/O
	JP	NZ,EXIT
;
; STEP 6:  RENAME THE FILE
;
	POP	DE		;GET PTR TO FCB
	LD	C,23		;RENAME
	CALL	BDOS
	INC	A		;SET ZERO FLAG IF ERROR
	JP	Z,PRFNF		;PRINT NO SOURCE FILE MESSAGE
	JP	EXIT
;
	ENDIF			;RENON
;
;Section 5F
;Command: PROT
;Function:  To set the attributes of a file (R/O and SYS)
;
;Form:
;	PROT afn RSI
;If either R or S are omitted, the file is made R/W or DIR, resp;
;R and S may be in any order.  If I is present, Inspection is enabled.
;
	IF	PROTON
ATT:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WPROT
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	XOR	A		;SET NO INSPECT
	LD	(INSPECT),A
	LD	HL,0		;SET R/O AND SYS ATTRIBUTES OFF
	LD	DE,FCB2+1	;PT TO ATTRIBUTES
	LD	B,3		;3 CHARS MAX
ATT1:
	LD	A,(DE)		;GET CHAR
	INC	DE		;PT TO NEXT
	CP	'I'		;INSPECT?
	JR	Z,ATTI
	CP	'R'		;SET R/O?
	JR	Z,ATTR
	CP	'S'		;SET SYS?
	JR	Z,ATTS
ATT2:
	DJNZ	ATT1
	JR	ATT3
ATTI:
	LD	(INSPECT),A	;SET FLAG
	JR	ATT2
ATTR:
	LD	H,80H		;SET R/O BIT
	JR	ATT2
ATTS:
	LD	L,80H		;SET SYS BIT
	JR	ATT2
ATT3:
	LD	(FATT),HL	;SAVE FILE ATTRIBUTES
	LD	A,1		;SELECT DIR AND SYS FILES
	CALL	GETDIR		;LOAD DIRECTORY
	JP	Z,PRFNF		;NO FILE ERROR
	LD	(NXTFILE),HL	;PT TO NEXT FILE
	JR	ATT5
ATT4:
	LD	HL,(NXTFILE)	;PT TO NEXT FILE
	LD	A,(HL)		;END OF LIST?
	OR	A
	JP	Z,EXIT
	CALL	CRLF		;NEW LINE
ATT5:
	PUSH	HL		;SAVE PTR TO CURRENT FILE
	CALL	PRFN		;PRINT ITS NAME
	LD	(NXTFILE),HL	;SAVE PTR TO NEXT FILE
	CALL	PRINT
	DEFB	' Set to R','/'+80H
	LD	HL,(FATT)	;GET ATTRIBUTES
	LD	C,'W'		;ASSUME R/W
	LD	A,H		;GET R/O BIT
	OR	A
	JR	Z,ATT6
	LD	C,'O'		;SET R/O
ATT6:
	LD	A,C		;GET CHAR
	CALL	CONOUT
	LD	A,L		;GET SYS FLAG
	OR	A		;SET FLAG
	JR	Z,ATT7
	CALL	PRINT
	DEFB	' and SY','S'+80H
ATT7:
INSPECT EQU	$+1		;PTR FOR IN-THE-CODE MODIFICATION
	LD	A,0		;GET INSPECT FLAG
	OR	A		;Z=NO
	POP	HL		;GET PTR TO CURRENT FILE
	JR	Z,ATT8
	CALL	ERAQ1		;ASK FOR Y/N
	JR	NZ,ATT4		;ADVANCE TO NEXT FILE IF NOT Y
ATT8:
	LD	DE,FCB1+1	;COPY INTO FCB1
	LD	B,11		;11 BYTES
	LDIR
FATT	EQU	$+1		;PTR FOR IN-THE-CODE MODIFICATION
	LD	HL,0		;GET ATTRIBUTES
	DEC	DE		;PT TO SYS BYTE
	DEC	DE
	LD	A,L		;GET SYS FLAG
	CALL	ATTSET		;SET ATTRIBUTE CORRECTLY
	DEC	DE		;PT TO R/O BYTE
	LD	A,H		;GET R/O FLAG
	CALL	ATTSET
	LD	DE,FCB1		;PT TO FCB
	LD	C,30		;SET ATTRIBUTES
	CALL	BDOS
	JR	ATT4
ATTSET:
	OR	A		;0=CLEAR ATTRIBUTE
	JR	Z,ATTST1
	LD	A,(DE)		;GET BYTE
	OR	80H		;SET ATTRIBUTE
	LD	(DE),A
	RET
ATTST1:
	LD	A,(DE)		;GET BYTE
	AND	7FH		;CLEAR ATTRIBUTE
	LD	(DE),A
	RET
;
	ENDIF			;PROTON
;
;Section 5G
;Command: CP
;Function:  To copy a file from one place to another
;
;Form:
;	CP new=old
;
	IF	CPON
COPY:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WCP
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
;
; STEP 0:  IF NEW IS BLANK, MAKE IT THE SAME NAME AND TYPE AS OLD
;
	LD	DE,FCB1+1	;PT TO NEW FILE NAME
	LD	A,(DE)		;GET FIRST CHAR
	CP	' '		;NO NAME?
	JR	NZ,COPY0
	LD	HL,FCB2+1	;MAKE SAME AS OLD
	LD	B,11		;11 BYTES
	LDIR
;
; STEP 1:  SEE IF NEW=OLD AND ABORT IF SO
;
COPY0:
	LD	HL,FCB1		;PT TO NEXT
	LD	DE,FCB2		;PT TO OLD
	PUSH	HL		;SAVE PTRS
	PUSH	DE
	INC	HL		;PT TO FILE NAME
	INC	DE
	LD	B,13		;COMPARE 13 BYTES
COPY1:
	LD	A,(DE)		;GET OLD
	CP	(HL)		;COMPARE TO NEW
	JR	NZ,COPY2
	INC	HL		;PT TO NEXT
	INC	DE
	DJNZ	COPY1
	LD	C,25		;GET CURRENT DISK
	CALL	BDOS
	INC	A		;MAKE 1..P
	LD	B,A		;CURRENT DISK IN B
	POP	DE		;GET PTR TO DN
	POP	HL
	LD	A,(DE)		;GET DISK
	LD	C,A		;... IN C
	OR	A		;CURRENT?
	JR	NZ,COPY1A
	LD	C,B		;MAKE C CURRENT
COPY1A:
	LD	A,(HL)		;GET DISK
	OR	A		;CURRENT?
	JR	NZ,COPY1B
	LD	A,B		;MAKE A CURRENT
COPY1B:
	CP	C		;SAME DISK ALSO?
	JR	NZ,COPY3		;CONTINUE WITH OPERATION
	JR	CPERR
COPY2:
	POP	DE		;GET PTRS
	POP	HL
;
; STEP 2:  SET USER NUMBERS
;
COPY3:
	LD	A,(FCB1+13)	;GET NEW USER
	LD	(USRNEW),A
	LD	A,(FCB2+13)	;GET OLD USER
	LD	(USROLD),A
;
; STEP 3:  SEE IF OLD FILE EXISTS
;
	LD	HL,OLDFCB	;COPY OLD INTO 2ND FCB
	PUSH	HL		;SAVE PTR TO 2ND FCB
	EX	DE,HL
	LD	B,14		;14 BYTES
	LDIR
	CALL	LOGOLD		;LOG IN USER NUMBER OF OLD FCB
	POP	HL		;GET PTR TO 2ND FCB
	CALL	INITFCB2	;INIT FCB
	LD	C,17		;LOOK FOR FILE
	CALL	BDOS
	INC	A		;CHECK FOR ERROR
	JP	Z,PRFNF		;FILE NOT FOUND
;
; STEP 4:  SEE IF NEW EXISTS
;
	CALL	LOGNEW		;LOG INTO NEW'S USER AREA
	CALL	EXTEST		;TEST
	JP	Z,EXIT		;ERROR EXIT
;
; STEP 5:  CREATE NEW
;
	LD	DE,FCB1		;PT TO FCB
	LD	C,22		;MAKE FILE
	CALL	BDOS
	INC	A		;ERROR?
	JR	NZ,COPY4
;
; COPY ERROR
;
CPERR:
	CALL	PRINT
	DEFB	' Copy','?'+80H
	JP	EXIT
;
; STEP 6:  OPEN OLD
;
COPY4:
	CALL	LOGOLD		;GET USER
	LD	HL,OLDFCB	;PT TO FCB
	CALL	INITFCB2	;INIT FCB
	LD	C,15		;OPEN FILE
	CALL	BDOS
;
; STEP 7:  COPY OLD TO NEW WITH BUFFERING
;
COPY5:
	CALL	LOGOLD		;GET USER
	LD	B,0		;SET COUNTER
	LD	HL,TPA		;SET NEXT ADDRESS TO COPY INTO
COPY5A:
	PUSH	HL		;SAVE ADDRESS AND COUNTER
	PUSH	BC
	LD	DE,OLDFCB	;READ BLOCK FROM FILE
	LD	C,20
	CALL	BDOS
	POP	BC		;GET COUNTER AND ADDRESS
	POP	DE
	OR	A		;OK?
	JR	NZ,COPY5B
	PUSH	BC		;SAVE COUNTER
	LD	HL,TBUFF	;COPY FROM BUFFER
	LD	B,128		;128 BYTES
	LDIR
	EX	DE,HL		;HL PTS TO NEXT
	POP	BC		;GET COUNTER
	INC	B		;INCREMENT IT
	LD	A,B		;DONE?
	CP	CPBLOCKS	;DONE IF CPBLOCKS LOADED
	JR	NZ,COPY5A
COPY5B:
	LD	A,B		;GET COUNT
	OR	A
	JR	Z,COPY6		;DONE IF NOTHING LOADED
	PUSH	BC		;SAVE COUNT
	CALL	LOGNEW		;GET USER
	LD	HL,TPA		;PT TO TPA
COPY5C:
	LD	DE,TBUFF	;COPY INTO TBUFF
	LD	B,128		;128 BYTES
	LDIR
	PUSH	HL		;SAVE PTR TO NEXT
	LD	DE,FCB1		;PT TO FCB
	LD	C,21		;WRITE BLOCK
	CALL	BDOS
	OR	A
	JR	NZ,CPERR		;COPY ERROR
	POP	HL		;GET PTR TO NEXT BLOCK
	POP	BC		;GET COUNT
	DEC	B		;COUNT DOWN
	JR	Z,COPY5		;GET NEXT
	PUSH	BC		;SAVE COUNT
	JR	COPY5C
;
; STEP 8:  CLOSE FILES
;
COPY6:
	CALL	LOGOLD		;GET USER
	LD	DE,OLDFCB	;PT TO FCB
	LD	C,16		;CLOSE FILE
	CALL	BDOS
	CALL	LOGNEW		;GET USER
	LD	DE,FCB1		;PT TO FCB
	LD	C,16		;CLOSE FILE
	CALL	BDOS
	CALL	PRINT
	DEFB	' Don','e'+80H
	JP	EXIT
;
; LOG INTO USER NUMBER OF OLD FILE
;
LOGOLD:
USROLD	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;GET NUMBER
	JP	SETUSR
;
; LOG INTO USER NUMBER OF NEW FILE
;
LOGNEW:
USRNEW	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;GET NUMBER
	JP	SETUSR
;
	ENDIF			;CPON
;
;Section 5H
;Command: PEEK
;Function:  Display memory
;
;Form:
;	PEEK startadr		- 256 bytes displayed
;	PEEK startadr endadr	- range of bytes displayed
;
	IF	PEEKON
PEEK:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WPEEK
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	LD	HL,TBUFF+1	;FIND FIRST NUMBER
NXTPEEK EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	DE,0		;DEFAULT PEEK ADDRESS IF NONE
	CALL	SKSP		;SKIP TO NON-BLANK
	CALL	NZ,HEXNUM	;GET START ADDRESS IF ANY (ELSE DEFAULT)
	CALL	PRINT
	DEFB	' Pee','k'+80H
	CALL	ADRAT		;PRINT ADDRESS MESSAGE
	PUSH	DE		;SAVE IT
	LD	BC,256		;COMPUTE END ADDRESS
	EX	DE,HL
	ADD	HL,BC
	EX	DE,HL		;END ADDRESS IN DE
	CALL	SKSP		;SKIP TO NON-BLANK
	JR	Z,PEEK1		;PROCESS
	CALL	HEXNUM		;GET 2ND NUMBER IN DE
PEEK1:
	POP	HL		;HL IS START ADDRESS, DE IS END ADDRESS
	CALL	PEEK2		;DO PEEK
	LD	(NXTPEEK),HL	;SET CONTINUED PEEK ADDRESS
	JP	EXIT
;
; DISPLAY LOOP
;
PEEK2:
	LD	A,D		;SEE IF DE<=HL
	CP	H
	RET	C		;OUT OF BOUNDS
	JR	NZ,PEEK2A		;HL > DE
	LD	A,E
	CP	L
	RET	Z
	RET	C
PEEK2A:
	CALL	CRLF		;NEW LINE
	LD	A,H		;PRINT ADDRESS
	CALL	PASHC
	LD	A,L
	CALL	PAHC
	CALL	DASH		;PRINT LEADER
	LD	B,16		;16 BYTES TO DISPLAY
	PUSH	HL		;SAVE START ADDRESS
PEEK3:
	LD	A,(HL)		;GET NEXT BYTE
	CALL	PASHC		;PRINT WITH LEADING SPACE
	INC	HL		;PT TO NEXT
	DJNZ	PEEK3
	POP	HL		;PT TO FIRST
	LD	B,16		;16 BYTES
	LD	A,' '		;SPACE AND FENCE
	CALL	CONOUT
	CALL	PRINT
	DEFB	FENCE+80H
PEEK4:
	LD	A,(HL)		;GET NEXT BYTE
	LD	C,'.'		;ASSUME DOT
	AND	7FH		;MASK IT
	CP	' '		;DOT IF LESS THAN SPACE
	JR	C,PEEK5
	CP	7FH		;DON'T PRINT DEL
	JR	Z,PEEK5
	LD	C,A		;CHAR IN C
PEEK5:
	LD	A,C		;GET CHAR
	CALL	CONOUT		;SEND IT
	INC	HL		;PT TO NEXT
	DJNZ	PEEK4
	CALL	PRINT		;CLOSING FENCE
	DEFB	FENCE+80H
	CALL	BREAK		;ALLOW ABORT
	JR	PEEK2
;
	ENDIF			;PEEKON
;
; PRINT A AS 2 HEX CHARS
;   PASHC - LEADING SPACE
;
	IF	PEEKON OR POKEON
PASHC:
	PUSH	AF		;SAVE A
	CALL	PRINT
	DEFB	' '+80H
	POP	AF
PAHC:
	PUSH	BC		;SAVE BC
	LD	C,A		;BYTE IN C
	RRCA			;EXCHANGE NYBBLES
	RRCA
	RRCA
	RRCA
	CALL	PAH		;PRINT HEX CHAR
	LD	A,C		;GET LOW
	POP	BC		;RESTORE BC AND FALL THRU TO PAH
PAH:
	AND	0FH		;MASK
	ADD	A,'0'		;CONVERT TO ASCII
	CP	'9'+1		;LETTER?
	JR	C,PAH1
	ADD	A,7		;ADJUST TO LETTER
PAH1:
	JP	CONOUT
;
	ENDIF			;PEEKON OR POKEON
;
;Section 5I
;Command: POKE
;Function:  Place Values into Memory
;
;Form:
;	POKE startadr val1 val2 ...
;
	IF	POKEON
POKE:
;
; CHECK FOR WHEEL APPROVAL IF OPTION ENABLED
;
	IF	WPOKE
	CALL	WHLTST
	ENDIF			;WHEEL APPROVAL
;
	CALL	RETSAVE
	LD	HL,TBUFF+1	;PT TO FIRST CHAR
	CALL	SKSP		;SKIP TO NON-BLANK
	JR	Z,NOARGS		;ARG ERROR
	CALL	HEXNUM		;CONVERT TO NUMBER
	CALL	PRINT
	DEFB	' Pok','e'+80H
	CALL	ADRAT		;PRINT AT MESSAGE
;
; LOOP FOR STORING HEX VALUES SEQUENTIALLY VIA POKE
;
POKE1:
	PUSH	DE		;SAVE ADDRESS
	CALL	SKSP		;SKIP TO NON-BLANK
	JP	Z,EXIT		;DONE
	CP	'"'		;QUOTED TEXT?
	JR	Z,POKE2
	CALL	HEXNUM		;GET NUMBER
	LD	A,E		;GET LOW
	POP	DE		;GET ADDRESS
	LD	(DE),A		;STORE NUMBER
	INC	DE		;PT TO NEXT
	JR	POKE1
;
; STORE ASCII CHARS
;
POKE2:
	POP	DE		;GET NEXT ADDRESS
	INC	HL		;PT TO NEXT CHAR
POKE3:
	LD	A,(HL)		;GET NEXT CHAR
	OR	A		;DONE?
	JP	Z,EXIT
	LD	(DE),A		;PUT CHAR
	INC	HL		;PT TO NEXT
	INC	DE
	JR	POKE3
;
; No Argument Error
;
NOARGS:
	CALL	PRINT
	DEFB	' Arg','?'+80H
	JP	EXIT
;
	ENDIF			;POKEON
;
;Section 5J
;Command: REG
;Function:  Manipulate Memory Registers
;
;Forms:
;	REG D or REG		<-- Display Register Value
;	REG Mreg		<-- Decrement Register Value
;	REG Preg		<-- Increment Register Value
;	REG Sreg value		<-- Set Register Value
;
	IF	REGON
REGCMD:
	LD	HL,FCB1+1	;PT TO FIRST ARG
	LD	A,(HL)		;GET FIRST CHAR
	PUSH	AF		;SAVE CHAR
	CP	'A'		;ASSUME DIGIT IF LESS THAN 'A'
	JR	C,REGC1
	INC	HL		;PT TO DIGIT
REGC1:
	LD	A,(HL)		;GET DIGIT
	CALL	REGPTR		;PT TO REGISTER
	POP	AF		;GET CHAR
	CP	'S'		;SET?
	JR	Z,RSET
	CP	'P'		;PLUS?
	JR	Z,RINC
	CP	'M'		;MINUS?
	JR	Z,RDEC
;
; SHOW REGISTER VALUES
;
RSHOW:
	XOR	A		;SELECT REGISTER 0
	LD	B,A		;COUNTER SET TO 0 IN B
	CALL	REGP2		;HL PTS TO REGISTER 0
RSHOW1:
	LD	A,B		;GET COUNTER VALUE
	CP	10
	JP	Z,CRLF		;NEW LINE AND EXIT IF DONE
	CALL	PRINT
	DEFB	'  Reg',' '+80H
	LD	A,B		;PRINT REGISTER NUMBER
	ADD	A,'0'
	CALL	CONOUT
	CALL	PRINT
	DEFB	' ','='+80H
	PUSH	BC		;SAVE COUNTER
	CALL	REGOUT		;PRINT REGISTER VALUE
	POP	BC		;GET COUNTER
	INC	B		;INCREMENT COUNTER
	LD	A,B		;CHECK FOR NEW LINE
	AND	3
	CALL	Z,CRLF
	INC	HL		;PT TO NEXT REGISTER
	JR	RSHOW1
;
; INCREMENT REGISTER VALUE
;	HL PTS TO MEMORY REGISTER ON INPUT
;
RINC:
	INC	(HL)		;INCREMENT IT
	JR	REGOUT		;PRINT RESULT
;
; DECREMENT REGISTER VALUE
;	HL PTS TO MEMORY REGISTER ON INPUT
;
RDEC:
	DEC	(HL)		;DECREMENT VALUE
	JR	REGOUT		;PRINT RESULT
;
; SET REGISTER VALUE
;	HL PTS TO REGISTER ON INPUT
;
RSET:
	LD	DE,FCB2+1	;PT TO VALUE
	LD	B,0		;INIT VALUE TO ZERO
RSET1:
	LD	A,(DE)		;GET NEXT DIGIT
	INC	DE		;PT TO NEXT
	SUB	'0'		;CONVERT TO BINARY
	JR	C,RSET2
	CP	10		;RANGE?
	JRNC	RSET2
	LD	C,A		;DIGIT IN C
	LD	A,B		;MULTIPLY OLD BY 10
	ADD	A,A		;*2
	ADD	A,A		;*4
	ADD	A,B		;*5
	ADD	A,A		;*10
	ADD	A,C		;ADD IN NEW DIGIT
	LD	B,A		;RESULT IN B
	JR	RSET1
RSET2:
	LD	(HL),B		;SET VALUE
REGOUT:
	CALL	PRINT		;PRINT LEADING SPACE
	DEFB	' '+80H
	LD	A,(HL)		;GET REGISTER VALUE
	LD	B,100		;PRINT 100'S
	LD	C,0		;SET LEADING SPACE FLAG
	CALL	DECB		;PRINT 100'S
	LD	B,10		;PRINT 10'S
	CALL	DECB		;PRINT 10'S
	ADD	A,'0'		;PRINT 1'S
	JP	CONOUT
;
; SUBTRACT B FROM A UNTIL CARRY, THEN PRINT DIGIT COUNT
;
DECB:
	LD	D,'0'		;SET DIGIT
DECB1:
	SUB	B		;SUBTRACT
	JR	C,DECB2
	INC	D		;ADD 1 TO DIGIT CHAR
	JR	DECB1
DECB2:
	ADD	A,B		;ADD BACK IN
	LD	E,A		;SAVE A IN E
	LD	A,D		;GET DIGIT CHAR
	CP	'0'		;LEADING ZERO CHECK
	JR	NZ,DECB3
	LD	A,C		;ANY LEADING DIGIT YET?
	OR	A
	JR	Z,DECB4
DECB3:
	LD	A,D		;GET DIGIT CHAR
	CALL	CONOUT		;PRINT IT
	INC	C		;SET C<>0 FOR LEADING DIGIT CHECK
DECB4:
	LD	A,E		;RESTORE A FOR NEXT ROUND
	RET

;
; SET HL TO POINT TO MEMORY REGISTER WHOSE INDEX IS PTED TO BY HL
;	ON INPUT, A CONTAINS REGISTER CHAR
;	ON OUTPUT, HL = ADDRESS OF MEMORY REGISTER (REG 0 ASSUMED IF ERROR)
;
REGPTR:
	LD	B,0		;INIT TO ZERO
	SUB	'0'		;CONVERT
	JR	C,REGP1
	CP	10		;RANGE
	JRNC	REGP1
	LD	B,A		;VALUE IN B
REGP1:
	LD	A,B		;VALUE IN A
REGP2:
	LD	HL,Z3MSG+30H	;PT TO MEMORY REGISTERS
	ADD	A,L		;PT TO PROPER REGISTER
	LD	L,A
	LD	A,H
	ADC	A,0
	LD	H,A		;HL PTS TO REGISTER
	RET
;
	ENDIF			;REGON

;
;Section 5K
;Command: WHL/WHLQ
;Function:  Set the Wheel Byte on or off
;
;Form:
;	WHL		-- turn Wheel Byte OFF
;	WHL password	-- turn Wheel Byte ON if password is correct
;	WHLQ		-- find out status of Wheel Byte
;
	IF	WHLON
WHL:
	LD	HL,FCB1+1	;PT TO FIRST CHAR
	LD	A,(HL)		;GET IT
	CP	' '		;TURN BYTE OFF IF NO PASSWORD
	JR	Z,WHLOFF
	LD	DE,WHLPASS
	LD	B,8		;CHECK 8 CHARS
WHL1:
	LD	A,(DE)		;GET CHAR
	CP	(HL)		;COMPARE
	JR	NZ,WHLMSG
	INC	HL		;PT TO NEXT
	INC	DE
	DJNZ	WHL1
;
; TURN ON WHEEL BYTE
;
	LD	A,0FFH		;TURN ON WHEEL BYTE
	JR	WHLSET
;
; TURN OFF WHEEL BYTE
;
WHLOFF:
	XOR	A		;TURN OFF WHEEL BYTE
WHLSET:
	LD	(Z3WHL),A	;SET WHEEL BYTE AND PRINT MESSAGE
;
; PRINT WHEEL BYTE MESSAGE
;
WHLMSG:
	CALL	PRINT
	DEFB	' Wheel Byte',' '+80H
	LD	A,(Z3WHL)	;GET WHEEL BYTE
	OR	A		;ZERO IS OFF
	JR	Z,OFFM
	CALL	PRINT
	DEFB	'O','N'+80H
	RET
OFFM:
	CALL	PRINT
	DEFB	'OF','F'+80H
	RET
;
; WHEEL PASSWORD DEFINED FROM SYSRCP.LIB FILE
;
	DEFB	'Z'-'@'		;LEADING ^Z IN CASE OF TYPE
WHLPASS:
	WPASS			;USE MACRO
;
	ENDIF			;WHLON

;
;Section 5L
;Command: ECHO
;Function:  Echo Text without Interpretation to Console or Printer
;
;Form:
;	ECHO text		<-- echo text to console
;	ECHO $text		<-- echo text to printer
;
;	Additionally, if a form feed character is encountered in the
; output string, no further output will be done, a new line will be
; issued, and this will be followed by a form feed character.  That is:
;
;		ECHO $text^L
;
; will cause "text" to be printed on the printer followed by CR, LF, FF.
;
ECHO:
	LD	HL,TBUFF+1	;PT TO FIRST CHAR
ECHO1:
	LD	A,(HL)		;SKIP LEADING SPACES
	INC	HL		;PT TO NEXT
	CP	' '
	JR	Z,ECHO1
;
	IF	ECHOLST
	LD	B,A		;CHAR IN B
	CP	'$'		;PRINT FLAG?
	JR	Z,ECHO2
	ENDIF			;ECHOLST
;
	DEC	HL		;PT TO CHAR
;
; LOOP TO ECHO CHARS
;
ECHO2:
	LD	A,(HL)		;GET CHAR
	OR	A		;EOL?
	JR	Z,ECHO4
;
	IF	ECHOLST
	CP	FF		;FORM FEED?
	JR	Z,ECHO3
	ENDIF			;ECHOLST
;
ECHO2C:
	CALL	ECHOUT		;SEND CHAR
	INC	HL		;PT TO NEXT
	JR	ECHO2
;
; FORM FEED - SEND NEW LINE FOLLOWED BY FORM FEED IF PRINTER OUTPUT
;
	IF	ECHOLST
ECHO3:
	LD	A,B		;CHECK FOR PRINTER OUTPUT
	CP	'$'
	JR	NZ,ECHOFF		;SEND FORM FEED NORMALLY IF NOT PRINTER
	CALL	ECHONL		;SEND NEW LINE
	LD	A,FF		;SEND FORM FEED
	JR	ECHOUT
;
; SEND FORM FEED CHAR TO CONSOLE
;
ECHOFF:
	LD	A,FF		;GET CHAR
	JR	ECHO2C
	ENDIF			;ECHOLST
;
; END OF PRINT LOOP - CHECK FOR PRINTER TERMINATION
;
ECHO4:
	IF	NOT ECHOLST
;
	RET
;
	ELSE
;
	LD	A,B		;CHECK FOR PRINTER OUTPUT
	CP	'$'
	RET	NZ		;DONE IF NO PRINTER OUTPUT
;
; OUTPUT A NEW LINE
;
ECHONL:
	LD	A,CR		;OUTPUT NEW LINE ON PRINTER
	CALL	ECHOUT
	LD	A,LF		;FALL THRU TO ECHOUT
;
	ENDIF			;NOT ECHOLST
;
; OUTPUT CHAR TO PRINTER OR CONSOLE
;
ECHOUT:
	LD	C,A		;CHAR IN C
	PUSH	HL		;SAVE HL
	PUSH	BC		;SAVE BC
	LD	DE,0CH-3	;OFFSET FOR CONSOLE OUTPUT
;
	IF	ECHOLST
	LD	A,B		;CHECK FOR PRINTER
	CP	'$'
	JR	NZ,ECHOUT1
	INC	DE		;ADD 3 FOR PRINTER OFFSET
	INC	DE
	INC	DE
;
	ENDIF			;ECHOLST
;
; OUTPUT CHAR IN C WITH BIOS OFFSET IN DE
;
ECHOUT1:
	CALL	BIOUT		;BIOS OUTPUT
	POP	BC		;RESTORE BC,HL
	POP	HL
	RET

;
; OUTPUT CHAR IN C TO BIOS WITH OFFSET IN DE
;
BIOUT:
	LD	HL,(WBOOT+1)	;GET ADDRESS OF WARM BOOT
	ADD	HL,DE		;PT TO ROUTINE
	JP	(HL)		;JUMP TO IT

;
;  ** SUPPORT UTILITIES **
;

;
;  CHECK FOR USER INPUT; IF ^C, RETURN WITH Z
;
BREAK:
	PUSH	HL		;SAVE REGS
	PUSH	DE
	PUSH	BC
	LD	E,0FFH		;GET CHAR IF ANY
	LD	C,6		;CONSOLE STATUS CHECK
	CALL	BDOS
	POP	BC		;RESTORE REGS
	POP	DE
	POP	HL
	CP	CTRLC		;CHECK FOR ABORT
	JP	Z,EXIT		;EXIT
	CP	CTRLX		;SKIP?
	RET

; ;
; ; COPY HL TO DE FOR B BYTES
; ;
; LDIR:
; 	LD	A,(HL)		;GET
; 	LD	(DE),A		;PUT
; 	INC	HL		;PT TO NEXT
; 	INC	DE
; 	DJNZ	LDIR		;LOOP
; 	RET

;
;  PRINT FILE NOT FOUND MESSAGE
;
PRFNF:
	CALL	PRINT
	DEFB	' No File','s'+80H
	JP	EXIT

;
;  OUTPUT NEW LINE TO CON:
;
CRLF:
	LD	A,CR
	CALL	CONOUT
	LD	A,LF
	JP	CONOUT

;
; SEARCH FOR FIRST AND NEXT
;
SEARF:
	PUSH	BC		; SAVE COUNTER
	PUSH	HL		; SAVE HL
	LD	C,17		; SEARCH FOR FIRST FUNCTION
SEARF1:
	LD	DE,FCB1		; PT TO FCB
	CALL	BDOS
	INC	A		; SET ZERO FLAG FOR ERROR RETURN
	POP	HL		; GET HL
	POP	BC		; GET COUNTER
	RET
SEARN:
	PUSH	BC		; SAVE COUNTER
	PUSH	HL		; SAVE HL
	LD	C,18		; SEARCH FOR NEXT FUNCTION
	JR	SEARF1

;
; CONSOLE INPUT
;
CONIN:
	PUSH	HL		; SAVE REGS
	PUSH	DE
	PUSH	BC
	LD	C,1		; INPUT
	CALL	BDOS
	POP	BC		; GET REGS
	POP	DE
	POP	HL
	AND	7FH		; MASK MSB
	CP	61H
	RET	C
	AND	5FH		; TO UPPER CASE
	RET

;
; LOG INTO USER AREA CONTAINED IN FCB1
;
LOGUSR:
	LD	A,(FCB1+13)	;GET USER NUMBER
SETUSR:
	LD	E,A
	LD	C,32		;USE BDOS FCT
	JP	BDOS

;
;  PRINT FILE NAME PTED TO BY HL
;
PRFN:
	CALL	PRINT		;LEADING SPACE
	DEFB	' '+80H
	LD	B,8		;8 CHARS
	CALL	PRFN1
	LD	A,'.'		;DOT
	CALL	CONOUT
	LD	B,3		;3 CHARS
PRFN1:
	LD	A,(HL)		; GET CHAR
	INC	HL		; PT TO NEXT
	CALL	CONOUT		; PRINT CHAR
	DJNZ	PRFN1		; COUNT DOWN
	RET

;
; SAVE RETURN ADDRESS
;
RETSAVE:
	POP	DE		; GET RETURN ADDRESS
	POP	HL		; GET RETURN ADDRESS TO ZCPR3
	LD	(Z3RET),HL	; SAVE IT
	PUSH	HL		; PUT RETURN ADDRESS TO ZCPR3 BACK
	PUSH	DE		; PUT RETURN ADDRESS BACK
	RET

;
; EXIT TO ZCPR3
;
EXIT:
Z3RET	EQU	$+1		; POINTER TO IN-THE-CODE MODIFICATION
	LD	HL,0		; RETURN ADDRESS
	JP	(HL)		; GOTO ZCPR3

;
; TEST WHEEL BYTE FOR APPROVAL
;   IF WHEEL BYTE IS 0 (OFF), ABORT WITH A MESSAGE (FLUSH RET ADR AND EXIT)
;
	IF	WHEEL		;IF ANY WHEEL OPTION IS RUNNING
WHLTST:
	LD	A,(Z3WHL)	;GET WHEEL BYTE
	OR	A		;ZERO?
	RET	NZ
	POP	AF		;CLEAR STACK
	CALL	PRINT
	DEFB	' No Whee','l'+80H
	RET
	ENDIF			;WHEEL

;
; PRINT A DASH
;
	IF	LTON OR PEEKON
DASH:
	CALL	PRINT
	DEFB	' -',' '+80H
	RET
;
	ENDIF			;LTON OR PEEKON
;
; PRINT ADDRESS MESSAGE
;   PRINT ADDRESS IN DE
;
	IF	PEEKON OR POKEON
ADRAT:
	CALL	PRINT
	DEFB	' at',' '+80H
	LD	A,D		;PRINT HIGH
	CALL	PAHC
	LD	A,E		;PRINT LOW
	JP	PAHC
;
; EXTRACT HEXADECIMAL NUMBER FROM LINE PTED TO BY HL
;   RETURN WITH VALUE IN DE AND HL PTING TO OFFENDING CHAR
;
HEXNUM:
	LD	DE,0		;DE=ACCUMULATED VALUE
	LD	B,5		;B=CHAR COUNT
HNUM1:
	LD	A,(HL)		;GET CHAR
	CP	' '+1		;DONE?
	RET	C		;RETURN IF SPACE OR LESS
	INC	HL		;PT TO NEXT
	SUB	'0'		;CONVERT TO BINARY
	JR	C,NUMERR		;RETURN AND DONE IF ERROR
	CP	10		;0-9?
	JR	C,HNUM2
	SUB	7		;A-F?
	CP	10H		;ERROR?
	JR	NC,NUMERR
HNUM2:
	LD	C,A		;DIGIT IN C
	LD	A,D		;GET ACCUMULATED VALUE
	RLCA			;EXCHANGE NYBBLES
	RLCA
	RLCA
	RLCA
	AND	0F0H		;MASK OUT LOW NYBBLE
	LD	D,A
	LD	A,E		;SWITCH LOW-ORDER NYBBLES
	RLCA
	RLCA
	RLCA
	RLCA
	LD	E,A		;HIGH NYBBLE OF E=NEW HIGH OF E,
	;  LOW NYBBLE OF E=NEW LOW OF D
	AND	0FH		;GET NEW LOW OF D
	OR	D		;MASK IN HIGH OF D
	LD	D,A		;NEW HIGH BYTE IN D
	LD	A,E
	AND	0F0H		;MASK OUT LOW OF E
	OR	C		;MASK IN NEW LOW
	LD	E,A		;NEW LOW BYTE IN E
	DJNZ	HNUM1		;COUNT DOWN
	RET
;
; NUMBER ERROR
;
NUMERR:
	CALL	PRINT
	DEFB	' Num','?'+80H
	JP	EXIT
;
; SKIP TO NEXT NON-BLANK
;
SKSP:
	LD	A,(HL)		;GET CHAR
	INC	HL		;PT TO NEXT
	CP	' '		;SKIP SPACES
	JR	Z,SKSP
	DEC	HL		;PT TO GOOD CHAR
	OR	A		;SET EOL FLAG
	RET
;
	ENDIF			;PEEKON OR POKEON
;
; Test File in FCB for unambiguity and existence, ask user to delete if so
;   Return with Z flag set if R/O or no permission to delete
;
	IF	RENON OR CPON
EXTEST:
	CALL	AMBCHK		;AMBIGUOUS FILE NAMES NOT ALLOWED
	CALL	SEARF		;LOOK FOR SPECIFIED FILE
	JR	Z,EXOK		;OK IF NOT FOUND
	CALL	GETSBIT		;POSITION INTO DIR
	INC	DE		;PT TO FILE NAME
	EX	DE,HL		;HL PTS TO FILE NAME
	PUSH	HL		;SAVE PTR TO FILE NAME
	CALL	PRFN		;PRINT FILE NAME
	POP	HL
	CALL	ROTEST		;CHECK FOR R/O
	JR	NZ,EXER
	CALL	ERAQ		;ERASE?
	JR	NZ,EXER		;RESTART AS ERROR IF NO
	LD	DE,FCB1		;PT TO FCB1
	LD	C,19		;DELETE FILE
	CALL	BDOS
EXOK:
	XOR	A
	DEC	A		;NZ = OK
	RET
EXER:
	XOR	A		;ERROR FLAG - FILE IS R/O OR NO PERMISSION
	RET

;
; CHECK FOR AMBIGUOUS FILE NAME IN FCB1
;   RETURN Z IF SO
;
AMBCHK:
	LD	HL,FCB1+1	;PT TO FCB
;
; CHECK FOR AMBIGUOUS FILE NAME PTED TO BY HL
;
AMBCHK1:
	PUSH	HL
	LD	B,11		;11 BYTES
AMB1:
	LD	A,(HL)		;GET CHAR
	AND	7FH		;MASK
	CP	'?'
	JR	Z,AMB2
	INC	HL		;PT TO NEXT
	DJNZ	AMB1
	DEC	B		;SET NZ FLAG
	POP	DE
	RET
AMB2:
	POP	HL		;PT TO FILE NAME
	CALL	PRFN
	CALL	PRINT
	DEFB	' is AF','N'+80H
	JP	EXIT
;
	ENDIF			;RENON OR CPON
;
;  CHECK USER TO SEE IF HE APPROVES ERASE OF FILE
;	RETURN WITH Z IF YES
;
	IF	RENON OR CPON OR ERAON OR PROTON
ERAQ:
	CALL	PRINT
	DEFB	' - Eras','e'+80H
ERAQ1:
	CALL	PRINT
	DEFB	' (Y/N)?',' '+80H
	CALL	CONIN		;GET RESPONSE
	CP	'Y'		;KEY ON YES
	RET
;
	ENDIF			;RENON OR CPON OR ERAON OR PROTON
;
; TEST FILE PTED TO BY HL FOR R/O
;	NZ IF R/O
;
	IF	RENON OR ERAON OR CPON
ROTEST:
	PUSH	HL		;ADVANCE TO R/O BYTE
	LD	BC,8		;PT TO 9TH BYTE
	ADD	HL,BC
	LD	A,(HL)		;GET IT
	AND	80H		;MASK BIT
	PUSH	AF
	LD	HL,ROMSG
	CALL	NZ,PRINT1	;PRINT IF NZ
	POP	AF		;GET FLAG
	POP	HL		;GET PTR
	RET
ROMSG:
	DEFB	' is R/','O'+80H
;
	ENDIF			;RENON OR ERAON OR CPON
;
; INIT FCB1, RETURN WITH DE PTING TO FCB1
;
	IF	ERAON OR LTON OR CPON
INITFCB1:
	LD	HL,FCB1		;PT TO FCB
INITFCB2:
	PUSH	HL		;SAVE PTR
	LD	BC,12		;PT TO FIRST BYTE
	ADD	HL,BC
	LD	B,24		;ZERO 24 BYTES
	XOR	A		;ZERO FILL
	CALL	FILLP		;FILL MEMORY
	POP	DE		;PT TO FCB
	RET
;
	ENDIF			;ERAON OR LTON OR CPON
;
; BUFFERS
;
NXTFILE:
	DEFS	2		;PTR TO NEXT FILE IN LIST

;
; SIZE ERROR TEST
;
	IF	($ GT (RCP + RCPS*128))
	*** RCP Package too big		;RCP IS TOO LARGE FOR BUFFER
	ENDIF

;
; END OF SYS.RCP
;

	END
