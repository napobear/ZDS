   1:			;	title	*   *** Z8E - Z80 Debug Monitor ***    *
   2:			;	subttl	(C) Copyright 1984, 1985   by Richard A. Surwilo
   3:			
   4:			; -----------------------------------------------------------------------------
   5:			; Modified to be compatible with zmac assembler and to be run as a stand-alone
   6:			; debugger (without CP/M support)
   7:			; Feb 2006 - Piergiorgio Betti <pbetti@lpconsul.net>
   8:			; N.B. as of 20060620 this is partially true. Just console IO has been changed.
   9:			; -----------------------------------------------------------------------------
  10:			
  11:			;------------------------------------------------------------------------------
  12:			;
  13:			;  Copyright (C) 1984, 1985   by Richard A. Surwilo.  All rights reserved.
  14:			;
  15:			;  No part of this publication may be reproduced, transmitted, transcribed,
  16:			;  stored in a retrieval system, or translated into any language or computer
  17:			;  language in any form or by any means, electronic, mechanical, magnetic,
  18:			;  optical, chemical, manual or otherwise, without express prior written
  19:			;  permission of:
  20:			;
  21:			;      Richard  A. Surwilo  330 Calvin Court, Wyckoff, NJ 074816
  22:			;
  23:			;  Note:
  24:			;	    This program is distributed in violation of the restrictions
  25:			;	    on reproduction and transmission outlined above.  It would
  26:			;	    appear that Rick Surwilo released this program to the public
  27:			;	    domain without removing the notice.
  28:			;
  29:			;------------------------------------------------------------------------------
  30:			;
  31:			;                       Revision history
  32:			;  15 Feb 08	 v3.7	Switch to RST8 instead of RST38 and some other minor
  33:			;			fix to cope with ZDS interrupt handling
  34:			;
  35:			;  21 Feb 06	 v3.6	Modifified syntax for zmac cross-assembler
  36:			;			Piergiorgio Betti <pbetti@lpconsul.net>
  37:			;
  38:			;  27 Dec 88 jrs v3.5	Released 24 Jan 89.  Includes a few patches by
  39:			;			George Havach.
  40:			;
  41:			;		1.	Changed operation of <cr> in some commands to make
  42:			;			a more consistent user interface.  (I won't be
  43:			;			offended if users want it changed back - jrs.)
  44:			;
  45:			;		2.	Enhancement to patch 1.5:- altered the search for
  46:			;			"MACRO-80" sentinel in RPRN files to allow for a
  47:			;			TITLE pseudo-op.
  48:			;
  49:			;		3.	Shortened and improved the code for the 'I' command.
  50:			;
  51:			;		4.	Tested and corrected the ANSIXYCP module which I have
  52:			;			been supplying since May 1987.  The code has now been
  53:			;			incorporated into the main source file and can be
  54:			;			activated during assembly by setting "aterm equ true".
  55:			;
  56:			;		5.	Discarded the '#' command introduced in 3.3.11 as with
  57:			;			a minor adjustment the 'L' command with no file name
  58:			;			does the same thing.
  59:			;
  60:			;		6.	If S or J was last command issued then <cr> alone
  61:			;			repeats S or J in single-step mode.  Very useful for
  62:			;			stepping through a small section of a program.
  63:			;
  64:			;	(gah)	7.	Adapted a patch by George Havach to correct the display
  65:			;			of IX and IY in disassembled instructions when upper
  66:			;			case is set.
  67:			;
  68:			;	(gah)	8.	Made room for patching in 'clear screen' code at
  69:			;			MBANNR: for more dignified start-up.
  70:			;
  71:			;	(gah)	9.	Replaced tilde ("~") with period (".") as a general
  72:			;			substitute for non-displayable ASCII characters, for
  73:			;			consistency with practically every other screen-dump
  74:			;			utility.  [Retained "hazeltine" conditional - jrs]
  75:			;
  76:			;  12 Dec 88 jrs v3.4	Made patch 3.3.1 object-configurable because some
  77:			;			terminals, particularly those which have binary
  78:			;			cursor addressing, must use an offset of 80h to stop
  79:			;			the BDOS from expanding tabs and for those terminals
  80:			;			clearing bit 7 is nasty.
  81:			;
  82:			;   5 Dec 88 eg  v3.3	Included a number of fixes and features submitted by
  83:			;  (installed by jrs)	Eric Gans in January and March 88.
  84:			;
  85:			;		 1.	Clear bit 7 of characters sent to screen to avoid
  86:			;			strange effects on some computers (such as Kaypro
  87:			;			which prints graphic characters if bit 7 is on).
  88:			;
  89:			;		 2.	Allow 'z' command without an address to mean dis-
  90:			;			assemble from last instruction for last-specified
  91:			;			number of lines.
  92:			;
  93:			;		 3.	Allow 'g' command without an address to mean the
  94:			;			equivalent of 'g  pc'  or  'g  $' (i.e. continue
  95:			;			execution from current instruction).
  96:			;
  97:			;		 4.	Show absolute destination addresses when dis-
  98:			;			assembling relative jump instructions (jr and djnz).
  99:			;
 100:			;		 5.	Display flags along with registers when using the
 101:			;			's' and 'x' commands.
 102:			;
 103:			;		 6.	Allow easy refresh of the 'animated debug' screen
 104:			;			after program output has disturbed it.  Use 'j  #'
 105:			;			to force refresh.
 106:			;
 107:			;		 7.	After Z8E's internal disk I/O operations, reset
 108:			;			DMA to 80h for the benefit of target programs.
 109:			;
 110:			;		 8.	Allow cancellation of commands with CAN (ctrl-X)
 111:			;			when argument buffer is empty.  For example if you
 112:			;			have entered 'd  100' then first ^X erases the '100'
 113:			;			and the second cancels the 'd'.
 114:			;
 115:			;		 9.	Implement '>' command to change user number and so
 116:			;			allow loading of files from user areas other than
 117:			;			that from which Z8E was initiated.
 118:			;
 119:			;		10.	Implement '?' command to evaluate and display argument
 120:			;			expressions.  Accepts a register name as the first
 121:			;			operand.  (reg) allows indirect addressing so that,
 122:			;			for example, '?  (hl)' displays value at the memory
 123:			;			location whose address is contained in HL.
 124:			;
 125:			;		11.	Implement '#' command to recall and display the
 126:			;			highest address occupied by a program.
 127:			;
 128:			;   4 Dec 88 jrs v3.2	Expand asterisks in file names when using 'i' command.
 129:			;
 130:			;  27 Nov 88 jrs v3.1	Bug fix - deleted three spurious instructions from
 131:			;			the initialisation code which was added to support
 132:			;			breakpoint vectors at addresses other than 38h.
 133:			;
 134:			;  16 Nov 88 jrs v3.0	Bumped version number to regain sequence with USA.
 135:			;			Until now there were two independent streams of
 136:			;			development.  (A date prefixed by '-' denotes a
 137:			;			version from the "USA" stream).
 138:			;
 139:			;			Extended Jim Moore's idea of substituting RST 30h
 140:			;			(RST 6) for RST 38h (RST 7).  Now the breakpoint
 141:			;			vector address can be patched without re-assembling.
 142:			;
 143:			;  11 Nov 88 jrs v1.5	Added code to distinguish between RPRN files created
 144:			;			by Macro-80 and Z80ASM 1.3 so Z8E can load symbols
 145:			;			from either type of RPRN file.
 146:			;
 147:			;- 30 Nov 87 eg  v2.1	FCB and command tail initialisation routine supplied
 148:			;			by Eric Gans.  [Does not appear in the current source
 149:			;			as it duplicated v1.4 but consumed more code space.]
 150:			;
 151:			;  15 May 87 jrs v1.4	Implemented "I" command to initialise the command
 152:			;			tail at 80h and the default FCB name blocks at 5Ch
 153:			;			and 6Ch.
 154:			;
 155:			;			Renamed I(nput) command to L(oad) to make way for new
 156:			;			I(nitialise) command.  Documentation changed 13/6/87.
 157:			;
 158:			;			Filtered source code to all lower case.  Sometime
 159:			;			Between 1.0 And 1.2 The Comments Had Been Modified So
 160:			;			That Every Word Started With A Capital Letter And It
 161:			;			Really Did Look Quite Silly.
 162:			;
 163:			;  20 Apr 87 jrs v1.3	Fixed register display in animated debug mode.  Z8E
 164:			;			now handles EX AF,AF' and EXX instructions correctly.
 165:			;			Duplicates patch of 21 Oct 86 but was developed quite
 166:			;			independently and coded very differently.
 167:			;
 168:			;			Added equates to tailor the source to assemblers
 169:			;			other than M80.
 170:			;
 171:			;- 21 Oct 86 fh  v2.0	Fixed register display in animated debug mode.  Z8E
 172:			;  (installed by gmi)	now handles EX AF,AF' and EXX instructions correctly.
 173:			;
 174:			;  08 Mar 86 jrs v1.2	(No version number change - all mods purely cosmetic)
 175:			;			Modified org directives to bypass bug in m80
 176:			;			Added jterm conditional for testing
 177:			;			Added hazeltine conditional for tilde suppression
 178:			;			Changed dates to more universal format
 179:			;
 180:			;  16 Jan 86 ijb v1.2	Cursor addressing for post '=>' in jdbg75
 181:			;			to cover systems that have a destructive bs
 182:			;
 183:			;-  3 Dec 85 jgm v?.?	Added EQUates for breakpoint address so it could be
 184:			;			something other than 38h.
 185:			;
 186:			;  25 Sep 85 ras v1.1	Fix case bug
 187:			;			Fix usym bug
 188:			;			Clean up comments
 189:			;
 190:			;	ras = Richard Surwilo		Stamford, Connecticut
 191:			;	ijb = ?
 192:			;	jrs = Jon Saxton		Sydney, New South Wales
 193:			;	jgm = Jim Moore			Anaheim, California
 194:			;	eg  = Eric Gans			Los Angeles, California
 195:			;	fh  = Frankie Hogan
 196:			;	gbi = Gary Inman		Los Angeles, California
 197:			;	gah = George Havach		California
 198:			;
 199:			;------------------------------------------------------------------------------
 200:			;
 201:			include darkstar.equ
**** darkstar.equ ****
   1:			;****** Equ's file autogenerated by genequs ver: 1.0
   2:			;****** Input files:
   3:			;****** SysCommon.lst
   4:	FDC4          	FIN            	EQU	0FDC4H
   5:	FD89          	DLY1           	EQU	0FD89H
   6:	FD87          	DLY2           	EQU	0FD87H
   7:	FDE1          	FOUT           	EQU	0FDE1H
   8:	FE70          	U1NUL          	EQU	0FE70H
   9:	FE25          	U0ISR          	EQU	0FE25H
  10:	FE59          	U1ISR          	EQU	0FE59H
  11:	FD85          	DELAY          	EQU	0FD85H
  12:	FE4E          	UISRE          	EQU	0FE4EH
  13:	FDB5          	FSTAT          	EQU	0FDB5H
  14:	FE32          	UISRI          	EQU	0FE32H
  15:	FC4B          	BBU1ST         	EQU	0FC4BH
  16:	FC45          	BBU1RX         	EQU	0FC45H
  17:	FC3F          	BBU1TX         	EQU	0FC3FH
  18:	FD29          	BBEXEC         	EQU	0FD29H
  19:	FD05          	BBHDRD         	EQU	0FD05H
  20:	FD6A          	BBVOID         	EQU	0FD6AH
  21:	FE86          	UASTKB         	EQU	0FE86H
  22:	FD6B          	MMPMAP         	EQU	0FD6BH
  23:	FE0F          	INTRDI         	EQU	0FE0FH
  24:	FC2D          	SCONIN         	EQU	0FC2DH
  25:	FC15          	VCONIN         	EQU	0FC15H
  26:	FCE1          	BBDIV16        	EQU	0FCE1H
  27:	FCFF          	BBHDWR         	EQU	0FCFFH
  28:	FD78          	MMGETP         	EQU	0FD78H
  29:	FDFE          	INTREN         	EQU	0FDFEH
  30:	FE79          	RLDROM         	EQU	0FE79H
  31:	FCE7          	BBMUL16        	EQU	0FCE7H
  32:	FC00          	SYSCOM         	EQU	0FC00H
  33:	FE84          	UASTAV         	EQU	0FE84H
  34:	FE19          	SYTIMR         	EQU	0FE19H
  35:	FC33          	SCONST         	EQU	0FC33H
  36:	FC1B          	VCONST         	EQU	0FC1BH
  37:	FC39          	BBU0INI        	EQU	0FC39H
  38:	FC51          	BBU1INI        	EQU	0FC51H
  39:	FC87          	BBFREAD        	EQU	0FC87H
  40:	FD23          	BBEIDCK        	EQU	0FD23H
  41:	FD0B          	BBHDGEO        	EQU	0FD0BH
  42:	FEB4          	BBSTACK        	EQU	0FEB4H
  43:	FC81          	BBFHOME        	EQU	0FC81H
  44:	FD94          	BBCONIN        	EQU	0FD94H
  45:	FC27          	CRDUREG        	EQU	0FC27H
  46:	FFF0          	SINTVEC        	EQU	0FFF0H
  47:	FEB4          	SYSCMLO        	EQU	0FEB4H
  48:	FE22          	VOIDISR        	EQU	0FE22H
  49:	FC9F          	BBSTTIM        	EQU	0FC9FH
  50:	FDAA          	BBCONST        	EQU	0FDAAH
  51:	FC27          	SCONOUT        	EQU	0FC27H
  52:	FC0F          	VCONOUT        	EQU	0FC0FH
  53:	FCED          	BBOFFCAL       	EQU	0FCEDH
  54:	FC57          	BBINICTC       	EQU	0FC57H
  55:	FE90          	BBSTBASE       	EQU	0FE90H
  56:	FC5D          	BBRESCTC       	EQU	0FC5DH
  57:	FCA5          	BBRDTIME       	EQU	0FCA5H
  58:	FCC3          	BBCPTIME       	EQU	0FCC3H
  59:	FD5A          	BBCALRET       	EQU	0FD5AH
  60:	FCB7          	BBDMASET       	EQU	0FCB7H
  61:	FC00          	BBJTOBNK       	EQU	0FC00H
  62:	FCBD          	BBDSKSEL       	EQU	0FCBDH
  63:	FCF3          	BBHDINIT       	EQU	0FCF3H
  64:	FCB1          	BBSECSET       	EQU	0FCB1H
  65:	FD11          	BBHDBOOT       	EQU	0FD11H
  66:	FC69          	BBUPLCHR       	EQU	0FC69H
  67:	FC99          	BBPRNCHR       	EQU	0FC99H
  68:	FCCF          	BBVCPMBT       	EQU	0FCCFH
  69:	FC93          	BBFLOPIO       	EQU	0FC93H
  70:	FD1D          	BBEPMNGR       	EQU	0FD1DH
  71:	FCD5          	BBSIDSET       	EQU	0FCD5H
  72:	FD17          	BBLDPART       	EQU	0FD17H
  73:	FC75          	BBRDVDSK       	EQU	0FC75H
  74:	FC8D          	BBFWRITE       	EQU	0FC8DH
  75:	FCC9          	BBCPBOOT       	EQU	0FCC9H
  76:	FC21          	BBCURSET       	EQU	0FC21H
  77:	FCAB          	BBTRKSET       	EQU	0FCABH
  78:	FC7B          	BBWRVDSK       	EQU	0FC7BH
  79:	FD9F          	BBCONOUT       	EQU	0FD9FH
  80:	FCF9          	BBDRIVEID      	EQU	0FCF9H
  81:	FC63          	BBPSNDBLK      	EQU	0FC63H
  82:	FC03          	BBCRTCINI      	EQU	0FC03H
  83:	FC6F          	BBPRCVBLK      	EQU	0FC6FH
  84:	FC09          	BBCRTFILL      	EQU	0FC09H
  85:	FCDB          	BBFDRVSEL      	EQU	0FCDBH
  86:			;****** EOF ***
  87:			
**** z8d.asm ****
 202:			;
 203:			
 204:	FFFF          	TRUE	EQU	-1
 205:	0000          	FALSE	EQU	0
 206:			
 207:			; The following equate setup an incarnation that will run without CP/M support
 208:			; It is hardware dependent (since calls are made directly to the monitor ROM)
 209:			; Here it is tailored for my Z80darkStar. Follow the STLONE symbol to find
 210:			; were customize the calls...
 211:			
 212:	FFFF          	STLONE	EQU TRUE
 213:			
 214:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 215:			; The following EQUates should both be set to FALSE to generate a "standard"
 216:			; Z8E.COM for distribution.  The JTERM is mine which I only put in for use
 217:			; while testing to save having to configure the object code for my terminal.
 218:			; (jrs 8 mar 86)  The ATERM is for an ANSI-compatible terminal such as a
 219:			; VT100 in which case setting ATERM to TRUE will cause the ANSIXYCP module
 220:			; to be included during assembly.  (jrs 28 dec 88)
 221:			
 222:	0000          	JTERM	EQU	FALSE		;Should always be false for distribution
 223:	0000          	ATERM	EQU	FALSE		;- - - ditto - - -
 224:	FFFF          	Z80DS	EQU	TRUE
 225:			
 226:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 227:			; The following equ should normally be set to 0.  It is only required if
 228:			; you have a Hazeltine terminal which uses tilde as a command character
 229:			
 230:	0000          	HAZELTINE EQU	FALSE
 231:			
 232:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 233:			; Configure this source to your favourite assembler by setting one of
 234:			; the following equates to true.  If you use an assembler not mentioned
 235:			; below then make up a new equate for it.
 236:			
 237:	0000          	M80	EQU	FALSE		;Microsoft's Macro-80
 238:	0000          	ASMB	EQU	FALSE		;Cromemco's Z80 assembler
 239:	FFFF          	SLR	EQU	TRUE		;SLR's lightning-fast Z80ASM assembler
 240:			
 241:			; (Note that there is no real distinction between M80 and SLR.  Either
 242:			;  assembler may be used with either EQUate set TRUE.)
 243:			;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 244:			
 245:	0000          	COMPACT	EQU	JTERM OR ATERM
 246:			
 247:	0000          	     IF	COMPACT
 253:			     ENDIF
 254:			
 255:	FFFF          	     IF	NOT ASMB
 256:				.Z80			;so M80 users don't need /z switch
 257:			     ENDIF
 258:			
 259:	0000          	     IF	ASMB
 264:			     ENDIF
 265:			
 266:	0010          	MAXBP	EQU	16		;Number	of breakpoints configured
 267:			
 268:	0008          	BS	EQU	08H		;ASCII 	backspace
 269:	0009          	TAB	EQU	09H		;	tab
 270:	000A          	LF	EQU	0AH		;	line feed
 271:	000C          	FORMF	EQU	0CH		;	form feed
 272:	000D          	CR	EQU	0DH		;	carriage return
 273:	001B          	ESC	EQU	1BH		;       escape
 274:	0018          	CTLX	EQU	'X' and	1fh	;	control	x - delete line
 275:	0003          	CTLC	EQU	'C' and	1fh	;	control	c - warm boot
 276:	001A          	EOF	EQU	'Z' and	1fh	;	control	z - logical eof
 277:	0027          	QUOTE	EQU	27H		;	quote
 278:	007E          	TILDE	EQU	7EH		;	tilde
 279:	007F          	DEL	EQU	7FH		;	del
 280:			
 281:	0005          	BDOS	EQU	5
 282:	005C          	FCB5C	EQU	5CH		;CP/M default FCB
 283:			
 284:	0000          	INOP	EQU	000		;Z80 instructions
 285:	00C3          	IJP	EQU	0C3H
 286:	00C9          	IRT	EQU	0C9H
 287:	00CF          	RST38	EQU	0CFH		; uses RST 8
 288:			
 289:	0080          	IOBUF	EQU	80H		;Disk read buffer for symbol loading
 290:			
 292:			
 293:			;******************************************************************************
 294:			;*
 295:			;*	nint:	  Initialization - relocating loader - symbol loader
 296:			;*
 297:			;*	Initialization:
 298:			;*	- Save system I	register
 299:			;*	- Determine max symbol length before loading symbol table
 300:			;*        permissable values are 6 and 14 which are converted to bit
 301:			;*	  masks by bumping by one
 302:			;*	- Set CP/M DMA address to 80h
 303:			;*	- Check first command line argument for (xx) where xx is the
 304:			;*	  number of slots in the symbol table to reserve.
 305:			;*	- Move first file name found in command line to local memory
 306:			;*	  since it will be loaded last.  At the end of initialization
 307:			;*	  (or symbol loading if required) this file name will be loaded
 308:			;*	  into the keyboard input buffer and the file will be loaded
 309:			;*	  just as if the user had entered the info as a Z8E command.
 310:			;*	- Move all subsequent file names in the	command	line buffer to
 311:			;*	  local input buffer (inbf) in low memory, where they can
 312:			;*	  be found by the parse	routine (prsr).
 313:			;*
 314:			;*	Relocating loader:
 315:			;*	- Move absolute	memory image of	Z8E to top of TPA
 316:			;*	- Adjust all addresses in relocated monitor to reflect new
 317:			;*	  execution area.  This is accomplished by repeated calls to
 318:			;*	  zlen to calculate instruction	lengths.
 319:			;*	- All addresses	< the absolute value of	z8eorg are considered
 320:			;*	  to be	absolute values	and are	not modified.
 321:			;*	- Relocate all address pointers	in command and operand jump
 322:			;*	  tables.
 323:			;*
 324:			;******************************************************************************
 325:			
 326:	FFFF          	      IF	M80 OR SLR
 327:				ASEG
 328:			      ENDIF
 329:			
 330:	0000          	      IF ASMB
 332:			      ENDIF
 333:			
 334:	0000          	      IF	ASMB
 338:			      ENDIF
 339:			
 340:			;     if	SLR or M80
 341:			;	Use :: at end of label name to generate a global symbol
 342:			;	when assembling to a .REL file (i.e. when using M80 or
 343:			;	when using Z80ASM with the /M switch).  Doing it this
 344:			;	way lets us assemble to a .REL file with either assembler
 345:			;	or directly to a .COM file with Z80ASM without changing
 346:			;	the source at all.
 347:			;     endif
 348:			
 349:	0100          		ORG	100H
 350:			
 351:	0100  C3B301  		JP	NINT
 352:			
 353:	0000          	      IF	ASMB
 355:			      ELSE
 356:	0103          	RSTVEC:
 357:			      ENDIF
 358:	0103  08      		DEFB	08H		;Default (but patchable) breakpoint vector
 359:			
 360:	0000          	      IF	ASMB
 362:			      ELSE
 363:	0104          	COMASK:
 364:			      ENDIF
 365:	0104  7F      		DEFB	7FH		;Mask applied to characters before output
 366:							;to screen.  Patch to 0FFh if your terminal
 367:							;needs high-order bit set on occasions.
 368:			
 369:	0000          	      IF	ASMB
 371:			      ELSE
 372:	0105          	MBANNR:
 373:			      ENDIF
 374:	0000          	      IF	JTERM
 376:			      ENDIF
 377:	FFFF          	      IF	Z80DS
 378:	0105  0C      		DEFB	$0C
 379:			      ELSE
 381:			      ENDIF
 382:	0106  0D0A    		DEFB	CR,LF
 383:	0108  5A384420		DEFB	'Z8D  V3.7 - 15 Feb 08'
	      2056332E
	      37202D20
	      31352046
	      65622030
	      38
 384:	011D  0D0A    		DEFB	CR,LF
 385:	FFFF          	      IF STLONE
 386:	011F  5A383044		DEFB	'Z80DARKSTAR MONITOR-ONLY VERSION.',CR,LF
	      41524B53
	      54415220
	      4D4F4E49
	      544F522D
	      4F4E4C59
	      20564552
	      53494F4E
	      2E0D0A
 387:			      ENDIF
 388:	0142  436F7079		DEFB	'Copyright (c) 1984, 1985  Richard A. Surwilo'
	      72696768
	      74202863
	      29203139
	      38342C20
	      31393835
	      20205269
	      63686172
	      6420412E
	      20537572
	      77696C6F
 389:	016E  0D0A    		DEFB	CR,LF
 390:	0170  436F7079		DEFB	'Copyright (c) 2006-2008 Piergiorgio Betti <pbetti@lpconsul.net>'
	      72696768
	      74202863
	      29203230
	      30362D32
	      30303820
	      50696572
	      67696F72
	      67696F20
	      42657474
	      69203C70
	      62657474
	      69406C70
	      636F6E73
	      756C2E6E
	      65743E
 391:	01AF  0D0A0A  		DEFB	CR,LF,LF
 392:	01B2  00      		DEFB	0
 393:			
 394:	01B3          	NINT:
 395:	01B3  F3      		DI			; disable interrupts in hardware
 396:			; 	CALL	GDISIN		; and lock monitor to reenable them
 397:	01B4  319D30  		LD	SP,STACK
 398:	01B7  ED57    		LD	A,I		;Save i reg for user
 399:	01B9  328C2F  		LD	(IREG),A
 400:	01BC  CD400A  		CALL	INIT
 401:	01BF  110501  		LD	DE,MBANNR	;Dispense with formalities
 402:	01C2  CD7328  		CALL	PRINT
 403:			
 404:			; Patch code for a specific breakpoint routine address.
 405:			;
 406:			; Adapted from an idea by Jim Moore (3 Dec 85) but made object-patchable
 407:			; (jrs 15 Nov 88)
 408:			
 409:	01C5  3A0301  		LD	A,(RSTVEC)	;Get breakpoint vector address
 410:	01C8  6F      		LD	L,A
 411:	01C9  2600    		LD	H,0
 412:	01CB  220C02  		LD	(NINT03+1),HL	;Patch the code
 413:	01CE  23      		INC	HL		;HL now holds rstVec+1
 414:	01CF  22D302  		LD	(NINT71+1),HL	;Patch some more code
 415:	01D2  F6C7    		OR	0C7H		;Convert vector address into RST xx
 416:	01D4  326C14  		LD	(G400+1),A	;Patch the code
 417:	01D7  329914  		LD	(G518+1),A
 418:			
 419:			; Patch code for terminal output - jrs 3.4
 420:	0000          	IF NOT STLONE
 423:			ENDIF
 424:			; Do config based on max length of symbol names
 425:			
 426:	01DA  3A062F  		LD	A,(MAXLEN)	;Check max symbol length
 427:	01DD  3C      		INC	A		;Create mask
 428:	01DE  FE0F    		CP	15
 429:	01E0  47      		LD	B,A		;B - maxlen mask - 15
 430:	01E1  3E3E    		LD	A,62		;A - maxlin disassembly line length (62)
 431:	01E3  0E44    		LD	C,68		;C - column to display first byte of memory
 432:							;    window for J command
 433:	01E5  1603    		LD	D,3		;D - bytes per line of memory window display
 434:	01E7  CAF201  		JP	Z,NINT00	;Z - max symbol length is 14
 435:			
 436:							;If not 14 - use default values
 437:	01EA  0607    		LD	B,7		;B - maxlen mask -  7
 438:	01EC  3E1E    		LD	A,30		;A - maxlin disassembly line length (30)
 439:	01EE  0E38    		LD	C,56		;C - column to display first byte of memory
 440:	01F0  1607    		LD	D,7		;    window for J command
 441:	01F2  32082F  	NINT00:	LD	(MAXLIN),A
 442:	01F5  78      		LD	A,B
 443:	01F6  32062F  		LD	(MAXLEN),A
 444:	01F9  79      		LD	A,C
 445:	01FA  320A2F  		LD	(FWNDOW),A
 446:	01FD  7A      		LD	A,D
 447:	01FE  320B2F  		LD	(NLMASK),A
 448:			
 449:			;Reset CP/M DMA address for those instances in which Z8E is used to debug
 450:			;itself.  Otherwise DMA address is left where Z8E stopped loading itself.
 451:			;(Last statement no longer true - see patch 3.3.1)
 452:			;IF NOT STLONE
 453:	0201  118000  		LD	DE,80H
 454:	0204  0E1A    		LD	C,26
 455:	0206  CD0500  		CALL	BDOS
 456:			;ENDIF
 457:	0209  3EC3    		LD	A,IJP		;Initialize where L80 fears to tread
 458:			
 459:			; The next instruction is PATCHED before it is executed
 460:	020B  323800  	NINT03:	LD	(38H),A		;Init trap to breakpoint handler
 461:			;IF STLONE
 462:			;	JP	NINT55
 463:			;ENDIF
 464:	020E  215D00  		LD	HL,5DH		;Save current contents of default fcb
 465:	0211  7E      		LD	A,(HL)
 466:	0212  FE28    		CP	'('		;Is first char in fcb a paren?
 467:	0214  2B      		DEC	HL
 468:	0215  2048    		JR	NZ,NINT25	;Not paren - no user symbol table requested
 469:	0217  23      		INC	HL		;Point back to paren
 470:	0218  11D72F  		LD	DE,INBF		;Start of input buffer here in low memory
 471:	021B  060F    		LD	B,15		;Max chars in fcb following first paren
 472:	021D  23      	NINT05:	INC	HL		;Bump fcb pointer
 473:	021E  12      		LD	(DE),A		;Move char to low memory keyboard input buffer
 474:							;so that prsr thinks this is keyboard input
 475:	021F  13      		INC	DE		;Bump input buffer pointer
 476:	0220  7E      		LD	A,(HL)
 477:	0221  FE29    		CP	')'		;Look for trailing paren
 478:	0223  2807    		JR	Z,NINT10
 479:	0225  10F6    		DJNZ	NINT05		;Examine entire fcb at 5ch looking for paren
 480:	0227  215C00  		LD	HL,FCB5C	;Trailing paren not found - this must be
 481:							; kookie file name
 482:	022A  1833    		JR	NINT25		;Ignore
 483:			
 484:			;Call iarg to determine amount of space to allocate in user symbol table.
 485:			;This arg must be enclosed in parentheses and must appear after the first
 486:			;arg in the command line.  Since opening and closing parens were found
 487:			;add a pound sign to make this into default decimal number then call xval
 488:			;to evaluate.
 489:			
 490:	022C  EB      	NINT10:	EX	DE,HL		;HL - input buffer pointer
 491:	022D  3623    		LD	(HL),'#'	;Add trailing paren before calling iarg
 492:							;who will evaluate argument as if it was
 493:							;entered from keyboard
 494:	022F  23      		INC	HL
 495:	0230  77      		LD	(HL),A		;Restore trailing paren following pound sign
 496:	0231  23      		INC	HL
 497:	0232  3600    		LD	(HL),0		;Add end of line null
 498:	0234  CDA926  		CALL	IARG
 499:	0237  EB      		EX	DE,HL		;DE - evaluated argument
 500:	0238  215C00  		LD	HL,FCB5C
 501:	023B  2022    		JR	NZ,NINT25	;Arg error - ignore input
 502:	023D  218100  		LD	HL,81H		;Start of command line tail
 503:	0240  7E      	NINT15:	LD	A,(HL)
 504:	0241  3620    		LD	(HL),' '	;Replace the text which appeared between
 505:							;the parens and the parens themselves with
 506:							;spaces
 507:			
 508:	0243  FE29    		CP	')'		;Closing paren ends search
 509:	0245  2803    		JR	Z,NINT20
 510:	0247  23      		INC	HL		;Point to char following closing paren
 511:	0248  18F6    		JR	NINT15
 512:	024A  EB      	NINT20:	EX	DE,HL		;Arg to hl for mult times maxlen bytes per
 513:							;symbol table entry
 514:	024B  29      		ADD	HL,HL
 515:	024C  29      		ADD	HL,HL
 516:	024D  29      		ADD	HL,HL
 517:	024E  3A062F  		LD	A,(MAXLEN)	;8 or 16 bytes per symbol table entry?
 518:	0251  FE07    		CP	7
 519:	0253  CA5702  		JP	Z,NINT22	;z - must be 8
 520:	0256  29      		ADD	HL,HL
 521:	0257  EB      	NINT22:	EX	DE,HL
 522:	0258  ED533309		LD	(USYMBL),DE	;Save number of bytes to reserve
 523:	025C  216C00  		LD	HL,6CH		;since user symbol table arg was present then
 524:							;target file must be in default fcb number 2
 525:			
 526:	025F  11E809  	NINT25:	LD	DE,ZBUF		;Local buffer
 527:	0262  011000  		LD	BC,16
 528:	0265  EDB0    		LDIR			;Move FCB contents to local memory
 529:	0267  218000  		LD	HL,80H		;Command line buffer address
 530:	026A  7E      		LD	A,(HL)
 531:	026B  A7      		AND	A		;Test for no input
 532:	026C  2834    		JR	Z,NINT55	;No input - clear symbol table
 533:	026E  4F      		LD	C,A		;BC - number of	chars in command line buffer
 534:	026F  70      		LD	(HL),B		;Clear byte count
 535:	0270  09      		ADD	HL,BC		;Point to last char in buffer
 536:	0271  23      		INC	HL
 537:	0272  70      		LD	(HL),B		;Set end of line null after last char
 538:	0273  218100  		LD	HL,81H
 539:	0276  7E      	NINT30:	LD	A,(HL)		;Look for start	of first file name
 540:	0277  A7      		AND	A		;Found the end of line null?
 541:	0278  2828    		JR	Z,NINT55	;Z - no	files to load
 542:	027A  FE20    		CP	' '		;Leading space?
 543:	027C  2004    		JR	NZ,NINT35	;Not space - found start of file name
 544:	027E  23      		INC	HL
 545:	027F  0D      		DEC	C		;Decrement command line	byte count
 546:	0280  18F4    		JR	NINT30		;Keep looking for start	of file	name
 547:	0282  11F809  	NINT35:	LD	DE,ZNMBUF	;Save name here	for later display
 548:	0285  12      		LD	(DE),A
 549:	0286  13      		INC	DE
 550:	0287  23      	NINT40:	INC	HL		;Find first trailing space
 551:	0288  7E      		LD	A,(HL)
 552:	0289  FE20    		CP	' '
 553:	028B  2808    		JR	Z,NINT45	;Found space - move remainder of buffer
 554:	028D  12      		LD	(DE),A		;Save file name	character for display
 555:	028E  13      		INC	DE
 556:	028F  A7      		AND	A		;End of	line?
 557:	0290  2810    		JR	Z,NINT55	;z - only one file specified
 558:	0292  0D      		DEC	C
 559:	0293  18F2    		JR	NINT40
 560:	0295  79      	NINT45:	LD	A,C		;Check byte count
 561:	0296  FE52    		CP	INBFSZ		;versus	size of	our local input	buffer
 562:	0298  3802    		JR	C,NINT50	;carry - size is ok
 563:	029A  0E52    		LD	C,INBFSZ	;Only move as much as will fit
 564:	029C  11D72F  	NINT50:	LD	DE,INBF
 565:	029F  EDB0    		LDIR			;Move command line to local memory
 566:	02A1  AF      		XOR	A
 567:			
 568:	02A2  21000C  	NINT55:	LD	HL,Z8EORG	;clear local symbol table to nulls
 569:	02A5  0610    		LD	B,Z8E-Z8EORG	;symbol	table size
 570:	02A7  77      	NINT60:	LD	(HL),A		;nulls to entire local symbol table
 571:	02A8  23      		INC	HL
 572:	02A9  10FC    		DJNZ	NINT60
 573:	02AB  2A0600  		LD	HL,(06)		;start of bdos
 574:			;IF STLONE
 575:			;	LD	HL,$EF00
 576:			;ENDIF
 577:	02AE  6F      		LD	L,A		;init stack address to 256 boundary
 578:	02AF  010025  		LD	BC,NMEM		;monitor size
 579:	02B2  A7      		AND	A
 580:	02B3  ED42    		SBC	HL,BC		;hl - starting address of z8e in upper
 581:							;memory
 582:	02B5  22E309  		LD	(Z8EB),HL	;monitor bias -	for relocation work
 583:	02B8  ED5B3309		LD	DE,(USYMBL)
 584:	02BC  ED52    		SBC	HL,DE
 585:	02BE  22E509  		LD	(NTPA),HL	;end of	tpa - for symbol loading
 586:	02C1  7A      		LD	A,D		;check for no user symbol table
 587:	02C2  B3      		OR	E
 588:	02C3  2808    		JR	Z,NINT75	;no table - no clearing required
 589:	02C5  3600    	NINT70:	LD	(HL),0		;fill user symbol table with nulls
 590:	02C7  23      		INC	HL
 591:	02C8  1B      		DEC	DE
 592:	02C9  7A      		LD	A,D
 593:	02CA  B3      		OR	E
 594:	02CB  20F8    		JR	NZ,NINT70
 595:	02CD  EB      	NINT75:	EX	DE,HL		;hl - start of z8e in hi memory
 596:			
 597:	02CE  217500  		LD	HL,BPHN-Z8EORG	;entry point to	breakpoint handler
 598:	02D1  19      		ADD	HL,DE
 599:			
 600:			; The next instruction will be PATCHED by the time it is executed.
 601:	02D2  223900  	NINT71:	LD	(39H),HL	;Init RST 38h trap location
 602:			
 603:	02D5  21000C  		LD	HL,Z8EORG
 604:	02D8  EDB0    		LDIR			;z8e now in hi memory - relocate addresses
 605:	02DA  2AE309  		LD	HL,(Z8EB)	;recover hi memory starting address
 606:	02DD  111400  		LD	DE,Z8ECMD-Z8EORG
 607:	02E0  19      		ADD	HL,DE		;first instruction to relocate
 608:	02E1  EB      		EX	DE,HL
 609:	02E2  CDC81A  	NINT80:	CALL	ZLEN00		;calculate instruction length
 610:	02E5  62      		LD	H,D
 611:	02E6  6B      		LD	L,E		;de - current instruction   hl - ditto
 612:	02E7  0600    		LD	B,0
 613:	02E9  09      		ADD	HL,BC
 614:	02EA  EB      		EX	DE,HL		;de - next address to relocate
 615:	02EB  79      		LD	A,C		;test length
 616:	02EC  D603    		SUB	3
 617:	02EE  3822    		JR	C,NINT90	;one or	two byters are non-relocatable
 618:	02F0  4F      		LD	C,A
 619:	02F1  09      		ADD	HL,BC		;bump if four byter
 620:	02F2  7E      		LD	A,(HL)
 621:	02F3  214B2A  		LD	HL,Z80R		;table of relocatable instructions
 622:	02F6  0E20    		LD	C,Z80RL		;size
 623:	02F8  EDB1    		CPIR
 624:	02FA  2016    		JR	NZ,NINT90	;nz - not relocatable
 625:	02FC  EB      		EX	DE,HL
 626:	02FD  2B      		DEC	HL		;point to address byte requiring bias
 627:	02FE  7E      		LD	A,(HL)
 628:	02FF  D60C    		SUB	Z8EORG SHR 8	;test for absolute address < z8eorg
 629:	0301  380D    		JR	C,NINT85	;absolute - no relocation needed
 630:	FFFF          	IF STLONE
 631:	0303  7E      		LD	A,(HL)		;load again
 632:	0304  FEF0    		CP	$F0		;test for address in monitor ROM space
 633:	0306  3008    		JR	NC,NINT85	;absolute - no relocation needed
 634:	0308  D60C    		SUB	Z8EORG SHR 8	;recalculate
 635:			ENDIF
 636:	030A  47      		LD	B,A
 637:	030B  3AE409  		LD	A,(Z8EBH)	;hi order byte of address bias
 638:	030E  80      		ADD	A,B		;plus upper byte of operand address
 639:	030F  77      		LD	(HL),A		;set relocated address
 640:	0310  23      	NINT85:	INC	HL
 641:	0311  EB      		EX	DE,HL		;de - next address to test
 642:	0312  010A1D  	NINT90:	LD	BC,NREL-Z8EORG	;end of	relocatable portion of monitor
 643:	0315  2AE309  		LD	HL,(Z8EB)
 644:	0318  09      		ADD	HL,BC		;hl - absolute end of relocated	monitor
 645:	0319  A7      		AND	A
 646:	031A  ED52    		SBC	HL,DE		;reached end?
 647:	031C  30C4    		JR	NC,NINT80	;nc - more
 648:	031E  112400  		LD	DE,NCMD+ZOPJTL	;size -	command	and operand jump tables
 649:	0321  2AE309  		LD	HL,(Z8EB)	;base of relocated monitor
 650:			;	LD	A,-(HIGH Z8EORG); [was:  ld a,-(z8eorg/256)]
 651:	0324  3EF4    		LD	A,-(Z8EORG/256)	;
 652:	0326  84      		ADD	A,H		;relocation bias byte to add to	ptrs
 653:	0327  57      		LD	D,A		;d - bias to add  e - count of pointers
 654:							;		      requiring relocation
 655:	0328  09      		ADD	HL,BC		;first point to	operand	names
 656:	0329  013000  		LD	BC,ZOPJTB	;add length of operand name table
 657:	032C  09      		ADD	HL,BC		;point to first	entry in jump table
 658:	032D  23      	NINT95:	INC	HL
 659:	032E  7E      		LD	A,(HL)		;hi byte jump table entry
 660:	032F  82      		ADD	A,D		;plus bias
 661:	0330  77      		LD	(HL),A		;replace in table
 662:	0331  23      		INC	HL
 663:	0332  1D      		DEC	E
 664:	0333  20F8    		JR	NZ,NINT95	;nz - more table entries to relocate
 665:			
 666:			
 667:			;******************************************************************************
 668:			;*
 669:			;*	ZSYM:	Symbol table build from	.sym and .prn files
 670:			;*
 671:			;*	LFCB called to parse the input buffer (inbf) in low memory.
 672:			;*	INBF contains the command line tail which bdos passed to us at
 673:			;*	80h and which we have since moved to inbf (so that prsr thinks
 674:			;*	it's just keyboard input).
 675:			;*
 676:			;*	All valid file names are opened for input.
 677:			;*
 678:			;*	If the file name terminates with a comma then we assume	the
 679:			;*	user is	specifying a bias which	is to be added to every	symbol
 680:			;*	loaded from the	file.
 681:			;*
 682:			;*	zsym	general	file handiling
 683:			;*	.sym	load L80 .sym file or load SLR .lst file
 684:			;*	.prn	load M80 .prn file or load SLR .prn file
 685:			;*
 686:			;*	Symbol table always begins on an 8 or 16 byte boundary
 687:			;*	depending on the value in maxlen.
 688:			;*
 689:			;******************************************************************************
 690:			
 691:	0335  CD251E  	ZSYM:	CALL	LFCB		;Initialize fcb
 692:	0338  C29008  		JP	NZ,ZSTX		;nz - error
 693:	033B  11C129  		LD	DE,MLDG		;Display loading message
 694:	033E  CD7028  		CALL	NPRINT		;Output	crlf - then print
 695:	0341  112930  		LD	DE,PRSBF
 696:	0344  CD7328  		CALL	PRINT		;Display file name
 697:	0347  79      		LD	A,C 		;lfcb returns delimeter in c reg
 698:	0348  32F42E  		LD	(DELIM),A	;Temp save delimiter so we know if a bias has
 699:							;been specified
 700:	034B  CD1026  		CALL	CRLF
 701:	034E  CD8C1E  		CALL	LOPN		;Try to	open symbol table file
 702:	0351  3D      		DEC	A		;
 703:	0352  FAAF08  		JP	M,ZFNF		;m - file not found
 704:	0355  3AF42E  		LD	A,(DELIM)	;Check delimeter
 705:	0358  FE2C    		CP	','
 706:	035A  210000  		LD	HL,00
 707:	035D  2048    		JR	NZ,ZSYM10	;nz - no comma means no	symbol bias
 708:	035F  CD2B1A  		CALL	PRSR		;Let prsr extract symbol bias
 709:	0362  C2CE08  		JP	NZ,ZOFF		;Parse error - use bias	of 0000
 710:	0365  32F42E  		LD	(DELIM),A	;Save delimeter	which followed bias
 711:	0368  112930  		LD	DE,PRSBF
 712:	036B  210000  		LD	HL,00
 713:	036E  CDC418  		CALL	XVAL		;Evaluate bias
 714:	0371  2834    		JR	Z,ZSYM10	;z - numeric bias specified
 715:			
 716:							;User has specified a bias in the form
 717:							; of a symbol name
 718:	0373  2AE509  		LD	HL,(NTPA)	;Check bias specified by symbol	name
 719:	0376  3A062F  		LD	A,(MAXLEN)
 720:	0379  2F      		CPL
 721:	037A  5F      		LD	E,A
 722:	037B  16FF    		LD	D,0FFH		;Lower end of TPA by amount equal to
 723:							; the value of maxlen negated to insert
 724:							; jump to bdos
 725:	037D  19      		ADD	HL,DE
 726:	037E  3A0C2F  		LD	A,(CASE)	;Check case of symbol table
 727:	0381  A7      		AND	A
 728:	0382  CA9503  		JP	Z,ZSYM05	;z - symbol names are already in upper case
 729:	0385  112930  		LD	DE,PRSBF	;prsr stored symbol name here
 730:	0388  1A      	ZSYM00:	LD	A,(DE)
 731:	0389  A7      		AND	A
 732:	038A  CA9503  		JP	Z,ZSYM05	;z - end of label symbol name
 733:	038D  CDFE25  		CALL	ILCS		;Change each char in symbol name to lower case
 734:	0390  12      		LD	(DE),A
 735:	0391  13      		INC	DE		;Store converted character
 736:	0392  C38803  		JP	ZSYM00
 737:	0395  112930  	ZSYM05:	LD	DE,PRSBF
 738:	0398  CDCB19  		CALL	FSYM00		;Search	symbol table
 739:	039B  C2CE08  		JP	NZ,ZOFF		;nz - not found
 740:	039E  3A062F  		LD	A,(MAXLEN)
 741:	03A1  B5      		OR	L
 742:	03A2  6F      		LD	L,A
 743:	03A3  7E      		LD	A,(HL)		;Fetch hi order	address	associated
 744:							; with symbol
 745:	03A4  2B      		DEC	HL
 746:	03A5  6E      		LD	L,(HL)
 747:	03A6  67      		LD	H,A		;HL - symbol value
 748:	03A7  22E62E  	ZSYM10:	LD	(BIAS),HL	;Bias to add to	each symbol address
 749:	03AA  210000  		LD	HL,00
 750:	03AD  3AB62F  		LD	A,(FCBTYP)
 751:	03B0  ED4BE509		LD	BC,(NTPA)	;Current end of TPA
 752:	03B4  FE53    		CP	'S'		;Is this a .sym	file?
 753:	03B6  CAC803  		JP	Z,RFSYM		;RFSYM file loaded differently from RPRN
 754:	03B9  FE4C    		CP	'L'
 755:	03BB  C2BF04  		JP	NZ,RPRN		;If not RLST then must be RPRN
 756:	03BE  11F708  		LD	DE,RLSTXX	;Look for RLST string id string
 757:	03C1  ED533509		LD	(PSTRNG),DE	;Store pointer to string to find
 758:	03C5  CDDA08  		CALL	FSTRNG
 759:			
 760:							;BC - symbol table pointer
 761:			
 762:	03C8  3A062F  	RFSYM:	LD	A,(MAXLEN)	;Lower TPA address by 16 or 8
 763:	03CB  2F      		CPL
 764:	03CC  A1      		AND	C		;for storing next symbol and address
 765:	03CD  4F      		LD	C,A
 766:	03CE  3A062F  		LD	A,(MAXLEN)
 767:	03D1  2F      		CPL			;This is negate plus one
 768:	03D2  81      		ADD	A,C
 769:	03D3  4F      		LD	C,A
 770:	03D4  DAD803  		JP	C,RFSYM00	;Treat carry as complement of subtraction
 771:	03D7  05      		DEC	B
 772:	03D8          	RFSYM00:
 773:	03D8  EB      		EX	DE,HL
 774:	03D9  21A530  		LD	HL,STACK+8	;Check for monster symbol table	ready to eat us
 775:	03DC  A7      		AND	A
 776:	03DD  ED42    		SBC	HL,BC
 777:	03DF  D2B808  		JP	NC,ZMEM		;End symbol load before	stack is clobbered
 778:	03E2  EB      		EX	DE,HL
 779:	03E3  3A062F  		LD	A,(MAXLEN)	;Load symbol length mask (7 or 15)
 780:	03E6  3D      		DEC	A		;
 781:	03E7  57      		LD	D,A		;D - actual max length of symbols (6 or 14)
 782:	03E8  AF      		XOR	A
 783:	03E9  02      	RFSYM10:	LD	(BC),A		;Init symbol table entry to nulls
 784:	03EA  03      		INC	BC
 785:	03EB  15      		DEC	D
 786:	03EC  20FB    		JR	NZ,RFSYM10
 787:	03EE  5A      		LD	E,D		;Clear DE for hex00
 788:	03EF  AF      		XOR	A
 789:	03F0  323909  		LD	(STAR),A	;Clear ** found flag
 790:	03F3  3E04    		LD	A,4		;Convert four bytes of address
 791:	03F5  32E709  		LD	(BYTES),A
 792:	03F8  CDFA07  	RFSYM20:	CALL	NCHR		;Fetch next character in file
 793:	03FB  FE1A    		CP	EOF
 794:	03FD  CA8306  		JP	Z,FEOF		;End of this symbol file
 795:	0400  FE30    		CP	'0'
 796:	0402  3051    		JR	NC,RFSYM25	;c -  must be control character or space
 797:							;nc - possible first char of address
 798:	0404  FE0A    		CP	LF
 799:	0406  CA1404  		JP	Z,RFSYM21
 800:	0409  FE2A    		CP	'*'		;** in slr .sym file?
 801:	040B  C2F803  		JP	NZ,RFSYM20
 802:	040E  323909  		LD	(STAR),A
 803:	0411  C35504  		JP	RFSYM25
 804:			
 805:	0414          	RFSYM21:
 806:	0414  CDFA07  		CALL	NCHR		;Fetch char following lf
 807:	0417  FE0D    		CP	CR
 808:	0419  CA3104  		JP	Z,RFSYM22	;z - consecutive crlf's means end of page
 809:	041C  FE30    		CP	'0'
 810:	041E  D25504  		JP	NC,RFSYM25	;nc - symbol address on new line
 811:	0421  FE1A    		CP	EOF
 812:	0423  CA8306  		JP	Z,FEOF
 813:	0426  FE2A    		CP	'*'		;** ?
 814:	0428  C2F803  		JP	NZ,RFSYM20
 815:	042B  323909  		LD	(STAR),A
 816:	042E  C35504  		JP	RFSYM25
 817:			
 818:	0431          	RFSYM22:
 819:	0431  3AB62F  		LD	A,(FCBTYP)
 820:	0434  FE4C    		CP	'L'		;z80asm RLST file?
 821:	0436  CA3E04  		JP	Z,RFSYM23
 822:	0439  FE50    		CP	'P'		;macro 80 v3.4?
 823:	043B  C2F803  		JP	NZ,RFSYM20
 824:	043E          	RFSYM23:
 825:	043E  11F708  		LD	DE,RLSTXX	;Bypass inter-page verbiage
 826:	0441  ED533509		LD	(PSTRNG),DE
 827:	0445  CDDA08  		CALL	FSTRNG
 828:	0448  FE1A    		CP	EOF
 829:	044A  CA8306  		JP	Z,FEOF
 830:			
 831:	044D  CDFA07  		CALL	NCHR
 832:	0450  FE1A    		CP	EOF
 833:	0452  CA8306  		JP	Z,FEOF
 834:			
 835:			
 836:	0455  CD3508  	RFSYM25:	CALL	HEX00		;Have first char of address - convert
 837:	0458  CD8008  		CALL	TOTSYM		;Bump total of symbols loaded
 838:	045B  3AB62F  		LD	A,(FCBTYP)	;Is this a RFSYM file?
 839:	045E  FE53    		CP	'S'
 840:	0460  C4FA07  		CALL	NZ,NCHR		;Eat addrress/symbol separator for RLST file
 841:	0463  3A062F  		LD	A,(MAXLEN)
 842:	0466  3D      		DEC	A
 843:	0467  32E709  		LD	(BYTES),A	;Init max symbol length counter
 844:	046A  CDFA07  	RFSYM30:	CALL	NCHR		;Read symbol name char
 845:	046D  FE09    		CP	TAB
 846:	046F  CAA204  		JP	Z,RFSYM45
 847:	0472  FE0D    		CP	CR
 848:	0474  CAA204  		JP	Z,RFSYM45
 849:	0477  FE20    		CP	' '
 850:	0479  CAA204  		JP	Z,RFSYM45
 851:	047C  02      		LD	(BC),A
 852:	047D  3A0C2F  	        LD	A,(CASE)        ;Check user requested case
 853:	0480  A7      		AND	A
 854:	0481  280D    		JR	Z,RFSYM35	;z - upper case	requested by user
 855:	0483  0A      		LD	A,(BC)		;Recover char
 856:	0484  FE41    		CP	'A'
 857:	0486  3808    		JR	C,RFSYM35	;c - must be number
 858:	0488  FE5B    		CP	'Z'+1
 859:	048A  D29004  		JP	NC,RFSYM35
 860:	048D  F620    		OR	20H
 861:	048F  02      		LD	(BC),A          ;Restore symbol name char as lower case
 862:	0490  03      	RFSYM35:	INC	BC
 863:	0491  3AE709  		LD	A,(BYTES)
 864:	0494  3D      		DEC	A
 865:	0495  32E709  		LD	(BYTES),A
 866:	0498  20D0    		JR	NZ,RFSYM30
 867:	049A  CDFA07  	RFSYM40:	CALL	NCHR
 868:	049D  FE21    		CP	21H
 869:	049F  D29A04  		JP	NC,RFSYM40
 870:	04A2  3A3909  	RFSYM45:	LD	A,(STAR)	;Check if this was ** in address field
 871:	04A5  A7      		AND	A
 872:	04A6  C2B604  		JP	NZ,RFSYM50
 873:	04A9  3A3709  		LD	A,(RELCHR)	;Check for external symbol
 874:	04AC  FE20    		CP	' '
 875:	04AE  CAC803  		JP	Z,RFSYM		;Space means absolute
 876:	04B1  FE27    		CP	QUOTE
 877:	04B3  CAC803  		JP	Z,RFSYM		;Quote means relocatable
 878:	04B6  3A062F  	RFSYM50:	LD	A,(MAXLEN)
 879:	04B9  B1      		OR	C
 880:	04BA  4F      		LD	C,A
 881:	04BB  03      		INC	BC		;Point BC to next higher symbol block so
 882:							;that rewinding by maxlen bytes will actually
 883:							;overlay this symbol.  This ensures that
 884:							;external symbols are not kept in table.
 885:			
 886:	04BC  C3C803  		JP RFSYM
 887:			
 888:			
 889:	04BF          	RPRN:				;Don't yet know if this .prn file was
 890:							;generated by M80 or Z80ASM.  To find out
 891:							;I pull a dirty trick.  I force a read
 892:							;and look for a formfeed, up to 80 characters
 893:							;of program title, a HT and "MACRO-80" in the
 894:							;I/O buffer, then I reset the pointer so that
 895:							;the next character read comes from the
 896:							;beginning of the file.  Will probably get
 897:							;confused by a HT in the program title.
 898:							;  jrs 14/11/88, 22/12/88.
 899:			
 900:	04BF  CDFA07  		CALL	NCHR		;Force a read.  First byte of file is
 901:							; returned in A, pointer to next byte in HL
 902:	04C2  FE0C    		CP	FORMF		;Test character
 903:	04C4  2017    		JR	NZ,RPRNBB	;Exit M80 testing now if not a formfeed
 904:	04C6  0652    		LD	B,82		;Maximum number of characters to search
 905:	04C8  3E09    		LD	A,TAB		;What to look for
 906:	04CA  EDB1    		CPIR
 907:	04CC  200F    		JR	NZ,RPRNBB	;If no tab then not an M80 .prn file
 908:	04CE  EB      		EX	DE,HL		;Point at strings to be compared
 909:	04CF  212809  		LD	HL,RM80XX
 910:	04D2  46      		LD	B,(HL)		;Number of bytes to compare
 911:	04D3  23      		INC	HL
 912:	04D4          	RPRNAA:
 913:	04D4  1A      		LD	A,(DE)		;Compare bytes
 914:	04D5  BE      		CP	(HL)
 915:	04D6  C2DD04  		JP	NZ,RPRNBB	;Exit loop if different
 916:	04D9  23      		INC	HL		; otherwise step the pointers
 917:	04DA  13      		INC	DE
 918:	04DB  10F7    		DJNZ	RPRNAA		;Loop until difference encountered or
 919:	04DD          	RPRNBB:				; all bytes compared.
 920:	04DD  218000  		LD	HL,IOBUF	;Reset buffer pointer
 921:	04E0  ED4BE509		LD	BC,(NTPA)
 922:	04E4  C26B06  		JP	NZ,RSLR		;If not M80 then do Z80ASM .prn file load
 923:			
 924:				; End of dirty trick code
 925:			
 926:	04E7  110909  		LD	DE,RPRNXX
 927:	04EA  ED533509		LD	(PSTRNG),DE
 928:	04EE  CDDA08  		CALL	FSTRNG
 929:	04F1  FE1A    		CP	EOF
 930:	04F3  C2FF04  		JP	NZ,RPRN00
 931:	04F6          	RPRNCC:
 932:	04F6  117009  		LD	DE,MSYMNF       ;display symbol table not found message
 933:	04F9  CD7328  		CALL	PRINT
 934:	04FC  C3E906  		JP	FEOF50          ;check for more symbol files to load
 935:			
 936:	04FF          	RPRN00:
 937:	04FF  ED4BE509		LD	BC,(NTPA)       ;bc - current end of the tpa
 938:	0503  0B      		DEC	BC              ;this points us into the next lower
 939:			                                ;symbol table block
 940:							;this is first char of symbol table
 941:	0504  AF      		XOR	A
 942:	0505  B5      		OR	L		;get next byte from file but without bumping
 943:							;pointer allowing us to reread same char (in
 944:							;case it is last character in buffer
 945:			
 946:	0506  CC0208  		CALL	Z,ZDREAD		;only do true read if last character was last
 947:							;in buffer
 948:	0509  7E      		LD	A,(HL)
 949:	050A  FE30    		CP	'0'
 950:	050C  DA1405  		JP	C,RPR325	;non-numeric: macro-80 v3.44
 951:			
 952:	050F  FE3A    		CP	'9'+1
 953:	0511  DABC05  		JP	C,RPR4		;numeric:     macro-80 v3.4
 954:			
 955:			
 956:			;Macro-80 v3.4 dec 1980 symbol table load
 957:			
 958:	0514  3A062F  	RPR325:	LD	A,(MAXLEN)
 959:	0517  2F      		CPL
 960:	0518  A1      		AND	C               ;now rewind within 8 or 16 byte block
 961:							;(depending on maxlen) in order to point
 962:							;to first byte
 963:	0519  4F      		LD	C,A
 964:			
 965:	051A  EB      	        EX	DE,HL           ;de - save file buffer pointer
 966:	051B  21AD30  		LD	HL,STACK + 16   ;check for encroaching symbol table
 967:	051E  ED42    		SBC	HL,BC           ;versus current symbol table address
 968:	0520  D2B808  		JP	NC,ZMEM         ;nc - out of memory
 969:	0523  EB      		EX	DE,HL           ;return file buffer pointer
 970:	0524  3A062F  		LD	A,(MAXLEN)
 971:	0527  57      		LD	D,A
 972:	0528  15      		DEC	D		;d - symbol name length
 973:	0529  AF      		XOR	A
 974:	052A  5F      		LD	E,A
 975:	052B  02      	RPR330:	LD	(BC),A          ;pre-clear name portion of symbol table to
 976:			                                ;nulls
 977:	052C  03      		INC	BC
 978:	052D  15      		DEC	D               ;now any name less than maxlen chars in length
 979:	052E  C22B05  		JP	NZ,RPR330       ;is terminated with a null
 980:	0531  3A062F  		LD	A,(MAXLEN)
 981:	0534  2F      		CPL
 982:	0535  A1      		AND	C
 983:	0536  4F      		LD	C,A
 984:	0537  CDFA07  	RPR335:	CALL	NCHR            ;next char from file buffer
 985:	053A  FE21    		CP	21H
 986:	053C  D28205  		JP	NC,RPR351	;nc - this is first character of symbol name
 987:	053F  FE1A    		CP	EOF		;end of	file?
 988:	0541  CA8306  		JP	Z,FEOF
 989:	0544  FE0A    		CP	LF		;line feed?
 990:	0546  C23705  		JP	NZ,RPR335
 991:	0549  CDFA07  	RPR340:	CALL	NCHR		;get character following line feed
 992:	054C  FE0D    		CP	CR
 993:	054E  CA5605  		JP	Z,RPR342
 994:	0551  FE0C    		CP	FORMF		;form feed?
 995:	0553  C28205  		JP	NZ,RPR351
 996:	0556  1E03    	RPR342:	LD	E,3		;symbols resume	three lines hence following
 997:							;a form feed character - so count linefeeds
 998:	0558  FE0D    		CP	CR		;did we find cr or a formf?
 999:	055A  C25E05  		JP	NZ,RPR345	;nz - formf
1000:	055D  1D      		DEC	E		;just look for two lf's
1001:	055E  CDFA07  	RPR345:	CALL	NCHR
1002:	0561  FE0A    		CP	LF
1003:	0563  C25E05  		JP	NZ,RPR345	;loop til three found
1004:	0566  1D      		DEC	E
1005:	0567  C25E05  		JP	NZ,RPR345
1006:			
1007:	056A  AF      		XOR	A
1008:	056B  B5      		OR	L		;get next byte from file but without bumping
1009:							;pointer allowing us to reread same char in
1010:							;case it is last character in buffer
1011:			
1012:	056C  CC0208  		CALL	Z,ZDREAD		;only do true read if last character was last
1013:							;in buffer
1014:	056F  7E      		LD	A,(HL)
1015:	0570  FE0D    		CP	CR		;four crlf's is eof
1016:	0572  CA8306  		JP	Z,FEOF
1017:			
1018:	0575  CDFA07  	RPR350:	CALL	NCHR            ;next char from file
1019:	0578  FE1A    		CP	EOF
1020:	057A  CA8306  		JP	Z,FEOF
1021:	057D  FE09    		CP	TAB
1022:	057F  CA9905  		JP	Z,RPR355
1023:	0582  02      	RPR351:	LD	(BC),A		;move character	of symbol name
1024:	0583  3A0C2F  		LD	A,(CASE)        ;check user requested case
1025:	0586  A7      		AND	A
1026:	0587  280C    		JR	Z,RPR352        ;z - user wants upper case
1027:	0589  0A      		LD	A,(BC)          ;get char back from symbol table
1028:	058A  FE41    		CP	'A'
1029:	058C  3807    		JR	C,RPR352        ;must be numeric - no case here
1030:	058E  FE5B    		CP	'Z'+1
1031:	0590  3003    		JR	NC,RPR352
1032:	0592  C620    		ADD	A,20H
1033:	0594  02      		LD	(BC),A          ;replace char with lower case equivalent
1034:	0595  03      	RPR352:	INC	BC
1035:	0596  C37505  		JP	RPR350
1036:			
1037:	0599  3E04    	RPR355:	LD	A,4
1038:	059B  32E709  		LD	(BYTES),A
1039:	059E  CDFA07  	RPR357:	CALL	NCHR
1040:	05A1  FE20    		CP	' '
1041:	05A3  CA9E05  		JP	Z,RPR357
1042:			
1043:	05A6  CD3508  		CALL	HEX00           ;now read the next four characters from the
1044:							;file and convert them to a hex address -
1045:							;store in symbol table entry
1046:			
1047:			
1048:	05A9  3A3709  		LD	A,(RELCHR)      ;recover char which followed address
1049:			
1050:	05AC  FE20    		CP	' '             ;this char followed address
1051:	05AE  2805    		JR	Z,RPR370        ;microsoft absolute address
1052:	05B0  FE27    		CP	QUOTE           ;relocatable address?
1053:	05B2  C21405  		JP	NZ,RPR325
1054:			                                ;by not rewinding the symbol table pointer
1055:			                                ;the next symbol will overlay this one.
1056:			
1057:	05B5  0B      	RPR370:	DEC	BC
1058:	05B6  CD8008  		CALL	TOTSYM
1059:			
1060:	05B9  C31405  		JP	RPR325
1061:			
1062:			
1063:			;macro-80 v3.44 symbol loading routine
1064:			
1065:	05BC  3A062F  	RPR4:	LD	A,(MAXLEN)	;lower tpa address by maxlen
1066:	05BF  2F      		CPL
1067:	05C0  A1      		AND	C		;for storing next symbol and address
1068:	05C1  4F      		LD	C,A		;bc - next address of symbol table entry
1069:							;     on an 8 or 16 byte boundary
1070:	05C2  EB      		EX	DE,HL
1071:	05C3  21A530  		LD	HL,STACK+8	;check for monster symbol table
1072:	05C6  A7      		AND	A
1073:	05C7  ED42    		SBC	HL,BC
1074:	05C9  D2B808  		JP	NC,ZMEM		;end symbol load before	stack is clobbered
1075:	05CC  EB      		EX	DE,HL
1076:	05CD  3A062F  		LD	A,(MAXLEN)
1077:	05D0  3D      		DEC	A		;pre-clear symbol table entry with nulls
1078:	05D1  57      		LD	D,A
1079:	05D2  AF      		XOR	A
1080:	05D3  02      	RPR410:	LD	(BC),A		;for length equal to maxlen
1081:	05D4  03      		INC	BC
1082:	05D5  15      		DEC	D
1083:	05D6  20FB    		JR	NZ,RPR410
1084:	05D8  5A      		LD	E,D		;clear de for hex00
1085:	05D9  3E04    		LD	A,4		;convert four bytes of address
1086:	05DB  32E709  		LD	(BYTES),A
1087:	05DE  CDFA07  	RPR420:	CALL	NCHR		;fetch next character in file
1088:	05E1  FE1A    		CP	EOF
1089:	05E3  CA8306  		JP	Z,FEOF
1090:	05E6  FE30    		CP	'0'
1091:	05E8  3028    		JR	NC,RPR425	;nc - address digit
1092:	05EA  FE0A    		CP	LF
1093:	05EC  C2DE05  		JP	NZ,RPR420	;nz - leading space or cr
1094:			
1095:			
1096:	05EF  CDFA07  		CALL	NCHR		;check character following lf
1097:	05F2  FE0D    		CP	CR
1098:	05F4  CA8306  		JP	Z,FEOF		;blank line is eof
1099:			
1100:	05F7  FE0C    		CP	FORMF		;form feed?
1101:	05F9  C21206  		JP	NZ,RPR425	;no - first character of next address
1102:			
1103:	05FC  1E03    		LD	E,3		;must be form feed
1104:	05FE  CDFA07  	RPR421:	CALL	NCHR
1105:	0601  FE0A    		CP	LF		;three lf's follow form feed before symbols
1106:							;resume on next page
1107:	0603  C2FE05  		JP	NZ,RPR421
1108:	0606  1D      		DEC	E
1109:	0607  C2FE05  		JP	NZ,RPR421
1110:			
1111:	060A  CDFA07  		CALL	NCHR
1112:	060D  FE1A    		CP	EOF
1113:	060F  CA8306  		JP	Z,FEOF
1114:			
1115:	0612          	RPR425:
1116:	0612  CD3508  		CALL	HEX00		;have first char of address - convert
1117:			
1118:	0615  CDFA07  		CALL	NCHR		;eat address/symbol separator
1119:			
1120:	0618  3A062F  		LD	A,(MAXLEN)
1121:	061B  3D      		DEC	A
1122:	061C  32E709  		LD	(BYTES),A	;max chars to store in symbol table
1123:			
1124:			
1125:	061F  CDFA07  	RPR430:	CALL	NCHR		;read symbol name char
1126:	0622  FE21    		CP	21H
1127:	0624  DA5206  		JP	C,RPR440	;found separator
1128:	0627  02      		LD	(BC),A
1129:	0628  3A0C2F  	        LD	A,(CASE)        ;check user requested case
1130:	062B  A7      		AND	A
1131:	062C  280C    		JR	Z,RPR435	;c - upper case	requested by user
1132:	062E  0A      		LD	A,(BC)		;recover char
1133:	062F  FE41    		CP	'A'
1134:	0631  3807    		JR	C,RPR435	;c - must be number
1135:	0633  FE5B    		CP	'Z'+1
1136:	0635  3003    		JR	NC,RPR435
1137:	0637  F620    		OR	20H
1138:	0639  02      		LD	(BC),A          ;restore symbol name char as lower case
1139:	063A  03      	RPR435:	INC	BC              ;bump symbol table pointer
1140:	063B  3AE709  		LD	A,(BYTES)	;character counter
1141:	063E  3D      		DEC	A
1142:	063F  32E709  		LD	(BYTES),A
1143:	0642  C21F06  		JP	NZ,RPR430	;not max length
1144:			
1145:			
1146:	0645  CDFA07  	RPR438:	CALL	NCHR		;eat chars until next address found
1147:	0648  FE1A    		CP	EOF
1148:	064A  CA8306  		JP	Z,FEOF
1149:	064D  FE20    		CP	' '		;found symbol/address
1150:	064F  C24506  		JP	NZ,RPR438
1151:			
1152:			
1153:	0652  3A062F  	RPR440:	LD	A,(MAXLEN)
1154:	0655  2F      		CPL
1155:	0656  A1      		AND	C
1156:	0657  4F      		LD	C,A
1157:			
1158:	0658  3A3709  		LD	A,(RELCHR)      ;recover char which followed address
1159:	065B  FE20    		CP	' '             ;this char followed address
1160:	065D  2805    		JR	Z,RPR450        ;microsoft absolute address
1161:	065F  FE27    		CP	QUOTE           ;relocatable address?
1162:	0661  C2BC05  		JP	NZ,RPR4	        ;nz - must be  external symbol. we don't
1163:			                                ;actually load them or count them in total.
1164:			                                ;by not rewinding the symbol table pointer
1165:			                                ;the next symbol will overlay this one.
1166:			
1167:	0664  0B      	RPR450:	DEC	BC
1168:	0665  CD8008  		CALL	TOTSYM
1169:	0668  C3BC05  		JP	RPR4
1170:			
1171:			; SLR Z80ASM symbol table loading routines
1172:			
1173:	066B          	RSLR:
1174:	066B  111409  		LD	DE,RSLRXX	;If this .prn file really is a Z80ASM
1175:	066E  ED533509		LD	(PSTRNG),DE	;product then we can use existing code
1176:	0672  CDDA08  		CALL	FSTRNG		;to load the symbols.
1177:	0675  FE1A    		CP	EOF
1178:	0677  C2C803  		JP	NZ,RFSYM
1179:	067A  117009  		LD	DE,MSYMNF       ;display symbol table not found message
1180:	067D  CD7328  		CALL	PRINT
1181:	0680  C3E906  		JP	FEOF50          ;check for more symbol files to load
1182:			
1183:			
1184:	0683          	FEOF:                           ;We always pre-decrement the symbol table
1185:			                                ;pointer in anticipation of storing the next
1186:			                                ;symbol.  Now that we hit the end of a symbol
1187:			                                ;table we must adjust the pointer in
1188:			                                ;preparation for loading the symbols from the
1189:			                                ;next file (if there is one).
1190:	0683  3A062F  	        LD	A,(MAXLEN)
1191:	0686  6F      		LD	L,A
1192:	0687  2600    		LD	H,0
1193:	0689  2C      		INC	L
1194:	068A  09      		ADD	HL,BC           ;point to last loaded symbol
1195:	068B  44      		LD	B,H
1196:	068C  4D      		LD	C,L             ;bc - spare copy
1197:	068D  2F      		CPL
1198:	068E  A1      		AND	C
1199:	068F  4F      		LD	C,A
1200:	0690  ED43E509		LD	(NTPA),BC       ;save current end of tpa address
1201:	0694  3A3A09  	        LD	A,(NSYMHI)      ;hi order number of symbols loaded (bcd)
1202:	0697  CD1F08  		CALL	HEXC            ;convert to ascii
1203:	069A  67      		LD	H,A             ;returned in a - move to h (other digit in l)
1204:	069B  223C09  		LD	(MHEX),HL       ;store in message
1205:	069E  3A3B09  		LD	A,(NSYMLO)
1206:	06A1  CD1F08  		CALL	HEXC            ;convert lo order
1207:	06A4  67      		LD	H,A
1208:	06A5  223E09  		LD	(MHEX+2),HL
1209:	06A8  114109  		LD	DE,MSYMBB       ;display number of symbols loaded message
1210:	06AB  0E09    		LD	C,9
1211:	06AD  CD0500  		CALL	BDOS
1212:	06B0  113C09  		LD	DE,MHEX         ;now look thru ascii number of symbols to
1213:			                                ;strip leading zeros
1214:	06B3  0603    		LD	B,3
1215:	06B5  1A      	FEOF10:	LD	A,(DE)
1216:	06B6  FE30    		CP	'0'
1217:	06B8  2003    		JR	NZ,FEOF20       ;nz - found first non-zero
1218:	06BA  13      		INC	DE
1219:	06BB  10F8    		DJNZ	FEOF10          ;if first three chars zero - fall thru and
1220:			                                ;print the fourth regardless
1221:	06BD  0E09    	FEOF20: LD      C,09
1222:	06BF  CD0500  		CALL	BDOS            ;print the number as string ending with $
1223:	06C2  CD1026  		CALL	CRLF
1224:	06C5  2A3109  		LD	HL,(TSYM)       ;now add in bcd total for this file to bcd
1225:			                                ;total for all files
1226:	06C8  ED5B3A09		LD	DE,(NSYM)       ;tsym - total for all files
1227:			                                ;nsym - total for this file
1228:	06CC  7C      		LD	A,H
1229:	06CD  82      		ADD	A,D
1230:	06CE  27      		DAA
1231:	06CF  67      		LD	H,A
1232:	06D0  7D      		LD	A,L
1233:	06D1  8B      		ADC	A,E
1234:	06D2  27      		DAA
1235:	06D3  6F      		LD	L,A
1236:	06D4  223109  		LD	(TSYM),HL
1237:	06D7  210000  		LD	HL,00           ;clear out total for next file
1238:	06DA  223A09  		LD	(NSYM),HL
1239:	06DD  2AE309  		LD	HL,(Z8EB)
1240:	06E0  11D722  		LD	DE,SYMFLG-Z8EORG
1241:	06E3  19      		ADD	HL,DE           ;hl - pointer to symbol flag in hi memory
1242:	06E4  AF      		XOR	A
1243:	06E5  77      		LD	(HL),A		;zero -	symbol table present
1244:	06E6  32D72E  		LD	(SYMFLG),A      ;also set flag in lo memory where we are
1245:			                                ;currently so that fsym knows theres a symbol
1246:			                                ;table to search thru if the user specified a
1247:			                                ;symbol name bias as part of the command line
1248:			
1249:	06E9  3AF42E  	FEOF50:	LD	A,(DELIM)       ;check command line delimter
1250:	06EC  A7      		AND	A               ;test for end of line null
1251:	06ED  C23503  		JP	NZ,ZSYM         ;nz - not null means more files
1252:			
1253:			
1254:			
1255:			
1256:	06F0  2AE509  	LOAD:	LD	HL,(NTPA)	;current end of	memory
1257:	06F3  3AD72E  		LD	A,(SYMFLG)	;check for symbol table
1258:	06F6  A7      		AND	A
1259:	06F7  2008    		JR	NZ,LOAD00	;nz - no symbol	table
1260:	06F9  57      		LD	D,A
1261:	06FA  3A062F  		LD	A,(MAXLEN)
1262:	06FD  5F      		LD	E,A		;de - length of a symbol table block
1263:	06FE  1C      		INC	E
1264:	06FF  ED52    		SBC	HL,DE		;compensate for	pre-increment of pointer
1265:	0701  ED5B0600	LOAD00:	LD	DE,(06)		;de - real entry point to bdos
1266:	0705  220600  		LD	(06),HL		;point to our origin in	hi memory
1267:	0708  36C3    		LD	(HL),IJP		;init jump to bdos at start of z8e
1268:	070A  23      		INC	HL
1269:	070B  73      		LD	(HL),E
1270:	070C  23      		INC	HL
1271:	070D  72      		LD	(HL),D
1272:	070E  1E00    		LD	E,0		;de - old start of bdos address in also our
1273:			                                ;ending address
1274:	0710  2AE309  		LD	HL,(Z8EB)       ;load out starting address in hi memory
1275:	0713  011000  		LD	BC,Z8E-Z8EORG   ;fetch the number of bytes between z8e's base
1276:			                                ;address and the entry point of the command
1277:			                                ;processor  - internal symbol table size
1278:			
1279:	0716  09      		ADD	HL,BC
1280:	0717  44      		LD	B,H
1281:	0718  4D      		LD	C,L		;BC - relocated	z8e address
1282:	0719  EB      		EX	DE,HL           ;DE - entry point z8e   HL - old start of bdos
1283:	071A  2B      		DEC	HL              ;HL - last byte in our memory
1284:	071B  70      		LD	(HL),B
1285:	071C  2B      		DEC	HL
1286:	071D  71      		LD	(HL),C		;z8e (monitor entry point) on stack
1287:	071E  F9      		LD	SP,HL           ;now set current stack to just below our
1288:			                                ;return address
1289:	071F  EB      		EX	DE,HL           ;hl - relocated address z8e
1290:	0720  23      		INC	HL
1291:	0721  23      		INC	HL              ;hl - points to ld  sp,0000 instruction at the
1292:			                                ;start of the command processor. replace 0000
1293:			                                ;with the address bdos-1
1294:	0722  73      		LD	(HL),E          ;set real stack address
1295:	0723  23      		INC	HL
1296:	0724  72      		LD	(HL),D
1297:	0725  2AE309  		LD	HL,(Z8EB)	;base of relocated code
1298:	0728  11AD23  		LD	DE,FCB-Z8EORG	;relative offset from start of monitor
1299:	072B  19      		ADD	HL,DE
1300:	072C  EB      		EX	DE,HL		;de - fcb address in relocated monitor in hi
1301:			                                ;memory
1302:	072D  21E809  		LD	HL,ZBUF		;
1303:	0730  011000  		LD	BC,16
1304:	0733  EDB0    		LDIR			;init fcb with saved file name
1305:	0735  11BB09  		LD	DE,MZ8ELD	;print memory space occupied by	z8e
1306:	0738  CD7328  		CALL	PRINT
1307:	073B  2AE309  		LD	HL,(Z8EB)       ;display our base address in upper memory
1308:	073E  CD3926  		CALL	OUTADR
1309:	0741  3E2D    		LD	A,'-'
1310:	0743  CDB225  		CALL	TTYO
1311:	0746  CD2226  		CALL 	RSPACE
1312:	0749  CD2226  		CALL	RSPACE
1313:	074C  2A0600  		LD	HL,(06)         ;this points to the new jump to bdos
1314:	074F  23      		INC	HL
1315:	0750  5E      		LD	E,(HL)          ;de - old start of bdos address
1316:	0751  23      		INC	HL
1317:	0752  56      		LD	D,(HL)
1318:	0753  EB      		EX	DE,HL
1319:	0754  2E00    		LD	L,0             ;256 byte boundary to bypass cp/m serial no.
1320:	0756  CD3926  		CALL	OUTADR
1321:			
1322:	0759  3AD72E  		LD	A,(SYMFLG)      ;test for presence of symbol table
1323:	075C  A7      		AND	A
1324:	075D  204C    		JR	NZ,LOAD40       ;nz - no table
1325:	075F  11A709  		LD	DE,MSYMLD       ;display start address of symbol table message
1326:	0762  CD7328  		CALL	PRINT
1327:	0765  2A0600  		LD	HL,(06)         ;vector to bdos is start of symbol table
1328:	0768  CD3926  		CALL	OUTADR
1329:	076B  3E2D    		LD	A,'-'
1330:	076D  CDB225  		CALL	TTYO
1331:	0770  CD2226  		CALL	RSPACE
1332:	0773  CD2226  		CALL	RSPACE
1333:	0776  2AE309  		LD	HL,(Z8EB)       ;start of internal symbol table is end of
1334:			                                ;symbol table built from files
1335:	0779  2B      		DEC	HL
1336:	077A  CD3926  		CALL	OUTADR
1337:			
1338:	077D  3A3109  		LD	A,(TSYMHI)      ;total number of symbols from all files (bcd)
1339:	0780  CD1F08  		CALL	HEXC            ;convert to ascii
1340:	0783  67      		LD	H,A             ;move hi order ascii digit to h
1341:	0784  223C09  		LD	(MHEX),HL       ;store double ascii digit
1342:	0787  3A3209  		LD	A,(TSYMLO)
1343:	078A  CD1F08  		CALL	HEXC            ;convert lo order
1344:	078D  67      		LD	H,A
1345:	078E  223E09  		LD	(MHEX+2),HL     ;save in string
1346:	0791  115C09  		LD	DE,TSYMBB       ;total symbols message
1347:	0794  0E09    		LD	C,9
1348:	0796  CD0500  		CALL	BDOS
1349:	0799  113C09  		LD	DE,MHEX         ;address of ascii digits
1350:	079C  0603    		LD	B,3             ;check for leading zeros
1351:	079E  1A      	LOAD20:	LD	A,(DE)
1352:	079F  FE30    		CP	'0'
1353:	07A1  2003    		JR	NZ,LOAD30       ;nz - found first nz in string
1354:	07A3  13      		INC	DE
1355:	07A4  10F8    		DJNZ	LOAD20          ;check first three digits then fall thru and
1356:			                                ;print fourth regardless
1357:	07A6  0E09    	LOAD30:	LD	C,09
1358:	07A8  CD0500  		CALL	BDOS
1359:			
1360:	07AB  2A0600  	LOAD40:	LD	HL,(06)
1361:	07AE  2B      		DEC	HL              ;hl - address of new tpa
1362:	07AF  11CF09  		LD	DE,MNVMEM       ;display address as memory available
1363:	07B2  CD7328  		CALL	PRINT
1364:	07B5  CD3926  		CALL	OUTADR
1365:	07B8  CD1026  		CALL	CRLF
1366:	07BB  3600    		LD	(HL),0          ;now store two zeros at the top of the tpa and
1367:			                                ;set stack pointer to this very same address.
1368:			                                ;this allows users to do a warm boot via ret
1369:			                                ;in the same way as if they had been loaded by
1370:			                                ;cp/m.
1371:	07BD  2B      		DEC	HL
1372:	07BE  3600    		LD	(HL),0
1373:	07C0  ED4BE309		LD	BC,(Z8EB)       ;our relocated address in hi memory
1374:	07C4  EB      		EX	DE,HL           ;de - last available location in tpa
1375:	07C5  218523  		LD	HL,SPREG-Z8EORG ;address (relative to the start of z8e) where
1376:			                                ;we store the user stack pointer address
1377:	07C8  09      		ADD	HL,BC           ;hl - pointer to
1378:	07C9  73      		LD	(HL),E          ;save user stack in spreg in hi memory
1379:	07CA  23      		INC	HL
1380:	07CB  72      		LD	(HL),D
1381:	07CC  211000  		LD	HL,Z8E-Z8EORG
1382:	07CF  3AE909  		LD	A,(ZBUFNM)	;first char of file name
1383:	07D2  FE20    		CP	' '             ;do we have a file to load?
1384:	07D4  2813    		JR	Z,LOAD50        ;z - no
1385:	07D6  11C129  		LD	DE,MLDG         ;display loading message and target file name
1386:	07D9  CD7028  		CALL	NPRINT
1387:	07DC  11F809  		LD	DE,ZNMBUF
1388:	07DF  CD7328  		CALL	PRINT
1389:			                                ;enter the monitor in hi memory at entry
1390:			                                ;point lldr10
1391:			
1392:	07E2  217911  		LD	HL,LLDR10-Z8EORG
1393:	07E5  ED4BE309		LD	BC,(Z8EB)
1394:	07E9  09      	LOAD50:	ADD	HL,BC           ;hl - actual address of lldr10 in hi memory
1395:	07EA  EB      		EX	DE,HL           ;now clear out the buffer at 80h so the user
1396:			                                ;program doesn't mistakenly think that our
1397:			                                ;command line tail is really his.
1398:	07EB  218000  		LD	HL,IOBUF
1399:	07EE  3600    		LD	(HL),0          ;set number of chars zero (80h)
1400:	07F0  23      		INC	HL
1401:	07F1  067F    		LD	B,127           ;clear until start of tpa
1402:	07F3  3620    	LOAD60:	LD	(HL),' '
1403:	07F5  23      		INC	HL
1404:	07F6  10FB    		DJNZ	LOAD60
1405:	07F8  EB      		EX	DE,HL           ;lldr10 address back to HL
1406:	07F9  E9      		JP	(HL)            ;Hi-ho, hi-ho to the loader we must go
1407:			
1408:			
1409:			
1411:			;This routine reads one char from the disk I/O
1412:			;buffer returning it in A. Upon entry we check
1413:			;the low order buffer pointer - 0 means we hit
1414:			;the  256 boundary (end of buffer) and a  read
1415:			;is needed.
1416:			
1417:	07FA  AF      	NCHR:	XOR	A
1418:	07FB  B5      		OR	L
1419:	07FC  CC0208  		CALL	Z,ZDREAD
1420:	07FF  7E      		LD	A,(HL)
1421:	0800  23      		INC	HL
1422:	0801  C9      		RET
1423:			
1424:	0802  C5      	ZDREAD:	PUSH	BC
1425:	0803  D5      		PUSH	DE
1426:	0804  11AD2F  		LD	DE,FCB
1427:	0807  0E14    		LD	C,20            ;sequential file read
1428:	0809  CD0500  		CALL	BDOS
1429:	080C  A7      		AND	A               ;test for error
1430:	080D  218000  		LD	HL,IOBUF        ;assume ok - init i/o buffer address
1431:	0810  D1      		POP	DE
1432:	0811  C1      		POP	BC
1433:	0812  C8      		RET	Z               ;z - no errors
1434:	0813  117009  		LD	DE,MSYMNF       ;display symbol table not found message
1435:	0816  CD7328  		CALL	PRINT
1436:	0819  319D30  		LD	SP,STACK        ;reinit stack
1437:	081C  C3E906  		JP	FEOF50          ;check for more symbol files to load
1438:			
1439:			
1440:			;hexc
1441:			;Convert byte in a to two ASCII hex digits.
1442:			;return: a - converted hi order digit
1443:			;        l -           lo order digit
1444:			
1445:	081F  67      	HEXC:	LD	H,A
1446:	0820  0F      		RRCA
1447:	0821  0F      		RRCA
1448:	0822  0F      		RRCA
1449:	0823  0F      		RRCA
1450:	0824  CD2908  		CALL	HEXC00
1451:	0827  6F      		LD	L,A
1452:	0828  7C      		LD	A,H
1453:	0829  E60F    	HEXC00:	AND	0FH
1454:	082B  C690    		ADD	A,90H
1455:	082D  27      		DAA
1456:	082E  CE40    		ADC	A,40H
1457:	0830  27      		DAA
1458:	0831  C9      		RET
1459:			
1460:			
1461:			;hex:
1462:			;This routine is called by the symbol table
1463:			;building routines, .sym and .prn and its
1464:			;function is to convert ascii addresses
1465:			;into binary.  Since we are reading files in
1466:			;a known format we don't init any loop counts;
1467:			;instead, we look for delimeters.
1468:			
1469:			
1470:	0832  CDFA07  	HEX:	CALL	NCHR            ;get char from disk i/o buffer
1471:	0835  FE3A    	HEX00:	CP	3AH             ;convert ascii to hex
1472:	0837  DA3C08  		JP	C,HEX10         ;c - must be delimeter
1473:	083A  D607    		SUB	7
1474:	083C  D630    	HEX10:	SUB	'0'
1475:	083E  EB      		EX	DE,HL           ;shift hl left four
1476:	083F  29      		ADD	HL,HL
1477:	0840  29      		ADD	HL,HL
1478:	0841  29      		ADD	HL,HL
1479:	0842  29      		ADD	HL,HL
1480:	0843  B5      		OR	L               ;or in this new digit
1481:	0844  6F      		LD	L,A
1482:	0845  EB      		EX	DE,HL
1483:	0846  3AE709  		LD	A,(BYTES)
1484:	0849  3D      		DEC	A
1485:	084A  32E709  		LD	(BYTES),A
1486:	084D  C23208  		JP	NZ,HEX
1487:	0850  CDFA07  		CALL	NCHR
1488:	0853  FE49    		CP	'I'             ;global?
1489:	0855  CCFA07  		CALL	Z,NCHR          ;z - need to read next to determine absolute
1490:			                                ;    or relocatable
1491:			
1492:	0858  323709  		LD	(RELCHR),A      ;we need to save this character for .prn files
1493:			                                ;so we can tell whether to add this symbol
1494:			                                ;to the count of symbols loaded.  if this
1495:			                                ;is an external name we skip the add.
1496:			
1497:	085B  FE20    		CP	' '             ;space means absolute
1498:	085D  280A    		JR	Z,HEX30         ;no bias added to absolute symbols
1499:	085F  3AE62E  		LD	A,(BIASLO)
1500:	0862  83      		ADD	A,E             ;add in bias as specified by user or default
1501:			                                ;as initialized by us (zero)
1502:	0863  5F      		LD	E,A
1503:	0864  3AE72E  		LD	A,(BIASHI)
1504:	0867  8A      		ADC	A,D
1505:	0868  57      		LD	D,A
1506:	0869  3A062F  	HEX30:	LD	A,(MAXLEN)      ;now point to last byte of symbol table
1507:			                                ;entry, which is where we will store
1508:			                                ;address just computed
1509:	086C  2F      		CPL
1510:	086D  A1      		AND	C
1511:	086E  4F      		LD	C,A
1512:	086F  3A062F  		LD	A,(MAXLEN)
1513:	0872  B1      		OR	C
1514:	0873  4F      		LD	C,A             ;never worry about carry - we always start
1515:			                                ;with 256 boundary
1516:	0874  7A      	        LD	A,D             ;store lo order symbol address
1517:	0875  02      		LD	(BC),A
1518:	0876  0B      		DEC	BC		;point to penultimate byte in block
1519:	0877  7B      		LD	A,E             ;hi order byte of address into symbol table
1520:	0878  02      		LD	(BC),A
1521:	0879  3A062F  		LD	A,(MAXLEN)	;mask to rewind symbol table pointer to the
1522:							;start of this block
1523:	087C  2F      		CPL
1524:	087D  A1      		AND	C
1525:	087E  4F      		LD	C,A
1526:	087F  C9      		RET
1527:			
1528:			
1529:	0880  113B09  	TOTSYM:	LD	DE,NSYMLO       ;nsym - bcd running count of the number of
1530:	0883  1A      		LD	A,(DE)		;       symbols loaded so far
1531:	0884  C601    		ADD	A,1		;bump by one symbol
1532:	0886  27      		DAA	;keep bcd format
1533:	0887  12      		LD	(DE),A
1534:	0888  D0      		RET	NC
1535:	0889  1B      		DEC	DE              ;account for carry by bumping hi order byte
1536:	088A  1A      		LD	A,(DE)
1537:	088B  C601    		ADD	A,1
1538:	088D  27      		DAA
1539:	088E  12      		LD	(DE),A
1540:	088F  C9      		RET
1541:			
1542:			
1543:			;zstx:
1544:			;Possible syntax error was detected as lfcb tried to init the FCB.
1545:			;However, we never keep track of how many files appeared in the
1546:			;command line we just keep calling lfcb.  Hence, we will always get
1547:			;an error return at some point when the input buffer runs out of
1548:			;valid input.  We check for real syntax error or end of command
1549:			;line by examining the first byte of the parse buffer:  if zero then
1550:			;prsr found no valid characters in the input buffer and this is the
1551:			;end of input - else, lfcb found real syntax error.
1552:			
1553:			
1554:	0890  3A2930  	ZSTX:	LD	A,(PRSBF)
1555:	0893  A7      		AND	A		;real syntax error - or	end of input?
1556:	0894  CAF006  		JP	Z,LOAD          ;z - more files
1557:	0897  11C129  		LD	DE,MLDG		;display loading message and symbol name
1558:							;to preserve the syntax used on good loads
1559:	089A  CD7028  		CALL	NPRINT
1560:	089D  112930  		LD	DE,PRSBF	;display file name currently in parse buffer so
1561:							;user knows where goof was
1562:	08A0  CD7328  		CALL	PRINT
1563:	08A3  CD1026  		CALL	CRLF
1564:	08A6  11F029  		LD	DE,MSNTX	;now display syntax error
1565:	08A9  CD7328  		CALL	PRINT
1566:	08AC  C3E906  		JP	FEOF50		;check for more files to load
1567:			
1568:			
1569:	08AF  11CB29  	ZFNF:	LD	DE,MFILNF	;display file not found
1570:	08B2  CD7328  		CALL	PRINT
1571:	08B5  C3E906  		JP	FEOF50
1572:			
1573:			
1574:	08B8  11FF29  	ZMEM:	LD	DE,MMEMXX	;display out of memory message
1575:	08BB  CD7328  		CALL	PRINT
1576:	08BE  CD1026  		CALL	CRLF
1577:	08C1  21062F  		LD	HL,MAXLEN
1578:	08C4  6E      		LD	L,(HL)
1579:	08C5  2600    		LD	H,00
1580:	08C7  09      		ADD	HL,BC
1581:	08C8  22E509  		LD	(NTPA),HL
1582:	08CB  C3F006  		JP	LOAD
1583:			
1584:			
1585:	08CE  118909  	ZOFF:	LD	DE,MINVOF	;display invalid offset using 0000 message
1586:	08D1  CD7328  		CALL	PRINT
1587:	08D4  210000  		LD	HL,00
1588:	08D7  C3A703  		JP	ZSYM10
1589:			
1590:			
1591:	08DA          	FSTRNG:
1592:	08DA  C5      		PUSH	BC
1593:	08DB  D5      		PUSH	DE
1594:	08DC          	FSTR00:
1595:	08DC  ED5B3509		LD	DE,(PSTRNG)     ;address of canned string pointer
1596:	08E0  1A      		LD	A,(DE)		;length
1597:	08E1  47      		LD	B,A
1598:	08E2  13      		INC	DE
1599:	08E3  CDFA07  	FSTR10:	CALL	NCHR		;get char
1600:	08E6  FE1A    		CP	EOF
1601:	08E8  CAF408  		JP	Z,FSTR20
1602:	08EB  EB      		EX	DE,HL		;DE - buffer ptr  HL - "symbols:" string ptr
1603:	08EC  BE      		CP	(HL)
1604:	08ED  EB      		EX	DE,HL
1605:	08EE  C2DC08  		JP	NZ,FSTR00	;mismatch read more from file
1606:	08F1  13      		INC	DE
1607:	08F2  10EF    		DJNZ	FSTR10          ;check entire string length
1608:	08F4  D1      	FSTR20:	POP	DE
1609:	08F5  C1      		POP	BC
1610:	08F6  C9      		RET
1611:			
1612:	08F7  11      	RLSTXX:	DEFB	RLSTSZ		;string length
1613:	08F8  53796D62		DEFB	'Symbol Table:'
	      6F6C2054
	      61626C65
	      3A
1614:	0905  0D0A0D0A		DEFB	CR,LF,CR,LF
1615:	0011          	RLSTSZ	EQU	$ - RLSTXX - 1
1616:			
1617:			
1618:	0909  0A      	RPRNXX:	DEFB	RPRNSZ		;string length
1619:	090A  53796D62		DEFB	'Symbols:'	;string to search for in M80's .prn files
	      6F6C733A
1620:							;indicating start of symbol table
1621:	0912  0D0A    		DEFB	CR,LF
1622:	000A          	RPRNSZ	EQU	$ - RPRNXX - 1
1623:			
1624:	0914  13      	RSLRXX:	DEFB	RSLRSZ
1625:	0915  53796D62		DEFB	'Symbols Detected.'
	      6F6C7320
	      44657465
	      63746564
	      2E
1626:	0926  0D0A    		DEFB	CR,LF
1627:	0013          	RSLRSZ	EQU	$ - RSLRXX - 1
1628:			
1629:	0928  08      	RM80XX:	DEFB	RM80SZ
1630:	0929  4D414352		DEFB	'MACRO-80'
	      4F2D3830
1631:	0008          	RM80SZ	EQU	$ - RM80XX - 1
1632:			
1633:	0931          	TSYM:
1634:	0931  00      	TSYMHI:	DEFB	0
1635:	0932  00      	TSYMLO:	DEFB	0
1636:			
1637:	0933  0000    	USYMBL:	DEFW	0
1638:			
1639:	0935  0000    	PSTRNG:	DEFW	0
1640:			
1641:	0937  00      	RELCHR:	DEFB	0
1642:			
1643:	0938  00      	BIDPRN:	DEFB	0
1644:			
1645:	0939  00      	STAR:	DEFB	0
1646:			
1647:	093A          	NSYM:
1648:	093A  00      	NSYMHI:	DEFB	0
1649:	093B  00      	NSYMLO:	DEFB	0
1650:	093C  20202020	MHEX:	DEFB	'    '
1651:	0940  24      		DEFB	'$'
1652:			
1653:	0941  4E756D62	MSYMBB:	DEFB	'Number Of Symbols Loaded: $'
	      6572204F
	      66205379
	      6D626F6C
	      73204C6F
	      61646564
	      3A2024
1654:			
1655:	095C  0D0A    	TSYMBB:	DEFB	CR,LF
1656:	095E  546F7461		DEFB	'Total Symbols:   $'
	      6C205379
	      6D626F6C
	      733A2020
	      2024
1657:			
1658:	0970  53796D62	MSYMNF:	DEFB	'Symbol Table Not Found'
	      6F6C2054
	      61626C65
	      204E6F74
	      20466F75
	      6E64
1659:	0986  0D0A00  		DEFB	CR,LF,0
1660:			
1661:	0989  496E7661	MINVOF:	DEFB	'Invalid Offset - Using 0000'
	      6C696420
	      4F666673
	      6574202D
	      20557369
	      6E672030
	      303030
1662:	09A4  0D0A00  		DEFB	CR,LF,0
1663:			
1664:	09A7  0D0A    	MSYMLD:	DEFB	CR,LF
1665:	09A9  53796D62		DEFB	'Symbol Table:    '
	      6F6C2054
	      61626C65
	      3A202020
	      20
1666:	09BA  00      		DEFB	0
1667:			
1668:	09BB  0D0A    	MZ8ELD:	DEFB	CR,LF
1669:	09BD  5A384520		DEFB	'Z8E Relocated:   '
	      52656C6F
	      63617465
	      643A2020
	      20
1670:	09CE  00      		DEFB	0
1671:			
1672:	09CF  0D0A    	MNVMEM:	DEFB	CR,LF
1673:	09D1  546F7020		DEFB	'Top Of Memory:   '
	      4F66204D
	      656D6F72
	      793A2020
	      20
1674:	09E2  00      		DEFB	00
1675:			
1676:	09E3  00      	Z8EB:	DEFB	00
1677:	09E4  00      	Z8EBH:	DEFB	00
1678:	09E5  0000    	NTPA:	DEFW	00
1679:			
1680:	09E7  00      	BYTES:	DEFB	00
1681:			
1682:	09E8  00      	ZBUF:	DEFB	00
1683:	09E9  00000000	ZBUFNM:	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	      00000000
	      00000000
	      000000
1684:	09F8          	ZNMBUF:
1685:	09F8 .. 0A3F 00		DEFS	72
1686:			; 	REPT	18
1687:			; 	DEFW	0,0
1688:			; 	ENDM
1689:	0000          	    IF	ASMB
1691:			    ELSE
1692:	0A40          	INIT:
1693:			    ENDIF
1694:	0A40  C9      		RET
1695:	0A41 .. 0B3F 00		DEFS	255
1697:			;******************************************************************************
1698:			;*
1699:			;*	z8e:	Entry point to monitor
1700:			;*
1701:			;*		Each command begins with the output of the '*' prompt.
1702:			;*		Command	character is validated by checking the cmd table,
1703:			;*
1704:			;*		Relative position of command letter in cmd table also used
1705:			;*		as index into command jump table jtcmd.
1706:			;*
1707:			;*		All commands entered with b = 0.
1708:			;*
1709:			;******************************************************************************
1710:			
1711:			
1712:	0C00          		ORG	($+255) AND 0FF00H
1713:			;was	org	256*(($+255)/256)
1714:			
1715:	0C00          	Z8EORG:
1716:							;Note: first three bytes here become a jump to
1717:	0C00 .. 0C0F 00		DEFS	16		;      BDOS after we are loaded
1718:							;
1719:							;This is the internal symbol table
1720:			
1721:	0C10  A7      	Z8E:	AND	A		;Any do-nothing	instruction with the sign
1722:							;bit set to indicate end of internal symbol
1723:							;table
1724:			
1725:	0C11  31      		DEFB	31H		;LD SP,nnnn - Load monitor stack pointer
1726:	0C12  0080    	Z8ESP:	DEFW	8000H		;Actual	address	filled in by nint at load
1727:							;time when we figure out where bdos is
1728:			
1729:	0C14  F3      	Z8ECMD:	DI			; lock interrupts and enable local RST38
1730:	0C15  CD281D  		CALL	ENAISR		;
1731:			; 	CALL	GDISIN		;
1732:	0C18  21100C  		LD	HL,Z8E
1733:	0C1B  E5      		PUSH	HL
1734:	0C1C  11AC29  		LD	DE,PROMPT	;display prompt (asterisk)
1735:	0C1F  CD7028  		CALL	NPRINT
1736:	0C22  210E2F  		LD	HL,JSTEPF	;full screen debugging in effect?
1737:	0C25  7E      		LD	A,(HL)
1738:	0C26  A7      		AND	A
1739:	0C27  200C    		JR	NZ,Z8E10	;nz - no
1740:			
1741:	0C29  0E0A    		LD	C,10
1742:	0C2B  CD2926  		CALL	SPACES		;If this was jdbg clear command line residue
1743:	0C2E  060A    		LD	B,10
1744:	0C30  CD3D28  	Z8E00:	CALL	BKSP
1745:	0C33  10FB    		DJNZ	Z8E00
1746:			
1747:	0C35  CDD225  	Z8E10:	CALL	INCHAR		;Read in command character
1748:			
1749:			; +++ jrs 3.5.6 ++++++++++++++++++
1750:	0C38  FE0D    		CP	CR		;+Check for empty command line
1751:	0C3A  2012    		JR	NZ,Z8E16	;+Something there - process it
1752:	0C3C  3ABC29  		LD	A,(LCMD)	;+Nothing - see if S or J was last command
1753:	0C3F  FE4A    		CP	'J'		;+Repeat 'J' command?
1754:	0C41  CA8B0D  		JP	Z,JDBG00	;+
1755:	0C44  210100  		LD	HL,1		;+
1756:	0C47  FE53    		CP	'S'		;+Repeat 'S' command?
1757:	0C49  CA7815  		JP	Z,STEP40	;+
1758:	0C4C  3E0D    		LD	A,CR		;+
1759:	0C4E          	Z8E16:				;+
1760:			; ++++++++++++++++++++++++++++++++
1761:	0C4E  CD0726  		CALL	IXLT		;Translate to upper case for compare
1762:	0C51  32BC29  		LD	(LCMD),A
1763:	0C54  FE4A    		CP	'J'		;If command is anything but j then indicate
1764:							;that screen is corrupted.  at next invokation
1765:							;jdbg will know to repaint the screen.
1766:	0C56  2803    		JR	Z,Z8E20
1767:	0C58  320E2F  		LD	(JSTEPF),A	;Full screen flag nz - full screen debugging
1768:							;in progress
1769:			
1770:			
1771:	0C5B  011B00  	Z8E20:	LD	BC,NCMD		;total number of commands
1772:	0C5E  218229  		LD	HL,CMD		;table of ascii	command	characters
1773:	0C61  EDB1    		CPIR
1774:	0C63  C27C0D  		JP	NZ,EXXX		;command letter not found in table
1775:	0C66  214C29  		LD	HL,JTCMD	;command jump table
1776:	0C69  09      		ADD	HL,BC
1777:	0C6A  09      		ADD	HL,BC		;index into table
1778:	0C6B  5E      		LD	E,(HL)		;lo order command processing routine
1779:	0C6C  23      		INC	HL
1780:	0C6D  56      		LD	D,(HL)		;upper address
1781:	0C6E  0E03    		LD	C,3
1782:	0C70  CD2926  		CALL	SPACES		;print spaces regardless
1783:	0C73  EB      		EX	DE,HL		;hl - address of command processing routine
1784:	0C74  E9      		JP	(HL)
1786:			;******************************************************************************
1787:			;*
1788:			;*	bphn:	breakpoint handler - rst38s land here
1789:			;*
1790:			;*		bphn   - bphn00	  save all user	registers
1791:			;*		bphn10 - bphn20	  check	that user pc matches entry in brktbl.
1792:			;*		bphn80		  special single step processing.
1793:			;*
1794:			;*	note:	sbps is	both a flag and	the count of the number	of step	bps.
1795:			;*		sbps is	set to 1 merely	to indicate that the single-stepping
1796:			;*		is in effect.  then the	number of step bps is added to one.
1797:			;*		hence, if 1 step bp was	set then  sbps = 2 and if 2 step bps
1798:			;*		were set (conditional jump, call, ret) sbps = 3.
1799:			;*
1800:			;******************************************************************************
1801:			
1802:	0C75  22792F  	BPHN:	LD	(HLREG),HL	;save user hl
1803:	0C78  E1      		POP	HL		;pop breakpoint	pc from	stack
1804:	0C79  ED73852F		LD	(SPREG),SP	;save user sp
1805:	0C7D  ED7B120C		LD	SP,(Z8ESP)	;switch	to our stack
1806:	0C81  2B      		DEC	HL		;point to location of rst instruction
1807:	0C82  22832F  		LD	(PCREG),HL	;save user pc
1808:	0C85  ED53772F		LD	(DEREG),DE	;save user de
1809:	0C89  ED43752F		LD	(BCREG),BC	;save user bc
1810:	0C8D  F5      		PUSH	AF
1811:	0C8E  E1      		POP	HL		;user accumulator and flag to hl
1812:	0C8F  22732F  		LD	(AFREG),HL	;save user af
1813:	0C92  ED57    		LD	A,I
1814:	0C94  67      		LD	H,A		;save user i reg
1815:	0C95  ED5F    		LD	A,R
1816:	0C97  6F      		LD	L,A		;save user r reg
1817:	0C98  228B2F  		LD	(RREG),HL
1818:	0C9B  08      		EX	AF,AF'          ;Bank In Prime Regs
1819:	0C9C  D9      		EXX
1820:	0C9D  22812F  		LD	(HLPREG),HL	;save
1821:	0CA0  ED537F2F		LD	(DEPREG),DE
1822:	0CA4  ED437D2F		LD	(BCPREG),BC
1823:	0CA8  F5      		PUSH	AF
1824:	0CA9  E1      		POP	HL
1825:	0CAA  227B2F  		LD	(AFPREG),HL
1826:	0CAD  DD22872F		LD	(IXREG),IX	;save user ix
1827:	0CB1  FD22892F		LD	(IYREG),IY	;save user iy
1828:	0CB5  3AF02E  		LD	A,(BPS)
1829:	0CB8  A7      		AND	A		;check for zero	bp count
1830:	0CB9  CA6D0D  		JP	Z,BPXXX		;error - no bps	set
1831:	0CBC  47      		LD	B,A		;b - number of breakpoints
1832:	0CBD  211D2F  		LD	HL,BRKTBL	;breakpoint storage table
1833:	0CC0  AF      		XOR	A
1834:	0CC1  4F      		LD	C,A		;init breakpoint found flag
1835:	0CC2  5E      	BPHN10:	LD	E,(HL)
1836:	0CC3  23      		INC	HL
1837:	0CC4  56      		LD	D,(HL)		;de - breakpoint address
1838:	0CC5  23      		INC	HL
1839:	0CC6  7E      		LD	A,(HL)		;saved contents	of breakpoint address
1840:	0CC7  23      		INC	HL
1841:	0CC8  12      		LD	(DE),A		;replace rst 38	with actual data
1842:	0CC9  3A832F  		LD	A,(PCREGL)	;user pc - lo order
1843:	0CCC  AB      		XOR	E
1844:	0CCD  5F      		LD	E,A		;versus	breakpoint address in table
1845:	0CCE  3A842F  		LD	A,(PCREGH)
1846:	0CD1  AA      		XOR	D		;check hi order
1847:	0CD2  B3      		OR	E
1848:	0CD3  2001    		JR	NZ,BPHN20	;no match - check next entry in	table
1849:	0CD5  48      		LD	C,B		;pc found in table set c reg nz
1850:	0CD6  10EA    	BPHN20:	DJNZ	BPHN10		;restore all user data
1851:	0CD8  21EF2E  		LD	HL,SBPS		;fetch number of step bps (0-2)
1852:	0CDB  46      		LD	B,(HL)
1853:	0CDC  AF      		XOR	A
1854:	0CDD  77      		LD	(HL),A		;clear regardless
1855:	0CDE  B1      		OR	C		;test bp found flag
1856:	0CDF  CA6D0D  		JP	Z,BPXXX		;z - bp	not in table
1857:	0CE2  23      		INC	HL		;point to bp count
1858:	0CE3  56      		LD	D,(HL)		;d - bp count
1859:	0CE4  05      		DEC	B
1860:	0CE5  FAF70C  		JP	M,BPHN30	;m - this was user bp not step or jdbg
1861:	0CE8  7E      		LD	A,(HL)
1862:	0CE9  90      		SUB	B		;subtract number of step bps from bp count
1863:	0CEA  77      		LD	(HL),A		;restore bp count
1864:	0CEB  3ABC29  		LD	A,(LCMD)	;what command got us here?
1865:	0CEE  FE53    		CP	'S'		;step?
1866:	0CF0  2861    		JR	Z,BPHN90	;step command - check count
1867:			
1868:							;now we know we have jdbg in progress.  need
1869:							;to check for user specified bp at the same
1870:							;address. if we find one stop trace.
1871:	0CF2  78      		LD	A,B		;number of step bps to accumulator (1 or 2).
1872:			
1873:	0CF3  91      		SUB	C		;compare number of step bps with the offset
1874:							;into the bp table where the current bp was
1875:							;found.  since step bps are always at the end
1876:							;of the table we can determine how bp was set.
1877:			
1878:	0CF4  D2380E  	 	JP	NC,JDBG30	;nc - we are at end of table so more tracing
1879:			
1880:	0CF7  79      	BPHN30:	LD	A,C
1881:	0CF8  ED44    		NEG
1882:	0CFA  82      		ADD	A,D		;create index into pass count table
1883:	0CFB  87      		ADD	A,A
1884:	0CFC  21532F  		LD	HL,PSCTBL	;pass count table
1885:	0CFF  85      		ADD	A,L
1886:	0D00  6F      		LD	L,A
1887:	0D01  3001    		JR	NC,BPHN35
1888:	0D03  24      		INC	H
1889:	0D04  5E      	BPHN35:	LD	E,(HL)
1890:	0D05  23      		INC	HL
1891:	0D06  56      		LD	D,(HL)		;de - pass count
1892:	0D07  7A      		LD	A,D
1893:	0D08  B3      		OR	E
1894:	0D09  2813    		JR	Z,BPHN50	;no count in effect
1895:	0D0B  1B      		DEC	DE
1896:	0D0C  72      		LD	(HL),D
1897:	0D0D  2B      		DEC	HL
1898:	0D0E  73      		LD	(HL),E		;restored updated count
1899:	0D0F  7A      		LD	A,D
1900:	0D10  B3      		OR	E		;did it	just go	zero?
1901:	0D11  280B    		JR	Z,BPHN50	;count just expired
1902:	0D13  78      		LD	A,B		;pass count not zero - go or jdbg?
1903:	0D14  A7      		AND	A
1904:	0D15  F2380E  		JP	P,JDBG30	;if step flag p we had step bps
1905:	0D18  2A832F  		LD	HL,(PCREG)
1906:	0D1B  C33E14  		JP	G100		;continue go command
1907:	0D1E  B0      	BPHN50:	OR	B		;test if we had step bps
1908:	0D1F  FA340D  		JP	M,BPHN60	;this was go - print bp message
1909:	0D22  3E58    		LD	A,'X'
1910:	0D24  32BC29  		LD	(LCMD),A	;clear command letter so xreg disassembles
1911:	0D27  CD8728  		CALL	HOME		;home cursor
1912:	0D2A  CDAD1F  		CALL	XREG
1913:	0D2D  0616    		LD	B,22		;cursor on penultimate line
1914:	0D2F  0E00    		LD	C,00
1915:	0D31  CD8A28  		CALL	XYCP
1916:			
1917:	0D34  11A429  	BPHN60:	LD	DE,BPMSG	;print *bp*
1918:	0D37  CD7328  		CALL	PRINT		;print message pointed to by de
1919:	0D3A  2A832F  		LD	HL,(PCREG)
1920:	0D3D  CD3926  		CALL	OUTADR		;display breakpoint address
1921:	0D40  EB      		EX	DE,HL
1922:	0D41  CD2025  		CALL	FADR		;attempt to find label at this address
1923:	0D44  EB      		EX	DE,HL		;de - bp address
1924:	0D45  C2100C  		JP	NZ,Z8E		;nz - no label found
1925:	0D48  3A062F  		LD	A,(MAXLEN)
1926:	0D4B  3D      		DEC	A
1927:	0D4C  4F      		LD	C,A		;c - max size of label
1928:	0D4D  CD7C28  		CALL	PRINTB
1929:	0D50  C3100C  		JP	Z8E
1930:	0D53  CDAD1F  	BPHN90:	CALL	XREG		;display all registers
1931:	0D56  2AED2E  		LD	HL,(NSTEP)	;fetch trace count
1932:	0D59  2B      		DEC	HL
1933:	0D5A  7D      		LD	A,L
1934:	0D5B  B4      		OR	H
1935:	0D5C  CA100C  		JP	Z,Z8E		;count expired - prompt	for command
1936:	0D5F  CD7225  		CALL	TTYQ		;test for abort	trace
1937:	0D62  FE0D    		CP	CR
1938:	0D64  CA100C  		JP	Z,Z8E
1939:	0D67  CD1026  		CALL	CRLF		;
1940:	0D6A  C37815  		JP	STEP40		;continue trace
1941:			
1942:			
1943:	0D6D  119D29  	BPXXX:	LD	DE,BPEMSG
1944:	0D70  CD7328  		CALL	PRINT
1945:	0D73  2A832F  		LD	HL,(PCREG)
1946:	0D76  CD3926  		CALL	OUTADR
1947:	0D79  C3100C  		JP	Z8E
1948:			
1949:			
1950:	0D7C  EB      	EXXX:	EX	DE,HL
1951:	0D7D  11BD29  		LD	DE,EMXXX
1952:	0D80  CD7328  		CALL	PRINT
1953:	0D83  EB      		EX	DE,HL
1954:	0D84  C9      		RET
1956:			;******************************************************************************
1957:			;*
1958:			;*	jdbg:	animated debugger
1959:			;*
1960:			;*	Jdbg allows the user to watch the Z80 CPU actually execute the
1961:			;*	code.  Jdbg displays 18 disassembled instructions on the screen
1962:			;*	as well as a user defined memory block referred to in the
1963:			;*	comments as a window.
1964:			;*
1965:			;*	Entry point jdbg:
1966:			;*
1967:			;*	Jdbg processes user input as a prelude to the actual animation
1968:			;*	of the code.  The user enters the starting address to animate
1969:			;*	optionally preceded by a subroutine qualifier.  The subroutine
1970:			;*	qualifier may be either a "*" which instructs Z8E not to trace
1971:			;*	any subroutines which are located below 100h (ie. bdos calls),
1972:			;*	or it may be a "/" which means no tracing of any subroutines.
1973:			;*	Jdbg will also paint the original screen with the register
1974:			;*	contents as well as the memory window.  The contents of the
1975:			;*	memory window are also moved into argbuf so that we can compare
1976:			;*	the 'old' contents with the 'new' contents once a the first bp
1977:			;*	is reached.
1978:			;*
1979:			;*	Entry point jdbg30:
1980:			;*
1981:			;* 	Entered here via bphn who determines that animation is in
1982:			;*	effect.  In order to cut down on superfluous cursor move-
1983:			;*	ment on the screen we compare the old register and memory
1984:			;*	window contents with the new contents following the latest
1985:			;*	bp.  We only output the changes.  Next we determine if the
1986:			;*	current pc exists in disassembled form somewhere on the
1987:			;*	screen; if not, we display 18 new disassembled instructions
1988:			;*	with the current pc as line one.
1989:			;*
1990:			;*	Exit jdbg95:
1991:			;*
1992:			;*	Save current register contents and jump to step40 for next
1993:			;*	single step.
1994:			;*
1995:			;******************************************************************************
1996:			
1997:	0D85          	JDBG:
1998:	0D85  CD8727  		CALL	IEDTBC		;get command line
1999:	0D88  F2AE0D  		JP	P,JDBG02	;p - have input
2000:			
2001:	0D8B  210F2F  	JDBG00:	LD	HL,LASTRO
2002:	0D8E  46      		LD	B,(HL)		;row position of arrow on screen
2003:	0D8F  0E12    		LD	C,18		;column
2004:	0D91  CD8A28  		CALL	XYCP
2005:	0D94  0E02    		LD	C,2
2006:	0D96  CD2926  		CALL	SPACES
2007:	0D99  0617    		LD	B,17H
2008:	0D9B  0E00    		LD	C,00
2009:	0D9D  CD8A28  		CALL	XYCP
2010:	0DA0  210E2F  		LD	HL,JSTEPF
2011:	0DA3  7E      		LD	A,(HL)
2012:	0DA4  3601    		LD	(HL),1
2013:	0DA6  A7      		AND	A
2014:	0DA7  CA280F  		JP	Z,JDBG90	;J was last means screen intact - just move
2015:							;arrow, else fall thru and repaint screen.
2016:							;Indicate single step
2017:	0DAA          	JDBG01:				;+ eg 3.3.6
2018:	0DAA  3E0A    		LD	A,10
2019:	0DAC  183F    		JR	JDBG10		;init timer
2020:			
2021:	0DAE  7E      	JDBG02:	LD	A,(HL)		;check first char of input
2022:	0DAF  FE23    		CP	'#'		;+ eg 3.3.6
2023:	0DB1  2007    		JR	NZ,JDBG2A	;+ Skip if not repaint request
2024:	0DB3  210E2F  		LD	HL,JSTEPF	;+
2025:	0DB6  3601    		LD	(HL),1		;+ Signal repaint request
2026:	0DB8  18F0    		JR	JDBG01		;+
2027:	0DBA          	JDBG2A:				;+
2028:	0DBA  EB      		EX	DE,HL		;de - save input buffer	address
2029:	0DBB  21EC2E  		LD	HL,WFLAG	;wflag tells us	whether	to trace subroutines
2030:							;or walk around	them
2031:	0DBE  36FF    		LD	(HL),0FFH	;conditionally assume trace all
2032:	0DC0  D62F    		SUB	'/'		;slash means don't trace any
2033:	0DC2  2805    		JR	Z,JDBG03	;
2034:	0DC4  C605    		ADD	A,'/'-'*'	;check for star	- no trace of bdos subs
2035:	0DC6  2004    		JR	NZ,JDBG05
2036:	0DC8  3C      		INC	A		;set flag one to indicate no trace of subs
2037:							;at address < 100h (bdos calls)
2038:	0DC9  77      	JDBG03:	LD	(HL),A		;set wflag
2039:	0DCA  AF      		XOR	A		;if slash or space replace with	null in	inbf
2040:							;so parser will	ignore
2041:	0DCB  12      		LD	(DE),A
2042:	0DCC  CDA926  	JDBG05:	CALL	IARG		;now evaluate address
2043:	0DCF  280C    		JR	Z,JDBG08	;z - no error
2044:	0DD1  3AD62F  		LD	A,(INBFNC)	;check number of characters
2045:	0DD4  3D      		DEC	A		;check for just / or just *
2046:	0DD5  28B4    		JR	Z,JDBG00	;treat as single step
2047:	0DD7  320E2F  		LD	(JSTEPF),A	;indicate screen corrupted
2048:	0DDA  C37C0D  		JP	EXXX		;error -
2049:	0DDD  22832F  	JDBG08:	LD	(PCREG),HL	;save address at which to start	tracing
2050:	0DE0  A7      		AND	A		;check delimter
2051:	0DE1  3E0A    		LD	A,10		;no delimeter use default timer value
2052:	0DE3  2808    		JR	Z,JDBG10
2053:	0DE5  CDA926  		CALL	IARG		;check if user wants non-default timer
2054:	0DE8  3E0A    		LD	A,10
2055:	0DEA  2001    		JR	NZ,JDBG10	;error - use default
2056:	0DEC  7D      		LD	A,L		;a - timer value as entered by user
2057:	0DED  32FD2E  	JDBG10:	LD	(TIMER),A
2058:	0DF0  0618    		LD	B,24		;xmit crlf's to clear screen
2059:	0DF2  CD1026  	JDBG15:	CALL	CRLF		;clear screen
2060:	0DF5  10FB    		DJNZ	JDBG15
2061:	0DF7  CD760F  		CALL	RGDISP		;display current user regs
2062:	0DFA  CD440F  		CALL	ZWNW		;display disassembled window
2063:	0DFD  3A192F  		LD	A,(WNWSIZ)
2064:	0E00  A7      		AND	A		;test if window being displayed
2065:	0E01  2830    		JR	Z,JDBG28
2066:	0E03  11AB2F  		LD	DE,WINDOW	;save user specified memory block til next bp
2067:	0E06  2A172F  		LD	HL,(WNWTAB)	;start of memory window address
2068:	0E09  010300  		LD	BC,3
2069:	0E0C  3A0A2F  	JDBG20: LD	A,(FWNDOW)	;position cursor starting at column
2070:	0E0F  D606    		SUB	6
2071:	0E11  CD820F  		CALL	CURS
2072:	0E14  CD3926  	       	CALL	OUTADR		;display address of memory window
2073:	0E17  3A0A2F  	JDBG25:	LD	A,(FWNDOW)
2074:	0E1A  CD820F  		CALL	CURS		;column position on screen of memory window
2075:							;is (rel pos * 3) + (fwndow)
2076:	0E1D  7E      		LD	A,(HL)		;display this byte
2077:			
2078:	0E1E  12      		LD	(DE),A		;save this byte in window between bps
2079:	0E1F  CD4326  		CALL	OUTHEX
2080:	0E22  04      		INC	B		;move and display user specifed number
2081:			                                ;of bytes (wnwsiz)
2082:	0E23  3A192F  		LD	A,(WNWSIZ)
2083:	0E26  90      		SUB	B
2084:	0E27  280A    		JR	Z,JDBG28
2085:	0E29  23      		INC	HL
2086:	0E2A  13      		INC	DE
2087:	0E2B  3A0B2F  		LD	A,(NLMASK)	;check for new line time
2088:	0E2E  A0      		AND	B
2089:	0E2F  20E6    		JR	NZ,JDBG25	;not end of line - display next byte else...
2090:	0E31  18D9    		JR	JDBG20		;...display address first
2091:	0E33  3E03    	JDBG28:	LD	A,3		;point to very first instruction
2092:	0E35  C3EC0E  		JP	JDBG75
2093:			
2094:			
2095:							;breakpoint handler jumps here for full
2096:							;screen single step
2097:	0E38  0E03    	JDBG30:	LD  	C,3
2098:	0E3A  CD2926  		CALL	SPACES		;remove => from screen
2099:	0E3D  41      		LD	B,C		;(c=0 after spaces executes)
2100:	0E3E  21732F  		LD	HL,REGCON	;new contents of registers following bp
2101:	0E41  11932F  		LD	DE,REGSAV	;old prior to bp
2102:	0E44  1A      	JDBG35:	LD	A,(DE)		;compare old vs new
2103:	0E45  BE      		CP	(HL)
2104:	0E46  23      		INC	HL
2105:	0E47  13      		INC	DE
2106:	0E48  2004    		JR	NZ,JDBG40	;different - display new
2107:	0E4A  1A      		LD	A,(DE)		;check hi order byte of this reg pair
2108:	0E4B  BE      		CP	(HL)
2109:	0E4C  2827    		JR	Z,JDBG45	;z - hi and lo bytes the same so try next reg
2110:	0E4E          	JDBG40:
2111:			;	ld	a,4		;col position of reg pair is (rel pos * 9) + 3
2112:			;	and	b
2113:			;	jr	z,jdbg42
2114:			;	ld	a,3
2115:			;	and	b		;- 9 bytes deleted here
2116:			;	inc	a
2117:	0E4E  C5      		PUSH	BC		;+save register number
2118:	0E4F  48      		LD	C,B		;+move it to c while we build line number
2119:	0E50  0600    		LD	B,0		;+assume first line for now
2120:	0E52  3E07    		LD	A,7		;+regs-per-line mask
2121:	0E54  B9      		CP	C		;+generate carry if second line
2122:	0E55  CB10    		RL	B		;+shift carry into line number
2123:	0E57  A1      		AND	C		;+generate line-relative register number
2124:	0E58  4F      		LD	C,A		;+col = reg * 9 + 3 if non-prime
2125:	0E59  87      		ADD	A,A		;+ *2
2126:	0E5A  87      		ADD	A,A		;+ *4
2127:	0E5B  87      		ADD	A,A		;+ *8
2128:	0E5C  81      		ADD	A,C		;+ *9
2129:	0E5D  CB51    		BIT	2,C		;+is it a prime (alternate) register?
2130:	0E5F  2803    		JR	Z,JDBG42	;+skip if not
2131:	0E61  81      		ADD	A,C		;+*10
2132:	0E62  D603    		SUB	3		;+col = reg * 10 if prime
2133:	0E64          	JDBG42:
2134:	0E64  C603    		ADD	A,3		;+
2135:	0E66  4F      		LD	C,A		;+
2136:	0E67  CD8A28  		CALL	XYCP		;+
2137:	0E6A  C1      		POP	BC		;+ added 29 bytes
2138:			
2139:			;	add	a,3		;- deleted another 5 bytes here
2140:			;	call	curs		;- nett cost = 14 bytes for new code
2141:			;				;- but we save 19 bytes in 'curs:' routine
2142:			
2143:	0E6B  7E      		LD	A,(HL)		;display upper byte of reg contents
2144:	0E6C  CD4326  		CALL	OUTHEX
2145:	0E6F  2B      		DEC	HL		;rewind to pick up lo order byte
2146:	0E70  7E      		LD	A,(HL)
2147:	0E71  23      		INC	HL
2148:	0E72  CD4326  		CALL	OUTHEX		;display lo order
2149:	0E75  23      	JDBG45:	INC	HL
2150:	0E76  13      		INC	DE
2151:	0E77  04      		INC	B
2152:	0E78  3E0C    		LD	A,REGSIZ/2	;number of reg pairs to display
2153:	0E7A  90      		SUB	B
2154:	0E7B  20C7    		JR	NZ,JDBG35
2155:	0E7D  CD2226  		CALL	RSPACE
2156:	0E80  0601    		LD	B,1
2157:	0E82  0E24    		LD	C,36
2158:	0E84  CD8A28  		CALL	XYCP
2159:			
2160:	0E87  0600    		LD	B,0
2161:	0E89  CDCC1B  		CALL	PSWDSP		;now display flag reg mnemonics
2162:			
2163:	0E8C  3A192F  		LD	A,(WNWSIZ)	;check window size
2164:	0E8F  A7      		AND	A
2165:	0E90  2821    		JR	Z,JDBG60	;z - no memory window in effect
2166:	0E92  2A172F  		LD	HL,(WNWTAB)	;hl - address of start of window
2167:	0E95  010300  		LD	BC,03
2168:	0E98  11AB2F  		LD	DE,WINDOW	;old contents of window stored here
2169:	0E9B  1A      	JDBG50:	LD	A,(DE)		;compare old vs new
2170:	0E9C  BE      		CP	(HL)
2171:	0E9D  280B    		JR	Z,JDBG55	;same - no reason to display
2172:	0E9F  3A0A2F  		LD	A,(FWNDOW)	;col position of byte is (rel pos * 3) + 50
2173:	0EA2  CD820F  		CALL	CURS
2174:	0EA5  7E      		LD	A,(HL)		;display byte
2175:			
2176:	0EA6  12      		LD	(DE),A		;we only need to move byte if it changed
2177:			
2178:	0EA7  CD4326  		CALL	OUTHEX
2179:	0EAA  04      	JDBG55:	INC	B		;bump memory window byte count
2180:	0EAB  3A192F  		LD	A,(WNWSIZ)  	;max size
2181:	0EAE  23      		INC	HL
2182:	0EAF  13      		INC	DE
2183:	0EB0  90      		SUB	B
2184:	0EB1  20E8    		JR	NZ,JDBG50	;loop until entire window examined
2185:			
2186:	0EB3  3E12    	JDBG60:	LD	A,18		;init count of disassembled instructions
2187:	0EB5  32F32E  		LD	(JLINES),A
2188:	0EB8  ED5BE22E		LD	DE,(ZASMFL)	;address of first disassembled instruction
2189:							;on screen
2190:	0EBC  2A832F  	JDBG65:	LD	HL,(PCREG)
2191:	0EBF  A7      		AND	A
2192:	0EC0  ED52    		SBC	HL,DE
2193:	0EC2  2821    		JR	Z,JDBG70	;found - pc exists somewhere on screen
2194:	0EC4  CDC81A  		CALL	ZLEN00		;compute length	of this	instruction
2195:	0EC7  0600    		LD	B,0
2196:	0EC9  EB      		EX	DE,HL		;hl - address on disassembled instruction
2197:	0ECA  09      		ADD	HL,BC		;add length to compute address of next inline
2198:							;instruction for display
2199:	0ECB  EB      		EX	DE,HL		;de - restore new istruction pointer
2200:	0ECC  21F32E  		LD	HL,JLINES
2201:	0ECF  35      		DEC	(HL)		;dec screen line count
2202:	0ED0  20EA    		JR	NZ,JDBG65
2203:	0ED2  2A832F  		LD	HL,(PCREG)	;pc not	on screen - so current pc will be new
2204:							;first pc on screen
2205:	0ED5  22E22E  		LD	(ZASMFL),HL
2206:	0ED8  010003  		LD	BC,0300H	;cursor	row 4 -	col 1
2207:	0EDB  CD8A28  		CALL	XYCP
2208:	0EDE  CD440F  		CALL	ZWNW		;instruction not on screen so paint a new
2209:							;screen	starting at current pc
2210:	0EE1  3E03    		LD	A,3		;disassembled instructions start on line 4
2211:	0EE3  1807    		JR	JDBG75
2212:	0EE5  3AF32E  	JDBG70:	LD	A,(JLINES)
2213:	0EE8  ED44    		NEG
2214:	0EEA  C615    		ADD	A,21		;a - screen row	on which to position cursor
2215:	0EEC  320F2F  	JDBG75:	LD	(LASTRO),A	;save position of arrow
2216:	0EEF  47      		LD	B,A		;pass to xycp
2217:	0EF0  0E12    		LD	C,18		;pass column
2218:	0EF2  CD8A28  		CALL	XYCP		;position cursor routine
2219:	0EF5  11B029  		LD	DE,MRROW
2220:	0EF8  CD7328  		CALL	PRINT
2221:	0EFB  3A0F2F  		LD	A,(LASTRO)	;xy positioning added after '=>' as
2222:							;some systems have a destructive bs
2223:	0EFE  0E11    		LD	C,17		;new cursor loc
2224:	0F00  CD8A28  		CALL	XYCP		;put it there
2225:	0F03  3A0E2F  		LD	A,(JSTEPF)
2226:	0F06  3D      		DEC	A		;test if single stepping
2227:	0F07  CA360F  		JP	Z,JDBG95
2228:	0F0A  CD7225  		CALL	TTYQ
2229:	0F0D  21FD2E  		LD	HL,TIMER
2230:	0F10  46      		LD	B,(HL)
2231:	0F11  2812    		JR	Z,JDBG80
2232:	0F13  FE30    		CP	'0'
2233:	0F15  380A    		JR	C,JDBG78
2234:	0F17  FE3A    		CP	3AH
2235:	0F19  301B    		JR	NC,JDBG95
2236:	0F1B  E60F    		AND	0FH
2237:	0F1D  77      		LD	(HL),A
2238:	0F1E  47      		LD	B,A
2239:	0F1F  1804    		JR	JDBG80
2240:	0F21  FE0D    	JDBG78:	CP	CR		;carriage return ends command
2241:	0F23  2811    		JR	Z,JDBG95
2242:			
2243:	0F25  CDA90F  	JDBG80:	CALL	CLOK
2244:			
2245:	0F28  11932F  	JDBG90:	LD	DE,REGSAV	;move current reg contents to save area
2246:	0F2B  21732F  		LD	HL,REGCON
2247:	0F2E  011800  		LD	BC,REGSIZ
2248:	0F31  EDB0    		LDIR
2249:	0F33  C37815  		JP	STEP40
2250:			
2251:			
2252:							;user requested abort from console
2253:	0F36  0616    	JDBG95: LD	B,22		;position cursor on line 23 for prompt
2254:	0F38  0E00    		LD	C,0
2255:	0F3A  CD8A28  		CALL	XYCP
2256:	0F3D  AF      		XOR	A
2257:	0F3E  320E2F  		LD	(JSTEPF),A	;indicate we have full screen of data
2258:	0F41  C3100C  		JP	Z8E		;to z8e command processor
2259:			
2260:			
2261:			
2262:	0F44          	ZWNW:				;display disassembly window
2263:	0F44  3E12    		LD	A,18		;number of instructions to disassemble
2264:	0F46  2A832F  	ZWNW05:	LD	HL,(PCREG)
2265:	0F49  22E22E  		LD	(ZASMFL),HL	;save pc of first line
2266:	0F4C  32F32E  	ZWNW10:	LD	(JLINES),A
2267:	0F4F  22E02E  		LD	(ZASMPC),HL	;save here as well
2268:	0F52  115530  		LD	DE,ZASMBF+96	;disassemble in upper portion of buffer to
2269:							;prevent overlap with big memory windows.
2270:							;otherwise, every time we disassemble a new
2271:							;screen we have to repaint the window.
2272:			
2273:	0F55  CD6420  		CALL	ZASM10		;disassemble first instruction
2274:	0F58  3E1E    		LD	A,30		;test line length
2275:	0F5A  B9      		CP	C
2276:	0F5B  2802    		JR	Z,ZWNW20
2277:	0F5D  0E2A    		LD	C,42
2278:	0F5F  CD7C28  	ZWNW20:	CALL	PRINTB
2279:	0F62  CD1026  		CALL	CRLF
2280:	0F65  2AE42E  		LD	HL,(ZASMNX)	;hl - next address to disassemble
2281:	0F68  3AF32E  		LD	A,(JLINES)
2282:	0F6B  3D      		DEC	A
2283:	0F6C  20DE    		JR	NZ,ZWNW10
2284:	0F6E  0603    		LD	B,3		;position cursor next to next instruction
2285:							;to execute which is the first one on the
2286:							;screen - line 4  col 20
2287:	0F70  0E14    		LD	C,20
2288:	0F72  CD8A28  		CALL	XYCP
2289:	0F75  C9      		RET
2290:			
2291:			
2292:							;display regs at top of screen:
2293:	0F76  CD8728  	RGDISP:	CALL	HOME		;home cursor
2294:	0F79  CDAD1F  		CALL	XREG		;display regs
2295:	0F7C  CDCC1B  		CALL	PSWDSP		;display flag reg
2296:	0F7F  C31026  		JP	CRLF
2297:			
2298:			
2299:			
2300:	0F82  C5      	CURS:	PUSH	BC		;This routine has been simplified and shortened
2301:	0F83  D5      		PUSH	DE		;by 19 bytes because it is no longer used for
2302:	0F84  E5      		PUSH	HL		;register display positioning.  jrs 20/4/87
2303:	0F85  57      		LD	D,A
2304:	0F86  59      		LD	E,C		;save base row address
2305:			;	cp	3		;test if reg or memory window (3 is reg)
2306:			;	ld	a,7
2307:			;	jr	z,curs00	;z - regs are eight per line (first line)
2308:			
2309:	0F87  3A0B2F  		LD	A,(NLMASK)
2310:	0F8A  A0      	CURS00:	AND	B		;item number mod lnmask is the relative pos of
2311:	0F8B  4F      		LD	C,A		;reg contents or memory data byte
2312:	0F8C  87      		ADD	A,A		;
2313:	0F8D  81      		ADD	A,C
2314:	0F8E  4F      		LD	C,A		;c - rel pos times three
2315:			
2316:			;	ld	a,d		;if base column address is < 50 then this is
2317:							;reg display
2318:			;	sub	3
2319:			;	ld	h,a
2320:			;	ld	a,c
2321:			;	jr	nz,curs20	;nz - not reg display - must be memory
2322:			;	add	a,a		;so multiply times three again
2323:			;	add	a,c		;times 9 in all for register display
2324:			
2325:	0F8F  82      	CURS20:	ADD	A,D		;add in base
2326:	0F90  4F      		LD	C,A		;c - absolute col number
2327:			;	xor	a		;test if this is reg or memory window display
2328:			;	or	h
2329:			;	jr	z,curs30	;z - this is register display
2330:	0F91  3A0A2F  		LD	A,(FWNDOW)
2331:	0F94  FE44    		CP	68		;14-char symbols in effect?
2332:	0F96  CA9B0F  		JP	Z,CURS40
2333:	0F99  CB38    	CURS30:	SRL	B
2334:	0F9B  3EFC    	CURS40:	LD	A,0FCH
2335:	0F9D  A0      		AND	B		;now compute row number
2336:	0F9E  0F      		RRCA
2337:	0F9F  0F      		RRCA
2338:	0FA0  83      		ADD	A,E		;base row address
2339:	0FA1  47      		LD	B,A		;b - absolute row number
2340:	0FA2  CD8A28  		CALL	XYCP		;convert row and column to xy cursor address
2341:	0FA5  E1      		POP	HL
2342:	0FA6  D1      		POP	DE
2343:	0FA7  C1      		POP	BC
2344:	0FA8  C9      		RET
2345:			
2346:			
2347:			
2348:	0FA9          	CLOK:
2349:	0FA9  1632    		LD	D,50  		;idle loop - decrement to 0 and reload
2350:	0FAB  1E00    		LD	E,00
2351:	0FAD  05      		DEC	B		;user specified the loop counter
2352:	0FAE  F8      		RET	M
2353:	0FAF  1B      	CLOK10:	DEC	DE
2354:	0FB0  7B      		LD	A,E
2355:	0FB1  B2      		OR	D
2356:	0FB2  20FB    		JR	NZ,CLOK10
2357:	0FB4  18F3    		JR	CLOK
2358:			
2360:			;******************************************************************************
2361:			;*
2362:			;*	exam:	examine	memory and display in hex and ascii.  user is allowed
2363:			;*		to modify memory after every byte is displayed.	ilin called
2364:			;*		to parse input buffer into a single string of bytes which is
2365:			;*		returned in argbuf.  the byte count of the string is returned
2366:			;*		in argbc, and this number of bytes is transferred to the
2367:			;*		current	memory address.
2368:			;*
2369:			;*		user may optionally scan memory	by entering cr.	 command
2370:			;*		terminates when	a single space is entered.
2371:			;*
2372:			;*		enter:	b - 0
2373:			;*		       de - address at which to	display	first byte
2374:			;*
2375:			;******************************************************************************
2376:			
2377:	0FB6  CD5E26  	EXAM:	CALL	ILIN
2378:	0FB9  C27C0D  		JP	NZ,EXXX
2379:	0FBC  EB      		EX	DE,HL
2380:	0FBD  CD3026  	EXAM00:	CALL	NEWLIN
2381:	0FC0  1A      		LD	A,(DE)		;fetch byte to display regardless
2382:	0FC1  CD3727  		CALL	OUTBYT
2383:	0FC4  CD4727  		CALL	RBYTE
2384:	0FC7  20F4    		JR	NZ,EXAM00 	;nz - don't replace memory contents
2385:	0FC9  FE2E    		CP	'.'
2386:	0FCB  2005    		JR	NZ,EXAM10
2387:	0FCD  3AD62F  		LD	A,(INBFNC)
2388:	0FD0  3D      		DEC	A
2389:	0FD1  C8      		RET	Z
2390:	0FD2  218F2F  	EXAM10:	LD	HL,ARGBC	;byte count to c
2391:	0FD5  4E      		LD	C,(HL)
2392:	0FD6  0600    		LD	B,0
2393:	0FD8  ED53E42E		LD	(EXAMPT),DE
2394:	0FDC  21932F  		LD	HL,ARGBF	;start of evaluated input
2395:	0FDF  EDB0    		LDIR
2396:	0FE1  3AFF2E  		LD	A,(TRMNTR)
2397:	0FE4  FE0D    		CP	CR
2398:	0FE6  28D5    		JR	Z,EXAM00
2399:	0FE8  ED5BE42E		LD	DE,(EXAMPT)
2400:	0FEC  18CF    		JR	EXAM00
2402:			;------------------------------------------------------------------------------
2403:			;
2404:			;	hsym:	display symbol table
2405:			;
2406:			;	User may display the symbol table on the console.  If no arg
2407:			;	entered on command line then the entire table is dumped start-
2408:			;	ing with the first symbol.  If a valid symbol is entered then
2409:			;	we will try to find the symbol in the table; if found, the
2410:			;	table is dumped starting at that point.  If the symbol is not
2411:			;	found the user gets a ? and the command terminates.
2412:			;
2413:			;	Symbols are displayed in blocks of 32.  After each block the
2414:			;	user is given the opportunity of continuing or ending the
2415:			;	command:
2416:			;
2417:			;		cr - Terminate			\  jrs 27 Dec 88
2418:			;	    not cr - Display next block		/  v 3.5.1
2419:			;
2420:			;------------------------------------------------------------------------------
2421:			
2422:	0FEE  CD5E26  	HSYM:	CALL	ILIN		;Read in line of data
2423:	0FF1  21100C  		LD	HL,Z8E		;Assume no symbol entered
2424:	0FF4  200F    		JR	NZ,HSYM10	;NZ - no input means display entire table
2425:	0FF6  112930  		LD	DE,PRSBF
2426:	0FF9  CDC819  		CALL	FSYM		;Attempt to find this symbol name in table
2427:	0FFC  C27C0D  		JP	NZ,EXXX		;Error - symbol	not found in symbol table
2428:	0FFF  3A062F  		LD	A,(MAXLEN)
2429:	1002  B5      		OR	L		;Point to next symbol table entry (next block)
2430:	1003  6F      		LD	L,A		;HL - ptr to last byte in this entry
2431:	1004  23      		INC	HL		;Now next entry toward hi memory
2432:	1005  3A062F  	HSYM10:	LD	A,(MAXLEN)	;Max size of symbol name
2433:	1008  4F      		LD	C,A
2434:	1009  0D      		DEC	C
2435:	100A  3C      		INC	A		;Make 8 or 16
2436:	100B  5F      		LD	E,A
2437:	100C  AF      		XOR	A
2438:	100D  57      		LD	D,A		;DE - size of symbol table entry
2439:	100E  ED52    		SBC	HL,DE		;Previous entry toward low memory
2440:	1010  7E      		LD	A,(HL)		;Null means this is unused slot is user
2441:							;defined symbol table
2442:	1011  A7      		AND	A
2443:	1012  28F1    		JR	Z,HSYM10
2444:	1014  3D      		DEC	A		;Neg means this is jp opcode (0c3h) of jump to
2445:							;BDOS
2446:	1015  F8      		RET	M
2447:	1016  3A062F  		LD	A,(MAXLEN)
2448:	1019  CB3F    		SRL	A
2449:	101B  CB3F    		SRL	A
2450:	101D  EE02    		XOR	2
2451:	101F  A0      		AND	B		;Check symbols per line count
2452:	1020  CC1026  		CALL	Z,CRLF		;crlf every fourth
2453:	1023  05      		DEC	B		;Now decrement symbols per line count
2454:	1024  CD7C28  		CALL	PRINTB		;Treat symbol table entry as a buffer and
2455:							;Six chars or until null, whichever is first
2456:	1027  0C      		INC	C		;Tack on two spaces
2457:	1028  0C      		INC	C
2458:	1029  CD2926  		CALL	SPACES
2459:	102C  3A062F  		LD	A,(MAXLEN)
2460:	102F  B5      		OR	L		;Point to last byte in symbol table block
2461:	1030  6F      		LD	L,A
2462:	1031  56      		LD	D,(HL)		;Upper byte of symbol address
2463:	1032  2B      		DEC	HL
2464:	1033  5E      		LD	E,(HL)		;Low order
2465:	1034  EB      		EX	DE,HL
2466:	1035  CD3926  		CALL	OUTADR		;HL - symbol address to display
2467:	1038  0E04    		LD	C,4
2468:	103A  CD2926  		CALL	SPACES		;Next symbol name starts 4 spaces to the right
2469:	103D  EB      		EX	DE,HL		;HL - symbol table pointer
2470:	103E  3A062F  		LD	A,(MAXLEN)
2471:	1041  2F      		CPL
2472:	1042  A5      		AND	L		;Rewind to point to byte zero of entry
2473:	1043  6F      		LD	L,A
2474:	1044  78      		LD	A,B
2475:	1045  E61F    		AND	31		;Displayed block of 32 symbols?
2476:	1047  20BC    		JR	NZ,HSYM10
2477:	1049  CD1026  		CALL	CRLF
2478:	104C  CD9225  		CALL	TTYI		;Test if user wants abort
2479:	104F  FE0D    		CP	CR
2480:	1051  20B2    		JR	NZ,HSYM10	;Not CR - continue (jrs v3.5.1)
2481:	1053  C9      		RET			;CR - end command
2483:			;*****************************************************************************
2484:			;*
2485:			;*	usym:   write symbol table to disk
2486:			;*
2487:			;*****************************************************************************
2488:			
2489:	1054  CD8727  	USYM:	CALL	IEDTBC		;get a command line
2490:	1057  F8      		RET	M		;no input ends command
2491:	1058  CD6223  		CALL	BLDF		;build fcb
2492:	105B  C2B11E  		JP	NZ,ESNTX	;syntax error
2493:	105E  21100C  		LD	HL,Z8E		;start at beginning
2494:	1061  3AD72E  		LD	A,(SYMFLG)	;do we even have a symbol table?
2495:	1064  A7      		AND	A
2496:	1065  C0      		RET	NZ		;no table - end command
2497:	1066  0680    		LD	B,128		;disk write buffer size
2498:	1068  32E42E  		LD	(LINES),A	;clear symbols per line counter
2499:	106B  11D12F  		LD	DE,SYMBUF
2500:	106E  3A062F  	USYM10:	LD	A,(MAXLEN)
2501:	1071  4F      		LD	C,A		;max size of symbol name
2502:	1072  2F      		CPL
2503:	1073  A5      		AND	L		;rewind to byte zero of symbol table entry
2504:	1074  6F      		LD	L,A
2505:	1075  78      		LD	A,B		;temp save buffer count
2506:	1076  0600    		LD	B,0
2507:	1078  ED42    		SBC	HL,BC
2508:	107A  2B      		DEC	HL		;point to 8 or 16 byte boundary
2509:	107B  47      		LD	B,A		;restore buffer count
2510:			
2511:	107C  7E      		LD	A,(HL)		;null means this is unused slot in user
2512:							;defined symbol table
2513:	107D  A7      		AND	A
2514:	107E  28EE    		JR	Z,USYM10
2515:	1080  3D      		DEC	A		;neg means this is jp opcode (0c3h) of jump to
2516:							;bdos
2517:	1081  F29110  		JP	P,USYM20
2518:	1084  CDC710  		CALL	PCRLF		;hit end of table - put crlf in buffer
2519:	1087  3E1A    		LD	A,EOF
2520:	1089  0601    		LD	B,1		;force buffer write
2521:	108B  CDDF10  		CALL	PUTC		;put eof in file
2522:	108E  C32723  		JP	CLOSEF		;this is a wrap
2523:			
2524:	1091  3A062F  	USYM20:	LD	A,(MAXLEN)
2525:	1094  B5      		OR	L
2526:	1095  6F      		LD	L,A		;point to hi order byte of symbol address
2527:	1096  CDD010  		CALL	PBIN		;put address in buffer
2528:	1099  3E20    		LD	A,' '
2529:	109B  CDDF10  		CALL	PUTC		;followed by space just like l80
2530:	109E  3A062F  		LD	A,(MAXLEN)
2531:	10A1  2F      		CPL
2532:	10A2  A5      		AND	L		;rewind to byte zero of symbol entry
2533:	10A3  6F      		LD	L,A
2534:			
2535:	10A4  0D      		DEC	C		;14 Sep 85   restore maxlen size as count
2536:			
2537:	10A5  7E      	USYM25:	LD	A,(HL)		;fetch char of symbol name
2538:	10A6  A7      		AND	A		;null?
2539:	10A7  2809    		JR	Z,USYM40	;name is less than 6 chars long
2540:	10A9  CDDF10  		CALL	PUTC		;put valid symbol name chars in buffer
2541:	10AC  0D      		DEC	C
2542:	10AD  2803    		JR	Z,USYM40	;z - just moved last char
2543:	10AF  23      		INC	HL
2544:	10B0  18F3    		JR	USYM25
2545:	10B2  3E09    	USYM40:	LD	A,TAB		;tab separates name and next address
2546:	10B4  CDDF10  		CALL	PUTC		;insert tab before address field
2547:	10B7  3AE42E  		LD	A,(LINES)
2548:	10BA  3D      		DEC	A
2549:	10BB  32E42E  		LD	(LINES),A
2550:	10BE  E603    		AND	3		;insert crlf every fourth symbol
2551:	10C0  20AC    		JR	NZ,USYM10
2552:	10C2  CDC710  		CALL	PCRLF
2553:	10C5  18A7    		JR	USYM10
2554:			
2555:			
2556:			
2557:	10C7  3E0D    	PCRLF:	LD	A,CR
2558:	10C9  CDDF10  		CALL	PUTC
2559:	10CC  3E0A    		LD	A,LF
2560:	10CE  180F    		JR	PUTC
2561:			
2562:			
2563:							;convert two byte binary address to ascii
2564:							;and put into buffer
2565:	10D0  CDD410  	PBIN:	CALL	PBIN00
2566:	10D3  2B      		DEC	HL
2567:	10D4  7E      	PBIN00:	LD	A,(HL)
2568:	10D5  CD5126  		CALL	BINX
2569:	10D8  CDDF10  		CALL	PUTC
2570:	10DB  7E      		LD	A,(HL)
2571:	10DC  CD5526  		CALL	BINX00
2572:			
2573:			
2574:	10DF  12      	PUTC:	LD	(DE),A		;just like pascal - put char into buffer
2575:	10E0  13      		INC	DE
2576:	10E1  05      		DEC	B		;buffer count passed in b
2577:	10E2  C0      		RET	NZ
2578:	10E3  11D12F  	PUTC00:	LD	DE,SYMBUF	;hit end of buffer - reinit pointer to start
2579:	10E6  CD4623  		CALL	BDWRIT		;write current buffer [ras 14 sep 85]
2580:	10E9  0680    		LD	B,128		;reinit tally
2581:	10EB  C9      		RET
2583:			
2584:			;------------------------------------------------------------------------------
2585:			;
2586:			;	dump:  Dump memory in hex and ASCII
2587:			;
2588:			;	Memory is dumped in hex	and ASCII in user-specified block size.
2589:			;	If the D command is given without arguments then memory	is dumped
2590:			;	beginning at the address where we left off as store in blkptr.
2591:			;	User is	queried	after each block is dumped:
2592:			;
2593:			;		cr - End command			\  v 3.5.1
2594:			;	    Not	cr - Dump next consecutive block	/  jrs 27 Dec 88
2595:			;
2596:			;------------------------------------------------------------------------------
2597:			
2598:	10EC  CD8727  	DUMP:	CALL	IEDTBC		;Solicit input
2599:	10EF  F2FB10  		JP	P,DUMP00	;p - input present
2600:	10F2  ED5BD82E		LD	DE,(BSIZ)	;No input means	use previous block size
2601:	10F6  2ADA2E  		LD	HL,(BLKPTR)	;   ...	and address
2602:	10F9  1823    		JR	DUMP30
2603:	10FB  CDA926  	DUMP00:	CALL	IARG		;Read in next arg (starting address)
2604:	10FE  C27C0D  		JP	NZ,EXXX		;Invalid starting address
2605:	1101  EB      		EX	DE,HL		;DE - starting address to dump
2606:	1102  CDA926  		CALL	IARG		;Next arg (block size)
2607:	1105  2805    		JR	Z,DUMP15	;Z - no	errors
2608:	1107  210000  		LD	HL,000		;Default to block size of 256
2609:	110A  1809    		JR	DUMP20
2610:	110C  AF      	DUMP15:	XOR	A
2611:	110D  B4      		OR	H		;Test for block	size or	ending address
2612:	110E  2805    		JR	Z,DUMP20	;Less than 256 must be block size
2613:	1110  ED52    		SBC	HL,DE		;Compute size
2614:	1112  DA7C0D  		JP	C,EXXX
2615:	1115  7D      	DUMP20:	LD	A,L
2616:	1116  B4      		OR	H
2617:	1117  2001    		JR	NZ,DUMP25
2618:	1119  24      		INC	H
2619:	111A  22D82E  	DUMP25:	LD	(BSIZ),HL
2620:	111D  EB      		EX	DE,HL		;DE - block size   HL -	memory pointer
2621:	111E  0610    	DUMP30:	LD	B,16		;Init bytes-per-line count
2622:	1120  CD7225  		CALL	TTYQ
2623:	1123  FE0D    		CP	CR
2624:	1125  C8      		RET	Z
2625:	1126  CD1026  		CALL	CRLF		;Display current address on new line
2626:	1129  CD3926  		CALL	OUTADR
2627:	112C  0E02    		LD	C,2
2628:	112E  CD2926  		CALL	SPACES		;Hex display starts two	spaces right
2629:	1131  05      	DUMP40:	DEC	B		;Decrement column count
2630:	1132  7E      		LD	A,(HL)
2631:	1133  23      		INC	HL
2632:	1134  CD1F26  		CALL	OTHXSP		;Display memory	in hex
2633:	1137  0C      		INC	C		;Tally of hex bytes displayed
2634:	1138  1B      		DEC	DE		;Decrement block count
2635:	1139  7A      		LD	A,D
2636:	113A  B3      		OR	E		;Test for end of block
2637:	113B  2806    		JR	Z,DUMP50	;Z - end of block
2638:	113D  AF      		XOR	A
2639:	113E  B0      		OR	B		;End of	line?
2640:	113F  20F0    		JR	NZ,DUMP40	;Not end of line - dump	more in	hex
2641:	1141  181B    		JR	DUMP60
2642:	1143  3AD92E  	DUMP50:	LD	A,(BSIZHI)
2643:	1146  A7      		AND	A		;Block size greater than 256?
2644:	1147  2007    		JR	NZ,DUMP55	;NZ - greater
2645:	1149  3AD82E  		LD	A,(BSIZLO)
2646:	114C  E6F0    		AND	0F0H		;Block size less than 16?
2647:	114E  280E    		JR	Z,DUMP60	;Z - less
2648:	1150  3AD82E  	DUMP55:	LD	A,(BSIZLO)
2649:	1153  E60F    		AND	0FH		;Block size multiple of	16?
2650:	1155  2807    		JR	Z,DUMP60	;Multiple of 16
2651:	1157  ED44    		NEG
2652:	1159  C610    		ADD	A,16
2653:	115B  47      		LD	B,A
2654:	115C  87      		ADD	A,A
2655:	115D  80      		ADD	A,B
2656:	115E  C603    	DUMP60:	ADD	A,3		;Plus three - begin ASCII display
2657:	1160  47      		LD	B,A		;Pad line until	ASCII display area
2658:	1161  CD2226  	DUMP70:	CALL	RSPACE
2659:	1164  10FB    		DJNZ	DUMP70
2660:	1166  ED42    		SBC	HL,BC		;Rewind	memory point by	like amount
2661:	1168  7E      	DUMP80:	LD	A,(HL)		;Start ASCII display
2662:	1169  23      		INC	HL
2663:	116A  CD4828  		CALL	ASCI
2664:	116D  0D      		DEC	C
2665:	116E  20F8    		JR	NZ,DUMP80
2666:	1170  CD7225  		CALL	TTYQ		;CR aborts command
2667:	1173  FE0D    		CP	CR
2668:	1175  CA100C  		JP	Z,Z8E
2669:	1178  7A      		LD	A,D		;Test for block	size tally expired
2670:	1179  B3      		OR	E
2671:	117A  20A2    		JR	NZ,DUMP30
2672:	117C  ED5BD82E		LD	DE,(BSIZ)	;Reinit	block size
2673:	1180  CD9225  		CALL	TTYI		;Query user for	more
2674:	1183  FE0D    		CP	CR
2675:			; Next two lines replaced by inverted test - 27 Dec 88 - jrs - V 3.5.1
2676:			;	call	z,crlf
2677:			;	jr	z,dump30	;not cr	- next block
2678:			;----				(Comment on last line is wrong anyway!)
2679:	1185  C41026  		CALL	NZ,CRLF		;Not cr - next block
2680:	1188  2094    		JR	NZ,DUMP30
2681:			;----
2682:	118A  22DA2E  		LD	(BLKPTR),HL
2683:	118D  C9      		RET			;end command
2685:			;******************************************************************************
2686:			;*
2687:			;*	rgst:  display and optionally modify individual	registers
2688:			;*
2689:			;*	call iedt:   read edited input into inbf
2690:			;*	call prsr:   parse input
2691:			;*	call mreg:   validate register name and	map into reg storage
2692:			;*	call iarg:   query user	for replacement
2693:			;*
2694:			;******************************************************************************
2695:			
2696:	118E  0E20    	RGST:	LD	C,' '		;get edited input
2697:	1190  0652    		LD	B,INBFSZ
2698:	1192  CD8E27  		CALL	IEDT
2699:	1195  F8      		RET	M
2700:	1196  3AFF2E  		LD	A,(TRMNTR)
2701:	1199  FE20    		CP	' '
2702:	119B  CC3D28  		CALL	Z,BKSP
2703:	119E  CD2B1A  		CALL	PRSR
2704:	11A1  B0      		OR	B		;unbalanced quotes (prime reg?)
2705:	11A2  F2B211  		JP	P,RGST00
2706:	11A5  E67F    		AND	7FH
2707:	11A7  FE03    		CP	3
2708:	11A9  2063    		JR	NZ,RGST25
2709:	11AB  2B      		DEC	HL
2710:	11AC  7E      		LD	A,(HL)
2711:	11AD  D627    		SUB	QUOTE
2712:	11AF  205D    		JR	NZ,RGST25
2713:	11B1  77      		LD	(HL),A
2714:	11B2  3AD62F  	RGST00:	LD	A,(INBFNC)	;number	of characters in buffer
2715:	11B5  FE04    		CP	4
2716:	11B7  3055    		JR	NC,RGST25	;error - too many chars
2717:	11B9  ED44    		NEG
2718:	11BB  C604    		ADD	A,4		;calculate space padding
2719:	11BD  4F      		LD	C,A
2720:	11BE  FE03    		CP	3		;was it	one?
2721:	11C0  200B    		JR	NZ,RGST10
2722:	11C2  1A      		LD	A,(DE)
2723:	11C3  CD0726  		CALL	IXLT
2724:	11C6  FE50    		CP	'P'
2725:	11C8  2003    		JR	NZ,RGST10
2726:	11CA  32D62F  		LD	(INBFNC),A	;any number > 2	indicates 16 bit register
2727:	11CD  CD2926  	RGST10:	CALL	SPACES
2728:	11D0  7E      		LD	A,(HL)		;check last char in parse buffer
2729:	11D1  D627    		SUB	QUOTE
2730:	11D3  2001    		JR	NZ,RGST15	;not quote
2731:	11D5  77      		LD	(HL),A		;replace with null
2732:	11D6  CD2312  	RGST15:	CALL	MREG		;validate register name
2733:	11D9  2033    		JR	NZ,RGST25	;error
2734:	11DB  3AFE2E  		LD	A,(REGTRM)	;mreg stored char following reg	name
2735:	11DE  A7      		AND	A
2736:	11DF  202D    		JR	NZ,RGST25	;error - no operators allowed
2737:	11E1  3AD62F  		LD	A,(INBFNC)	;now check number of chars in buffer
2738:	11E4  47      		LD	B,A		;save in b reg for 8 or	16 bit reg test
2739:	11E5  3D      		DEC	A		;test for one -	8 bit reg
2740:	11E6  0E03    		LD	C,3
2741:	11E8  2807    		JR	Z,RGST20
2742:	11EA  7E      		LD	A,(HL)
2743:	11EB  CD4326  		CALL	OUTHEX		;display byte of reg contents
2744:	11EE  2B      		DEC	HL
2745:	11EF  0E01    		LD	C,1
2746:	11F1  7E      	RGST20:	LD	A,(HL)
2747:	11F2  CD1F26  		CALL	OTHXSP
2748:	11F5  CD2926  		CALL	SPACES		;reg c - number	of spaces to print
2749:	11F8  EB      		EX	DE,HL		;de - save reg contents	pointer
2750:	11F9  CD6A26  	RGST22:	CALL	ISTR		;query user for	reg value replacement
2751:	11FC  3AD62F  		LD	A,(INBFNC)	;test number of	chars in input buffer
2752:	11FF  3D      		DEC	A		;
2753:	1200  FA1A12  		JP	M,RGST40	;none -	prompt for next	reg name
2754:	1203  CD7626  		CALL	IRSM
2755:	1206  280B    		JR	Z,RGST30
2756:	1208  3AD62F  		LD	A,(INBFNC)
2757:	120B  A7      		AND	A
2758:	120C  28EB    		JR	Z,RGST22
2759:	120E  CD7C0D  	RGST25:	CALL	EXXX
2760:	1211  1807    		JR	RGST40		;accept	new reg	name
2761:	1213  EB      	RGST30:	EX	DE,HL
2762:	1214  73      		LD	(HL),E
2763:	1215  05      		DEC	B		;test for 16 bit reg
2764:	1216  2802    		JR	Z,RGST40	;z - 8 bit reg
2765:	1218  23      		INC	HL
2766:	1219  72      		LD	(HL),D		;save upper byte of user input
2767:	121A  CD1026  	RGST40:	CALL	CRLF
2768:	121D  CD2726  		CALL	SPACE5
2769:	1220  C38E11  		JP	RGST
2770:			
2771:			
2772:			
2773:	1223  0E17    	MREG:	LD	C,23		;number	of reserved operands
2774:	1225  CD2D18  		CALL	OPRN00		;check validity	of register name
2775:	1228  1A      		LD	A,(DE)		;last char examined by operand routine
2776:	1229  CDB01A  		CALL	OPRTOR
2777:	122C  C0      		RET	NZ		;error - not null or valid operator
2778:	122D  32FE2E  		LD	(REGTRM),A	;save terminator character for rgst
2779:	1230  79      		LD	A,C
2780:	1231  FE11    		CP	17		;valid reg names are less than 17
2781:	1233  3805    		JR	C,MREG00	;so far	so good
2782:	1235  D617    		SUB	23		;last chance - may be pc
2783:	1237  C0      		RET	NZ		;error - invalid reg name
2784:	1238  3E0A    		LD	A,10		;make pc look like p for mapping
2785:	123A  21B82E  	MREG00:	LD	HL,REGMAP	;ptrs to register contents storage
2786:	123D  85      		ADD	A,L		;index into table by operand value
2787:	123E  6F      		LD	L,A
2788:	123F  3001    		JR	NC,MREG05
2789:	1241  24      		INC	H
2790:	1242  78      	MREG05:	LD	A,B		;b reg set m by	prsr if	trailing quote
2791:	1243  A7      		AND	A
2792:	1244  3E00    		LD	A,0		;assume	no quote - not prime reg
2793:	1246  F24B12  		JP	P,MREG10	;p - correct assumption
2794:	1249  3E08    		LD	A,8		;bias pointer for prime	reg contents
2795:	124B  86      	MREG10:	ADD	A,(HL)
2796:	124C  4F      		LD	C,A		;save mapping byte
2797:	124D  E67F    		AND	7FH		;strip sign
2798:							;so iarg knows 16 bit reg pair
2799:	124F  21732F  		LD	HL,REGCON	;use mapping byte to build pointer
2800:	1252  85      		ADD	A,L
2801:	1253  6F      		LD	L,A
2802:	1254  3001    		JR	NC,MREG50
2803:	1256  24      		INC	H
2804:	1257  AF      	MREG50:	XOR	A		;hl - pointer to register contents
2805:	1258  C9      		RET
2806:			
2808:			;******************************************************************************
2809:			;*
2810:			;*	qprt:	read and display / write to i/o	ports
2811:			;*
2812:			;*		contents of ports are displayed	and the	user is	queried
2813:			;*		input character	effects	the current port address:
2814:			;*
2815:			;*		space -	display	next sequential	port on	same line
2816:			;*		lf    -	display	next sequential	port on	new line
2817:			;*		cr    -	end command
2818:			;*		slash -	display	same port on same line
2819:			;*		^     -	display	previous port on new line
2820:			;*
2821:			;*		any other input	is treated as a	replacement byte and
2822:			;*		is output to the current port address.	any of the
2823:			;*		above characters may be	used to	continue the display.
2824:			;*
2825:			;*		enter: e  - port at which to begin display
2826:			;*
2827:			;******************************************************************************
2828:			
2829:	1259          	QPRT:
2830:	1259          	NPRT:
2831:	1259  AF      		XOR	A
2832:	125A  32F32E  		LD	(PARENF),A
2833:	125D  CD8727  	  	CALL	IEDTBC		;get port specified by user
2834:	1260  211B2F  		LD	HL,PORT
2835:	1263  5E      		LD	E,(HL)
2836:	1264  FAAF12  		JP	M,QPRT30	;m - no input means use last port number
2837:	1267  EB      		EX	DE,HL
2838:	1268  CDA926  	        CALL	IARG		;extract address
2839:	126B  C27C0D  		JP	NZ,EXXX
2840:	126E  EB      		EX	DE,HL 		;e - new port number
2841:	126F  73      		LD	(HL),E
2842:	1270  3AF32E  		LD	A,(PARENF)
2843:	1273  FE28    		CP	'('
2844:	1275  2038    		JR	NZ,QPRT30
2845:	1277  0E02    		LD	C,2
2846:	1279  CD2926  		CALL	SPACES
2847:	127C  4B      	QPRT00:	LD	C,E
2848:	127D  ED78    		IN	A,(C)
2849:	127F  47      		LD	B,A
2850:	1280  CD4326  		CALL	OUTHEX
2851:	1283  0E02    		LD	C,2
2852:	1285  CD2926  		CALL	SPACES
2853:	1288  0E08    		LD	C,8		;number of bits to display
2854:	128A  CB20    	QPRT10:	SLA	B		;most significant bit to carry
2855:	128C  3E30    		LD	A,'0'
2856:	128E  CE00    		ADC	A,0		;carry makes it a 1
2857:	1290  CDB225  		CALL	TTYO
2858:	1293  0D      		DEC	C
2859:	1294  20F4    		JR	NZ,QPRT10
2860:	1296  4B      		LD	C,E
2861:	1297  0603    		LD	B,3
2862:	1299  CD7225  		CALL	TTYQ
2863:	129C  FE0D    		CP	CR
2864:	129E  C8      		RET	Z
2865:	129F  CDA90F  		CALL	CLOK		;so we don't go faster than the terminal
2866:	12A2  59      		LD	E,C
2867:	12A3  78      		LD	A,B
2868:	12A4  A7      		AND	A
2869:	12A5  F0      		RET	P
2870:	12A6  060C    		LD	B,12
2871:	12A8  CD3D28  	QPRT20:	CALL	BKSP
2872:	12AB  10FB    		DJNZ	QPRT20
2873:	12AD  18CD    		JR	QPRT00
2874:	12AF  CD1026  	QPRT30:	CALL	CRLF
2875:	12B2  7B      		LD	A,E
2876:	12B3  321B2F  		LD	(PORT),A
2877:	12B6  CD1F26  		CALL	OTHXSP
2878:	12B9  CD2226  		CALL	RSPACE
2879:	12BC  4B      		LD	C,E
2880:	12BD  3ABC29  		LD	A,(LCMD)
2881:	12C0  FE4E    		CP	'N'
2882:	12C2  2805    		JR	Z,QPRT50
2883:	12C4  ED78    	       	IN	A,(C)
2884:	12C6  CD3727  		CALL	OUTBYT
2885:	12C9  CD4727  	QPRT50:	CALL	RBYTE
2886:	12CC  3AFF2E  		LD	A,(TRMNTR)
2887:	12CF  200F    		JR	NZ,QPRT60
2888:	12D1  FE2E    		CP	'.'
2889:	12D3  C8      		RET	Z
2890:	12D4  218F2F  		LD	HL,ARGBC
2891:	12D7  46      		LD	B,(HL)
2892:	12D8  21932F  		LD	HL,ARGBF
2893:	12DB  4B      		LD	C,E		;port number
2894:	12DC  EDB3    		OTIR
2895:	12DE  18CF    		JR	QPRT30
2896:	12E0  FE20    	QPRT60:	CP	' '
2897:	12E2  20CB    		JR	NZ,QPRT30
2898:	12E4  1B      		DEC	DE
2899:	12E5  18C8    		JR	QPRT30
2900:			
2901:			
2903:			;******************************************************************************
2904:			;*
2905:			;*	break:	set breakpoint routine
2906:			;*
2907:			;*	breakpoint address storage table (brktbl) is examined and user
2908:			;*	specified breakpoint is	considered valid unless:
2909:			;*
2910:			;*		     - table full
2911:			;*		     - address already exists in table
2912:			;*
2913:			;*	optional pass counts can be specified by the user immediatley following
2914:			;*	the breakpoint if they are enclosed in parens.
2915:			;*
2916:			;*	entry point brk30:
2917:			;*	      entered from single step command to set breakpoint.  two table
2918:			;*	      slots are	permanently available for step breakpoints. step
2919:			;*	      routine calls with c pos to tell us not to look for more args
2920:			;*	      in the input buffer.
2921:			;*
2922:			;******************************************************************************
2923:			
2924:	12E7  CD8727  	BREAK:	CALL	IEDTBC
2925:	12EA  F8      		RET	M		;end command - no input
2926:	12EB  0EFF    		LD	C,0FFH		;set neg - distinguish ourselves from step
2927:	12ED  3AF02E  	BRK10:	LD	A,(BPS)		;fetch current bp count
2928:	12F0  FE10    		CP	MAXBP		;table full
2929:	12F2  D27C0D  		JP	NC,EXXX		;full -	abort command
2930:	12F5  47      		LD	B,A		;save current count
2931:	12F6  CDA926  		CALL	IARG
2932:	12F9  C27C0D  		JP	NZ,EXXX
2933:	12FC  EB      		EX	DE,HL		;de - breakpoint address to set
2934:	12FD  211D2F  	BRK30:	LD	HL,BRKTBL
2935:	1300  AF      		XOR	A
2936:	1301  B0      		OR	B		;check for no breakpoints in effect
2937:	1302  2816    		JR	Z,BRK60		;none -	bypass check for duplicate
2938:	1304  7B      	BRK40:	LD	A,E
2939:	1305  BE      		CP	(HL)		;check lo order	address	match
2940:	1306  23      		INC	HL
2941:	1307  200D    		JR	NZ,BRK50	;no match - check next
2942:	1309  7A      		LD	A,D
2943:	130A  96      		SUB	(HL)		;check hi order
2944:	130B  2009    		JR	NZ,BRK50	;no match - check next
2945:	130D  B1      		OR	C
2946:	130E  F0      		RET	P
2947:	130F  21F02E  		LD	HL,BPS		;pointer to bp count
2948:	1312  7E      		LD	A,(HL)
2949:	1313  90      		SUB	B		;create	index into psctbl
2950:	1314  180C    		JR	BRK70
2951:	1316  23      	BRK50:	INC	HL
2952:	1317  23      		INC	HL		;bump past contents storage byte
2953:	1318  10EA    		DJNZ	BRK40
2954:	131A  73      	BRK60:	LD	(HL),E		;set in	table
2955:	131B  23      		INC	HL
2956:	131C  72      		LD	(HL),D
2957:	131D  21F02E  		LD	HL,BPS		;breakpoint count
2958:	1320  7E      		LD	A,(HL)		;fetch current count for user as index
2959:	1321  34      		INC	(HL)		;bump bp count
2960:	1322  11532F  	BRK70:	LD	DE,PSCTBL	;base of pass count table
2961:	1325  87      		ADD	A,A		;two byte table
2962:	1326  83      		ADD	A,E
2963:	1327  5F      		LD	E,A
2964:	1328  3001    		JR	NC,BRK80
2965:	132A  14      		INC	D
2966:	132B  AF      	BRK80:	XOR	A
2967:	132C  12      		LD	(DE),A		;pre-clear pass	count table entry
2968:	132D  13      		INC	DE
2969:	132E  12      		LD	(DE),A
2970:	132F  B1      		OR	C		;test if this was step calling
2971:	1330  F0      		RET	P		;i'm positive it was
2972:	1331  3AF42E  		LD	A,(DELIM)	;check delimeter which followed	bp address
2973:	1334  A7      		AND	A
2974:	1335  C8      		RET	Z		;end of	line null - terminate command
2975:	1336  FE2C    		CP	','		;check for pass	count delimeter
2976:	1338  C2ED12  		JP	NZ,BRK10	;not comma means treatt	this as	new bp
2977:	133B  CDA926  		CALL	IARG		;get next arg
2978:	133E  C27C0D  		JP	NZ,EXXX		;nz - evaluation error
2979:	1341  EB      		EX	DE,HL		;de - pass count as entered by user
2980:	1342  72      		LD	(HL),D		;store pass count in table
2981:	1343  2B      		DEC	HL
2982:	1344  73      		LD	(HL),E
2983:	1345  A7      		AND	A		;check delimeter
2984:	1346  C2ED12  		JP	NZ,BRK10	;nz - more arguments follow
2985:	1349  C9      		RET			;end of	line null - terminate command
2987:			
2988:			;******************************************************************************
2989:			;*
2990:			;*	cbreak:	clear breakpoint
2991:			;*
2992:			;*	breakpoint address storage table (brktbl) is examined and breakpoint
2993:			;*	is removed if found. breakpoint	is removed by bubbling up all bp
2994:			;*	addresses which	follow,	ditto for pass counts.
2995:			;*
2996:			;******************************************************************************
2997:			
2998:	134A  CD8727  	CBREAK:	CALL	IEDTBC
2999:	134D  F8      		RET	M		;no input ends command
3000:	134E  3AF02E  		LD	A,(BPS)		;fetch breakpoint count
3001:	1351  B7      		OR	A		;any if	effect
3002:	1352  C8      		RET	Z		;no
3003:	1353  47      		LD	B,A		;temp save count
3004:	1354  CDA926  		CALL	IARG		;extract address to clear from input buffer
3005:	1357  111D2F  		LD	DE,BRKTBL	;bp address storage table
3006:	135A  2813    		JR	Z,CBRK10
3007:	135C  3A2930  		LD	A,(PRSBF)
3008:	135F  FE2A    		CP	'*'
3009:	1361  C27C0D  		JP	NZ,EXXX
3010:	1364  3AD62F  		LD	A,(INBFNC)
3011:	1367  3D      		DEC	A
3012:	1368  C27C0D  		JP	NZ,EXXX
3013:	136B  32F02E  		LD	(BPS),A
3014:	136E  C9      		RET
3015:			
3016:	136F  1A      	CBRK10:	LD	A,(DE)		;test lo order address for match
3017:	1370  BD      		CP	L
3018:	1371  13      		INC	DE
3019:	1372  2002    		JR	NZ,CBRK20	;no match - examine next entry
3020:	1374  1A      		LD	A,(DE)
3021:	1375  BC      		CP	H		;versus	hi order bp address
3022:	1376  13      	CBRK20:	INC	DE
3023:	1377  13      		INC	DE		;bump past contents save location
3024:	1378  2805    		JR	Z,CBRK30	;zero -	found bp in table
3025:	137A  10F3    		DJNZ	CBRK10
3026:	137C  C37C0D  		JP	EXXX		;error - breakpoint not	found
3027:	137F  26FF    	CBRK30:	LD	H,0FFH		;rewind	to point to bp address
3028:	1381  2EFD    		LD	L,-3
3029:	1383  19      		ADD	HL,DE
3030:	1384  EB      		EX	DE,HL		;de - ptr to bp	  hl - ptr to next bp
3031:	1385  78      		LD	A,B		;multiply number of bps	remaining in table
3032:							;times three bytes per entry
3033:	1386  87      		ADD	A,A
3034:	1387  80      		ADD	A,B
3035:	1388  4F      		LD	C,A		;init c	for ldir
3036:	1389  78      		LD	A,B		;save number of	bps remaining
3037:	138A  0600    		LD	B,0
3038:	138C  EDB0    		LDIR			;bubble	up all remaining entries in table
3039:	138E  4F      		LD	C,A		;
3040:	138F  21F02E  		LD	HL,BPS		;address of bp count
3041:	1392  7E      		LD	A,(HL)		;
3042:	1393  35      		DEC	(HL)		;decrement system breakpoint count
3043:	1394  91      		SUB	C		;compute relative number of pass count table
3044:							;entry we wish to clear
3045:	1395  87      		ADD	A,A		;times two bytes per entry
3046:	1396  6F      		LD	L,A
3047:	1397  60      		LD	H,B		;cheap clear
3048:	1398  11532F  		LD	DE,PSCTBL
3049:	139B  19      		ADD	HL,DE		;index into pass count table
3050:	139C  EB      		EX	DE,HL
3051:	139D  210200  		LD	HL,02
3052:	13A0  19      		ADD	HL,DE		;de - ptr to pass count	 hl - next in table
3053:	13A1  CB21    		SLA	C		;number	of pass	counts to move
3054:	13A3  EDB0    		LDIR
3055:	13A5  3AF42E  		LD	A,(DELIM)	;recheck delimeter
3056:	13A8  A7      		AND	A
3057:	13A9  209F    		JR	NZ,CBREAK	;not end of line terminator - clear more
3058:	13AB  C9      		RET
3060:			;***********************************************************************
3061:			;*
3062:			;*     obreak:	output all breakpoints and associated pass counts to
3063:			;*		console.  search symbol	table for match, if symbol name
3064:			;*		found display it along with address.
3065:			;*
3066:			;*     wbreak:	wipe out (clear) all breakpoints currently in effect
3067:			;*
3068:			;*		entered:  b - zero
3069:			;*
3070:			;***********************************************************************
3071:			
3072:	13AC  3AF02E  	OBREAK:	LD	A,(BPS)		;fetch bp count
3073:	13AF  3D      		DEC	A		;test for no breakpoints
3074:	13B0  F8      		RET	M		;m - none
3075:	13B1  47      		LD	B,A		;save count
3076:	13B2  211D2F  	OBRK00:	LD	HL,BRKTBL	;base of breakpoint storage table
3077:	13B5  58      		LD	E,B		;use current breakpoint	count as index
3078:	13B6  1600    		LD	D,0		;clear
3079:	13B8  19      		ADD	HL,DE		;this is a three byte table
3080:	13B9  19      		ADD	HL,DE
3081:	13BA  19      		ADD	HL,DE
3082:	13BB  5E      		LD	E,(HL)		;fetch lo order	bp address
3083:	13BC  23      		INC	HL
3084:	13BD  56      		LD	D,(HL)		;upper address
3085:	13BE  EB      		EX	DE,HL
3086:	13BF  CD3926  		CALL	OUTADR		;display address
3087:	13C2  EB      		EX	DE,HL		;hl - breakpoint table
3088:	13C3  CD2025  		CALL	FADR		;check symbol table for	name match
3089:							;   symbol table pointer returned in de
3090:							;   zero flag set if found
3091:	13C6  3A062F  		LD	A,(MAXLEN)
3092:	13C9  4F      		LD	C,A
3093:	13CA  0B      		DEC	BC		;max number of chars in	a symbol name
3094:	13CB  EB      		EX	DE,HL		;hl - symbol table address if
3095:	13CC  CC7C28  		CALL	Z,PRINTB	;display name if found in symbol table
3096:	13CF  78      		LD	A,B
3097:	13D0  87      		ADD	A,A		;bp number times two
3098:	13D1  21532F  		LD	HL,PSCTBL	;base of pass count table
3099:	13D4  85      		ADD	A,L
3100:	13D5  6F      		LD	L,A
3101:	13D6  3001    		JR	NC,OBRK10
3102:	13D8  24      		INC	H
3103:	13D9  5E      	OBRK10:	LD	E,(HL)		;lo order pass count
3104:	13DA  23      		INC	HL
3105:	13DB  56      		LD	D,(HL)		;upper byte
3106:	13DC  7A      		LD	A,D		;test if pass count in effect
3107:	13DD  B3      		OR	E
3108:	13DE  2808    		JR	Z,OBRK20	;z - no	pass count for this bp
3109:	13E0  0C      		INC	C
3110:	13E1  CD2926  		CALL	SPACES
3111:	13E4  EB      		EX	DE,HL
3112:	13E5  CD3926  		CALL	OUTADR		;display pass count in hex
3113:	13E8  CD1026  	OBRK20:	CALL	CRLF
3114:	13EB  0E05    		LD	C,5
3115:	13ED  CD2926  		CALL	SPACES
3116:	13F0  05      		DEC	B		;dec bp	count
3117:	13F1  F2B213  		JP	P,OBRK00
3118:	13F4  C9      		RET
3119:			
3120:			
3121:			
3122:	13F5  CD8727  	KDMP:	CALL	IEDTBC		;let user input address of memory to display
3123:	13F8  F8      		RET	M		;no input ends command
3124:	13F9  CDA926  		CALL	IARG		;evaluate user arg
3125:	13FC  C27C0D  		JP	NZ,EXXX
3126:	13FF  EB      		EX	DE,HL		;de - save memory address
3127:	1400  CDA926  		CALL	IARG		;now get count
3128:	1403  3E00    		LD	A,0
3129:	1405  2018    		JR	NZ,KDMP20	;error during input - display 00 bytes
3130:	1407  B4      		OR	H
3131:	1408  C27C0D  		JP	NZ,EXXX		;greater than 256 is error
3132:	140B  3A062F  		LD	A,(MAXLEN)	;max symbol length
3133:	140E  0602    		LD	B,2		;assume big names
3134:	1410  FE0F    		CP	15
3135:	1412  3E12    		LD	A,18		;number of disassembled lines displayed
3136:	1414  2802    		JR	Z,KDMP00
3137:	1416  0603    		LD	B,3		;double number of lines one extra time
3138:	1418  87      	KDMP00:	ADD	A,A		;times two
3139:	1419  10FD    		DJNZ	KDMP00
3140:	141B  BD      		CP	L
3141:	141C  3801    		JR	C,KDMP20	;if number of bytes specified by user is too
3142:							;large then use default
3143:	141E  7D      		LD	A,L		;use value specified by user
3144:	141F  ED53172F	KDMP20:	LD	(WNWTAB),DE
3145:	1423  32192F  		LD	(WNWSIZ),A
3146:	1426  C9      		RET
3148:			;**************************************************************************
3149:			;*
3150:			;*		     begin/resume execution of user program
3151:			;*
3152:			;*	address	entered:     execution begins at entered address
3153:			;*	no address entered:  execution resumed at specified by saved pc
3154:			;*
3155:			;*	breakpoint table examined:
3156:			;*	      -	memory contents	from each address is removed from user
3157:			;*		program	and saved in breakpoint	table
3158:			;*	      -	rst 38 instruction is placed at	each breakpoint	address
3159:			;*		in user	program
3160:			;*
3161:			;*	user registers restored
3162:			;*
3163:			;***************************************************************************
3164:			
3165:	1427  CD8727  	GO:	CALL	IEDTBC		;query user for	execution address
3166:			
3167:			;	ret	m		;- eg 3.3.3 no input - reprompt
3168:	142A  F23214  		JP	P,G001		;+ Skip if argument supplied, else:
3169:	142D  2A832F  		LD	HL,(PCREG)	;+ Use current PC
3170:	1430  1806    		JR	G002		;+
3171:	1432          	G001:				;+
3172:	1432  CDA926  		CALL	IARG
3173:	1435  C27C0D  		JP	NZ,EXXX		;error - invalid argument
3174:	1438          	G002:				;+
3175:	1438  CD1026  		CALL	CRLF
3176:	143B  CD1026  		CALL	CRLF
3177:	143E  22FB2E  	G100:	LD	(JMPLO),HL	;store execution address
3178:	1441  3EC3    		LD	A,IJP
3179:	1443  32FA2E  		LD	(SJMP),A		;set jp	instruction
3180:	1446  32F72E  		LD	(JMP2JP),A	;just in case
3181:	1449  3AF02E  		LD	A,(BPS)		;check breakpoint count
3182:	144C  A7      		AND	A
3183:	144D  CA0515  		JP	Z,G600		;z - no	bps in effect -	no restoration needed
3184:	1450  47      		LD	B,A
3185:	1451  211D2F  		LD	HL,BRKTBL
3186:	1454  0EFF    		LD	C,0FFH
3187:	1456  5E      	G300:	LD	E,(HL)
3188:	1457  23      		INC	HL
3189:	1458  56      		LD	D,(HL)		;de - breakpoint address removed from table
3190:	1459  23      		INC	HL		;point to contents save	byte in	table
3191:	145A  1A      		LD	A,(DE)
3192:	145B  77      		LD	(HL),A
3193:	145C  3AFB2E  		LD	A,(JMPLO)
3194:	145F  BB      		CP	E		;check if bp from table	matches	next pc
3195:	1460  2009    		JR	NZ,G400		;no match - set	breakpoint
3196:	1462  3AFC2E  		LD	A,(JMPHI)
3197:	1465  BA      		CP	D		;check hi order	next pc	address
3198:	1466  2003    		JR	NZ,G400		;no match - set	bp
3199:	1468  48      		LD	C,B		;set flag - current pc matches breakpoint
3200:	1469  1803    		JR	G500
3201:	146B  3ECF    	G400:	LD	A,RST38		;set rst38 instruction
3202:	146D  12      		LD	(DE),A		;save user byte	in brktbl
3203:	146E  23      	G500:	INC	HL
3204:	146F  10E5    		DJNZ	G300		;examine all entries
3205:	1471  0C      		INC	C		;current pc match breakpoint?
3206:	1472  CA0515  		JP	Z,G600		;z - no (c reg not 0ffh)
3207:	1475  3AEF2E  		LD	A,(SBPS)	;check number of step breakpoints
3208:	1478  A7      		AND	A		;tracing?
3209:	1479  C20515  		JP	NZ,G600		;nz - this is trace
3210:			
3211:							;pc points to address in breakpoint table
3212:							;next instruction will not be executed where
3213:							;it resides.  it will be moved to our internal
3214:							;buffer (execbf) and executed there. then we
3215:							;set an rst38 at actual location in user
3216:							;program.  this allows us to debug loops in
3217:							;which only one bp is set.  otherwise we would
3218:							;not be able to set a bp at the address where
3219:							;the pc points and debugging loops would be
3220:							;impossible.
3221:	147C  21F32E  		LD	HL,EXECBF
3222:	147F  ED5BFB2E		LD	DE,(JMPLO)	;de - pointer to next instruction to execute
3223:	1483  22FB2E  		LD	(JMPLO),HL	;execute buffer
3224:	1486  0604    		LD	B,4		;clear execute buffer
3225:	1488  3600    	G505:	LD	(HL),INOP
3226:	148A  23      		INC	HL
3227:	148B  10FB    		DJNZ	G505
3228:	148D  CDC81A  		CALL	ZLEN00		;calculate length
3229:							;if instruction modifies pc then zlen lets us
3230:							;know by setting b reg nz and c contains
3231:							;instruction length
3232:			
3233:	1490  22022F  		LD	(JROPND),HL	;if this is a jr instruction we need to save
3234:							;address where we will be jumping
3235:			
3236:			
3237:							;default execbf has been initialized:
3238:							;
3239:							;four nops
3240:							;     jp   user program
3241:							;
3242:	1493  EB      		EX	DE,HL		;hl - ptr to user instruction
3243:	1494  11F32E  		LD	DE,EXECBF
3244:	1497  7E      		LD	A,(HL)		;first object byte from	user program
3245:	1498  36CF    	G518:	LD	(HL),RST38	;replace
3246:	149A  C5      		PUSH	BC		;b - if nz this is a pc modifying instruction
3247:							;c - number of bytes of object code for this
3248:							;    instruction
3249:	149B  12      	G520:	LD	(DE),A		;into execute buffer
3250:	149C  13      		INC	DE
3251:	149D  23      		INC	HL		;bump user program pointer
3252:	149E  7E      		LD	A,(HL)		;next byte of instruction from user program
3253:	149F  0D      		DEC	C
3254:	14A0  20F9    		JR	NZ,G520
3255:	14A2  C1      		POP	BC
3256:							;the four nops in execbf have now been replaced
3257:							;by from one to four bytes of actual user
3258:							;instruction.  if user instruction was shorter
3259:							;than four bytes the nops remain and are
3260:							;executed until the jump back to the user
3261:							;program at jmp2jp is reached.
3262:			
3263:			
3264:	14A3  22F82E  		LD	(JMP2),HL	;address of next inline instruction within
3265:							;user code
3266:			
3267:	14A6  EB      		EX	DE,HL		;de - next inline instruction in user program
3268:	14A7  AF      		XOR	A
3269:	14A8  B0      		OR	B
3270:	14A9  285A    		JR	Z,G600		;z - the instruction in execbf is not a pc
3271:							;modifying instruction
3272:			
3273:	14AB  3AF32E  		LD	A,(EXECBF)	;first byte of instruction
3274:	14AE  0D      		DEC	C		;one byte instruction?
3275:	14AF  2854    		JR	Z,G600
3276:	14B1  0D      		DEC	C
3277:	14B2  2827    		JR	Z,G550		;two byter
3278:	14B4  0D      		DEC	C
3279:	14B5  204E    		JR	NZ,G600		;nz - must be four byter
3280:	14B7  41      		LD	B,C		;clear for cpir
3281:	14B8  0E09    		LD	C,Z803SL	;test for call instruction
3282:	14BA  21532A  		LD	HL,Z803S	;load list of first byte of call instructions
3283:	14BD  EDB1    		CPIR
3284:	14BF  2044    		JR	NZ,G600		;nz - not call
3285:			
3286:							;moving call instructions and executing them
3287:							;locally requires special processing because
3288:							;the z80 will store the address pc+3 on the
3289:							;stack.  in this case we do not want the
3290:							;address  execbf+3 on the stack.  we want the
3291:							;address of the actual location of the user
3292:							;instruction+3 on the stack.  we must do this
3293:							;by simulating a call instruction. we use the
3294:							;jp instruction which is equivalent to the
3295:							;call and we also push a computed return
3296:							;address on to the user stack pointed to by
3297:							;spreg.
3298:			
3299:	14C1  010800  		LD	BC,08		;point to jump instruction which is equivalent
3300:							;to call (call nz = jp nz)
3301:	14C4  09      		ADD	HL,BC
3302:	14C5  7E      		LD	A,(HL)		;fetch jump object byte
3303:	14C6  2A852F  		LD	HL,(SPREG)	;push next pc onto user stack
3304:	14C9  2B      		DEC	HL		;decrement user sp
3305:	14CA  72      		LD	(HL),D		;de - "return address"
3306:	14CB  2B      		DEC	HL
3307:	14CC  73      		LD	(HL),E
3308:	14CD  22852F  		LD	(SPREG),HL
3309:	14D0  32F32E  		LD	(EXECBF),A	;store jp op code
3310:	14D3  21F82E  		LD	HL,JMP2		;if conditional call and we fall thru
3311:							;we need to go back to address of call
3312:							;in user program + 3
3313:	14D6  73      		LD	(HL),E
3314:	14D7  23      		INC	HL
3315:	14D8  72      		LD	(HL),D
3316:	14D9  182A    		JR	G600
3317:							;if next instruction to execute is a
3318:							;relative jump we need to replace it with
3319:							;an absolute equivalent.  this is because
3320:							;having relocated the user jr instruction
3321:							;into execbf we will undoubtedly be out of
3322:							;range of the destination.
3323:			
3324:	14DB  0E06    	G550:	LD	C,Z802CL	;check if this is relative jump
3325:	14DD  21452A  		LD	HL,Z802C
3326:	14E0  A7      		AND	A		;clear carry
3327:	14E1  EDB1    		CPIR
3328:	14E3  2020    		JR	NZ,G600		;not a jr
3329:	14E5  79      		LD	A,C
3330:	14E6  01452A  		LD	BC,Z802C
3331:	14E9  ED42    		SBC	HL,BC
3332:	14EB  2B      		DEC	HL
3333:	14EC  015C2A  		LD	BC,Z803C
3334:	14EF  09      		ADD	HL,BC		;point to equivalent absolute jump
3335:	14F0  A7      		AND	A
3336:	14F1  7E      		LD	A,(HL)
3337:	14F2  21F32E  		LD	HL,EXECBF
3338:	14F5  2005    		JR	NZ,G555		;nz - not last in list (not djnz)
3339:			
3340:							;replace djnz with  dec   b
3341:							;		    jp    nz,
3342:			
3343:	14F7  3605    		LD	(HL),05		;dec b instruction
3344:	14F9  23      		INC	HL
3345:	14FA  3EC2    		LD	A,0C2H		;jp nz absolute
3346:	14FC  77      	G555:	LD	(HL),A
3347:	14FD  23      		INC	HL
3348:	14FE  ED4B022F		LD	BC,(JROPND)	;if this is a conditional jr we need the
3349:							;absolute destination of the jump
3350:	1502  71      		LD	(HL),C
3351:	1503  23      		INC	HL
3352:	1504  70      		LD	(HL),B
3353:			
3354:	1505  FD2A892F	G600:	LD	IY,(IYREG)	;restore user iy
3355:	1509  DD2A872F		LD	IX,(IXREG)	;restore user ix
3356:	150D  3A8B2F  		LD	A,(RREG)
3357:	1510  ED4F    		LD	R,A		;restore user r	reg
3358:	1512  3A8C2F  		LD	A,(IREG)
3359:	1515  ED47    		LD	I,A		;restore user i	reg
3360:	1517  ED4B7D2F		LD	BC,(BCPREG)	;restore user grade a prime regs
3361:	151B  ED5B7F2F		LD	DE,(DEPREG)
3362:	151F  2A7B2F  		LD	HL,(AFPREG)
3363:	1522  E5      		PUSH	HL
3364:	1523  F1      		POP	AF
3365:	1524  2A812F  		LD	HL,(HLPREG)
3366:	1527  08      		EX	AF,AF'
3367:	1528  D9      		EXX
3368:	1529  2A732F  		LD	HL,(AFREG)	;restore user accumulator and flag
3369:	152C  E5      		PUSH	HL
3370:	152D  F1      		POP	AF
3371:	152E  ED4B752F		LD	BC,(BCREG)	;restore user bc
3372:	1532  ED5B772F		LD	DE,(DEREG)	;restore user de
3373:	1536  2A792F  		LD	HL,(HLREG)	;restore user hl
3374:	1539  ED7B852F		LD	SP,(SPREG)	;restore user sp
3375:	153D  C3FA2E  		JP	SJMP
3377:			;******************************************************************************
3378:			;*
3379:			;*	step:  Single step (trace) routine
3380:			;*
3381:			;*	Call zlen to determine where to	set breakpoint.
3382:			;*
3383:			;*		pass:	   de -	current	pc address
3384:			;*
3385:			;*		returned:  b:  z - next	instruction will not modify pc.
3386:			;*				   set bp at address specified by pc+length.
3387:			;*
3388:			;*			   b: nz - next	instruction will modify	pc (jumps,
3389:			;*				   calls, and returns) thus set	bp at address
3390:			;*				   returned in hl.
3391:			;*
3392:			;*			   c:	 - number of bytes in current instruction.
3393:			;*
3394:			;*		zlen handles secondary breakpoint to set for all conditional
3395:			;*		call, return, and jump instructions.
3396:			;*
3397:			;*	Call brk00 to set breakpoint.
3398:			;*
3399:			;*		pass:	   b - current number of breakpoints.
3400:			;*			  hl - address at which	to set breakpoint.
3401:			;*
3402:			;*	entry point step:    entered by	user via (s)ingle step command.
3403:			;*	entry point step40:  entered by	breakpoint handler - step count	nz
3404:			;*
3405:			;*	exit:	to go routine to resume	execution.
3406:			;*
3407:			;******************************************************************************
3408:			
3409:	1540  3EFF    	STEP:	LD	A,0FFH
3410:	1542  32EC2E  		LD	(WFLAG),A	;set trace subroutine flag on
3411:	1545  CD8727  		CALL	IEDTBC		;query user for	trace count
3412:	1548  210100  		LD	HL,0001
3413:	154B  FA7815  		JP	M,STEP40	;null input - step count of one
3414:	154E  CD2B1A  		CALL	PRSR
3415:	1551  C27C0D  		JP	NZ,EXXX
3416:	1554  1A      		LD	A,(DE)		;first character from parse buffer
3417:	1555  D62F    		SUB	'/'
3418:	1557  32EC2E  		LD	(WFLAG),A	;may be	slash -	no subroutine tracing
3419:	155A  210000  		LD	HL,00
3420:	155D  2009    		JR	NZ,STEP20
3421:	155F  12      		LD	(DE),A
3422:	1560  3AD62F  		LD	A,(INBFNC)
3423:	1563  3D      		DEC	A
3424:	1564  23      		INC	HL
3425:	1565  2811    		JR	Z,STEP40
3426:	1567  2B      		DEC	HL
3427:	1568  CDC418  	STEP20:	CALL	XVAL		;evaluate contents of parse buffer
3428:	156B  C27C0D  		JP	NZ,EXXX
3429:	156E  ED5B832F		LD	DE,(PCREG)
3430:	1572  1A      		LD	A,(DE)		;first byte of op code at current pc
3431:	1573  FEC7    		CP	0C7H		;test for rst
3432:	1575  CA7C0D  		JP	Z,EXXX		;no tracing of rsts
3433:	1578  22ED2E  	STEP40:	LD	(NSTEP),HL	;save step count
3434:	157B  21EF2E  		LD	HL,SBPS		;set step flag nz - trace in effect
3435:	157E  34      		INC	(HL)
3436:	157F  ED5B832F		LD	DE,(PCREG)	;fetch current pc
3437:	1583  CDC81A  		CALL	ZLEN00		;determine number of bytes in instruction
3438:	1586  04      		INC	B		;test where to set breakpoint
3439:	1587  1002    		DJNZ	STEP50		;nz - set at address in	hl
3440:	1589  EB      		EX	DE,HL
3441:	158A  09      		ADD	HL,BC		;z - set at address pc + instruction length
3442:	158B  3AF02E  	STEP50:	LD	A,(BPS)		;get current number of bps
3443:	158E  47      		LD	B,A		;pass to set bp	routine	in b reg
3444:	158F  EB      		EX	DE,HL		;de - bp address to set
3445:	1590  CDFD12  		CALL	BRK30
3446:	1593  2A832F  		LD	HL,(PCREG)	;resume	execution at next pc
3447:	1596  AF      		XOR	A
3448:	1597  B0      		OR	B
3449:	1598  C23E14  		JP	NZ,G100		;nz - collision	with user bp
3450:	159B  EB      		EX	DE,HL
3451:	159C  21EF2E  		LD	HL,SBPS		;step bp set by	brk30 -	bump count
3452:	159F  34      		INC	(HL)
3453:	15A0  EB      		EX	DE,HL
3454:	15A1  C33E14  		JP	G100
3456:			;******************************************************************************
3457:			;*
3458:			;*	asmblr:	z80 assembler
3459:			;*
3460:			;******************************************************************************
3461:			
3462:	15A4          	ASMBLR:
3463:	15A4  CD5E26  		CALL	ILIN
3464:	15A7  C27C0D  		JP	NZ,EXXX
3465:	15AA  CD1026  	ASM000:	CALL	CRLF
3466:	15AD  22E02E  		LD	(ZASMPC),HL	;save here as well
3467:	15B0  CD6120  		CALL	ZASM08		;disassemble first instruction
3468:			
3469:	15B3          	ASM005:
3470:	15B3  2AE02E  		LD	HL,(ASMBPC)
3471:	15B6  CD1026  	ASM010:	CALL	CRLF
3472:	15B9  CD3926  		CALL	OUTADR		;display current assembly pc
3473:	15BC  0E16    		LD	C,22		;
3474:	15BE  CD2926  		CALL	SPACES		;leave room for	object code
3475:	15C1  3E03    		LD	A,3
3476:	15C3  21D12F  		LD	HL,OBJBUF	;zero scratch object code buffer
3477:	15C6  71      	ASM015:	LD	(HL),C
3478:	15C7  23      		INC	HL
3479:	15C8  3D      		DEC	A
3480:	15C9  F2C615  		JP	P,ASM015
3481:	15CC  32E42E  		LD	(OPRN01),A	;init operand key values to 0ffh
3482:	15CF  32E72E  		LD	(OPRN02),A
3483:	15D2  CD8727  		CALL	IEDTBC		;get user input
3484:	15D5  F8      		RET	M		;m - no	input ends command
3485:	15D6  CD1A26  		CALL	CRET
3486:	15D9  CD2B1A  		CALL	PRSR		;parse to obtain label
3487:	15DC  7E      		LD	A,(HL)		;check last character
3488:	15DD  FE3A    		CP	':'
3489:	15DF  202B    		JR	NZ,ASM040	;no colon found	- must be op code
3490:	15E1  3600    		LD	(HL),0		;erase colon
3491:	15E3  1A      		LD	A,(DE)		;fetch first char of label from	parse buffer
3492:	15E4  FE41    		CP	'A'
3493:	15E6  DA7A1A  		JP	C,ASMXXL	;error - first character must be alpha
3494:	15E9  FE7B    		CP	'z'+1
3495:	15EB  D27A1A  		JP	NC,ASMXXL	;label error
3496:	15EE  FE61    		CP	'a'
3497:	15F0  3005    		JR	NC,ASM030
3498:	15F2  FE5B    		CP	'Z'+1
3499:	15F4  D27A1A  		JP	NC,ASMXXL
3500:	15F7  210000  	ASM030:	LD	HL,00
3501:	15FA  22002F  		LD	(ISYMPT),HL	;clear pointer
3502:	15FD  CD071A  		CALL	ISYM		;attempt to insert symbol into symbol table
3503:	1600  C28A1A  		JP	NZ,ASMXXT	;error - symbol	table full
3504:	1603  22002F  		LD	(ISYMPT),HL	;save pointer to symbol	value in symbol	table
3505:	1606  CD2B1A  		CALL	PRSR		;extract opcode
3506:	1609  FAB315  		JP	M,ASM005	;m - statement contains	label only
3507:	160C  3AF42E  	ASM040:	LD	A,(DELIM)	;check delimeter
3508:	160F  FE2C    		CP	','		;check for invalid terminator
3509:	1611  CA7E1A  		JP	Z,ASMXXO
3510:	1614  0E49    		LD	C,73		;number	of opcodes in table as index
3511:	1616  0D      	ASM050:	DEC	C
3512:	1617  FA7E1A  		JP	M,ASMXXO	;opcode	not found
3513:	161A  0600    		LD	B,0
3514:	161C  21842D  		LD	HL,ZOPCNM	;table of opcode names
3515:	161F  09      		ADD	HL,BC
3516:	1620  09      		ADD	HL,BC		;index times four
3517:	1621  09      		ADD	HL,BC
3518:	1622  09      		ADD	HL,BC
3519:	1623  112930  		LD	DE,PRSBF	;start of parse	buffer
3520:	1626  0604    		LD	B,4
3521:	1628  1A      	ASM060:	LD	A,(DE)		;character from	parse buffer
3522:	1629  A7      		AND	A		;null?
3523:	162A  2002    		JR	NZ,ASM070
3524:	162C  3E20    		LD	A,' '		;for comparison	purposes
3525:	162E  CD0726  	ASM070:	CALL	IXLT		;force upper case for compare
3526:	1631  BE      		CP	(HL)
3527:	1632  20E2    		JR	NZ,ASM050	;mismatch - next opcode	name
3528:	1634  13      		INC	DE
3529:	1635  23      		INC	HL
3530:	1636  10F0    		DJNZ	ASM060		;must match all	four
3531:	1638  1A      		LD	A,(DE)		;null following	opcode?
3532:	1639  A7      		AND	A
3533:	163A  C27E1A  		JP	NZ,ASMXXO	;error - opcode	more than 4 characaters
3534:	163D  21FA2E  		LD	HL,IKEY		;relative position in table is key value
3535:	1640  71      		LD	(HL),C		;save opcode key value
3536:	1641  CD2B1A  		CALL	PRSR		;extract first operand
3537:	1644  FA6F16  		JP	M,ASM085	;m - none
3538:	1647  CD2A18  		CALL	OPRN		;evaluate operand
3539:	164A  2047    		JR	NZ,ASMXXU	;error - bad first operand
3540:	164C  11E42E  		LD	DE,OPRN01
3541:	164F  CDB81A  		CALL	OPNV		;save operand value and	key
3542:	1652  3AF42E  		LD	A,(DELIM)
3543:	1655  FE2C    		CP	','
3544:	1657  2016    		JR	NZ,ASM085	;need comma for	two operands
3545:	1659  CD2B1A  		CALL	PRSR		;extract second	operand
3546:	165C  FA861A  		JP	M,ASMXXS	;error - comma with no second operand
3547:	165F  FE2C    		CP	','
3548:	1661  CA861A  		JP	Z,ASMXXS	;illegal line termination
3549:	1664  CD2A18  		CALL	OPRN		;evaluate operand
3550:	1667  202A    		JR	NZ,ASMXXU	;error - bad second operand
3551:	1669  11E72E  		LD	DE,OPRN02
3552:	166C  CDB81A  		CALL	OPNV		;save second operand value and key
3553:	166F  AF      	ASM085:	XOR	A
3554:	1670  4F      		LD	C,A
3555:	1671  21842A  	ASM090:	LD	HL,ZOPCPT	;opcode	name pointer table
3556:	1674  0600    		LD	B,0
3557:	1676  09      		ADD	HL,BC		;index into table
3558:	1677  3AFA2E  		LD	A,(IKEY)	;fetch opcode key value
3559:	167A  BE      		CP	(HL)		;check for match
3560:	167B  2013    		JR	NZ,ASM095	;
3561:	167D  24      		INC	H		;point to first	operand	table
3562:	167E  11E42E  		LD	DE,OPRN01	;address of first operand key value
3563:	1681  CD5F17  		CALL	OPNM		;check validity
3564:	1684  200A    		JR	NZ,ASM095	;no match - next
3565:	1686  47      		LD	B,A		;save modified key value
3566:	1687  24      		INC	H		;point to second operand table
3567:	1688  11E72E  		LD	DE,OPRN02	;address of second operand key value
3568:	168B  CD5F17  		CALL	OPNM
3569:	168E  2808    		JR	Z,IBLD		;match - attempt final resolution
3570:	1690  0C      	ASM095:	INC	C		;bump index
3571:	1691  20DE    		JR	NZ,ASM090	;nz - check more
3572:	1693  3E55    	ASMXXU:	LD	A,'U'		;error
3573:	1695  C3901A  		JP	ASMXXX
3574:			
3575:			
3576:			
3577:			
3578:	1698  21D12F  	IBLD:	LD	HL,OBJBUF	;object	code temp buffer
3579:	169B  5F      		LD	E,A		;save second operand key
3580:	169C  7E      		LD	A,(HL)		;check first byte of object buffer
3581:	169D  A7      		AND	A		;null?
3582:	169E  79      		LD	A,C		;instruction key to accumulator	regardless
3583:	169F  4B      		LD	C,E		;save second operand modified key
3584:	16A0  2801    		JR	Z,IBLD00	;z - not ix or iy instruction
3585:	16A2  23      		INC	HL		;point to byte two of object code
3586:	16A3  FE40    	IBLD00:	CP	40H
3587:	16A5  3844    		JR	C,IBLD55	;c - 8080 instruction
3588:	16A7  FEA0    		CP	0A0H
3589:	16A9  300B    		JR	NC,IBLD10	;nc - not ed instruction
3590:	16AB  36ED    		LD	(HL),0EDH	;init byte one of object code
3591:	16AD  23      		INC	HL
3592:	16AE  FE80    		CP	80H		;check which ed	instruction we have
3593:	16B0  3839    		JR	C,IBLD55	;c - this is exact object byte
3594:	16B2  C620    		ADD	A,20H		;add bias to obtain object byte
3595:	16B4  1835    		JR	IBLD55
3596:	16B6  FEE0    	IBLD10:	CP	0E0H
3597:	16B8  3004    		JR	NC,IBLD20
3598:	16BA  C620    		ADD	A,20H		;8080 type - range 0c0h	to 0ffh
3599:	16BC  182D    		JR	IBLD55		;object	byte built
3600:	16BE  FEE8    	IBLD20:	CP	0E8H
3601:	16C0  3824    		JR	C,IBLD50	;8 bit reg-reg arithmetic or logic
3602:	16C2  FEF7    		CP	0F7H		;check for halt	disguised as ld (hl),(hl)
3603:	16C4  2004    		JR	NZ,IBLD30
3604:	16C6  3E76    		LD	A,76H		;halt object code
3605:	16C8  1821    		JR	IBLD55
3606:	16CA  FEF8    	IBLD30:	CP	0F8H
3607:	16CC  3018    		JR	NC,IBLD50	;8 bit reg-reg load
3608:	16CE  57      		LD	D,A		;temp save instruction key value
3609:	16CF  3AD12F  		LD	A,(OBJBUF)
3610:	16D2  A7      		AND	A		;check for previously stored first object byte
3611:	16D3  7A      		LD	A,D
3612:	16D4  36CB    		LD	(HL),0CBH	;init byte regardless
3613:	16D6  23      		INC	HL
3614:	16D7  2801    		JR	Z,IBLD40	;z - not ix or iy instruction
3615:	16D9  23      		INC	HL		;bump object code pointer - this is four byter
3616:	16DA  C6A8    	IBLD40:	ADD	A,0A8H		;add bias for comparison purposes
3617:	16DC  FE98    		CP	98H
3618:	16DE  3806    		JR	C,IBLD50	;c - shift or rotate instruction
3619:	16E0  0F      		RRCA
3620:	16E1  0F      		RRCA
3621:	16E2  E6C0    		AND	0C0H		;this is skeleton for bit instuctions
3622:	16E4  1805    		JR	IBLD55
3623:	16E6  87      	IBLD50:	ADD	A,A		;form skeleton
3624:	16E7  87      		ADD	A,A
3625:	16E8  87      		ADD	A,A
3626:	16E9  C680    		ADD	A,80H
3627:	16EB  77      	IBLD55:	LD	(HL),A		;store object byte
3628:	16EC  AF      		XOR	A
3629:	16ED  B1      		OR	C		;second	operand	need more processing?
3630:	16EE  11E72E  		LD	DE,OPRN02
3631:	16F1  C49D17  		CALL	NZ,RSLV		;resolve second	operand
3632:	16F4  C28E1A  		JP	NZ,ASMXXV	;error - invalid operand size
3633:	16F7  11E42E  		LD	DE,OPRN01
3634:	16FA  78      		LD	A,B
3635:	16FB  A7      		AND	A		;first operand resolvedX
3636:	16FC  C49D17  		CALL	NZ,RSLV		;more work to do
3637:	16FF  C28E1A  		JP	NZ,ASMXXV	;error - invalid operand size
3638:	1702  3AFA2E  		LD	A,(IKEY)
3639:	1705  D643    		SUB	67		;org directive?
3640:	1707  2007    		JR	NZ,IBLD60
3641:	1709  56      		LD	D,(HL)
3642:	170A  2B      		DEC	HL
3643:	170B  5E      		LD	E,(HL)
3644:	170C  EB      		EX	DE,HL
3645:	170D  C3AA15  		JP	ASM000		;z - org directive
3646:	1710  11D12F  	IBLD60:	LD	DE,OBJBUF
3647:	1713  3831    		JR	C,IBLD70	;c - instruction  nc - directive
3648:	1715  47      		LD	B,A		;number	of bytes for defb or defw or ddb
3649:	1716  13      		INC	DE		;point past erroneous assembled	opcode
3650:	1717  13      		INC	DE
3651:	1718  D603    		SUB	3		;test for ddb
3652:	171A  382E    		JR	C,IBLD75	;c - must be defb or defw
3653:	171C  3D      		DEC	A
3654:	171D  201E    		JR	NZ,IBLD65	;nz - must be ddb
3655:	171F  56      		LD	D,(HL)		;must be equ
3656:	1720  2B      		DEC	HL
3657:	1721  5E      		LD	E,(HL)
3658:	1722  2A002F  		LD	HL,(ISYMPT)	;fetch pointer to entry	in symbol table
3659:	1725  7C      		LD	A,H
3660:	1726  B5      		OR	L
3661:	1727  CA9316  		JP	Z,ASMXXU	;error - no label on equ statement
3662:	172A  72      		LD	(HL),D
3663:	172B  2B      		DEC	HL
3664:	172C  73      		LD	(HL),E		;store value of	symbol in symbol table
3665:	172D  0E06    		LD	C,6
3666:	172F  CD2926  		CALL	SPACES
3667:	1732  7A      		LD	A,D
3668:	1733  CD1F26  		CALL	OTHXSP
3669:	1736  7B      		LD	A,E
3670:	1737  CD1F26  		CALL	OTHXSP
3671:	173A  C3B315  		JP	ASM005		;ready for next	input
3672:	173D  05      	IBLD65:	DEC	B		;set count of object bytes to 2
3673:	173E  4E      		LD	C,(HL)		;exchange hi and lo order bytes	for ddb
3674:	173F  2B      		DEC	HL
3675:	1740  7E      		LD	A,(HL)
3676:	1741  71      		LD	(HL),C		;new hi order
3677:	1742  23      		INC	HL
3678:	1743  77      		LD	(HL),A		;new hi order replaces old lo order
3679:	1744  1804    		JR	IBLD75
3680:	1746  CDC81A  	IBLD70:	CALL	ZLEN00		;compute length	of instruction in bytes
3681:	1749  41      		LD	B,C		;b - number of bytes of	object code
3682:	174A  2AE02E  	IBLD75:	LD	HL,(ASMBPC)
3683:	174D  CD3926  		CALL	OUTADR		;re-display current location counter
3684:	1750  1A      	IBLD80:	LD	A,(DE)		;move from scratch object buffer
3685:	1751  77      		LD	(HL),A		;into address pointed to by location counter
3686:	1752  23      		INC	HL
3687:	1753  13      		INC	DE
3688:	1754  CD1F26  		CALL	OTHXSP		;display each object code byte
3689:	1757  10F7    		DJNZ	IBLD80
3690:	1759  22E02E  	IBLD90:	LD	(ASMBPC),HL
3691:	175C  C3B315  		JP	ASM005		;next input from user
3692:			
3693:			
3694:			
3695:			
3696:	175F  1A      	OPNM:	LD	A,(DE)		;key value computed by operand routine
3697:	1760  AE      		XOR	(HL)		;compare with table operand table entry
3698:	1761  C8      		RET	Z		;true match of operand key values
3699:	1762  AE      		XOR	(HL)		;restore
3700:	1763  87      		ADD	A,A		;86 all	no operand key values (0ffh)
3701:	1764  F8      		RET	M
3702:	1765  7E      		LD	A,(HL)		;fetch table entry
3703:	1766  E67F    		AND	7FH		;sans paren flag for comparison	purposes
3704:	1768  FE1B    		CP	1BH		;check table entry 8 bit - 16 bit - $ rel ?
3705:	176A  380B    		JR	C,OPNM00	;c - none of the above
3706:	176C  1A      		LD	A,(DE)		;fetch computed	key
3707:	176D  AE      		XOR	(HL)		;compare with paren flags
3708:	176E  F8      		RET	M		;error - paren mismatch
3709:	176F  1A      		LD	A,(DE)		;fetch key once	more
3710:	1770  E67F    		AND	7FH		;remove	paren flag
3711:	1772  FE17    		CP	17H		;computed as 8 bit - 16	bit - $	rel?
3712:	1774  2820    		JR	Z,OPNM40	;so far	so good
3713:	1776  C9      		RET			;
3714:	1777  FE19    	OPNM00:	CP	19H		;check for 8 bit reg
3715:	1779  300C    		JR	NC,OPNM20	;8 bit register	match
3716:	177B  FE18    		CP	18H		;table says must be hl - ix - iy
3717:	177D  C0      		RET	NZ		;computed key disagrees
3718:	177E  1A      		LD	A,(DE)		;fetch computed	key
3719:	177F  E607    		AND	7		;computed as hl	- ix - iy ?
3720:	1781  C0      		RET	NZ		;no
3721:	1782  1A      	OPNM10:	LD	A,(DE)		;fetch computed	key
3722:	1783  AE      		XOR	(HL)
3723:	1784  F8      		RET	M		;error - paren mismatch	on hl -	ix - iy
3724:	1785  180F    		JR	OPNM40
3725:	1787  1A      	OPNM20:	LD	A,(DE)		;fetch computed	key of 8 bit reg
3726:	1788  A7      		AND	A		;
3727:	1789  2002    		JR	NZ,OPNM30	;nz - not (hl)
3728:	178B  3D      		DEC	A		;error - 8 bit (hl) missing parens
3729:	178C  C9      		RET
3730:	178D  FE08    	OPNM30:	CP	8		;test user entered valid 8 bit reg
3731:	178F  3805    		JR	C,OPNM40	;c - ok
3732:	1791  A7      		AND	A		;test if no carry caused by paren flag
3733:	1792  F0      		RET	P		;error - this is not 8 bit reg with parens
3734:	1793  E607    		AND	7		;psuedo	8 bit reg: (hl)	(ix) (iy)?
3735:	1795  C0      		RET	NZ		;no
3736:	1796  7E      	OPNM40:	LD	A,(HL)		;fetch table entry
3737:	1797  E67F    		AND	7FH
3738:	1799  D618    		SUB	18H		;make values 18	thru 1f	relative zero
3739:	179B  BF      		CP	A		;zero means match
3740:	179C  C9      		RET
3741:			
3742:	179D  3D      	RSLV:	DEC	A
3743:	179E  2804    		JR	Z,RSLV00	;z - 8 bit reg (bits 0-2 of object byte)
3744:	17A0  3D      		DEC	A
3745:	17A1  2011    		JR	NZ,RSLV20	;nz - not 8 bit	reg (bits 3-5 of object	byte)
3746:	17A3  3D      		DEC	A		;make neg to indicate shift left required
3747:	17A4  4F      	RSLV00:	LD	C,A
3748:	17A5  1A      		LD	A,(DE)		;fetch computed	operand	key
3749:	17A6  E607    		AND	07		;lo three bits specify reg
3750:	17A8  EE06    		XOR	6		;create	true object code bits
3751:	17AA  0C      		INC	C		;test if bits 0-2 or bits 3-5
3752:	17AB  2003    		JR	NZ,RSLV10	;nz - 0	thru 2
3753:	17AD  87      		ADD	A,A
3754:	17AE  87      		ADD	A,A
3755:	17AF  87      		ADD	A,A
3756:	17B0  B6      	RSLV10:	OR	(HL)		;or with skeleton
3757:	17B1  77      		LD	(HL),A		;into scratch object buffer
3758:	17B2  BF      		CP	A		;set zero - no error
3759:	17B3  C9      		RET
3760:	17B4  13      	RSLV20:	INC	DE		;point to low order of operand value
3761:	17B5  4E      		LD	C,(HL)		;c - current skeleton  (if needed)
3762:	17B6  23      		INC	HL		;bump object code buffer pointer
3763:	17B7  3D      		DEC	A
3764:	17B8  201D    		JR	NZ,RSLV30	;nz - not relative jump
3765:	17BA  EB      		EX	DE,HL		;save object code pointer in de
3766:	17BB  7E      		LD	A,(HL)
3767:	17BC  23      		INC	HL
3768:	17BD  66      		LD	H,(HL)
3769:	17BE  6F      		LD	L,A		;hl - operand value computed by	xval
3770:	17BF  78      		LD	A,B
3771:	17C0  ED4BE02E		LD	BC,(ASMBPC)	;current location counter
3772:	17C4  03      		INC	BC
3773:	17C5  03      		INC	BC
3774:	17C6  ED42    		SBC	HL,BC		;calculate displacement	from current counter
3775:	17C8  EB      		EX	DE,HL		;de - displacement  hl - object	code pointer
3776:	17C9  47      		LD	B,A		;restore b reg
3777:	17CA  7B      		LD	A,E		;lo order displacement
3778:	17CB  14      		INC	D		;test hi order
3779:	17CC  2803    		JR	Z,RSLV25	;must have been	ff (backward displacement)
3780:	17CE  15      		DEC	D
3781:	17CF  C0      		RET	NZ		;error - hi order not zero or ff
3782:	17D0  2F      		CPL			;set sign bit for valid	forward	displacement
3783:	17D1  EE80    	RSLV25:	XOR	80H		;toggle	sign bit
3784:	17D3  F8      		RET	M		;error - sign bit disagrees with upper byte
3785:	17D4  73      		LD	(HL),E		;store displacement object byte
3786:	17D5  BF      		CP	A		;set zero flag - no errors
3787:	17D6  C9      		RET
3788:	17D7  3D      	RSLV30:	DEC	A
3789:	17D8  2014    		JR	NZ,RSLV40	;nz - not 8 bit	immediate
3790:	17DA  3E36    		LD	A,36H		;test for reg indirect - (hl),nn
3791:	17DC  B9      		CP	C
3792:	17DD  2007    		JR	NZ,RSLV35
3793:	17DF  3AD12F  		LD	A,(OBJBUF)	;test first object byte
3794:	17E2  B9      		CP	C
3795:	17E3  2801    		JR	Z,RSLV35	;z - (hl),nn
3796:	17E5  23      		INC	HL		;must be (ix+index),nn	or  (iy+index),nn
3797:	17E6  1A      	RSLV35:	LD	A,(DE)		;move lo order operand value to	object buffer
3798:	17E7  77      		LD	(HL),A
3799:	17E8  13      		INC	DE
3800:	17E9  1A      		LD	A,(DE)		;test hi order
3801:	17EA  A7      		AND	A		;
3802:	17EB  C8      		RET	Z		;z - must be 0 thru +255
3803:	17EC  3C      		INC	A		;error if not -1 thru -256
3804:	17ED  C9      		RET
3805:	17EE  3D      	RSLV40:	DEC	A
3806:	17EF  2008    		JR	NZ,RSLV50	;nz - not 16 bit operand
3807:	17F1  1A      		LD	A,(DE)		;move both bytes of operand to object buffer
3808:	17F2  77      		LD	(HL),A
3809:	17F3  23      		INC	HL
3810:	17F4  13      		INC	DE
3811:	17F5  1A      		LD	A,(DE)		;byte two
3812:	17F6  77      		LD	(HL),A
3813:	17F7  BF      		CP	A		;set zero flag - no errors of course
3814:	17F8  C9      		RET
3815:	17F9  3D      	RSLV50:	DEC	A		;test restart instruction or bit number
3816:	17FA  200D    		JR	NZ,RSLV60	;nz - bit or interrupt mode number
3817:	17FC  1A      		LD	A,(DE)		;check restart value specified
3818:	17FD  E6C7    		AND	0C7H		;betweed 0 and 38h?
3819:	17FF  C0      		RET	NZ		;error
3820:	1800  1A      		LD	A,(DE)		;fetch lo order	operand	value
3821:	1801  F6C7    		OR	0C7H		;or with instruction skeleton
3822:	1803  2B      		DEC	HL
3823:	1804  77      		LD	(HL),A		;rewind	object code pointer
3824:	1805  13      		INC	DE
3825:	1806  1A      		LD	A,(DE)		;check hi order	operand	value
3826:	1807  A7      		AND	A		;error if not zero
3827:	1808  C9      		RET
3828:	1809  2B      	RSLV60:	DEC	HL		;rewind	object code buffer pointer
3829:	180A  1A      		LD	A,(DE)
3830:	180B  E6F8    		AND	0F8H		;ensure	bit number in range 0 -	7
3831:	180D  C0      		RET	NZ		;error
3832:	180E  3AFA2E  		LD	A,(IKEY)	;fetch opcode key value
3833:	1811  D613    		SUB	13H		;is this bit number of interrupt mode number?
3834:	1813  1A      		LD	A,(DE)		;fetch operand value regardless
3835:	1814  200D    		JR	NZ,RSLV70	;nz - bit number
3836:	1816  3646    		LD	(HL),46H
3837:	1818  E603    		AND	03		;im 0?
3838:	181A  C8      		RET	Z
3839:	181B  3656    		LD	(HL),56H
3840:	181D  3D      		DEC	A		;im 1?
3841:	181E  C8      		RET	Z
3842:	181F  365E    		LD	(HL),5EH
3843:	1821  3D      		DEC	A		;error if not im 2
3844:	1822  C9      		RET
3845:	1823  87      	RSLV70:	ADD	A,A		;shift bit number left three
3846:	1824  87      		ADD	A,A
3847:	1825  87      		ADD	A,A
3848:	1826  B6      		OR	(HL)		;or with skeleton
3849:	1827  77      		LD	(HL),A
3850:	1828  BF      		CP	A		;indicate no error
3851:	1829  C9      		RET
3852:			
3853:			
3854:			
3855:	182A  011600  	OPRN:	LD	BC,22		;count of reserved operand
3856:	182D  112930  	OPRN00:	LD	DE,PRSBF	;buffer	contains operand
3857:	1830  7E      		LD	A,(HL)		;last character	of operand in parse buffer
3858:	1831  D629    		SUB	')'
3859:	1833  2007    		JR	NZ,OPRN20	;not paren
3860:	1835  77      		LD	(HL),A		;remove	trailing paren - replace with null
3861:	1836  1A      		LD	A,(DE)		;check first character of parse	buffer
3862:	1837  D628    		SUB	'('
3863:	1839  C0      		RET	NZ		;error - unbalanced parens
3864:	183A  12      		LD	(DE),A		;remove	leading	paren -	replace	with null
3865:	183B  13      		INC	DE		;point to next character in parse buffer
3866:	183C  210A29  	OPRN20:	LD	HL,ZOPNM	;index into reserved operand name table
3867:	183F  79      		LD	A,C
3868:	1840  87      		ADD	A,A		;index times two
3869:	1841  85      		ADD	A,L
3870:	1842  6F      		LD	L,A
3871:	1843  3001    		JR	NC,OPRN25
3872:	1845  24      		INC	H
3873:	1846  1A      	OPRN25:	LD	A,(DE)		;from parse buffer
3874:	1847  CD0726  		CALL	IXLT		;translate to upper case for compare
3875:	184A  BE      		CP	(HL)		;versus	table entry
3876:	184B  13      		INC	DE
3877:	184C  205D    		JR	NZ,OPRN70	;no match - check next
3878:	184E  1A      		LD	A,(DE)		;check second character
3879:	184F  CD0726  		CALL	IXLT		;translate to upper case
3880:	1852  A7      		AND	A		;if null - this	is one character reg name
3881:	1853  2002    		JR	NZ,OPRN30
3882:	1855  3E20    		LD	A,' '		;for comparison	purposes
3883:	1857  23      	OPRN30:	INC	HL		;bump table pointer
3884:	1858  96      		SUB	(HL)
3885:	1859  2050    		JR	NZ,OPRN70	;no match - check next
3886:	185B  13      		INC	DE		;have match - bump buffer pointer
3887:	185C  B0      		OR	B		;
3888:	185D  C0      		RET	NZ		;nz - mreg calling
3889:	185E  79      		LD	A,C		;check index value
3890:	185F  E607    		AND	07
3891:	1861  2050    		JR	NZ,OPRN80	;not hl	ix iy -	check for residue
3892:	1863  1A      		LD	A,(DE)
3893:	1864  CDB01A  		CALL	OPRTOR		;check for expression operator
3894:	1867  204D    		JR	NZ,OPRN85	;no operator but not end of operand
3895:	1869  3E18    		LD	A,RIX OR RIY	;special ix iy hl processing
3896:	186B  A1      		AND	C		;test for index	reg
3897:	186C  2805    		JR	Z,OPRN35	;z - must be hl
3898:	186E  E610    		AND	10H		;transform index into 0ddh or ofdh
3899:	1870  87      		ADD	A,A
3900:	1871  C6DD    		ADD	A,0DDH		;a - first byte	of index reg opcode
3901:	1873  4F      	OPRN35:	LD	C,A		;temp save first object	byte
3902:	1874  21D12F  		LD	HL,OBJBUF
3903:	1877  AE      		XOR	(HL)
3904:	1878  280A    		JR	Z,OPRN40	;z - first operand matches second
3905:	187A  B9      		CP	C
3906:	187B  C0      		RET	NZ		;illegal ix iy hl combination
3907:	187C  3AE42E  		LD	A,(OPRN01)
3908:	187F  A7      		AND	A		;test if index reg was first operand
3909:	1880  2002    		JR	NZ,OPRN40
3910:	1882  3D      		DEC	A		;error - hl illegal as second
3911:	1883  C9      		RET
3912:			
3913:			
3914:	1884  71      	OPRN40:	LD	(HL),C		;init first byte of object code
3915:	1885  3A2930  		LD	A,(PRSBF)
3916:	1888  A7      		AND	A		;check for previously removed parens
3917:	1889  79      		LD	A,C
3918:	188A  0E00    		LD	C,0
3919:	188C  2025    		JR	NZ,OPRN80	;no parens - no	indexed	displacement
3920:	188E  A7      		AND	A		;check for ix or iy indexed instruction
3921:	188F  2822    		JR	Z,OPRN80	;z - not index reg instruction
3922:			
3923:	1891  ED62    		SBC	HL,HL		;clear hl
3924:	1893  1A      		LD	A,(DE)		;index reg displacement	processing
3925:	1894  A7      		AND	A		;test for default displacement
3926:	1895  C4C418  		CALL	NZ,XVAL		;not zero - evaluate
3927:	1898  201C    		JR	NZ,OPRN85	;nz - displacement in error
3928:	189A  0E00    		LD	C,00
3929:	189C  7D      		LD	A,L
3930:	189D  32D32F  		LD	(OBJBUF+2),A	;displacement always third byte
3931:	18A0  24      		INC	H		;check upper byte of index value
3932:	18A1  2803    		JR	Z,OPRN50	;must have been	0ffh
3933:	18A3  25      		DEC	H
3934:	18A4  C0      		RET	NZ		;error - index not -128	to +127
3935:	18A5  2F      		CPL
3936:	18A6  EE80    	OPRN50:	XOR	80H		;check sign bit
3937:	18A8  F8      		RET	M		;bit on	- index	out of range
3938:	18A9  BF      		CP	A		;no error - set	zero flag
3939:	18AA  C9      		RET
3940:	18AB  0D      	OPRN70:	DEC	C		;decrement reserved operand table index
3941:	18AC  FAB618  		JP	M,OPRN85	;m - not a reserved operand
3942:	18AF  1B      		DEC	DE		;rewind	parse buffer pointer
3943:	18B0  C33C18  		JP	OPRN20		;next table entry
3944:	18B3  1A      	OPRN80:	LD	A,(DE)		;check for end of parse	buffer
3945:	18B4  A7      		AND	A
3946:	18B5  C8      		RET	Z		;found end of line null
3947:	18B6  112930  	OPRN85:	LD	DE,PRSBF	;rewind	to start of input
3948:	18B9  AF      		XOR	A
3949:	18BA  B0      		OR	B
3950:	18BB  C0      		RET	NZ		;nz - this was mreg calling
3951:	18BC  ED62    		SBC	HL,HL		;clear hl
3952:	18BE  CDC418  		CALL	XVAL		;evaluate operand
3953:	18C1  0E17    		LD	C,17H		;assume	numeric	operand	found
3954:	18C3  C9      		RET
3955:			
3956:			
3957:	18C4  1A      	XVAL:	LD	A,(DE)		;check first char of parse buffer
3958:	18C5  A7      		AND	A
3959:	18C6  2001    		JR	NZ,XVAL00
3960:	18C8  13      		INC	DE		;bump past previously removed paren
3961:	18C9  22FB2E  	XVAL00:	LD	(MEXP),HL	;init expression accumulator
3962:	18CC  AF      		XOR	A
3963:	18CD  32F62E  		LD	(BASE10),A	;clear upper digit decimal accumulator
3964:	18D0  ED62    		SBC	HL,HL		;clear hl
3965:	18D2  22042F  		LD	(FNDSYM),HL	;clear symbol found flag
3966:	18D5  22022F  		LD	(PASS2),HL
3967:	18D8  1A      	XVAL05:	LD	A,(DE)		;char from parse buffer
3968:	18D9  CD0726  		CALL	IXLT		;translate to upper case
3969:	18DC  4F      		LD	C,A		;save character
3970:	18DD  13      		INC	DE		;bump parse buffer pointer
3971:	18DE  FE30    		CP	'0'		;check for valid ascii hex digit
3972:	18E0  3833    		JR	C,XVAL25
3973:	18E2  FE3A    		CP	':'
3974:	18E4  3817    		JR	C,XVAL15
3975:	18E6  FE41    		CP	'A'
3976:	18E8  382B    		JR	C,XVAL25
3977:	18EA  FE47    		CP	'G'
3978:	18EC  3027    		JR	NC,XVAL25
3979:	18EE  AF      		XOR	A		;check number entered flag (b reg sign bit)
3980:	18EF  B0      		OR	B
3981:	18F0  FAF718  		JP	M,XVAL10	;m - this was not first	char
3982:	18F3  3AD72E  		LD	A,(SYMFLG)	;check if symbol table present in memory
3983:	18F6  A7      		AND	A
3984:	18F7  79      	XVAL10:	LD	A,C		;input character back to accumulator
3985:	18F8  F21519  		JP	P,XVAL25	;p - have symbol table or invalid hex digit
3986:	18FB  D607    		SUB	7
3987:	18FD  D630    	XVAL15:	SUB	'0'		;ascii hex to hex nibble
3988:	18FF  87      		ADD	A,A		;shift left five - hi bit of nibble to carry
3989:	1900  87      		ADD	A,A
3990:	1901  87      		ADD	A,A
3991:	1902  87      		ADD	A,A
3992:	1903  87      		ADD	A,A
3993:	1904  0E04    		LD	C,4		;loop count
3994:	1906  ED6A    	XVAL20:	ADC	HL,HL		;hl left into carry - rotate carry into	hl
3995:	1908  8F      		ADC	A,A		;next bit of nibble into carry
3996:	1909  0D      		DEC	C
3997:	190A  20FA    		JR	NZ,XVAL20
3998:	190C  32F62E  		LD	(BASE10),A	;store what was	shifted	left out of hl
3999:	190F  3E80    		LD	A,80H		;set sign of b - number	entered	flag
4000:	1911  B0      		OR	B
4001:	1912  47      		LD	B,A
4002:	1913  18C3    		JR	XVAL05		;next character
4003:			
4004:	1915  CDB01A  	XVAL25:	CALL	OPRTOR		;have expression operator?
4005:	1918  280D    		JR	Z,XVAL30
4006:	191A  3A022F  		LD	A,(PASS2)
4007:	191D  A7      		AND	A
4008:	191E  C0      		RET	NZ
4009:	191F  3A032F  		LD	A,(PASS2+1)
4010:	1922  A7      		AND	A
4011:	1923  CA3219  		JP	Z,XVAL35
4012:	1926  C9      		RET
4013:			
4014:	1927  AF      	XVAL30:	XOR	A
4015:	1928  B0      		OR	B		;check number entered flag
4016:	1929  79      		LD	A,C		;restore unmodified input character to a
4017:	192A  C2AC19  		JP	NZ,XVAL90	;nz - take care	of previous operator
4018:	192D  A7      		AND	A		;end of	line null?
4019:	192E  C8      		RET	Z		;
4020:	192F  41      		LD	B,C		;this operator was first char of parse buffer
4021:	1930  18A6    		JR	XVAL05		;extract what follows this leading operator
4022:			
4023:	1932  79      	XVAL35:	LD	A,C		;recover character
4024:	1933  FE23    		CP	'#'		;decimal processing?
4025:	1935  2029    		JR	NZ,XVAL50	;nz - not decimal
4026:	1937  78      		LD	A,B		;check number entered flag
4027:	1938  EE80    		XOR	80H		;toggle
4028:	193A  F8      		RET	M		;error - pound sign with no number
4029:	193B  47      		LD	B,A
4030:	193C  C5      		PUSH	BC
4031:	193D  D5      		PUSH	DE
4032:	193E  EB      		EX	DE,HL		;save hex number in de
4033:	193F  21F62E  		LD	HL,BASE10
4034:	1942  3E06    		LD	A,6
4035:	1944  BE      		CP	(HL)		;check ten thousands digit
4036:	1945  3814    		JR	C,XVAL40	;error - obviously greater than	65535
4037:	1947  ED67    		RRD			;nibble	to accumulator
4038:	1949  23      	 	INC	HL
4039:	194A  72      		LD	(HL),D		;store hex number in temp buffer
4040:	194B  23      		INC	HL
4041:	194C  73      		LD	(HL),E		;lo order hex number
4042:	194D  2B      		DEC	HL		;point back to upper byte
4043:	194E  5F      		LD	E,A
4044:	194F  AF      		XOR	A
4045:	1950  57      		LD	D,A		;de - hex nibble
4046:	1951  CD5828  		CALL	BCDX		;convert hi order byte
4047:	1954  2005    		JR	NZ,XVAL40	;nz - error detected during conversion
4048:	1956  23      		INC	HL		;bump to lo byte to convert
4049:	1957  CD5828  		CALL	BCDX
4050:	195A  EB      		EX	DE,HL		;hl - converted	value
4051:	195B  D1      	XVAL40:	POP	DE
4052:	195C  C1      		POP	BC
4053:	195D  2841    		JR	Z,XVAL65	;z - no	errors detected
4054:	195F  C9      		RET
4055:			
4056:			
4057:			
4058:	1960  FE27    	XVAL50:	CP	QUOTE		;ascii literal processing
4059:	1962  200F    		JR	NZ,XVAL60	;nz - not quote
4060:	1964  EB      		EX	DE,HL		;
4061:	1965  5E      		LD	E,(HL)		;fetch literal from buffer
4062:	1966  23      		INC	HL
4063:	1967  BE      		CP	(HL)		;trailing quote	found?
4064:	1968  2805    		JR	Z,XVAL55	;found
4065:	196A  53      		LD	D,E		;make literal just fetch hi order of operand
4066:	196B  5E      		LD	E,(HL)		;fetch new literal as lo order
4067:	196C  23      		INC	HL
4068:	196D  BE      		CP	(HL)		;trailing quote?
4069:	196E  C0      		RET	NZ		;error - more than two chars between quotes
4070:	196F  EB      	XVAL55:	EX	DE,HL		;de - parse buffer ptr	 hl - operand
4071:	1970  13      		INC	DE		;bump past trailing quote
4072:	1971  182D    		JR	XVAL65
4073:			
4074:			
4075:	1973  1B      	XVAL60:	DEC	DE		;point to start	of operand in parse buffer
4076:	1974  ED53022F		LD	(PASS2),DE
4077:	1978  CDC819  		CALL	FSYM		;search	symbol table
4078:	197B  CA9719  		JP	Z,XVAL62	;symbol	found
4079:	197E  1A      		LD	A,(DE)
4080:	197F  13      		INC	DE
4081:	1980  FE24    		CP	'$'		;check for pc relative expression
4082:	1982  C28A19  		JP	NZ,XVAL61
4083:	1985  2AE02E  		LD	HL,(ASMBPC)	;current location value	is expression value
4084:	1988  1816    		JR	XVAL65
4085:							;symbol not found - retry evaluation process
4086:							;with pass2 flag set.  now token must be a
4087:							;valid hex digit or error
4088:	198A  ED5B022F	XVAL61:	LD	DE,(PASS2)
4089:	198E  78      		LD	A,B
4090:	198F  F680    		OR	80H		;set sign in b - valid digit detected which
4091:							;tells xval this must be hex number
4092:	1991  47      		LD	B,A
4093:	1992  ED62    		SBC	HL,HL		;clear hex number accumulator
4094:	1994  C3D818  		JP	XVAL05
4095:	1997  3A062F  	XVAL62:	LD	A,(MAXLEN)	;point to last byte of sym table entry
4096:	199A  B5      		OR	L
4097:	199B  6F      		LD	L,A
4098:	199C  7E      		LD	A,(HL)		;hi order symbol address
4099:	199D  2B      		DEC	HL
4100:	199E  6E      		LD	L,(HL)		;lo order
4101:	199F  67      		LD	H,A
4102:	19A0  78      	XVAL65:	LD	A,B		;check number entered flag
4103:	19A1  A7      		AND	A
4104:	19A2  F8      		RET	M		;error - numbers entered previous to symbol
4105:	19A3  EE80    		XOR	80H		;toggle	flag
4106:	19A5  47      		LD	B,A
4107:	19A6  1A      		LD	A,(DE)		;check char following symbol name in buffer
4108:	19A7  4F      		LD	C,A		;make it new current character
4109:	19A8  13      		INC	DE
4110:	19A9  C32719  		JP	XVAL30
4111:			
4112:			
4113:			
4114:			
4115:			
4116:	19AC  4F      	XVAL90:	LD	C,A		;temp save operator
4117:	19AD  3E80    		LD	A,80H		;toggle	number entered flag
4118:	19AF  A8      		XOR	B
4119:	19B0  F8      		RET	M		;return	nz - consecutive operators
4120:	19B1  41      		LD	B,C		;new on	deck operator
4121:	19B2  FE2D    		CP	'-'		;test last operator
4122:	19B4  D5      		PUSH	DE		;save buffer pointer
4123:	19B5  2005    		JR	NZ,XVAL95	;nz - addition
4124:	19B7  EB      		EX	DE,HL
4125:	19B8  ED62    		SBC	HL,HL		;clear
4126:	19BA  ED52    		SBC	HL,DE		;force current value neg by subtraction from 0
4127:	19BC  EB      	XVAL95:	EX	DE,HL
4128:	19BD  2AFB2E  		LD	HL,(MEXP)	;fetch accumulated operand total
4129:	19C0  19      		ADD	HL,DE		;add in	current
4130:	19C1  D1      		POP	DE		;restore buffer	pointer
4131:	19C2  78      		LD	A,B		;check operator	that got us here
4132:	19C3  A7      		AND	A		;end of	line null?
4133:	19C4  C2C918  		JP	NZ,XVAL00	;no -
4134:	19C7  C9      		RET			;operand processing complete
4135:			
4136:			
4137:			
4138:	19C8          	FSYM:
4139:	19C8  2A0600  		LD	HL,(06)		;de - buffer   hl - symbol table
4140:	19CB  3A062F  	FSYM00:	LD	A,(MAXLEN)
4141:	19CE  A5      		AND	L
4142:	19CF  4F      		LD	C,A
4143:	19D0  78      		LD	A,B		;temp save
4144:	19D1  0600    		LD	B,0
4145:	19D3  EB      		EX	DE,HL		;de - symbol table ptr	hl - parse buffer
4146:	19D4  ED42    		SBC	HL,BC		;rewind	parse buffer to	start of symbol
4147:	19D6  EB      		EX	DE,HL		;de - parse buffer  hl - symbol	table pointer
4148:	19D7  47      		LD	B,A		;restore b reg
4149:	19D8  3A062F  		LD	A,(MAXLEN)
4150:	19DB  B5      		OR	L
4151:	19DC  6F      		LD	L,A
4152:	19DD  23      		INC	HL		;next block of symbol table
4153:	19DE  7E      		LD	A,(HL)		;first character of symbol name
4154:	19DF  3D      		DEC	A
4155:	19E0  F8      		RET	M		;end of	table
4156:	19E1  3A062F  		LD	A,(MAXLEN)
4157:	19E4  3D      		DEC	A
4158:	19E5  4F      		LD	C,A		;chars per symbol
4159:	19E6  1A      	FSYM10:	LD	A,(DE)		;fetch char from buffer
4160:	19E7  CDB01A  		CALL	OPRTOR
4161:	19EA  2008    		JR	NZ,FSYM20	;nz - not operator or end of line null
4162:	19EC  7E      		LD	A,(HL)
4163:	19ED  A7      		AND	A		;null means end	of symbol name in symbol table
4164:	19EE  20DB    		JR	NZ,FSYM00
4165:	19F0  22042F  		LD	(FNDSYM),HL	;set symbol found flag nz -
4166:	19F3  C9      		RET
4167:	19F4  BE      	FSYM20:	CP	(HL)
4168:	19F5  20D4    		JR	NZ,FSYM00
4169:	19F7  23      		INC	HL
4170:	19F8  13      		INC	DE
4171:	19F9  0D      		DEC	C
4172:	19FA  20EA    		JR	NZ,FSYM10
4173:	19FC  22042F  		LD	(FNDSYM),HL	;set symbol found flag nz -
4174:	19FF  1A      	FSYM30:	LD	A,(DE)
4175:	1A00  CDB01A  		CALL	OPRTOR
4176:	1A03  C8      		RET	Z
4177:	1A04  13      		INC	DE
4178:	1A05  18F8    		JR	FSYM30
4179:			
4180:			
4181:			
4182:	1A07  CDC819  	ISYM:	CALL	FSYM		;search	for symbol in table
4183:	1A0A  2806    		JR	Z,ISYM00	;z - symbol found
4184:	1A0C  7E      		LD	A,(HL)		;test for empty	slot in	table
4185:	1A0D  A7      		AND	A
4186:	1A0E  C0      		RET	NZ		;symbol	table full
4187:	1A0F  32D72E  		LD	(SYMFLG),A	;indicate non-empty symbol table
4188:	1A12  3A062F  	ISYM00:	LD	A,(MAXLEN)	;rewind	point to start of table	entry
4189:	1A15  4F      		LD	C,A
4190:	1A16  2F      		CPL
4191:	1A17  A5      		AND	L
4192:	1A18  6F      		LD	L,A
4193:	1A19  EB      		EX	DE,HL		;de - pointer to start of symbol
4194:	1A1A  212930  		LD	HL,PRSBF
4195:	1A1D  0600    		LD	B,0		;move symbol from parse	buffer to table
4196:	1A1F  0D      		DEC	C
4197:	1A20  EDB0    		LDIR
4198:	1A22  2AE02E  		LD	HL,(ASMBPC)	;fetch value of	symbol
4199:	1A25  EB      		EX	DE,HL		;hl - pointer to address storage
4200:	1A26  73      		LD	(HL),E		;lo order current location into	table
4201:	1A27  23      		INC	HL
4202:	1A28  72      		LD	(HL),D		;upper byte
4203:	1A29  AF      		XOR	A
4204:	1A2A  C9      		RET
4206:			;******************************************************************************
4207:			;*
4208:			;*	prsr:	command	line parse routine
4209:			;*
4210:			;*	prsr will extract one argument from the	input buffer (inbf) and
4211:			;*	write it into the parse	buffer (prsbf).	an argument is treated
4212:			;*	as starting with the first non-delimeter character encountered
4213:			;*	in the input buffer and ends with the next delimeter found.
4214:			;*	all intervening	characters between the two delimeters are
4215:			;*	treated	as the argument	and are	moved to prsbf.
4216:			;*
4217:			;*	as each character is extracted from inbf a zero is written back
4218:			;*	to replace it.  thus a program which needs to extract multiple args
4219:			;*	need not save pointers in between calls	since prsr is trained
4220:			;*	to strip leading delimeters while looking for the start	of an
4221:			;*	argument:
4222:			;*
4223:			;*	     delimeters: null, space, comma
4224:			;*
4225:			;*	exit:	    de - starting address of parse buffer
4226:			;*		     b - sign bit: set if unbalanced parens, else sign reset
4227:			;*			 bits 6-0: number of chars in the parse	buffer
4228:			;*		     a - actual	delimter char which caused to terminate
4229:			;*		     f - zero flag set if no error
4230:			;*		quoflg - set equal to ascii quote if at	leeat one quote	found
4231:			;*
4232:			;*	error exit:  f - zero flag reset
4233:			;*
4234:			;******************************************************************************
4235:			
4236:	1A2B  AF      	PRSR:	XOR	A
4237:	1A2C  32EB2E  		LD	(QUOFLG),A	;clear quote flag
4238:	1A2F  212930  		LD	HL,PRSBF	;start of parser scratch buffer
4239:	1A32  0652    		LD	B,PRSBFZ	;buffer	size
4240:	1A34  48      		LD	C,B
4241:	1A35  3600    	PRSR10:	LD	(HL),0		;clear parse buffer to nulls
4242:	1A37  23      		INC	HL
4243:	1A38  10FB    		DJNZ	PRSR10
4244:	1A3A  212930  		LD	HL,PRSBF	;start of parse	buffer
4245:	1A3D  11D72F  		LD	DE,INBF		;start of input	buffer
4246:	1A40  0E51    		LD	C,INBFL		;max size of input buffer
4247:	1A42  1A      	PRSR20:	LD	A,(DE)		;from input buffer
4248:	1A43  EB      		EX	DE,HL
4249:	1A44  3600    		LD	(HL),0		;erase as we pick from input buffer
4250:	1A46  EB      		EX	DE,HL
4251:	1A47  0D      		DEC	C		;decrement buffer size tally
4252:	1A48  F8      		RET	M		;error -  end of input buffer reached
4253:	1A49  13      		INC	DE		;bump input buffer pointer
4254:	1A4A  CDA81A  		CALL	ZDLM00		;check for delimeter
4255:	1A4D  28F3    		JR	Z,PRSR20	;delimeter found - continue search
4256:	1A4F  32F32E  		LD	(PARENF),A
4257:	1A52  0E52    		LD	C,NPRSBF-PRSBF	;parse buffer size
4258:	1A54  77      	PRSR30:	LD	(HL),A
4259:	1A55  A7      		AND	A
4260:	1A56  281B    		JR	Z,PRSR60	;end of	line null always ends parse
4261:	1A58  FE27    		CP	QUOTE		;quote?
4262:	1A5A  2007    		JR	NZ,PRSR50
4263:	1A5C  32EB2E  		LD	(QUOFLG),A
4264:	1A5F  78      		LD	A,B		;quote found - toggle flag
4265:	1A60  EE80    		XOR	80H
4266:	1A62  47      		LD	B,A
4267:	1A63  0D      	PRSR50:	DEC	C		;decrement buffer size tally
4268:	1A64  F8      		RET	M		;error - end of	parse buffer reached
4269:	1A65  1A      		LD	A,(DE)		;next char from	input buffer
4270:	1A66  EB      		EX	DE,HL
4271:	1A67  3600    		LD	(HL),0		;clear as we remove
4272:	1A69  EB      		EX	DE,HL
4273:	1A6A  13      		INC	DE
4274:	1A6B  04      		INC	B		;bumping character count tests quote flag
4275:	1A6C  F4A51A  		CALL	P,ZDLM		;only look for delimeters if quote flag off
4276:	1A6F  23      		INC	HL		;bump parse buffer pointer
4277:	1A70  20E2    		JR	NZ,PRSR30
4278:	1A72  2B      		DEC	HL
4279:	1A73  112930  	PRSR60:	LD	DE,PRSBF	;return	pointing to start of parse buffer
4280:	1A76  32F42E  		LD	(DELIM),A
4281:	1A79  C9      		RET			;zero flag set - no errors
4282:			
4283:			
4284:			
4285:	1A7A  3E4C    	ASMXXL:	LD	A,'L'
4286:	1A7C  1812    		JR	ASMXXX
4287:	1A7E  3E4F    	ASMXXO:	LD	A,'O'
4288:	1A80  180E    		JR	ASMXXX
4289:	1A82  3E50    	ASMXXP:	LD	A,'P'
4290:	1A84  180A    		JR	ASMXXX
4291:	1A86  3E53    	ASMXXS:	LD	A,'S'
4292:	1A88  1806    		JR	ASMXXX
4293:	1A8A  3E54    	ASMXXT:	LD	A,'T'
4294:	1A8C  1802    		JR	ASMXXX
4295:	1A8E  3E56    	ASMXXV:	LD	A,'V'
4296:			
4297:	1A90  32BA29  	ASMXXX:	LD	(ASMFLG),A
4298:	1A93  CD1A26  		CALL	CRET
4299:	1A96  2AE02E  		LD	HL,(ASMBPC)
4300:	1A99  CD3926  		CALL	OUTADR
4301:	1A9C  11B329  		LD	DE,MXXXX
4302:	1A9F  CD7328  		CALL	PRINT
4303:	1AA2  C3B615  		JP	ASM010
4304:			
4305:			
4306:	1AA5  FE2C    	ZDLM:	CP	','
4307:	1AA7  C8      		RET	Z
4308:	1AA8  A7      	ZDLM00:	AND	A
4309:	1AA9  C8      		RET	Z
4310:	1AAA  FE09    		CP	TAB
4311:	1AAC  C8      		RET	Z
4312:	1AAD  FE20    		CP	' '
4313:	1AAF  C9      		RET
4314:			
4315:	1AB0  FE2B    	OPRTOR: CP	'+'
4316:	1AB2  C8      		RET	Z
4317:	1AB3  FE2D    		CP	'-'
4318:	1AB5  C8      		RET	Z
4319:	1AB6  A7      		AND	A
4320:	1AB7  C9      		RET
4321:			
4322:			
4323:			
4324:	1AB8  EB      	OPNV:	EX	DE,HL		;de - operand value  hl	- operand key storage
4325:	1AB9  3A2930  		LD	A,(PRSBF)	;check first byte of parse buffer
4326:	1ABC  A7      		AND	A		;if null - paren was removed
4327:	1ABD  79      		LD	A,C		;key value to accumulator
4328:	1ABE  2002    		JR	NZ,OPNV00	;nz - no paren
4329:	1AC0  F680    		OR	80H		;found null - set paren	flag
4330:	1AC2  77      	OPNV00:	LD	(HL),A		;store key value
4331:	1AC3  23      		INC	HL
4332:	1AC4  73      		LD	(HL),E		;lo order operand value
4333:	1AC5  23      		INC	HL
4334:	1AC6  72      		LD	(HL),D		;hi order
4335:	1AC7  C9      		RET
4336:			
4337:			
4339:			;******************************************************************************
4340:			;*
4341:			;*	zlen:  determine the number of bytes in	a z80 instruction
4342:			;*
4343:			;*
4344:			;*	entry point zlen00: used to return instruction length.
4345:			;*
4346:			;*			    de:	 address of instruction
4347:			;*
4348:			;*	return:	 b:  z - inline	instruction (next pc will be pc	plus length)
4349:			;*		    nz - pc modifying instruction such as call,	 jump, or ret
4350:			;*			 (see hl below)
4351:			;*		 c:	 number	of bytes in this instruction.
4352:			;*		de:	 preserved
4353:			;*		hl:	 next pc following the execution of the	instruction
4354:			;*			 pointed to by de.
4355:			;*
4356:			;******************************************************************************
4357:			
4358:	1AC8  1A      	ZLEN00:	LD	A,(DE)		;fetch first byte of op	code
4359:	1AC9  FECB    		CP	0CBH		;test for shift/bit manipulation instruction
4360:	1ACB  010200  		LD	BC,02
4361:	1ACE  C8      		RET	Z		;10-4 this is a	cb and length is always	2
4362:	1ACF  FEED    		CP	0EDH		;test for fast eddie
4363:	1AD1  201B    		JR	NZ,ZLEN15	;
4364:	1AD3  13      		INC	DE		;fetch byte two	of ed instruction
4365:	1AD4  1A      		LD	A,(DE)
4366:	1AD5  1B      		DEC	DE		;restore pointer
4367:	1AD6  21652A  		LD	HL,Z80ED	;ed four byter table
4368:	1AD9  0E06    		LD	C,Z80EDL	;length
4369:	1ADB  EDB1    		CPIR
4370:	1ADD  0E04    		LD	C,4		;assume	ed four	byter
4371:	1ADF  C8      		RET	Z		;correct assumption
4372:	1AE0  0E02    		LD	C,2		;set length for	return - if not	2 must be 4
4373:	1AE2  FE45    		CP	45H		;test for retn
4374:	1AE4  2803    		JR	Z,ZLEN10
4375:	1AE6  FE4D    		CP	4DH		;test for reti
4376:	1AE8  C0      		RET	NZ		;non-pc	modifying two byte ed
4377:	1AE9  3EC9    	ZLEN10:	LD	A,0C9H		;treat as ordinary return instruction
4378:	1AEB  C3A61B  		JP	ZLEN80
4379:	1AEE  FEDD    	ZLEN15:	CP	0DDH		;check for dd and fd index reg instructions
4380:	1AF0  2804    		JR	Z,ZLEN20
4381:	1AF2  FEFD    		CP	0FDH
4382:	1AF4  2029    		JR	NZ,ZLEN40
4383:	1AF6  13      	ZLEN20:	INC	DE		;fetch byte two	of index reg instruction
4384:	1AF7  1A      		LD	A,(DE)
4385:	1AF8  1B      		DEC	DE		;restore pointer
4386:	1AF9  FEE9    		CP	0E9H		;check for reg indirect	jump
4387:	1AFB  200C    		JR	NZ,ZLEN30	;
4388:	1AFD  04      		INC	B		;reg indirect jump - set pc modified flag nz
4389:	1AFE  1A      		LD	A,(DE)		;recheck for ix	or iy
4390:	1AFF  2A872F  		LD	HL,(IXREG)	;assume	ix
4391:	1B02  FEDD    		CP	0DDH
4392:	1B04  C8      		RET	Z		;correct assumption
4393:	1B05  2A892F  		LD	HL,(IYREG)
4394:	1B08  C9      		RET
4395:	1B09  21202A  	ZLEN30:	LD	HL,Z80FD	;check for dd or fd two	byter
4396:	1B0C  0E0B    		LD	C,Z80FDL
4397:	1B0E  EDB1    		CPIR
4398:	1B10  0E02    		LD	C,2		;assume	two
4399:	1B12  C8      		RET	Z
4400:	1B13  212B2A  		LD	HL,Z80F4	;not two - try four
4401:	1B16  0E05    		LD	C,Z80F4L
4402:	1B18  EDB1    		CPIR
4403:	1B1A  0E04    		LD	C,4		;assume	four
4404:	1B1C  C8      		RET	Z		;correct assumption
4405:	1B1D  0D      		DEC	C		;must be three
4406:	1B1E  C9      		RET
4407:	1B1F  E6C7    	ZLEN40:	AND	0C7H		;check for 8 bit immediate load
4408:	1B21  FE06    		CP	06
4409:	1B23  0E02    		LD	C,2		;assume	so
4410:	1B25  C8      		RET	Z
4411:	1B26  0D      		DEC	C		;assume	one byte op code
4412:	1B27  1A      		LD	A,(DE)
4413:	1B28  FE3F    		CP	3FH
4414:	1B2A  3803    		JR	C,ZLEN50	;opcodes 0 - 3f	require	further	investigation
4415:	1B2C  FEC0    		CP	0C0H		;8 bit reg-reg loads and arithmetics do	not
4416:	1B2E  D8      		RET	C
4417:	1B2F  214B2A  	ZLEN50:	LD	HL,Z803		;check for three byter
4418:	1B32  0E1A    		LD	C,Z803L
4419:	1B34  EDB1    		CPIR
4420:	1B36  2036    		JR	NZ,ZLEN60	;nz - not three
4421:	1B38  21532A  		LD	HL,Z803S	;established three byter - test conditional
4422:	1B3B  0E12    		LD	C,Z803CL
4423:	1B3D  EDB1    		CPIR
4424:	1B3F  0E03    		LD	C,3		;set length
4425:	1B41  C0      		RET	NZ		;nz - three byte inline	instruction
4426:	1B42  21532A  		LD	HL,Z803S
4427:	1B45  0E09    		LD	C,Z803SL	;now weed out jumps from calls
4428:	1B47  EDB1    		CPIR
4429:	1B49  0E03    		LD	C,3
4430:	1B4B  41      		LD	B,C		;set pc	modified flag -	we have	call or	jump
4431:	1B4C  EB      		EX	DE,HL
4432:	1B4D  23      		INC	HL
4433:	1B4E  5E      		LD	E,(HL)
4434:	1B4F  23      		INC	HL
4435:	1B50  56      		LD	D,(HL)		;de - address from instruction
4436:	1B51  EB      		EX	DE,HL
4437:	1B52  1B      		DEC	DE
4438:	1B53  1B      		DEC	DE		;restore instruction pointer
4439:	1B54  2805    		JR	Z,ZLEN55	;z - this is a call
4440:	1B56  FEC3    		CP	IJP		;test for unconditional jump
4441:	1B58  2057    		JR	NZ,ZLEN85
4442:	1B5A  C9      		RET
4443:	1B5B  3AEC2E  	ZLEN55:	LD	A,(WFLAG)	;test for no subroutine	trace flag
4444:	1B5E  A7      		AND	A		;zero means no sub tracing
4445:	1B5F  47      		LD	B,A		;clear for return - if sub trace off
4446:	1B60  C8      		RET	Z		;subroutine trace off -	return with b reg 00
4447:							;so bp is set at next inline instruction
4448:	1B61  05      		DEC	B
4449:	1B62  2003    		JR	NZ,ZLEN58
4450:	1B64  78      		LD	A,B
4451:	1B65  B4      		OR	H
4452:	1B66  C8      		RET	Z
4453:	1B67  1A      	ZLEN58:	LD	A,(DE)		;recover call object byte
4454:	1B68  41      		LD	B,C		;set nz	- pc modifying instruction
4455:	1B69  FECD    		CP	0CDH		;unconditional call??
4456:	1B6B  2044    		JR	NZ,ZLEN85	;zlen85	- set secondary	breakpoint if tracing
4457:	1B6D  C9      		RET
4458:			
4459:	1B6E  213A2A  	ZLEN60:	LD	HL,Z802
4460:	1B71  0E11    		LD	C,Z802L		;test for two byter
4461:	1B73  EDB1    		CPIR
4462:	1B75  201C    		JR	NZ,ZLEN70	;not two
4463:	1B77  21452A  		LD	HL,Z802C	;test for relative jump
4464:	1B7A  0E06    		LD	C,Z802CL
4465:	1B7C  EDB1    		CPIR
4466:	1B7E  0E02    		LD	C,2		;in any	case length is two
4467:	1B80  C0      		RET	NZ		;nz - not relative jump
4468:	1B81  60      		LD	H,B		;clear
4469:	1B82  04      		INC	B		;set pc	modified flag nz
4470:	1B83  13      		INC	DE		;fetch relative	displacement
4471:	1B84  1A      		LD	A,(DE)
4472:	1B85  6F      		LD	L,A
4473:	1B86  87      		ADD	A,A		;test forward or backward
4474:	1B87  3001    		JR	NC,ZLEN65	;p - forward
4475:	1B89  25      		DEC	H		;set hl	negative
4476:	1B8A  19      	ZLEN65:	ADD	HL,DE		;compute distance from instruction
4477:	1B8B  23      		INC	HL		;adjust	for built in bias
4478:	1B8C  1B      		DEC	DE		;restore pointer
4479:	1B8D  1A      		LD	A,(DE)		;fetch first byte of instruction
4480:	1B8E  FE18    		CP	18H		;uncondtional jump?
4481:	1B90  201F    		JR	NZ,ZLEN85	;conditional - set secondary bp	if tracing
4482:	1B92  C9      		RET
4483:	1B93  21302A  	ZLEN70:	LD	HL,Z801		;check for return instruction
4484:	1B96  0E0A    		LD	C,Z801L
4485:	1B98  EDB1    		CPIR
4486:	1B9A  0E01    		LD	C,1		;length	must be	1 in any case
4487:	1B9C  C0      		RET	NZ
4488:	1B9D  FEE9    		CP	0E9H
4489:	1B9F  2005    		JR	NZ,ZLEN80	;nz - not  jp (hl)
4490:	1BA1  04      		INC	B		;set pc	modified flag
4491:	1BA2  2A792F  		LD	HL,(HLREG)	;next pc contained in hlreg
4492:	1BA5  C9      		RET
4493:	1BA6  2A852F  	ZLEN80:	LD	HL,(SPREG)	;return	instructions hide next pc in stack
4494:	1BA9  46      		LD	B,(HL)
4495:	1BAA  23      		INC	HL
4496:	1BAB  66      		LD	H,(HL)
4497:	1BAC  68      		LD	L,B		;hl - return address removed from stack
4498:	1BAD  41      		LD	B,C		;set b nz - pc modification flag
4499:	1BAE  FEC9    		CP	0C9H
4500:	1BB0  C8      		RET	Z		;unconditional return
4501:	1BB1  3AEF2E  	ZLEN85:	LD	A,(SBPS)	;count of special step breakpoints
4502:	1BB4  A7      		AND	A		;test for zero
4503:	1BB5  C8      		RET	Z		;zero -	monitor	is not tracing
4504:	1BB6  3AF02E  		LD	A,(BPS)		;fetch number of bps currently in effect
4505:	1BB9  47      		LD	B,A		;pass to set breakpoint	routine	in b reg
4506:	1BBA  EB      		EX	DE,HL		;de - bp to set
4507:	1BBB  CDFD12  		CALL	BRK30		;set conditional breakpoint
4508:	1BBE  AF      		XOR	A
4509:	1BBF  B0      		OR	B
4510:	1BC0  0600    		LD	B,0
4511:	1BC2  ED5B832F		LD	DE,(PCREG)	;for setting inline bp - condition not m
4512:	1BC6  C0      		RET	NZ		;nz - collision	with user bp
4513:	1BC7  21EF2E  		LD	HL,SBPS
4514:	1BCA  34      		INC	(HL)		;bump count of step bps
4515:	1BCB  C9      		RET
4517:			;******************************************************************************
4518:			;*
4519:			;*	pswDsp:	display	current	state of flag register
4520:			;*
4521:			;*	pswbit:	table of bit masks with	which to test f	reg.
4522:			;*		two byte entry per bit (sign, zero, carry, parity).
4523:			;*
4524:			;*	pswmap - table of offsets into operand name table featuring a
4525:			;*		 two byte entry	for each flag bit.
4526:			;*		 bit 4 (unused by z80) from pswbit entry is on/off flag
4527:			;*		 lo bytes are the off states (p	nz nc po).
4528:			;*		 hi bytes are the on states  (m	 z  c pe).
4529:			;*
4530:			;*	- current state	of flag	register is displayed
4531:			;*	- user queried for changes
4532:			;*	- input	is parsed and tested for valid flag reg	mnemonics
4533:			;*	- if valid mnemonic found flag bit is set or reset accordingly
4534:			;*
4535:			;*	exit:	to z8e for next	command
4536:			;*
4537:			;******************************************************************************
4538:			
4539:	1BCC  110300  	PSWDSP:	LD	DE,3
4540:	1BCF  0600    		LD	B,0			;+ eg 3.3.5a
4541:	1BD1  21A82E  	PSW00:	LD	HL,PSWBIT		;table of bit mask for flags
4542:	1BD4  19      		ADD	HL,DE			;
4543:	1BD5  19      		ADD	HL,DE			;index times two
4544:	1BD6  7B      		LD	A,E
4545:	1BD7  ED44    		NEG				;now calculate index into pswmap
4546:	1BD9  C603    		ADD	A,3
4547:	1BDB  87      		ADD	A,A
4548:	1BDC  4F      		LD	C,A
4549:	1BDD  3A732F  		LD	A,(FREG)		;fetch current flag of user
4550:	1BE0  E6F7    		AND	0F7H
4551:	1BE2  A6      		AND	(HL)			;unused	bit in flag - ensure it's off
4552:	1BE3  21B02E  		LD	HL,PSWMAP
4553:	1BE6  09      		ADD	HL,BC			;pointer to mnemonic is	8 bytes	away
4554:	1BE7  2801    		JR	Z,PSW10			;this is an off	bit (nz	nc p po)
4555:	1BE9  23      		INC	HL			;on
4556:	1BEA  4E      	PSW10:	LD	C,(HL)			;fetch index into operand name table
4557:	1BEB  210A29  		LD	HL,ZOPNM
4558:	1BEE  09      		ADD	HL,BC			;two bytes per table entry
4559:	1BEF  09      		ADD	HL,BC
4560:	1BF0  0E02    		LD	C,2			;print both chars of mnemonic name
4561:	1BF2  CD7C28  		CALL	PRINTB
4562:	1BF5  CD2226  		CALL	RSPACE
4563:	1BF8  1D      		DEC	E			;do all	four flag bits
4564:	1BF9  F2D11B  		JP	P,PSW00
4565:	1BFC  CD1026  		CALL	CRLF
4566:	1BFF  3ABC29  		LD	A,(LCMD)
4567:			
4568:			;	cp	'J'			;- eg 3.3.5a
4569:			;	ret	z			;-
4570:	1C02  FE50    		CP	'P'			;+ Routine can now be called from
4571:	1C04  C0      		RET	NZ			;+  elsewhere
4572:			
4573:	1C05  CD2726  		CALL	SPACE5
4574:	1C08  CD8727  	PSW50:	CALL	IEDTBC
4575:	1C0B  F8      		RET	M			;no input
4576:	1C0C  CD2B1A  	PSW55:	CALL	PRSR
4577:	1C0F  C0      		RET	NZ			;parse error - end command
4578:	1C10  011601  		LD	BC,116H			;
4579:	1C13  CD3C18  		CALL	OPRN20			;check validity	of this	token
4580:	1C16  79      		LD	A,C
4581:	1C17  010800  		LD	BC,PSWCNT		;number	of flag	reg mnemonics
4582:	1C1A  21B02E  		LD	HL,PSWMAP
4583:	1C1D  EDB1    		CPIR				;check table
4584:	1C1F  C27C0D  		JP	NZ,EXXX			;error - nmemonic not found
4585:	1C22  21A82E  		LD	HL,PSWBIT		;bit mask table
4586:	1C25  09      		ADD	HL,BC
4587:	1C26  7E      		LD	A,(HL)			;fetch mask
4588:	1C27  EB      		EX	DE,HL			;
4589:	1C28  21732F  		LD	HL,FREG			;de - mask ptr	 hl - user flag	ptr
4590:	1C2B  E608    		AND	08			;bit says turn on or off
4591:	1C2D  1A      		LD	A,(DE)			;new copy of mask
4592:	1C2E  2005    		JR	NZ,PSW60		;nz - turn on
4593:	1C30  2F      		CPL
4594:	1C31  A6      		AND	(HL)			;and with current user flag
4595:	1C32  77      		LD	(HL),A			;return	flag reg with bit now off
4596:	1C33  18D7    		JR	PSW55			;check for more	input
4597:	1C35  E6F7    	PSW60:	AND	0F7H			;turn off on/off flag (bit 4)
4598:	1C37  B6      		OR	(HL)
4599:	1C38  77      		LD	(HL),A			;now turn on specified bit
4600:	1C39  18D1    		JR	PSW55
4602:			;******************************************************************************
4603:			;*
4604:			;*	movb:	move memory
4605:			;*
4606:			;*	call bcde to fetch destination block address and byte count
4607:			;*	call prsr
4608:			;*	check for head to head or tail to tail move
4609:			;*
4610:			;*	exit: to z8e for next command
4611:			;*
4612:			;******************************************************************************
4613:			
4614:	1C3B  CD5925  	MOVB:	CALL	BCDE		;bc - byte count  de - destination  hl - source
4615:	1C3E  C27C0D  		JP	NZ,EXXX		;input error ends command
4616:	1C41  AF      		XOR	A
4617:	1C42  ED52    		SBC	HL,DE
4618:	1C44  8F      		ADC	A,A
4619:	1C45  19      		ADD	HL,DE
4620:	1C46  09      		ADD	HL,BC
4621:	1C47  2B      		DEC	HL
4622:	1C48  EB      		EX		DE,HL		;de - address of last byte of source block
4623:	1C49  ED52    		SBC	HL,DE
4624:	1C4B  8F      		ADC	A,A
4625:	1C4C  19      		ADD	HL,DE		;hl - original destination address
4626:	1C4D  EB      		EX	DE,HL
4627:	1C4E  FE03    		CP	3
4628:	1C50  2007    		JR	NZ,MOVB00	;head to head
4629:	1C52  EB      		EX	DE,HL
4630:	1C53  09      		ADD	HL,BC
4631:	1C54  2B      		DEC	HL
4632:	1C55  EB      		EX	DE,HL
4633:	1C56  EDB8    		LDDR
4634:	1C58  C9      		RET
4635:	1C59  23      	MOVB00:	INC	HL
4636:	1C5A  A7      		AND	A
4637:	1C5B  ED42    		SBC	HL,BC
4638:	1C5D  EDB0    		LDIR
4639:	1C5F  C9      		RET
4641:			;******************************************************************************
4642:			;*
4643:			;*	yfil:	fill memory
4644:			;*
4645:			;*	call bcde to get byte count, starting address, and fill byte
4646:			;*
4647:			;*	exit:	to z8e for next	command
4648:			;*
4649:			;******************************************************************************
4650:			
4651:	1C60  CD5925  	YFIL:	CALL	BCDE		;bc - byte count  de - fill byte  hl - block
4652:	1C63  C27C0D  		JP	NZ,EXXX		;input error ends command
4653:	1C66  EB      		EX	DE,HL
4654:	1C67  21932F  	YFIL00:	LD	HL,ARGBF
4655:	1C6A  3A8F2F  		LD	A,(ARGBC)
4656:	1C6D  EDA0    	YFIL10:	LDI
4657:	1C6F  04      		INC	B
4658:	1C70  1003    		DJNZ	YFIL20
4659:	1C72  0C      		INC	C
4660:	1C73  0D      		DEC	C
4661:	1C74  C8      		RET	Z
4662:	1C75  3D      	YFIL20:	DEC	A
4663:	1C76  20F5    		JR	NZ,YFIL10
4664:	1C78  18ED    		JR	YFIL00
4666:			;*********************************************************************
4667:			;
4668:			;	CUSER	Change user routine	EG	5 Jan 88
4669:			;
4670:			;	10 Jan 88	Added check for bad args
4671:			;
4672:			;	Uses '>' as command
4673:			;
4674:			;*********************************************************************
4675:			
4676:	1C7A  CD8727  	CUSER:	CALL 	IEDTBC
4677:	1C7D  F8      		RET		M
4678:	1C7E  CDA926  		CALL		IARG		; gets user in HL as a hex no
4679:	1C81  C27C0D  		JP		NZ,EXXX		; don't allow bad (would go to user 0)
4680:	1C84  7C      		LD		A,H
4681:	1C85  B7      		OR		A
4682:	1C86  C27C0D  		JP		NZ,EXXX		; 2 - byte user number?
4683:	1C89  7D      		LD		A,L
4684:	1C8A  FE10    		CP		10H
4685:	1C8C  3807    		JR		C,CUSOK		; you can enter user in hex or decimal with '#'
4686:	1C8E  D606    		SUB		6		; else convert to decimal
4687:	1C90  FE10    		CP		10H		; see if still too big
4688:	1C92  D27C0D  		JP	NC,EXXX
4689:	1C95  0E20    	CUSOK:	LD 	C,32
4690:	1C97  5F      		LD		E,A
4691:	1C98  C30500  		JP		BDOS		; change user
4692:			
4693:			;*******************************************************************
4694:			;
4695:			;	QEVAL - expression evaluator	EG 10 Jan 88
4696:			;
4697:			;	Uses '?' as command
4698:			;
4699:			;*******************************************************************
4700:	1C9B  CD8727  	QEVAL: 	CALL 	IEDTBC		; get input
4701:	1C9E  F8      		RET		M		; none
4702:	1C9F  CDA926  		CALL		IARG		; Z8E does all the real work
4703:	1CA2  C27C0D  		JP		NZ,EXXX		; check for valid arg
4704:	1CA5  CD1026  		CALL		CRLF
4705:	1CA8  7C      		LD		A,H		; see if 1 byte
4706:	1CA9  B7      		OR		A
4707:	1CAA  201E    		JR		NZ,QEV01	; 2-byte number
4708:	1CAC  7D      		LD		A,L
4709:	1CAD  CD4326  		CALL		OUTHEX		; hex byte
4710:	1CB0  7D      		LD		A,L
4711:	1CB1  FE7F    		CP		7FH		; see if printable
4712:	1CB3  D0      		RET		NC
4713:	1CB4  FE20    		CP		' '
4714:	1CB6  D8      		RET		C
4715:	1CB7  0E03    		LD		C,3
4716:	1CB9  CD2926  		CALL		SPACES		; even up with spaces
4717:	1CBC  3E27    		LD		A,27H		; quote
4718:	1CBE  CDB225  		CALL		TTYO
4719:	1CC1  7D      		LD		A,L		; show char
4720:	1CC2  CDB225  		CALL		TTYO
4721:	1CC5  3E27    		LD		A,27H
4722:	1CC7  C3B225  		JP		TTYO
4723:	1CCA  C33926  	QEV01:	JP 	OUTADR		; output 2-byte result
4724:			
4725:			;***********************************************************
4726:			;
4727:			;	GADR - Get program addr data	EG 20 Feb 88
4728:			;
4729:			;	Uses '#' as command
4730:			;
4731:			;	Deleted 5/Jan/89 by jrs - unnecessary as L command
4732:			;	with no file name (now) does the same thing.
4733:			;
4734:			;************************************************************
4735:			;gadr:	ld 	hl,(loadn)
4736:			;	ld 	c,10		; out-of-memory flag
4737:			;	jp 	lbin22
4739:			;------------------------------------------------------------------------------
4740:			;
4741:			;	Initialise default FCB fields and command line	(16 may 87  jrs)
4742:			;
4743:			;	Calls iedtbc to get command tail
4744:			;	      lfcb   twice to extract file names
4745:			;
4746:			;	exit:	FCB name fields at 5Ch and 6Ch initialised
4747:			;		Command tail set up at 80h
4748:			;
4749:			;------------------------------------------------------------------------------
4750:			
4751:	1CCD          	IFCB:				;(Condensed, improved version - jrs 27 Dec 88)
4752:			
4753:	1CCD  CD8727  		CALL	IEDTBC		;Get command tail
4754:	1CD0  2B      		DEC	HL		;Point at input buffer length
4755:	1CD1  E5      		PUSH	HL		;Save input buffer pointer
4756:	1CD2  215C00  		LD	HL,FCB5C	;Zero out the default FCB
4757:	1CD5  0620    		LD	B,32
4758:	1CD7  3600    	IFCB00:	LD	(HL),0
4759:	1CD9  23      		INC	HL
4760:	1CDA  10FB    		DJNZ	IFCB00
4761:	1CDC  2E5D    		LD	L,FCB5C+1	;Blank out the two file names
4762:	1CDE  CD181D  		CALL	IBLANK
4763:	1CE1  2E6D    		LD	L,FCB5C+17
4764:	1CE3  CD181D  		CALL	IBLANK
4765:	1CE6  E1      		POP	HL		;Get input buffer pointer
4766:	1CE7  118000  		LD	DE,80H		;Destination is command line buffer
4767:	1CEA  46      		LD	B,(HL)		;Get input buffer length
4768:	1CEB  78      		LD	A,B		;Load length ready to put in command buffer
4769:	1CEC  04      		INC	B		;Account for the length byte itself
4770:	1CED          	IFCB02:
4771:	1CED  12      		LD	(DE),A		;Store character in command buffer
4772:	1CEE  13      		INC	DE		;Increment pointers
4773:	1CEF  23      		INC	HL
4774:	1CF0  7E      		LD	A,(HL)		;Load character from input buffer
4775:	1CF1  CD0726  		CALL	IXLT		;Translate to upper case
4776:	1CF4  10F7    		DJNZ	IFCB02		;Loop until all copied
4777:	1CF6  AF      		XOR	A		;Terminate the command buffer properly
4778:	1CF7  12      		LD	(DE),A
4779:	1CF8  CD251E  		CALL	LFCB		;Get a file name (if any)
4780:	1CFB  200B    		JR	NZ,IFCB12	;Skip if error
4781:	1CFD  115C00  		LD	DE,FCB5C	;Copy FCB to default FCB at 5ch
4782:	1D00  21AD2F  		LD	HL,FCB
4783:	1D03  010C00  		LD	BC,12		;(only move 12 bytes)
4784:	1D06  EDB0    		LDIR
4785:	1D08          	IFCB12:
4786:	1D08  CD251E  		CALL	LFCB		;Do second file name (if any)
4787:	1D0B  C0      		RET	NZ		;Exit now if error
4788:	1D0C  21AD2F  		LD	HL,FCB		;Copy file name part of FCB to
4789:	1D0F  116C00  		LD	DE,FCB5C+16	; second segment of default FCB
4790:	1D12  010C00  		LD	BC,12
4791:	1D15  EDB0    		LDIR
4792:	1D17  C9      		RET
4793:			
4794:	1D18          	IBLANK:				;Blank out 11 bytes at HL
4795:	1D18  060B    		LD	B,11
4796:	1D1A  3620    	IBL00:	LD	(HL),' '
4797:	1D1C  23      		INC	HL
4798:	1D1D  10FB    		DJNZ	IBL00
4799:	1D1F  C9      		RET
4800:			
4801:			; I originally intended that the following code should be used to expand
4802:			; asterisks in file names but I never invoked it anywhere!  Eventually
4803:			; someone complained and I corrected the omission by adding some code to
4804:			; the LFCB routine.  When I (re)discovered this code I noticed that it was
4805:			; longer than the code added to LFCB so I commented it out.  I am leaving
4806:			; it here because LFCB was never intended to handle ambiguous file names.
4807:			; I don't think there is a problem but should there turn out to be some
4808:			; sort of wierd conflict then it should be easy to activate this little
4809:			; routine.	jrs 27 Dec 88
4810:			;
4811:			;iwild:				;Expand asterisks in file names
4812:			;	ld	bc,8		;Enter with HL pointing at FCB+1
4813:			;	call	iexp		; i.e. first byte of file name.
4814:			;	ld	bc,3
4815:			;;	call	iexp
4816:			;;	ret
4817:			;iexp:
4818:			;	ld	a,'*'
4819:			;	cpir
4820:			;	ret	nz
4821:			;	inc	bc
4822:			;	dec	hl
4823:			;iexp10:
4824:			;	ld	(hl),'?'
4825:			;	inc	hl
4826:			;	dec	c
4827:			;	ret	z
4828:			;	jr	iexp10
4829:			
4830:	1D20  F5      	DISISR:	PUSH	AF
4831:	1D21  3EC9    		LD 	A,IRT
4832:	1D23  323800  		LD	($0038),A
4833:	1D26  F1      		POP	AF
4834:	1D27  C9      		RET
4835:			
4836:	1D28  F5      	ENAISR:	PUSH	AF
4837:	1D29  3EC3    		LD 	A,IJP
4838:	1D2B  323800  		LD	($0038),A
4839:	1D2E  F1      		POP	AF
4840:	1D2F  C9      		RET
4841:			
4843:			;******************************************************************************
4844:			;*
4845:			;*	lldr:	Load file
4846:			;*	User may supply	optional load bias if file name ends with comma.
4847:			;*
4848:			;*	lfcb:	Parse input buffer (inbf) and init FCB
4849:			;*
4850:			;*		Return:	z  - FCB initialized
4851:			;*			nz - syntax error
4852:			;*
4853:			;*	lopn:	Attempt to open file
4854:			;*
4855:			;*		Return:	nz - file opened
4856:			;*			 z - file not found
4857:			;*
4858:			;*	lmem:	Test if sufficient memory available for loading
4859:			;*
4860:			;*		Return: nc - out of memory
4861:			;*
4862:			;*	lbin: Loader
4863:			;*
4864:			;*		Eof found:     end command
4865:			;*		Out of memory: query user whether to continue
4866:			;*
4867:			;******************************************************************************
4868:			
4869:	1D30  CD201D  	LLDR:	CALL	DISISR
4870:	1D33  CD8727  		CALL	IEDTBC		;Get file name
4871:	1D36  F2461D  		JP	P,LLDR00     	;P - have input in inbf
4872:	1D39  2ADE2E  		LD	HL,(LOADN)
4873:	1D3C  7D      		LD	A,L
4874:	1D3D  B4      		OR	H
4875:	1D3E  CA7C0D  		JP	Z,EXXX
4876:			;	ld	c,a		;-
4877:	1D41  0E0A    		LD	C,10		;+ 3.5.5 jrs 5/jan/89
4878:	1D43  C3AA1D  		JP	LBIN22
4879:	1D46  CD1026  	LLDR00:	CALL	CRLF
4880:	1D49  CD251E  		CALL	LFCB		;Init FCB with name and	drive
4881:	1D4C  C2B11E  		JP	NZ,ESNTX	;nz - syntax error
4882:	1D4F  11C129  		LD	DE,MLDG		;Display loading string
4883:	1D52  CD7028  		CALL	NPRINT
4884:	1D55  112930  		LD	DE,PRSBF
4885:	1D58  1A      		LD	A,(DE)		;A - first char	of file	name
4886:	1D59  47      		LD	B,A
4887:	1D5A  CD7328  		CALL	PRINT
4888:	1D5D  3E2C    		LD	A,','
4889:	1D5F  B9      		CP	C		;C - terminator	following file name (from lfcb)
4890:	1D60  210001  		LD	HL,100H		;Assume	no bias
4891:	1D63  200C    		JR	NZ,LLDR05	;NZ - no comma means no	load bias
4892:	1D65  CDA926  		CALL	IARG		;Check for load	bias
4893:	1D68  C2B11E  		JP	NZ,ESNTX	;Error - bad argument
4894:	1D6B  CDA71E  		CALL	IMEM		;Check available memory
4895:	1D6E  D2B61E  		JP	NC,EMEMXX	;Out of	memory
4896:	1D71  22DC2E  	LLDR05:	LD	(LOADB),HL	;Save load bias
4897:	1D74  3E2E    		LD	A,'.'		;Test if file name is period
4898:	1D76  90      		SUB	B
4899:	1D77  2809    		JR	Z,LBIN		;File name is period - no open needed
4900:	1D79  CD201D  	LLDR10:	CALL	DISISR
4901:	1D7C  CD8C1E  		CALL	LOPN		;Attempt to open file -	entry from nint
4902:	1D7F  CABE1E  		JP	Z,EFILNF	;Z - file not found
4903:			
4904:			
4905:	1D82          	LBIN:
4906:	1D82  2ADC2E  		LD	HL,(LOADB)	;Fetch starting	load address
4907:	1D85  E5      	LBIN00:	PUSH	HL
4908:	1D86  EB      		EX	DE,HL
4909:	1D87  0E1A    		LD	C,26		;Set CP/M DMA address
4910:	1D89  CD0500  		CALL	BDOS
4911:	1D8C  11AD2F  		LD	DE,FCB
4912:	1D8F  0E14    		LD	C,20		;CP/M sequential file read
4913:	1D91  CD0500  		CALL	BDOS
4914:	1D94  D1      		POP	DE		;Recover DMA address
4915:	1D95  218000  		LD	HL,80H
4916:	1D98  19      		ADD	HL,DE		;Compute next DMA address
4917:	1D99  32F92E  		LD	(CFLAG),A	;Save EOF indicator as continuation flag
4918:	1D9C  4F      		LD	C,A
4919:	1D9D  A7      		AND	A
4920:	1D9E  2005    		JR	NZ,LBIN20	;NZ - end of file
4921:	1DA0  CDA71E  		CALL	IMEM		;Test if memory	available to load next sector
4922:	1DA3  38E0    		JR	C,LBIN00	;C - not out of	memory
4923:	1DA5  EB      	LBIN20:	EX	DE,HL
4924:	1DA6  2B      		DEC	HL
4925:	1DA7  22DE2E  		LD	(LOADN),HL	;End of load address
4926:	1DAA  11DC29  	LBIN22: LD	DE,MLODM	;Print loaded message
4927:	1DAD  CD7028  		CALL	NPRINT
4928:	1DB0  EB      		EX	DE,HL		;DE - ending address of	load
4929:	1DB1  2ADC2E  		LD	HL,(LOADB)
4930:	1DB4  CD3926  		CALL	OUTADR		;Display starting address of load
4931:	1DB7  EB      		EX	DE,HL
4932:	1DB8  CD3926  		CALL	OUTADR		;Display ending	address
4933:	1DBB  A7      		AND	A
4934:	1DBC  ED52    		SBC	HL,DE
4935:	1DBE  24      		INC	H
4936:	1DBF  11E629  		LD	DE,MLODPG
4937:	1DC2  CD7028  		CALL	NPRINT		;Display pages string
4938:	1DC5  6F      		LD	L,A		;zero L	reg
4939:	1DC6  7C      		LD	A,H		;Hi byte of ending address is number of pages
4940:	1DC7  FE64    		CP	100
4941:	1DC9  380E    		JR	C,LBIN30	;Less than 100
4942:	1DCB  2E32    		LD	L,'2'
4943:	1DCD  D6C8    		SUB	200
4944:	1DCF  3003    		JR	NC,LBIN25	;Greater than 200
4945:	1DD1  2D      		DEC	L		;change	to ASCII 1
4946:	1DD2  C664    		ADD	A,100		;Restore actual page count less 100
4947:	1DD4  67      	LBIN25:	LD	H,A		;Save page count
4948:	1DD5  7D      		LD	A,L
4949:	1DD6  CDB225  		CALL	TTYO
4950:	1DD9  162F    	LBIN30:	LD	D,2FH
4951:	1DDB  7C      		LD	A,H
4952:	1DDC  14      	LBIN35:	INC	D		;Tens and units	decimal	conversion loop
4953:	1DDD  D60A    		SUB	10
4954:	1DDF  30FB    		JR	NC,LBIN35
4955:	1DE1  C60A    		ADD	A,10		;Restore remainder
4956:	1DE3  5F      		LD	E,A		;Temp save while we print tens
4957:	1DE4  7A      		LD	A,D
4958:	1DE5  2C      		INC	L
4959:	1DE6  2D      		DEC	L		;Test L	reg
4960:	1DE7  2002    		JR	NZ,LBIN40	;NZ - ASCII 1 or 2 in L
4961:	1DE9  FE30    		CP	'0'		;Suppress leading zero - less than 10 pages
4962:	1DEB  C4B225  	LBIN40:	CALL	NZ,TTYO		;Print tens digit
4963:	1DEE  7B      		LD	A,E
4964:	1DEF  F630    		OR	'0'
4965:	1DF1  CDB225  		CALL	TTYO		;Print units
4966:	1DF4  CD1026  		CALL	CRLF
4967:			;	xor	a		;- eg 3.3.7a Test eof flag
4968:			;	or	c		;-
4969:	1DF7  79      		LD	A,C		;+ Test EOF flag
4970:	1DF8  FE0A    		CP	10		;+ Was it set by GADR (see 3.3.11)
4971:	1DFA  CA100C  		JP	Z,Z8E		;+ Exit if so
4972:	1DFD  B7      		OR	A		;+
4973:			;	jp	nz,z8e		;- nz - true eof means file loading complete
4974:	1DFE  201A    		JR	NZ,Z8EJ		;+
4975:	1E00  11FF29  		LD	DE,MMEMXX	;Print "out of memory" message
4976:	1E03  CD7328  		CALL	PRINT
4977:	1E06  110D2A  		LD	DE,MCNTU
4978:	1E09  CD7328  		CALL	PRINT		;Print continue? prompt
4979:	1E0C  CDD225  		CALL	INCHAR
4980:	1E0F  CD0726  		CALL	IXLT		;Make sure its upper case
4981:	1E12  FE59    		CP	'Y'
4982:	1E14  CD1026  		CALL	CRLF
4983:	1E17  CA821D  		JP	Z,LBIN		;User wants more loading
4984:	1E1A          	Z8EJ:				;+
4985:	1E1A  0E1A    		LD	C,26		;+ "Set DMA" function
4986:	1E1C  118000  		LD	DE,80H		;+ Restore default DMA for user program
4987:	1E1F  CD0500  		CALL	BDOS		;+
4988:	1E22  C3100C  		JP	Z8E		;Next command
4989:			
4990:			
4991:	1E25  CD2B1A  	LFCB:	CALL	PRSR		;parse input buffer to extract file name
4992:	1E28  57      		LD	D,A		;save char which terminated file name
4993:	1E29  3E0E    		LD	A,14
4994:	1E2B  B8      		CP	B		;over 14 chars is ng file name
4995:	1E2C  D8      		RET	C
4996:	1E2D  48      		LD	C,B		;b and c - byte	count of file name
4997:	1E2E  100D    		DJNZ	LFCB00		;test for only one char	in name
4998:	1E30  3A2930  		LD	A,(PRSBF)	;only one - is it period?
4999:	1E33  D62E    		SUB	'.'
5000:	1E35  2006    		JR	NZ,LFCB00
5001:	1E37  4A      		LD	C,D		;return	terminator
5002:	1E38  3AF92E  		LD	A,(CFLAG)	;continuation allowed?
5003:	1E3B  A7      		AND	A		;let lldr decide
5004:	1E3C  C9      		RET
5005:	1E3D  0600    	LFCB00:	LD	B,0
5006:	1E3F  3E3A    		LD	A,':'		;check for drive specifier in input
5007:	1E41  EDB9    		CPDR
5008:	1E43  41      		LD	B,C		;b - number of chars preceding colon
5009:	1E44  4A      		LD	C,D		;return	terminator in c
5010:	1E45  11AD2F  		LD	DE,FCB
5011:	1E48  3E00    		LD	A,0
5012:	1E4A  200A    		JR	NZ,LFCB10	;nz - no colon
5013:	1E4C  05      		DEC	B
5014:	1E4D  C0      		RET	NZ		;syntax	error -	more than one char
5015:	1E4E  7E      		LD	A,(HL)		;fetch drive specifier
5016:	1E4F  CD0726  		CALL	IXLT
5017:	1E52  77      		LD	(HL),A		;back to parse buffer as upper case
5018:	1E53  D640    		SUB	40H		;make name into	number
5019:	1E55  23      		INC	HL
5020:	1E56          	LFCB10:
5021:	1E56  12      	       	LD	(DE),A		;store drive number in fcb
5022:	1E57  3E20    		LD	A,' '
5023:	1E59  060B    		LD	B,11		;clear file name in fcb	to spaces
5024:	1E5B  13      	LFCB20:	INC	DE
5025:	1E5C  12      		LD	(DE),A
5026:	1E5D  10FC    		DJNZ	LFCB20
5027:	1E5F  0608    		LD	B,8		;max chars allowed in file name
5028:	1E61  11AE2F  		LD	DE,FCBNAM
5029:	1E64  CD6F1E  	LFCB30:	CALL	LFCB90
5030:	1E67  F8      		RET	M		;error - too many chars	in file	name
5031:	1E68  0603    		LD	B,3		;max chars allowed in file type
5032:	1E6A  11B62F  		LD	DE,FCBTYP
5033:	1E6D  A7      		AND	A
5034:	1E6E  C8      		RET	Z		;z - no	file type after	all
5035:			
5036:			
5037:			
5038:	1E6F  23      	LFCB90:	INC	HL		;Bump buffer pointer
5039:	1E70  7E      		LD	A,(HL)
5040:	1E71  A7      		AND	A		;Test for null at end of file name
5041:	1E72  C8      		RET	Z		;Null found - nothing more to parse
5042:	1E73  CD0726  		CALL	IXLT
5043:	1E76  77      		LD	(HL),A		;Translate parse buffer	to upper case
5044:	1E77  FE2E    		CP	'.'
5045:	1E79  C8      		RET	Z		;Period	found -	move file type into FCB
5046:			
5047:			; --- Added 4 Dec 88 --- jrs
5048:	1E7A  FE2A    		CP	'*'		;Expandable wildcard?
5049:	1E7C  2806    		JR	Z,LFCB95
5050:			; --- end of added code ---
5051:	1E7E  05      		DEC	B		;Dec max chars allowed
5052:	1E7F  F8      		RET	M		;Error if name or extension is too long
5053:							; or a character follows an asterisk
5054:	1E80  12      		LD	(DE),A		;Upper case only into FCB
5055:	1E81  13      		INC	DE
5056:	1E82  18EB    		JR	LFCB90
5057:			; --- Added 4 Dec 88 --- jrs
5058:	1E84          	LFCB95:
5059:	1E84  3E3F    		LD	A,'?'
5060:	1E86          	LFCB96:
5061:	1E86  12      		LD	(DE),A
5062:	1E87  13      		INC	DE
5063:	1E88  10FC    		DJNZ	LFCB96
5064:	1E8A  18E3    		JR	LFCB90
5065:			; --- end of added code ---
5066:	1E8C          	LOPN:
5067:	1E8C  21AE2F  		LD	HL,FCBNAM	;test for file name present
5068:	1E8F  7E      		LD	A,(HL)
5069:	1E90  FE20    		CP	' '
5070:	1E92  C8      		RET	Z		;space found means not file
5071:			;;	dec	hl
5072:			;;	ld	a,(hl)		;drive specifier
5073:			;;	and	a		;test for default drive
5074:			;	jr	z,lopn00	;z - default means no selection	required
5075:			;	dec	a		;select	drive
5076:			;	ld	e,a
5077:			;	ld	c,14
5078:			;	call	bdos
5079:	1E93  11AD2F  	LOPN00:	LD	DE,FCB
5080:	1E96  0618    		LD	B,NFCB-FCBEXT
5081:	1E98  21B92F  		LD	HL,FCBEXT	;clear remainder of fcb
5082:	1E9B  3600    	LOPN10:	LD	(HL),0
5083:	1E9D  23      		INC	HL
5084:	1E9E  10FB    		DJNZ	LOPN10
5085:	1EA0  0E0F    		LD	C,15
5086:	1EA2  CD0500  		CALL	BDOS		;tell bdos to open file
5087:	1EA5  3C      		INC	A		;test open return code
5088:	1EA6  C9      		RET			;nz - open ok
5089:			
5090:	1EA7  EB      	IMEM:	EX	DE,HL		;de - next load	address
5091:	1EA8  7A      		LD	A,D
5092:	1EA9  210700  		LD	HL,07		;ptr to	prt to start of	z8e
5093:	1EAC  BE      		CP	(HL)
5094:	1EAD  EB      		EX	DE,HL
5095:	1EAE  D8      		RET	C		;c - not out of memory
5096:	1EAF  EB      		EX	DE,HL
5097:	1EB0  C9      		RET			;de - last address loaded plus one
5098:			
5099:	1EB1  11F029  	ESNTX:	LD	DE,MSNTX	;print syntax error
5100:	1EB4  180B    		JR	EPRINT
5101:			
5102:	1EB6  11FF29  	EMEMXX:	LD	DE,MMEMXX	;print out of memory
5103:	1EB9  CD7028  		CALL	NPRINT
5104:	1EBC  1803    		JR	EPRINT
5105:			
5106:	1EBE  11CB29  	EFILNF:	LD	DE,MFILNF	;print file not	found
5107:			
5108:	1EC1  CD7028  	EPRINT:	CALL	NPRINT
5109:	1EC4  C3100C  		JP	Z8E
5111:			;*****************************************************************************
5112:			;*
5113:			;*            write memory segment to disk command
5114:			;*
5115:			;*****************************************************************************
5116:			
5117:	1EC7  CD8727  	WRIT:	CALL	IEDTBC		;fetch line of input
5118:	1ECA  F8      		RET	M		;no input -
5119:	1ECB  CD6223  		CALL	BLDF		;build fcb with first arg in buffer
5120:	1ECE  20E1    		JR	NZ,ESNTX	;oops - syntax error
5121:	1ED0  3AF42E  		LD	A,(DELIM)	;check char that terminated file name
5122:	1ED3  A7      		AND	A
5123:	1ED4  2009    		JR	NZ,WRIT10	;nz - not null means user entered addresses
5124:			
5125:	1ED6  ED5BDC2E		LD	DE,(LOADB)	;use default begin and end address of the last
5126:	1EDA  2ADE2E  		LD	HL,(LOADN)	;file loaded
5127:	1EDD  1812    		JR	WRIT30
5128:	1EDF  CDA926  	WRIT10:	CALL	IARG		;get address
5129:	1EE2  C27C0D  		JP	NZ,EXXX		;invalid address
5130:	1EE5  EB      		EX	DE,HL
5131:	1EE6  FE20    		CP	' '		;space terminator
5132:	1EE8  C27C0D  		JP	NZ,EXXX		;anything but is error
5133:	1EEB  CDA926  	WRIT20:	CALL	IARG		;get end address
5134:	1EEE  C27C0D  		JP	NZ,EXXX
5135:	1EF1  22E42E  	WRIT30:	LD	(ENDW),HL	;save address of where to end writing
5136:	1EF4  EB      		EX	DE,HL
5137:	1EF5  0E03    		LD	C,3
5138:	1EF7  CD2926  		CALL	SPACES
5139:	1EFA  CD3926  		CALL	OUTADR
5140:	1EFD  EB      		EX	DE,HL
5141:	1EFE  0E06    		LD	C,6
5142:	1F00  CD2926  		CALL	SPACES
5143:	1F03  CD4623  	WRIT40:	CALL	BDWRIT
5144:	1F06  217F00  		LD	HL,127
5145:	1F09  19      		ADD	HL,DE
5146:	1F0A  0606    		LD	B,6
5147:	1F0C  CD3D28  	WRIT50:	CALL	BKSP
5148:	1F0F  10FB    		DJNZ	WRIT50
5149:	1F11  CD3926  		CALL	OUTADR
5150:	1F14  23      		INC	HL
5151:	1F15  EB      		EX	DE,HL
5152:	1F16  2AE42E  		LD	HL,(ENDW)
5153:	1F19  ED52    		SBC	HL,DE
5154:	1F1B  30E6    		JR	NC,WRIT40
5155:	1F1D  C32723  		JP	CLOSEF
5156:			
5157:			
5158:			
5159:			;******************************************************************************
5160:			;*
5161:			;*	find:	locate string in memory
5162:			;*
5163:			;*		call iarg - get	starting address of seach
5164:			;*
5165:			;*		call in00 - get	match data concatenating multiple arguments
5166:			;*			    into a single string
5167:			;*
5168:			;*		addresses at which matches found displayed 8 per line.
5169:			;*		search continues until end of memory reached
5170:			;*		user may cancel	search at any time by hitting any key.
5171:			;*
5172:			;*		exit: to z8e for next command
5173:			;*
5174:			;******************************************************************************
5175:			
5176:	1F20  CD8727  	FIND:	CALL	IEDTBC
5177:	1F23  F8      		RET	M		;m - no	input
5178:	1F24  CDA926  		CALL	IARG		;extract starting address of search
5179:	1F27  C27C0D  		JP	NZ,EXXX		;error
5180:	1F2A  EB      		EX	DE,HL		;save starting address of search in de
5181:	1F2B  CD9726  	FIND00:	CALL	IN00		;extract search	string concatenating multiple
5182:							;arguments
5183:	1F2E  C27C0D  		JP	NZ,EXXX		;error - output	command	prompt
5184:	1F31  AF      		XOR	A
5185:	1F32  32E42E  		LD	(LINES),A	;clear crlf flag
5186:	1F35  EB      		EX	DE,HL		;starting address of search - hl
5187:	1F36  11932F  		LD	DE,ARGBF	;argument stored here
5188:			
5189:	1F39  ED4B042F		LD	BC,(FNDSYM)
5190:	1F3D  79      		LD	A,C
5191:	1F3E  B0      		OR	B		;symbol found?
5192:	1F3F  CA4A1F  		JP	Z,FIND40	;no
5193:			
5194:	1F42  EB      		EX	DE,HL		;hl - argument buffer
5195:	1F43  46      		LD	B,(HL)		;reverse order of the two bytes for symbols
5196:	1F44  23      		INC	HL
5197:	1F45  7E      		LD	A,(HL)
5198:	1F46  70      		LD	(HL),B
5199:	1F47  2B      		DEC	HL
5200:	1F48  77      		LD	(HL),A
5201:	1F49  EB      		EX	DE,HL
5202:			
5203:	1F4A  ED4B8F2F	FIND40:	LD	BC,(ARGBC)	;number	of bytes to look for
5204:	1F4E  CD1026  		CALL	CRLF
5205:	1F51  CD721F  	FIND50:	CALL	SRCH		;do the	search
5206:	1F54  2015    		JR	NZ,FIND60	;not found
5207:	1F56  CD3926  		CALL	OUTADR		;display address where match found
5208:	1F59  3AE42E  		LD	A,(LINES)
5209:	1F5C  3D      		DEC	A		;carriage return after 8 addresses displayed
5210:	1F5D  32E42E  		LD	(LINES),A
5211:	1F60  E607    		AND	7
5212:	1F62  CC1026  		CALL	Z,CRLF
5213:	1F65  CD7225  		CALL	TTYQ		;user requesting abort?
5214:	1F68  FE0D    		CP	CR
5215:	1F6A  C8      		RET	Z		;abort - return	to z8e
5216:	1F6B  23      	FIND60:	INC	HL		;point to next address at which	to start search
5217:	1F6C  09      		ADD	HL,BC		;ensure	we won't hit end of memory by adding
5218:							;in string size
5219:	1F6D  D8      		RET	C		;impending end of memory
5220:	1F6E  ED42    		SBC	HL,BC		;restore pointer
5221:	1F70  18DF    		JR	FIND50
5222:			
5223:	1F72  C5      	SRCH:	PUSH	BC
5224:	1F73  D5      		PUSH	DE
5225:	1F74  E5      		PUSH	HL
5226:	1F75  1A      	SRCH00:	LD	A,(DE)
5227:	1F76  EDA1    		CPI
5228:	1F78  C27F1F  		JP	NZ,SRCH10	;no match
5229:	1F7B  13      		INC	DE
5230:	1F7C  EA751F  		JP	PE,SRCH00	;tally not expired - check next
5231:	1F7F  E1      	SRCH10:	POP	HL
5232:	1F80  D1      		POP	DE
5233:	1F81  C1      		POP	BC
5234:	1F82  C9      		RET
5236:			;******************************************************************************
5237:			;*
5238:			;*	verify:	verify two blocks of data are identical
5239:			;*
5240:			;*		enter: de - starting address of	block 1
5241:			;*
5242:			;*		call bcde to get address of block 2 and	byte count
5243:			;*
5244:			;*		mismatch:   block 1 address and	byte are displayed
5245:			;*			    block 2 address and	byte are displayed
5246:			;*			    console intrrogated	- any input terminates verify
5247:			;*
5248:			;*		exit:	to z8e for next	command
5249:			;*
5250:			;******************************************************************************
5251:			
5252:	1F83  CD5925  	VERIFY:	CALL	BCDE		;get block 2 address and byte count
5253:	1F86  C27C0D  		JP	NZ,EXXX
5254:	1F89  EB      		EX	DE,HL
5255:	1F8A  1A      	VERF00:	LD	A,(DE)		;byte from block 1
5256:	1F8B  AE      		XOR	(HL)		;versus	byte from block	two
5257:	1F8C  2817    		JR	Z,VERF10	;match - no display
5258:	1F8E  CD3026  		CALL	NEWLIN
5259:	1F91  1A      		LD	A,(DE)
5260:	1F92  CD1F26  		CALL	OTHXSP		;display block 1 data
5261:	1F95  CD2226  		CALL	RSPACE
5262:	1F98  CD3926  		CALL	OUTADR		;display block two address
5263:	1F9B  7E      		LD	A,(HL)
5264:	1F9C  CD4326  		CALL	OUTHEX		;display results of xor
5265:	1F9F  CD7225  		CALL	TTYQ		;check input status
5266:	1FA2  FE0D    		CP	CR
5267:	1FA4  C8      		RET	Z
5268:	1FA5  23      	VERF10:	INC	HL		;bump block 1 pointer
5269:	1FA6  13      		INC	DE		;bump block 2 pointer
5270:	1FA7  0B      		DEC	BC		;dec byte count
5271:	1FA8  78      		LD	A,B
5272:	1FA9  B1      		OR	C
5273:	1FAA  20DE    		JR	NZ,VERF00
5274:	1FAC  C9      		RET
5276:			;******************************************************************************
5277:			;*
5278:			;*	xreg:	display	machine	state
5279:			;*
5280:			;*		regptr:	table contains offsets to names	in operand name	table.
5281:			;*			sign bit set indicates prime register.
5282:			;*
5283:			;*		regmap:	table contains offsets to reg contents table (regcon)
5284:			;*			sign bit ignored (used by rgst command).
5285:			;*
5286:			;*		regcon:	table of register contents.
5287:			;*
5288:			;*		exit:	make current pc	current	disassembly location counter.
5289:			;*			set bit	6 of disassembly flag byte (zasmfb)
5290:			;*			jump to	zasm30 to disassemble current instruction.
5291:			;*
5292:			;******************************************************************************
5293:			
5294:	1FAD  CD1A26  	XREG:	CALL	CRET
5295:	1FB0  010000  		LD	BC,0		;init reg index
5296:	1FB3  CDD61F  	XREG00:	CALL	XREG05		;display reg name and contents
5297:	1FB6  0C      		INC	C
5298:	1FB7  79      		LD	A,C
5299:	1FB8  FE08    		CP	8
5300:	1FBA  CC1026  		CALL	Z,CRLF
5301:	1FBD  79      		LD	A,C
5302:	1FBE  FE0C    		CP	0CH
5303:	1FC0  0600    		LD	B,0
5304:	1FC2  20EF    		JR	NZ,XREG00
5305:	1FC4  3ABC29  		LD	A,(LCMD)
5306:	1FC7  FE4A    		CP	'J'		;animated command in effect?
5307:	1FC9  C8      		RET	Z		;z - no disassembly required
5308:	1FCA  2A832F  		LD	HL,(PCREG)
5309:	1FCD  22E02E  		LD	(ZASMPC),HL
5310:			;	jp	zasm30		;- eg 3.3.5b
5311:	1FD0  CD9820  		CALL	ZASM30		;+
5312:	1FD3  C3CC1B  		JP	PSWDSP		;+
5313:			
5314:	1FD6  21C92E  	XREG05:	LD	HL,REGPTR	;map of	reg name pointers
5315:	1FD9  50      		LD	D,B
5316:	1FDA  09      		ADD	HL,BC
5317:	1FDB  7E      		LD	A,(HL)		;extract pointer
5318:	1FDC  E67F    		AND	7FH		;strip sign for	name indexing
5319:	1FDE  5F      		LD	E,A
5320:	1FDF  46      		LD	B,(HL)		;save copy of offset - need sign later
5321:	1FE0  210A29  		LD	HL,ZOPNM	;register name table
5322:	1FE3  19      		ADD	HL,DE
5323:	1FE4  19      		ADD	HL,DE		;two bytes per entry
5324:	1FE5  7E      		LD	A,(HL)
5325:	1FE6  CDB225  		CALL	TTYO		;display character one
5326:	1FE9  23      		INC	HL
5327:	1FEA  7E      		LD	A,(HL)
5328:	1FEB  FE20    		CP	' '		;is second character a space?
5329:	1FED  2002    		JR	NZ,XREG10
5330:	1FEF  3E43    		LD	A,'C'		;replace space - this is pc
5331:	1FF1  CDB225  	XREG10:	CALL	TTYO		;display second	character
5332:	1FF4  AF      		XOR	A
5333:	1FF5  B0      		OR	B		;now test sign
5334:	1FF6  F2FE1F  		JP	P,XREG20	;sign not set -	not prime reg
5335:	1FF9  3E27    		LD	A,27H		;display quote
5336:	1FFB  CDB225  		CALL	TTYO
5337:	1FFE  3E3A    	XREG20:	LD	A,':'
5338:	2000  CDB225  		CALL	TTYO
5339:	2003  21B82E  		LD	HL,REGMAP	;map of	pointers to reg	contents
5340:	2006  19      		ADD	HL,DE
5341:	2007  7E      		LD	A,(HL)
5342:	2008  F20D20  		JP	P,XREG30	;p - not prime reg
5343:	200B  C608    		ADD	A,8		;prime contents	8 bytes	past non-prime
5344:	200D  E67F    	XREG30:	AND	7FH		;ignore	sign
5345:	200F  5F      		LD	E,A
5346:	2010  21732F  		LD	HL,REGCON	;start of register contents storage
5347:	2013  19      		ADD	HL,DE
5348:	2014  56      		LD	D,(HL)		;hi order contents
5349:	2015  2B      		DEC	HL
5350:	2016  5E      		LD	E,(HL)
5351:	2017  EB      		EX	DE,HL
5352:	2018  CD3926  		CALL	OUTADR		;display contents
5353:	201B  C9      		RET
5354:			
5356:			;******************************************************************************
5357:			;*
5358:			;*	zasm
5359:			;*
5360:			;*	the disassembler is divided into two routines:
5361:			;*
5362:			;*	zasm - computes	the instruction	key value and finds the	opcode nmemonic
5363:			;*	opn  - uses the	key value to determine the number of operands and
5364:			;*	       displays	the operands.
5365:			;*
5366:			;*	entered: de - starting address to disassemble
5367:			;*
5368:			;*		zasm maps the 695 z80 instrucions into 256 key values.
5369:			;*              the instruction key value becomes the index into the
5370:			;*              opcode name pointer table (zopcnm), the first operand table
5371:			;*		(zopnd1), and the second operand table (zopnd2).
5372:			;*
5373:			;*		disassembly is done in user specified block sizes if the
5374:			;*		disassembly count evaluates to a number	between	1 and 255. if
5375:			;*		the count is greater than 255 the block	is disassembled	and the
5376:			;*		the command terminates.
5377:			;*
5378:			;*
5379:			;*		zasm15 - start of the disassembly loop
5380:			;*		zasmpc - address of the	instruction being disassembled
5381:			;*		zasmfb - disassembly flag byte
5382:			;*		zmflag - flag indicating directive processing (defb and	defw)
5383:			;*
5384:			;*			    bit	6 - xreg calling
5385:			;*			    bit	5 - asmblr calling
5386:			;*			    bit	0 - write to disk flag
5387:			;*
5388:			;*
5389:			;*
5390:			;******************************************************************************
5391:			
5392:			
5393:	201C          	ZASM:
5394:	201C  CD8727  		CALL	IEDTBC
5395:			
5396:			;	ret	m		;- eg 3.3.2
5397:	201F  F22F20  		JP	P,ZASM0		;+ Skip if arguments supplied, otherwise ...
5398:	2022  0600    		LD	B,0		;+ Signal no file write
5399:	2024  211000  		LD	HL,16		;+ Assume 16 lines of code
5400:	2027  22E82E  		LD	(ZASMWT),HL	;+
5401:	202A  22E62E  		LD	(ZASMCT),HL	;+
5402:	202D  1824    		JR	ZASM06		;+
5403:	202F          	ZASM0:				;+
5404:	202F  CDA926  		CALL	IARG
5405:	2032  C27C0D  		JP	NZ,EXXX
5406:	2035  EB      		EX	DE,HL
5407:	2036  CDA926  		CALL	IARG		;read in block size
5408:	2039  47      		LD	B,A		;save delimeter
5409:	203A  2803    		JR	Z,ZASM00
5410:	203C  210100  		LD	HL,1		;change	zero count to one
5411:	203F  AF      	ZASM00:	XOR	A
5412:	2040  B4      		OR	H
5413:	2041  2806    		JR	Z,ZASM05
5414:	2043  ED52    		SBC	HL,DE
5415:	2045  DA7C0D  		JP	C,EXXX		;error - start address greater than end
5416:	2048  19      		ADD	HL,DE
5417:	2049  22E62E  	ZASM05:	LD	(ZASMCT),HL	;save as permanent block count
5418:	204C  22E82E  		LD	(ZASMWT),HL	;save as working tally
5419:	204F  EB      		EX	DE,HL		;hl - current instruction pointer
5420:	2050  22E02E  		LD	(ZASMPC),HL
5421:	2053          	ZASM06:				;+ eg 3.3.2
5422:	2053  CD1026  		CALL	CRLF
5423:	2056  78      		LD	A,B		;check command line delimeter
5424:	2057  32F92E  		LD	(DWRITE),A	;save as write to disk flag:
5425:							;z - no write   nz - write
5426:	205A  A7      		AND	A
5427:	205B  C46223  		CALL	NZ,BLDF		;not end of line - build fcb
5428:	205E  C2B11E  		JP	NZ,ESNTX
5429:			
5430:	2061  11F52F  	ZASM08:	LD	DE,ZASMBF	;start of disassembly buffer
5431:			
5432:	2064  ED534A29	ZASM10:	LD	(ZASMIO),DE	;init pointer
5433:			
5434:	2068  ED5BE02E	ZASM15:	LD	DE,(ZASMPC)	;fetch address to disassemble
5435:	206C  CDC81A  		CALL	ZLEN00		;calculate length
5436:	206F  EB      		EX	DE,HL
5437:			
5438:							;loop back here for interactive disassembly -
5439:							;user requests format change. c reg:
5440:							;     6 and 7 off: disassemble as code
5441:							;     6       on:  hex defb
5442:							;     7       on:  hex defw or ascii defb
5443:			
5444:	2070  CD3926  	ZASM18:	CALL	OUTADR		;display instruction address
5445:	2073  11F12E  		LD	DE,ZMFLAG
5446:	2076  79      		LD	A,C		;save instruction length and format bits
5447:	2077  12      		LD	(DE),A
5448:	2078  E63F    		AND	3FH
5449:	207A  47      		LD	B,A		;b  - length
5450:	207B  4F      		LD	C,A		;c  - ditto
5451:	207C  7E      	ZASM20:	LD	A,(HL)
5452:	207D  CD1F26  		CALL	OTHXSP		;display object	code
5453:	2080  23      		INC	HL
5454:	2081  10F9    		DJNZ	ZASM20
5455:	2083  79      		LD	A,C		;number	of object bytes
5456:	2084  3D      		DEC	A
5457:	2085  EE03    		XOR	3
5458:	2087  47      		LD	B,A		;calculate space padding
5459:	2088  87      		ADD	A,A
5460:	2089  80      		ADD	A,B
5461:	208A  C602    		ADD	A,2
5462:	208C  47      		LD	B,A
5463:	208D  CD2226  	ZASM25:	CALL	RSPACE
5464:	2090  10FB    		DJNZ	ZASM25
5465:	2092  22E42E  		LD	(ZASMNX),HL	;store address of next instruction
5466:	2095  A7      		AND	A		;clear carry
5467:	2096  ED42    		SBC	HL,BC		;point to first	byte in	instruction
5468:	2098  EB      	ZASM30:	EX	DE,HL		;de - current instruction pointer
5469:	2099  2A4A29  		LD	HL,(ZASMIO)	;buffer	address	storage
5470:	209C  3A082F  		LD	A,(MAXLIN)
5471:	209F  47      		LD	B,A		;line length based on max symbol size
5472:	20A0  3620    	ZASM35:	LD	(HL),' '	;space out buffer
5473:	20A2  23      		INC	HL
5474:	20A3  10FB    		DJNZ	ZASM35
5475:	20A5  78      		LD	A,B
5476:	20A6  32EA2E  		LD	(OPNFLG),A
5477:	20A9  360D    		LD	(HL),CR		;append	crlf
5478:	20AB  23      		INC	HL
5479:	20AC  360A    		LD	(HL),LF
5480:	20AE  CD2025  		CALL	FADR		;find address match
5481:	20B1  2A4A29  		LD	HL,(ZASMIO)
5482:	20B4  2009    		JR	NZ,ZASM40	;nz - no table or not found
5483:	20B6  CD4A25  		CALL	XSYM
5484:	20B9  363A    		LD	(HL),':'
5485:	20BB  ED5BE02E		LD	DE,(ZASMPC)
5486:	20BF  21F12E  	ZASM40:	LD	HL,ZMFLAG	;check interactive disassembly flag
5487:	20C2  7E      		LD	A,(HL)		;sign bit tells all
5488:	20C3  A7      		AND	A
5489:	20C4  F2D120  		JP	P,ZASM42	;bit off - not interactive
5490:	20C7  066D    		LD	B,6DH		;test for defb
5491:	20C9  D682    		SUB	82H
5492:	20CB  287F    		JR	Z,ZASM90
5493:	20CD  AF      		XOR	A		;must be defw
5494:	20CE  05      		DEC	B
5495:	20CF  187B    		JR	ZASM90
5496:	20D1  1A      	ZASM42:	LD	A,(DE)		;first byte of op code
5497:	20D2  21A42E  		LD	HL,OP1000	;table of z80 specific opcodes
5498:	20D5  0E04    		LD	C,4
5499:	20D7  EDB1    	ZASM45:	CPIR			;check for fd dd ed or cb
5500:	20D9  2818    		JR	Z,ZASM55	;z - found
5501:	20DB  FE40    	ZASM50:	CP	40H
5502:	20DD  386D    		JR	C,ZASM90	;opcode	range 0	- 3f
5503:	20DF  06E0    		LD	B,0E0H		;
5504:	20E1  FEC0    		CP	0C0H		;
5505:	20E3  3067    		JR	NC,ZASM90	;opcode	range c0 - ff
5506:	20E5  FE80    		CP	80H
5507:	20E7  305E    		JR	NC,ZASM85	;opcode	range 80 - bf
5508:	20E9  06F8    		LD	B,0F8H		;
5509:	20EB  FE76    		CP	76H		;test for halt instruction
5510:	20ED  2058    		JR	NZ,ZASM85	;opcode	range 40 - 7f
5511:	20EF  3EFF    		LD	A,0FFH		;set halt instruction key value	to 0f7h
5512:	20F1  1859    		JR	ZASM90
5513:	20F3  13      	ZASM55:	INC	DE
5514:	20F4  1A      		LD	A,(DE)		;byte two of multi-byte	instruction
5515:	20F5  0D      		DEC	C		;test for ed instruction
5516:	20F6  2016    		JR	NZ,ZASM65	;nz - not an ed
5517:	20F8  FE80    		CP	80H
5518:	20FA  3008    		JR	NC,ZASM60	;opcode	range ed 40 - ed 7f
5519:	20FC  FE40    		CP	40H
5520:	20FE  304C    		JR	NC,ZASM90	;legal
5521:	2100  3E9F    		LD	A,09FH
5522:	2102  1848    		JR	ZASM90		;map to	question marks
5523:	2104  06E0    	ZASM60:	LD	B,0E0H		;set bias
5524:	2106  FEC0    		CP	0C0H		;test for illegal ed
5525:	2108  3842    		JR	C,ZASM90	;legal
5526:	210A  3EBF    		LD	A,0BFH		;map to	question marks
5527:	210C  183E    		JR	ZASM90		;opcode	range ed a0 - ed bb
5528:			
5529:			
5530:	210E  0C      	ZASM65:	INC	C
5531:	210F  2828    		JR	Z,ZASM80	;z - cb	instruction
5532:	2111  FECB    		CP	0CBH		;fd or dd - check for cb in byte two
5533:	2113  200F    		JR	NZ,ZASM70
5534:	2115  13      		INC	DE		;fetch last byte of fdcb or ddcb
5535:	2116  13      		INC	DE
5536:	2117  1A      		LD	A,(DE)
5537:	2118  0F      		RRCA
5538:	2119  381A    		JR	C,ZASM75
5539:	211B  E603    		AND	3
5540:	211D  FE03    		CP	3
5541:	211F  2014    		JR	NZ,ZASM75	;error
5542:	2121  1A      		LD	A,(DE)
5543:	2122  1815    		JR	ZASM80
5544:	2124  3AF12E  	ZASM70:	LD	A,(ZMFLAG)
5545:	2127  D603    		SUB	3
5546:	2129  1A      		LD	A,(DE)
5547:	212A  20AF    		JR	NZ,ZASM50
5548:	212C  216B2A  		LD	HL,Z80F3
5549:	212F  0E18    		LD	C,Z80F3L
5550:	2131  EDB1    		CPIR
5551:	2133  28A6    		JR	Z,ZASM50
5552:	2135  3E9F    	ZASM75:	LD	A,09FH
5553:	2137  1813    		JR	ZASM90
5554:	2139  FE40    	ZASM80:	CP	40H		;test type of cb instruction
5555:	213B  06E8    		LD	B,0E8H
5556:	213D  3808    		JR	C,ZASM85	;opcode	range cb 00 - cb 3f (shift)
5557:	213F  07      		RLCA
5558:	2140  07      		RLCA
5559:	2141  E603    		AND	03		;hi order bits become index
5560:	2143  06F0    		LD	B,0F0H
5561:	2145  1805    		JR	ZASM90		;opcode	range cb 40 - cb ff
5562:	2147  0F      	ZASM85:	RRCA
5563:	2148  0F      		RRCA
5564:	2149  0F      		RRCA			;bits 3-5 of cb	shift yield key
5565:	214A  E607    		AND	07H
5566:	214C  80      	ZASM90:	ADD	A,B		;add in	bias from b reg
5567:	214D  4F      		LD	C,A		;c - instruction key value
5568:	214E  AF      		XOR	A
5569:	214F  47      		LD	B,A
5570:	2150  21842A  		LD	HL,ZOPCPT	;opcode	name pointer table
5571:	2153  09      		ADD	HL,BC		;index into table
5572:	2154  6E      		LD	L,(HL)		;fetch opname index
5573:	2155  67      		LD	H,A
5574:	2156  29      		ADD	HL,HL
5575:	2157  29      		ADD	HL,HL		;index times four
5576:	2158  11842D  		LD	DE,ZOPCNM	;op code name table
5577:	215B  19      		ADD	HL,DE
5578:	215C  EB      		EX	DE,HL		;de - pointer to opcode	name
5579:	215D  2A4A29  		LD	HL,(ZASMIO)	;buffer	pointer	storage
5580:	2160  79      		LD	A,C
5581:	2161  32FA2E  		LD	(ZASMKV),A	;opcode key value
5582:	2164  3A062F  		LD	A,(MAXLEN)
5583:	2167  4F      		LD	C,A
5584:	2168  0C      		INC	C		;set label length based on max size
5585:			
5586:	2169  3ABC29  		LD	A,(LCMD)	;if xreg use compressed output format
5587:	216C  FE58    		CP	'X'
5588:	216E  2802    		JR	Z,ZASM92
5589:	2170  FE53    		CP	'S'		;step needs compressed format
5590:	2172  09      	ZASM92:	ADD	HL,BC
5591:	2173  0E04    		LD	C,4
5592:	2175  EB      		EX	DE,HL		;de - buffer   hl - opcode name	pointer
5593:	2176  EDB0    		LDIR
5594:	2178  03      		INC	BC		;one space after opcode	for compressed format
5595:	2179  2802    		JR	Z,ZASM95
5596:	217B  0E04    		LD	C,4		;four spaces for true disassembly
5597:	217D  EB      	ZASM95:	EX	DE,HL		;hl - buffer pointer
5598:	217E  09      		ADD	HL,BC		;start of operand field	in buffer
5599:	217F  3AFA2E  		LD	A,(ZASMKV)	;save the instruction key value
5600:	2182  FE9F    		CP	09FH
5601:	2184  2018    		JR	NZ,ZASM99
5602:	2186  ED5BE02E		LD	DE,(ZASMPC)
5603:	218A  3AF12E  		LD	A,(ZMFLAG)
5604:	218D  47      		LD	B,A
5605:	218E  1A      	ZASM97:	LD	A,(DE)
5606:	218F  4A      		LD	C,D
5607:	2190  CDD224  		CALL	ZHEX
5608:	2193  05      		DEC	B
5609:	2194  CAD321  		JP	Z,OPN020
5610:	2197  362C    		LD	(HL),','
5611:	2199  23      		INC	HL
5612:	219A  51      		LD	D,C
5613:	219B  13      		INC	DE
5614:	219C  18F0    		JR	ZASM97
5615:	219E  11842B  	ZASM99:	LD	DE,ZOPND1	;table of first	operands
5616:	21A1  83      		ADD	A,E
5617:	21A2  5F      		LD	E,A		;instant offset
5618:	21A3  7A      		LD	A,D
5619:	21A4  88      		ADC	A,B
5620:	21A5  57      		LD	D,A
5621:	21A6  1A      		LD	A,(DE)
5622:	21A7  3C      		INC	A
5623:	21A8  284F    		JR	Z,OPN040	;no operands
5624:			
5626:			;******************************************************************************
5627:			;*
5628:			;*                          - operand processing -
5629:			;*
5630:			;*	enter:	b - zero (process first	operand)
5631:			;*		c - instruction	key value
5632:			;*
5633:			;*   instruction key value is used to fetch operand key value:
5634:			;*
5635:			;*	operand	key value is in	the range 0 - 1fh
5636:			;*	operand key value interpretted as follows:
5637:			;*
5638:			;*      0 - 17h  use as index to fetch literal from operand
5639:			;*		 name table (sign bit set - parens required)
5640:			;*
5641:			;*     18 - 1fh  operand requires processing - use as index
5642:			;*	         into oprerand jump table which is located
5643:			;*	         immediately after name table
5644:			;*
5645:			;*	   0ffh  no operand
5646:			;*
5647:			;*   operand key value jump table routines: (buffer address in de)
5648:			;*
5649:			;*
5650:			;*   entry point   key         action
5651:			;*
5652:			;*     opn100	   18h	 relative jump
5653:			;*     opn200	   19h	 convert 8 bit operand to hex
5654:			;*     opn300	   1ah	 convert 16 bit	operand	to hex
5655:			;*     opn400	   1ch	 register specified in instruction
5656:			;*     opn600	   1dh	 hl/ix/iy instruction
5657:			;*     opn700	   1eh	 mask rst operand from bit 3-5 of rst instruction
5658:			;*     opn800	   1fh	 bit number is specified in bits 3-5 of	op code
5659:			;*
5660:			;*    exit: to zasm15 to continue block disassembly
5661:			;*
5662:			;******************************************************************************
5663:			
5664:	21AA  3D      	OPN:	DEC	A		;save operand key value
5665:	21AB  F2B121  		JP	P,OPN010
5666:	21AE  3628    		LD	(HL),'('
5667:	21B0  23      		INC	HL
5668:	21B1  EB      	OPN010:	EX	DE,HL		;de - buffer address
5669:	21B2  47      		LD	B,A
5670:	21B3  87      		ADD	A,A		;operand key value times two
5671:	21B4  210A29  	OPN012:	LD	HL,ZOPNM	;base of operand name/jump table
5672:	21B7  85      		ADD	A,L		;index into table
5673:	21B8  6F      		LD	L,A
5674:	21B9  3001    		JR	NC,OPN014
5675:	21BB  24      		INC	H		;account for carry
5676:	21BC  3E1F    	OPN014:	LD	A,1FH
5677:	21BE  A0      		AND	B
5678:	21BF  FE18    		CP	ZOPNML		;test if processing required
5679:	21C1  3805    		JR	C,OPN015	;c - operand is	a fixed	literal
5680:	21C3  7E      		LD	A,(HL)		;fetch processing routine address
5681:	21C4  23      		INC	HL
5682:	21C5  66      		LD	H,(HL)		;
5683:	21C6  6F      		LD	L,A		;hl - operand processing routine
5684:	21C7  E9      		JP	(HL)		;geronimoooooooo
5685:	21C8  EDA0    	OPN015:	LDI			;first byte of operand literal
5686:	21CA  03      		INC	BC		;compensate for	ldi
5687:	21CB  EB      		EX	DE,HL		;hl - buffer
5688:	21CC  1A      		LD	A,(DE)
5689:	21CD  FE20    		CP	' '		;test for space	as byte	two of literal
5690:	21CF  2802    		JR	Z,OPN020	;ignore	spaces appearing in byte two
5691:	21D1  77      		LD	(HL),A
5692:	21D2  23      		INC	HL		;bump buffer pointer
5693:	21D3  78      	OPN020:	LD	A,B		;operand key value
5694:	21D4  FE80    		CP	80H		;test for closed paren required
5695:	21D6  3803    		JR	C,OPN030	;c - none required
5696:	21D8  3629    		LD	(HL),')'
5697:	21DA  23      		INC	HL
5698:	21DB  3AEA2E  	OPN030:	LD	A,(OPNFLG)	;get flag byte
5699:	21DE  EEFF    		XOR	0FFH		;toggle operand number
5700:	21E0  32EA2E  		LD	(OPNFLG),A	;
5701:	21E3  2814    		JR	Z,OPN040	;z - just finished number two
5702:	21E5  3AFA2E  		LD	A,(ZASMKV)	;get op code key value
5703:	21E8  11842C  		LD	DE,ZOPND2	;index into operand2 table
5704:	21EB  83      		ADD	A,E
5705:	21EC  5F      		LD	E,A
5706:	21ED  3001    		JR	NC,OPN035
5707:	21EF  14      		INC	D
5708:	21F0  1A      	OPN035:	LD	A,(DE)		;get operand2 key value
5709:	21F1  3C      		INC	A
5710:	21F2  2805    		JR	Z,OPN040	;z - no	second operand
5711:	21F4  362C    		LD	(HL),','	;separate operands with comma in buffer
5712:	21F6  23      		INC	HL
5713:	21F7  18B1    		JR	OPN
5714:	21F9  2A4A29  	OPN040:	LD	HL,(ZASMIO)	;rewind	buffer pointer
5715:	21FC  3A082F  		LD	A,(MAXLIN)
5716:	21FF  4F      		LD	C,A
5717:	2200          	OPN041:
5718:	2200  3A0C2F  		LD	A,(CASE)
5719:	2203  A7      		AND	A
5720:	2204  280C    		JR	Z,OPN043	;Upper case requested - no need to convert
5721:							;reg names [ras 19 Sep 85]
5722:	2206  7E      	OPN042:	LD	A,(HL)
5723:	2207  A7      		AND	A		;if sign bit on then no case conversion
5724:	2208  F4FE25  		CALL	P,ILCS
5725:	220B  E67F    		AND	7FH		;in case we fell thru
5726:	220D  77      		LD	(HL),A
5727:	220E  23      		INC	HL
5728:	220F  0D      		DEC	C
5729:	2210  20F4    		JR	NZ,OPN042
5730:	2212          	OPN043:				;correct jmp from opn041 4-9-85
5731:	2212  3A082F  		LD	A,(MAXLIN)
5732:	2215  FE1E    		CP	30
5733:	2217  2802    		JR	Z,OPN044
5734:	2219  3E2C    		LD	A,44		;allow 16 comment chars
5735:	221B          	OPN044:
5736:	221B  4F      		LD	C,A		;number of chars to print (omit crlf)
5737:	221C  2A4A29  		LD	HL,(ZASMIO)
5738:	221F  3ABC29  		LD	A,(LCMD)
5739:	2222  FE4A    		CP	'J'		;j command
5740:	2224  C8      		RET	Z		;end of the line for full screen animation
5741:	2225  CD7C28  		CALL	PRINTB		;print buffer
5742:	2228  23      		INC	HL		;point past crlf to next 32 byte group
5743:	2229  23      		INC	HL
5744:	222A  EB      		EX	DE,HL
5745:	222B  3ABC29  		LD	A,(LCMD)	;jettison all commands except z
5746:	222E  FE58    		CP	'X'
5747:	2230  CA1026  		JP	Z,CRLF
5748:	2233  FE41    		CP	'A'
5749:	2235  CA1026  		JP	Z,CRLF
5750:	2238  FE53    		CP	'S'
5751:	223A  CA1026  		JP	Z,CRLF
5752:	223D  AF      		XOR	A
5753:	223E  32F22E  		LD	(ZASMF),A
5754:	2241  2AE62E  		LD	HL,(ZASMCT)	;check disassembly count
5755:	2244  2B      		DEC	HL
5756:	2245  7C      		LD	A,H
5757:	2246  B5      		OR	L		;test for count expired
5758:	2247  C2C522  		JP	NZ,OPN060	;nz - this is not a count of one so this is not
5759:							;interactive disassebly
5760:			
5761:	224A  CD9225  		CALL	TTYI		;check input command letter for interactive
5762:	224D  CD0726  		CALL	IXLT		;force upper case
5763:	2250  32F22E  		LD	(ZASMF),A
5764:	2253  FE43    		CP	'C'		;code?
5765:	2255  CC1A26  		CALL	Z,CRET		;if user wants code return cursor to start of
5766:							;line and disassemble again
5767:	2258  CA6820  		JP	Z,ZASM15
5768:	225B  0E82    		LD	C,82H		;assume defw
5769:	225D  FE44    		CP	'D'
5770:	225F  280B    		JR	Z,OPN045	;defw -	082h
5771:	2261  0D      		DEC	C		;assume ascii defb
5772:	2262  FE41    		CP	'A'
5773:	2264  2806    		JR	Z,OPN045	;ascii defb - 081h
5774:	2266  FE42    		CP	'B'
5775:	2268  200B    		JR	NZ,OPN046	;none of the above
5776:	226A  0EC1    		LD	C,0C1H		;hex defb - 0c1h
5777:	226C  CD1A26  	OPN045:	CALL	CRET
5778:	226F  2AE02E  		LD	HL,(ZASMPC)
5779:	2272  C37020  		JP	ZASM18
5780:			
5781:							;zasmf - 0 means this is block disassembly
5782:							;      - nz means char entered during
5783:			          			;        interactive mode was not c d a or b.
5784:			
5785:	2275  FE3B    	OPN046:	CP	';'		;check if user wants to insert comments
5786:	2277  204C    		JR	NZ,OPN060	;nz - user does not want to add comment
5787:			
5788:	2279  CDB225  		CALL	TTYO		;echo semicolon
5789:	227C  1B      		DEC	DE
5790:	227D  1B      		DEC	DE		;point to carriage return
5791:	227E  3E20    		LD	A,' '
5792:	2280  12      		LD	(DE),A		;clear crlf from buffer
5793:	2281  13      		INC	DE
5794:	2282  12      		LD	(DE),A
5795:	2283  13      		INC	DE
5796:	2284  CD2F23  		CALL	WRITE		;end of buffer - write if required
5797:	2287  061D    		LD	B,29
5798:	2289  3A082F  		LD	A,(MAXLIN)
5799:	228C  D61E    		SUB	30
5800:	228E  CA9522  		JP	Z,OPN048
5801:	2291  1B      		DEC	DE
5802:	2292  0610    		LD	B,16
5803:	2294  AF      		XOR	A
5804:	2295  4F      	OPN048:	LD	C,A
5805:	2296  C5      		PUSH	BC
5806:	2297  D5      		PUSH	DE		;save disassembly buffer pointer
5807:	2298  57      		LD	D,A
5808:	2299  CDA227  		CALL	IEDT03
5809:	229C  D1      		POP	DE
5810:	229D  C1      		POP	BC
5811:	229E  78      		LD	A,B		;recover max size of comment
5812:	229F  2B      		DEC	HL
5813:	22A0  46      		LD	B,(HL)		;number actually entered
5814:	22A1  90      		SUB	B
5815:	22A2  4F      		LD	C,A		;trailing spaces
5816:	22A3  23      		INC	HL
5817:	22A4  EB      		EX	DE,HL		;de - input buffer   hl - disassembly buffer
5818:	22A5  363B    		LD	(HL),';'
5819:	22A7  23      		INC	HL
5820:	22A8  05      	OPN049:	DEC	B		;pre-test count
5821:	22A9  FAB222  		JP	M,OPN050
5822:	22AC  1A      		LD	A,(DE)		;first char of input
5823:	22AD  13      		INC	DE
5824:	22AE  77      		LD	(HL),A		;into disassembly buffer
5825:	22AF  23      		INC	HL
5826:	22B0  18F6    		JR	OPN049
5827:	22B2  0D      	OPN050:	DEC	C
5828:	22B3  FABB22  		JP	M,OPN055
5829:	22B6  3620    		LD	(HL),' '
5830:	22B8  23      		INC	HL
5831:	22B9  18F7    		JR	OPN050
5832:	22BB  360D    	OPN055:	LD	(HL),CR
5833:	22BD  23      		INC	HL
5834:	22BE  360A    		LD	(HL),LF
5835:	22C0  23      		INC	HL
5836:	22C1  EB      		EX	DE,HL
5837:	22C2  C3D522  		JP	OPN065
5838:			
5839:	22C5          	OPN060:
5840:	22C5  3A082F  		LD	A,(MAXLIN)
5841:	22C8  FE1E    		CP	30		;test for 6 chars in label
5842:	22CA  CAD522  		JP	Z,OPN065	;z - buffer point ok
5843:	22CD  3E12    		LD	A,64-46		;bump buffer pointer to next 64 byte chunk
5844:	22CF  83      		ADD	A,E
5845:	22D0  5F      		LD	E,A
5846:	22D1  D2D522  		JP	NC,OPN065
5847:	22D4  14      		INC	D
5848:			
5849:	22D5  CD2F23  	OPN065:	CALL	WRITE		;check if write to disk flag in effect
5850:			
5851:	22D8  CD1026  		CALL	CRLF
5852:	22DB  ED534A29		LD	(ZASMIO),DE	;save new buffer pointer
5853:	22DF  2AE82E  		LD	HL,(ZASMWT)	;check disassembly count
5854:	22E2  AF      		XOR	A
5855:	22E3  B4      		OR	H		;less than 256?
5856:	22E4  280B    		JR	Z,OPN080	;less -	this is	tally
5857:	22E6  ED4BE42E		LD	BC,(ZASMNX)	;fetch next disassembly	address
5858:	22EA  ED42    		SBC	HL,BC		;versus	requested end address
5859:	22EC  382B    		JR	C,OPN095	;c - end
5860:	22EE  09      		ADD	HL,BC		;restore next disassembly address
5861:	22EF  1815    		JR	OPN085		;more
5862:	22F1  2B      	OPN080:	DEC	HL
5863:	22F2  7C      		LD	A,H
5864:	22F3  B5      		OR	L
5865:	22F4  2010    		JR	NZ,OPN085	;nz - more
5866:	22F6  2AE62E  		LD	HL,(ZASMCT)	;fetch permanent block size
5867:	22F9  3AF22E  		LD	A,(ZASMF)
5868:	22FC  A7      		AND	A
5869:	22FD  CC9225  		CALL	Z,TTYI		;query user - more?
5870:	2300  FE0D    		CP	CR		;return	means end
5871:	2302  2815    		JR	Z,OPN095
5872:	2304  1807    		JR	OPN090
5873:	2306          	OPN085:
5874:	2306  CD7225  		CALL	TTYQ
5875:	2309  FE0D    		CP	CR
5876:	230B  280C    		JR	Z,OPN095	;nz - terminate	disassembly
5877:	230D          	OPN090:
5878:	230D  22E82E  		LD	(ZASMWT),HL	;restore count
5879:	2310  2AE42E  		LD	HL,(ZASMNX)	;next instruction pointer
5880:	2313  22E02E  		LD	(ZASMPC),HL	;make current
5881:	2316  C36820  		JP	ZASM15		;disassemble next instruction
5882:			
5883:	2319  3AF92E  	OPN095:	LD	A,(DWRITE)	;writing to disk?
5884:	231C  A7      		AND	A
5885:	231D  C8      		RET	Z
5886:	231E  3E1A    		LD	A,EOF		;
5887:	2320  12      		LD	(DE),A		;set eof
5888:	2321  11F52F  		LD	DE,ZASMBF
5889:	2324  CD2F23  		CALL	WRITE
5890:			
5891:			
5892:			
5893:	2327  11AD2F  	CLOSEF:	LD	DE,FCB		;close file
5894:	232A  0E10    		LD	C,16
5895:	232C  C30500  		JP	BDOS
5896:			
5897:			
5898:			
5899:	232F  C5      	WRITE:	PUSH	BC
5900:	2330  E5      		PUSH	HL
5901:	2331  217530  		LD	HL,NZASM	;address of end of disassembly buffer
5902:	2334  A7      		AND	A
5903:	2335  ED52    		SBC	HL,DE
5904:	2337  200A    		JR	NZ,WRT10	;not end of buffer
5905:	2339  11F52F  		LD	DE,ZASMBF	;need to rewind buffer pointer
5906:	233C  3AF92E  		LD	A,(DWRITE)	;test write to disk flag
5907:	233F  A7      		AND	A
5908:	2340  C44623  		CALL	NZ,BDWRIT	;nz - writing to disk
5909:	2343  E1      	WRT10:	POP	HL
5910:	2344  C1      		POP	BC
5911:	2345  C9      		RET
5912:			
5913:			
5914:			
5915:	2346  C5      	BDWRIT:	PUSH	BC		;bdos write routine
5916:	2347  D5      		PUSH	DE
5917:	2348  E5      		PUSH	HL
5918:	2349  0E1A    		LD	C,26		;set dma address
5919:	234B  CD0500  		CALL	BDOS
5920:	234E  11AD2F  		LD	DE,FCB
5921:	2351  0E15    		LD	C,21
5922:	2353  CD0500  		CALL	BDOS		;write buffer
5923:							;+ eg 3.3.7b
5924:	2356  0E1A    		LD	C,26		;+ "Set DMA" function
5925:	2358  118000  		LD	DE,80H		;+ Restore default DMA for user program
5926:	235B  CD0500  		CALL	BDOS		;+
5927:	235E  E1      		POP	HL
5928:	235F  D1      		POP	DE
5929:	2360  C1      		POP	BC
5930:	2361  C9      		RET
5931:			
5932:			
5933:			
5934:	2362  CD251E  	BLDF:	CALL	LFCB		;initialize fcb
5935:	2365  C0      		RET	NZ		;error - invalid file name
5936:	2366  CD8C1E  		CALL	LOPN
5937:	2369  2808    		JR	Z,BLDF00	;no file - create one
5938:	236B  11AD2F  		LD	DE,FCB
5939:	236E  0E13    		LD	C,19		;file exists - delete it
5940:	2370  CD0500  		CALL	BDOS
5941:	2373  11AD2F  	BLDF00:	LD	DE,FCB		;create	new file
5942:	2376  0E16    		LD	C,22
5943:	2378  CD0500  		CALL	BDOS		;if no file create one
5944:	237B  AF      		XOR	A
5945:	237C  C9      		RET
5946:			
5948:			
5949:	237D  2AE02E  	OPN100:	LD	HL,(ZASMPC)
5950:	2380  23      		INC	HL
5951:	2381  7E      		LD	A,(HL)		;fetch relative	displacement
5952:	2382  4F      		LD	C,A
5953:	2383  0C      		INC	C
5954:	2384  87      		ADD	A,A		;test sign for displacement direction
5955:	2385  0600    		LD	B,0
5956:	2387  3001    		JR	NC,OPN105
5957:	2389  05      		DEC	B		;produce zero for forward - ff for back
5958:	238A  09      	OPN105:	ADD	HL,BC		;adjust	pc
5959:	238B  EB      		EX	DE,HL		;de - instruction ptr	hl - buffer
5960:	238C  CD2025  		CALL	FADR
5961:	238F  CC4A25  		CALL	Z,XSYM
5962:	2392  CAF921  		JP	Z,OPN040	;symbol	found
5963:			;	ld	(hl),'$'	;- eg 3.3.4a
5964:			;	inc	hl		;-
5965:			;	ld	a,c		;-
5966:			;	inc	a		;-
5967:	2395  0600    		LD	B,0
5968:			;	cp	82h		;-
5969:			;	jp	opn610		;- convert displacement to ascii
5970:	2397  C3F923  		JP	OPN316		;+
5971:			
5972:	239A  CDFA24  	OPN200:	CALL	ZMQF		;check for interactive disassembly
5973:	239D  300C    		JR	NC,OPN205	;sign off - not interactive
5974:	239F  87      		ADD	A,A		;shift out bit 6
5975:	23A0  7E      		LD	A,(HL)
5976:	23A1  3826    		JR	C,OPN215	;on - must be hex defb
5977:	23A3  CD0525  		CALL	ZASCII		;user wants ascii - check validity
5978:	23A6  2021    		JR	NZ,OPN215	;nz - untable to convert to ascii
5979:	23A8  C3D321  		JP	OPN020
5980:	23AB  CDB924  	OPN205:	CALL	ZNDX		;check for ix or iy instruction
5981:	23AE  EB      		EX	DE,HL		;buffer back to de
5982:	23AF  2002    		JR	NZ,OPN210	;nz - not ix or	iy
5983:	23B1  23      		INC	HL
5984:	23B2  23      		INC	HL		;must be  ld (ix+ind),nn
5985:	23B3  23      	OPN210:	INC	HL		;
5986:	23B4  7E      		LD	A,(HL)		;fetch object byte
5987:	23B5  2812    		JR	Z,OPN215	;no conversion of ix and iy displacements
5988:							;to ascii
5989:	23B7  3AFA2E  		LD	A,(ZASMKV)	;check for in or out instruction
5990:	23BA  FEB3    		CP	0B3H
5991:	23BC  280B    		JR	Z,OPN215	;no conversion of port addresses to ascii
5992:	23BE  FEBB    		CP	0BBH
5993:	23C0  2807    		JR	Z,OPN215
5994:	23C2  7E      		LD	A,(HL)
5995:	23C3  CD0525  		CALL	ZASCII
5996:	23C6  CAD321  		JP	Z,OPN020
5997:	23C9  EB      	OPN215:	EX	DE,HL
5998:	23CA  1A      		LD	A,(DE)
5999:	23CB  FE0A    		CP	10		;decimal number?
6000:	23CD  3006    		JR	NC,OPN220	;no - convert to hex
6001:	23CF  CDEF24  		CALL	ZHEX20		;86 the	leading	zero and trailing h
6002:	23D2  C3D321  		JP	OPN020
6003:	23D5  CDD224  	OPN220:	CALL	ZHEX		;do hex	to asii	conversion
6004:	23D8  3648    		LD	(HL),'H'	;following 8 bit hex byte
6005:	23DA  23      		INC	HL
6006:	23DB  C3D321  		JP	OPN020
6007:			
6008:	23DE  CDFA24  	OPN300:	CALL	ZMQF
6009:	23E1  3808    		JR	C,OPN315	;c - this is defw
6010:	23E3  CDB924  		CALL	ZNDX
6011:	23E6  EB      		EX	DE,HL		;de - buffer   hl - instruction	pointer
6012:	23E7  2001    		JR	NZ,OPN310	;nz - not ix or	iy
6013:	23E9  23      		INC	HL
6014:	23EA  23      	OPN310:	INC	HL
6015:	23EB  7E      	OPN315:	LD	A,(HL)		;fetch lo order	16 bit operand
6016:	23EC  23      		INC	HL
6017:	23ED  66      		LD	H,(HL)		;hi order
6018:	23EE  6F      		LD	L,A
6019:	23EF  EB      		EX	DE,HL		;de - 16 bit operand   hl - buffer
6020:	23F0  CD2025  		CALL	FADR
6021:	23F3  CC4A25  		CALL	Z,XSYM
6022:	23F6  CAD321  		JP	Z,OPN020	;symbol	found
6023:	23F9          	OPN316:				;+ eg 3.3.4b
6024:	23F9  7A      		LD	A,D		;convert hi order to hex
6025:	23FA  4F      		LD	C,A		;save spare copy
6026:	23FB  CDD224  		CALL	ZHEX
6027:	23FE  7B      		LD	A,E
6028:	23FF  57      		LD	D,A
6029:	2400  CDE024  		CALL	ZHEX10
6030:	2403  AF      		XOR	A
6031:	2404  B1      		OR	C
6032:	2405  2006    		JR	NZ,OPN320
6033:	2407  7A      		LD	A,D
6034:	2408  FE0A    		CP	10
6035:	240A  DAD321  		JP	C,OPN020
6036:	240D  3668    	OPN320:	LD	(HL),'h'
6037:	240F  23      		INC	HL
6038:	2410  C3D321  		JP	OPN020
6039:			
6040:	2413          	OPN400:
6041:	2413  CDB924  		CALL	ZNDX
6042:	2416  2008    		JR	NZ,OPN410	;nz - not ix or	iy instruction
6043:	2418  13      		INC	DE
6044:	2419  1A      		LD	A,(DE)
6045:	241A  FECB    		CP	0CBH		;check for indexed bit instruction
6046:	241C  2002    		JR	NZ,OPN410
6047:	241E  13      		INC	DE		;byte of interest is number four
6048:	241F  13      		INC	DE
6049:	2420  3E01    	OPN410:	LD	A,01		;check low bit of operand key value
6050:	2422  A0      		AND	B
6051:	2423  1A      		LD	A,(DE)		;fetch op code
6052:	2424  2003    		JR	NZ,OPN500	;nz - index 01bh
6053:	2426  1F      		RRA			;register specified in bits 0-5
6054:	2427  1F      		RRA
6055:	2428  1F      		RRA
6056:	2429  E607    	OPN500:	AND	007		;register specified in bits 0-2
6057:	242B  EE06    		XOR	006		;from the movie	of the same name
6058:	242D  C2B121  		JP	NZ,OPN010	;nz - not hl or	ix or iy
6059:	2430  3AE02E  		LD	A,(ZASMPC)
6060:	2433  AB      		XOR	E		;test if pc was	incremented
6061:	2434  3628    		LD	(HL),'('	;set leading paren
6062:	2436  23      		INC	HL
6063:	2437  0680    		LD	B,080H		;set sign bit -	closed paren required
6064:	2439  EB      		EX	DE,HL		;de - buffer
6065:	243A  CAB421  		JP	Z,OPN012
6066:			
6067:			
6068:			
6069:	243D          	OPN600:
6070:	243D  CDB924  		CALL	ZNDX		;determine if ix or iy
6071:	2440  2806    		JR	Z,OPN605	;z - must be ix	of iy
6072:	2442  3E80    		LD	A,80H
6073:	2444  A0      		AND	B
6074:	2445  C3B121  		JP	OPN010
6075:	2448          	OPN605:
6076:							;+Fix display of IX/IY when upper case is set
6077:	2448  F5      		PUSH	AF		;+Adapted from patch by George Havach (3.5.7)
6078:	2449  0EDF    		LD	C,0DFH		;+Upper case mask
6079:	244B  3A0C2F  		LD	A,(CASE)	;+See if upper or lower case
6080:	244E  B7      		OR	A		;+
6081:	244F  2802    		JR	Z,OPN606	;+Skip if upper case, otherwise
6082:	2451  0EFF    		LD	C,0FFH		;+ adjust mask
6083:	2453          	OPN606:				;+
6084:	2453  3E69    		LD	A,'i'		;+First character
6085:	2455  A1      		AND	C		;+Select case
6086:			;	ld	(hl),'i'	;-Set first character
6087:	2456  77      		LD	(HL),A		;+Set first character
6088:	2457  23      		INC	HL
6089:	2458  F1      		POP	AF		;+Second character
6090:	2459  CE78    		ADC	A,'x'		;Carry determines x or y (from zndx)
6091:	245B  A1      		AND	C		;+Select case
6092:	245C  77      		LD	(HL),A
6093:	245D  23      		INC	HL
6094:	245E  3E80    		LD	A,80H		;Test for parens
6095:	2460  A0      		AND	B
6096:	2461  CADB21  		JP	Z,OPN030	;z - not indexed instruction
6097:	2464  13      		INC	DE
6098:	2465  1A      		LD	A,(DE)		;fetch second byte of instruction
6099:	2466  FEE9    		CP	0E9H		;test for jp (ix) or jp	(iy)
6100:	2468  CAD321  		JP	Z,OPN020	;output	closed paren
6101:	246B  13      		INC	DE
6102:	246C  1A      		LD	A,(DE)		;fetch displacement byte
6103:	246D  FE80    		CP	80H		;test sign
6104:	246F  362B    	OPN610:	LD	(HL),'+'	;assume	forward
6105:	2471  3804    		JR	C,OPN620	;c - forward
6106:	2473  ED44    		NEG			;force positive
6107:	2475  362D    		LD	(HL),'-'
6108:	2477  23      	OPN620:	INC	HL		;bump buffer pointer
6109:	2478  E67F    		AND	7FH		;strip sign
6110:	247A  CDD224  		CALL	ZHEX		;convert to hex
6111:	247D  3E09    		LD	A,9
6112:	247F  BA      		CP	D
6113:	2480  D2D321  		JP	NC,OPN020
6114:	2483  3668    		LD	(HL),'h'
6115:	2485  23      		INC	HL
6116:	2486  C3D321  		JP	OPN020		;output	closed paren
6117:			
6118:			
6119:			
6120:			
6121:	2489  2AE02E  	OPN700:	LD	HL,(ZASMPC)
6122:	248C  7E      		LD	A,(HL)		;fetch restart instruction
6123:	248D  EB      		EX	DE,HL		;de - buffer   hl instruction pointer
6124:	248E  E638    		AND	38H
6125:	2490  CDD224  		CALL	ZHEX		;convert restart number	to ascii
6126:	2493  3648    		LD	(HL),'H'
6127:	2495  C3D321  		JP	OPN020
6128:			
6129:			
6130:			
6131:	2498  CDB924  	OPN800:	CALL	ZNDX
6132:	249B  2006    		JR	NZ,OPN810	;nz - not ddcb or fdcb instruction
6133:	249D  13      		INC	DE
6134:	249E  13      		INC	DE
6135:	249F  13      		INC	DE		;
6136:	24A0  1A      		LD	A,(DE)		;byte 4	of ix or iy bit	instruction
6137:	24A1  180B    		JR	OPN820
6138:	24A3  FE10    	OPN810:	CP	10H		;weed out interrupt mode instructions
6139:	24A5  1A      		LD	A,(DE)		;second	byte of	instruction regardless
6140:	24A6  2006    		JR	NZ,OPN820	;nz - cb bit instruction
6141:	24A8  EE46    		XOR	046H		;
6142:	24AA  2807    		JR	Z,OPN830	;z - interrupt mode zero
6143:	24AC  D608    		SUB	8
6144:	24AE  1F      	OPN820:	RRA
6145:	24AF  1F      		RRA
6146:	24B0  1F      		RRA
6147:	24B1  E607    		AND	07		;leave only bit	number
6148:	24B3  CDEF24  	OPN830:	CALL	ZHEX20		;convert to ascii
6149:	24B6  C3DB21  		JP	OPN030
6151:			;******************************************************************************
6152:			;*
6153:			;*		     disassembler utility subroutines
6154:			;*
6155:			;*	zndx:	  determines if	fd dd ed or cb instruction
6156:			;*		  caller uses returned values on an individual basis
6157:			;*
6158:			;*		   z  -	dd fd
6159:			;*		  nz  -	neither	of the above
6160:			;*		  current instruction pointer bumped if	cb or ed instruction
6161:			;*
6162:			;*	zhex:	  convert to byte in the accumulator to ascii with leading zero
6163:			;*		  store	in buffer
6164:			;*		  d - reg destroyed
6165:			;*
6166:			;*	zhex10:	  no leading zero permitted
6167:			;*	zhex20:	  convert lo order nibble only
6168:			;*
6169:			;******************************************************************************
6170:			
6171:	24B9  2AE02E  	ZNDX:	LD	HL,(ZASMPC)	;fetch current instruction pointer
6172:	24BC  EB      		EX	DE,HL		;de - instruction pointer   hl - buffer
6173:	24BD  1A      		LD	A,(DE)
6174:			;	ADD	A,-0FDH		;iy check
6175:	24BE  C603    		ADD	A,$03		;iy check
6176:	24C0  C8      		RET	Z
6177:	24C1  D6E0    		SUB	0DDH-0FDH	;ix check
6178:	24C3  C8      		RET	Z
6179:	24C4  FE10    		CP	10H		;ed check
6180:	24C6  2805    		JR	Z,ZNDX00
6181:	24C8  FEEE    		CP	0EEH		;cb check
6182:	24CA  3E00    		LD	A,0		;clear
6183:	24CC  C0      		RET	NZ
6184:	24CD  13      	ZNDX00:	INC	DE		;cb or ed - bump instruction pointer
6185:	24CE  2F      		CPL
6186:	24CF  A7      		AND	A		;ensure	nz set
6187:	24D0  2F      		CPL
6188:	24D1  C9      		RET
6189:			
6190:			
6191:			
6192:	24D2  57      	ZHEX:	LD	D,A
6193:	24D3  FEA0    		CP	0A0H		;test byte to convert
6194:	24D5  3805    		JR	C,ZHEX00	;starts	with decimal digit - 86	the lead zero
6195:	24D7  3630    		LD	(HL),'0'
6196:	24D9  23      		INC	HL
6197:	24DA  1804    		JR	ZHEX10
6198:	24DC  FE0A    	ZHEX00:	CP	10
6199:	24DE  380F    		JR	C,ZHEX20
6200:	24E0  0F      	ZHEX10:	RRCA
6201:	24E1  0F      		RRCA
6202:	24E2  0F      		RRCA
6203:	24E3  0F      		RRCA
6204:	24E4  E60F    		AND	0FH
6205:	24E6  C690    		ADD	A,90H
6206:	24E8  27      		DAA
6207:	24E9  CE40    		ADC	A,40H
6208:	24EB  27      		DAA			;a - ascii digit
6209:	24EC  77      		LD	(HL),A
6210:	24ED  23      		INC	HL
6211:	24EE  7A      		LD	A,D		;lo nibble conversion
6212:	24EF  E60F    	ZHEX20:	AND	0FH
6213:	24F1  C690    		ADD	A,90H
6214:	24F3  27      		DAA
6215:	24F4  CE40    		ADC	A,40H
6216:	24F6  27      		DAA
6217:	24F7  77      		LD	(HL),A
6218:	24F8  23      		INC	HL
6219:	24F9  C9      		RET
6220:			
6221:			
6222:			
6223:	24FA  21F12E  	ZMQF:	LD	HL,ZMFLAG	;check interactive disassembly flag
6224:	24FD  7E      		LD	A,(HL)
6225:	24FE  3600    		LD	(HL),0		;clear regardless
6226:	2500  2AE02E  		LD	HL,(ZASMPC)	;fetch current disassembly address
6227:	2503  87      		ADD	A,A		;check sign - on means interactive
6228:	2504  C9      		RET
6229:			
6230:			
6231:	2505  FE20    	ZASCII:	CP	' '
6232:	2507  D8      		RET	C
6233:	2508  A7      		AND	A
6234:	2509  F8      		RET	M
6235:	250A  FE7F    		CP	7FH		;rubout?
6236:	250C  2804    		JR	Z,ZASC10
6237:	250E  FE27    		CP	QUOTE
6238:	2510  2002    		JR	NZ,ZASC20
6239:	2512  A7      	ZASC10:	AND	A		;set nz - conversion not done
6240:	2513  C9      		RET
6241:	2514  EB      	ZASC20:	EX	DE,HL
6242:	2515  3627    		LD	(HL),QUOTE	;defb -	quoted character
6243:	2517  23      		INC	HL
6244:	2518  F680    		OR	80H		;hi bit on - no case conversion for this guy
6245:	251A  77      		LD	(HL),A
6246:	251B  23      		INC	HL
6247:	251C  3627    		LD	(HL),QUOTE
6248:	251E  BF      		CP	A
6249:	251F  C9      		RET
6250:			
6251:			
6252:			
6253:	2520  C5      	FADR:	PUSH	BC
6254:	2521  E5      		PUSH	HL
6255:	2522  2A0600  		LD	HL,(06)		;fetch top of tpa - start of symbol table
6256:	2525  ED4B062F		LD	BC,(MAXLEN)
6257:	2529  09      		ADD	HL,BC		;point to start of symbol name
6258:	252A  23      		INC	HL
6259:	252B  7E      	FADR00:	LD	A,(HL)		;first byte of symbol name
6260:	252C  3D      		DEC	A		;check validity
6261:	252D  FA4725  		JP	M,FADR30	;end of	table
6262:	2530  09      		ADD	HL,BC
6263:	2531  7E      		LD	A,(HL)		;fetch hi order	address	from table
6264:	2532  BA      		CP	D
6265:	2533  C23D25  		JP	NZ,FADR10
6266:	2536  2B      		DEC	HL
6267:	2537  7E      		LD	A,(HL)
6268:	2538  23      		INC	HL
6269:	2539  BB      		CP	E
6270:	253A  CA4125  		JP	Z,FADR20
6271:	253D  23      	FADR10:	INC	HL
6272:	253E  C32B25  		JP	FADR00
6273:	2541  EB      	FADR20:	EX	DE,HL		;return pointer in de
6274:	2542  79      		LD	A,C
6275:	2543  2F      		CPL
6276:	2544  A3      		AND	E
6277:	2545  5F      		LD	E,A
6278:	2546  AF      		XOR	A
6279:	2547  E1      	FADR30:	POP	HL
6280:	2548  C1      		POP	BC
6281:	2549  C9      		RET
6282:			
6283:	254A          	XSYM:
6284:	254A  3A062F  		LD	A,(MAXLEN)
6285:	254D  3D      		DEC	A
6286:	254E  4F      		LD	C,A
6287:	254F  1A      	XSYM00:	LD	A,(DE)
6288:	2550  A7      		AND	A
6289:	2551  C8      		RET	Z
6290:	2552  77      		LD	(HL),A
6291:	2553  23      		INC	HL
6292:	2554  13      		INC	DE
6293:	2555  0D      		DEC	C
6294:	2556  20F7    		JR	NZ,XSYM00
6295:	2558  C9      		RET
6297:			;******************************************************************************
6298:			;*
6299:			;*	bcde:  query user for 3	arguments: source address
6300:			;*					   destination address
6301:			;*					   byte	count
6302:			;*
6303:			;*	       used by move, verify, and yfil routines
6304:			;*
6305:			;*	       return: bc - byte count
6306:			;*		       de - destination
6307:			;*		       hl - source pointer
6308:			;*			z - no errors
6309:			;*
6310:			;*		       nz - no input entered
6311:			;*			  - untable to evaluate argument
6312:			;*			  - destination	address	< source
6313:			;*
6314:			;******************************************************************************
6315:			
6316:	2559  CD8727  	BCDE:	CALL	IEDTBC
6317:	255C  F8      		RET	M		;no input is treated as	error
6318:	255D  CDA926  		CALL	IARG		;read in starting block	address
6319:	2560  C0      		RET	NZ
6320:	2561  EB      		EX	DE,HL
6321:	2562  CDA926  		CALL	IARG
6322:	2565  C0      		RET	NZ
6323:	2566  ED52    		SBC	HL,DE		;end - start = byte count - 1
6324:	2568  D8      		RET	C
6325:	2569  44      		LD	B,H
6326:	256A  4D      		LD	C,L
6327:	256B  03      		INC	BC
6328:	256C  CD9726  		CALL	IN00		;read in destination block address
6329:	256F  C0      		RET	NZ
6330:	2570  EB      		EX	DE,HL		;set regs right
6331:	2571  C9      		RET
6332:			
6334:			;******************************************************************************
6335:			;*
6336:			;*			   console i/o routines
6337:			;*
6338:			;*   "physical"	i/o routines: ttyi - keyboard input
6339:			;*			      ttyo - console output
6340:			;*			      ttyq - console status
6341:			;*
6342:			;*   logical input routines:  inchar - input character processing
6343:			;*				       control characters echoed with ^
6344:			;*
6345:			;*   logical output routines: crlf   - output carriage return/line feed
6346:			;*			      cret   - output carriage return only
6347:			;*			     space   - output space
6348:			;*			    spaces   - output number of	spaces in passed in c
6349:			;*			    outhex   - output hex byte in a
6350:			;*			    othxsp   - output hex byte in a followed by	space
6351:			;*			    outadr   - output 16 bit hex value in hl followed
6352:			;*				       by space	- hl preserved
6353:			;*			     print   - output string - address in de
6354:			;*				       string terminated by null
6355:			;*			    printb   - output string - address in hl
6356:			;*						       byte count in c
6357:			;*						       end at first null
6358:			;*
6359:			;******************************************************************************
6360:	FFFF          	IF STLONE
6361:	2572          	TTYQ:
6362:	2572  CDAAFD  		CALL	BBCONST
6363:	2575  E67F    		AND	$7F
6364:	2577  C9      		RET
6365:			ELSE
6385:			ENDIF
6386:			
6387:	FFFF          	    IF NOT COMPACT
6388:	2592          		ORG	TTYQ+32
6389:			    ENDIF
6390:			
6391:	FFFF          	IF STLONE
6392:	2592          	TTYI:
6393:	2592  C5      		PUSH	BC
6394:	2593  D5      		PUSH	DE
6395:	2594  E5      		PUSH	HL
6396:	2595  CD94FD  		CALL	BBCONIN
6397:	2598  E1      		POP	HL
6398:	2599  D1      		POP	DE
6399:	259A  C1      		POP	BC
6400:	259B  C9      		RET
6401:			ELSE
6424:			ENDIF
6425:			
6426:	FFFF          	    IF NOT COMPACT
6427:	25B2          		ORG	TTYI+32
6428:			    ENDIF
6429:			
6430:	FFFF          	IF STLONE
6431:	25B2          	TTYO:
6432:	25B2  C5      		PUSH	BC
6433:	25B3  4F      		LD	C,A
6434:	25B4  CD9FFD  		CALL	BBCONOUT
6435:	25B7  C1      		POP	BC
6436:	25B8  C9      		RET
6437:			ELSE
6464:			ENDIF
6465:			
6466:	FFFF          	    IF NOT COMPACT
6467:	25D2          		ORG	TTYO+32
6468:			    ENDIF
6469:			
6470:	25D2  CD9225  	INCHAR:	CALL	TTYI
6471:	25D5  FE03    		CP	CTLC
6472:	25D7  2822    		JR	Z,EXICPM
6473:	25D9  FE0D    		CP	CR
6474:	25DB  C8      		RET	Z
6475:	25DC  FE09    		CP	TAB
6476:	25DE  C8      		RET	Z
6477:	25DF  FE0A    		CP	LF
6478:	25E1  C8      		RET	Z
6479:	25E2  FE08    		CP	BS
6480:	25E4  C8      		RET	Z
6481:	25E5  FE18    		CP	CTLX
6482:	25E7  C8      		RET	Z
6483:	25E8  FE20    		CP	' '
6484:	25EA  30C6    		JR	NC,TTYO
6485:	25EC  F5      		PUSH	AF
6486:	25ED  3E5E    		LD	A,'^'
6487:	25EF  CDB225  		CALL	TTYO
6488:	25F2  F1      		POP	AF
6489:	25F3  EE40    		XOR	40H
6490:	25F5  CDB225  		CALL	TTYO
6491:	25F8  EE40    		XOR	40H
6492:	25FA  C9      		RET
6493:			
6494:	25FB          	EXICPM:
6495:			; 	EI			; renable interrupts
6496:			; 	CALL	GENAIN		; unlock monitor to enable ints
6497:	25FB  C30000  		JP	$0000
6498:			
6499:	25FE  FE41    	ILCS:	CP	'A'
6500:	2600  D8      		RET	C
6501:	2601  FE5B    		CP	'Z'+1
6502:	2603  D0      		RET	NC
6503:	2604  F620    		OR	20H
6504:	2606  C9      		RET
6505:			
6506:			
6507:			
6508:	2607  FE61    	IXLT:	CP	'a'
6509:	2609  D8      		RET	C
6510:	260A  FE7B    		CP	'z'+1
6511:	260C  D0      		RET	NC
6512:	260D  D620    		SUB	20H
6513:	260F  C9      		RET
6514:			
6516:	2610  3E0D    	CRLF:	LD	A,CR
6517:	2612  CDB225  		CALL	TTYO
6518:	2615  3E0A    		LD	A,LF
6519:	2617  C3B225  		JP	TTYO
6520:			
6521:	261A  3E0D    	CRET:	LD	A,CR
6522:	261C  C3B225  		JP	TTYO
6523:			
6524:	261F  CD4326  	OTHXSP:	CALL	OUTHEX
6525:			
6526:	2622  3E20    	RSPACE:	LD	A,' '
6527:	2624  C3B225  		JP	TTYO
6528:			
6529:	2627  0E05    	SPACE5:	LD	C,5
6530:			
6531:	2629  CD2226  	SPACES:	CALL	RSPACE
6532:	262C  0D      		DEC	C
6533:	262D  20FA    		JR	NZ,SPACES
6534:	262F  C9      		RET
6535:			
6536:			
6537:			
6538:	2630  CD1026  	NEWLIN:	CALL	CRLF
6539:	2633  EB      		EX	DE,HL
6540:	2634  CD3926  		CALL	OUTADR
6541:	2637  EB      		EX	DE,HL
6542:	2638  C9      		RET
6543:			
6544:			
6545:	2639  7C      	OUTADR:	LD	A,H
6546:	263A  CD4326  		CALL	OUTHEX
6547:	263D  7D      		LD	A,L
6548:	263E  CD1F26  		CALL	OTHXSP
6549:	2641  18DF    		JR	RSPACE
6550:			
6551:			
6552:			
6553:	2643  F5      	OUTHEX:	PUSH	AF
6554:	2644  CD5126  		CALL	BINX
6555:	2647  CDB225  		CALL	TTYO
6556:	264A  F1      		POP	AF
6557:	264B  CD5526  		CALL	BINX00
6558:	264E  C3B225  		JP	TTYO
6559:			
6560:			
6561:			
6562:	2651  0F      	BINX:	RRCA
6563:	2652  0F      		RRCA
6564:	2653  0F      		RRCA
6565:	2654  0F      		RRCA
6566:	2655  E60F    	BINX00:	AND	0FH
6567:	2657  C690    		ADD	A,90H
6568:	2659  27      		DAA
6569:	265A  CE40    		ADC	A,40H
6570:	265C  27      		DAA
6571:	265D  C9      		RET
6573:	265E  C5      	ILIN:	PUSH	BC
6574:	265F  D5      		PUSH	DE
6575:	2660  0652    		LD	B,INBFSZ
6576:	2662  0E00    		LD	C,0
6577:	2664  CD9326  		CALL	RTIN
6578:	2667  D1      		POP	DE
6579:	2668  C1      		POP	BC
6580:	2669  C9      		RET
6581:			
6582:			
6583:	266A  C5      	ISTR:	PUSH	BC
6584:	266B  D5      		PUSH	DE
6585:	266C  0601    		LD	B,1
6586:	266E  0E20    		LD	C,' '
6587:	2670  CD8E27  		CALL	IEDT
6588:	2673  D1      		POP	DE
6589:	2674  C1      		POP	BC
6590:	2675  C9      		RET
6591:			
6592:			
6593:							;resume input after reading in one char
6594:			
6595:	2676  C5      	IRSM:	PUSH	BC
6596:	2677  D5      		PUSH	DE
6597:	2678  0651    		LD	B,INBFSZ-1	;max input size less one char already read in
6598:	267A  0E20    		LD	C,' '		;this is terminator char
6599:	267C  1601    		LD	D,1		;preset byte count
6600:	267E  7A      		LD	A,D
6601:	267F  32FC2E  		LD	(STRNGF),A	;set nz - this is string function
6602:	2682  21D82F  		LD	HL,INBF+1	;init buffer pointer
6603:	2685  CDA827  		CALL	IEDT05
6604:	2688  AF      		XOR	A
6605:	2689  32FC2E  		LD	(STRNGF),A	;this is no longer string function
6606:	268C  B2      		OR	D
6607:	268D  F49726  		CALL	P,IN00
6608:	2690  D1      		POP	DE
6609:	2691  C1      		POP	BC
6610:	2692  C9      		RET
6611:			
6612:			
6613:			
6614:	2693  CD8E27  	RTIN:	CALL	IEDT
6615:	2696  F8      		RET	M
6616:	2697  AF      	IN00:	XOR	A
6617:	2698  328F2F  		LD	(ARGBC),A
6618:	269B  21932F  		LD	HL,ARGBF
6619:	269E  22912F  		LD	(ARGBPT),HL
6620:	26A1  CDA926  	IN10:	CALL	IARG
6621:	26A4  C0      		RET	NZ
6622:	26A5  A7      		AND	A
6623:	26A6  20F9    		JR	NZ,IN10
6624:	26A8  C9      		RET
6625:			
6626:			
6627:			
6628:	26A9  C5      	IARG:	PUSH	BC
6629:	26AA  D5      		PUSH	DE
6630:	26AB  CDB426  		CALL	PARG
6631:	26AE  3AF42E  		LD	A,(DELIM)
6632:	26B1  D1      		POP	DE
6633:	26B2  C1      		POP	BC
6634:	26B3  C9      		RET
6636:	26B4  CD2B1A  	PARG:	CALL	PRSR		;extract next argument
6637:	26B7  C0      		RET	NZ		;parse error
6638:	26B8  3AEB2E  		LD	A,(QUOFLG)	;test for ascii	literal
6639:	26BB  A7      		AND	A
6640:	26BC  2834    		JR	Z,PARG10	;quote character not found
6641:	26BE  AF      		XOR	A
6642:	26BF  B0      		OR	B		;test for balanced quotes
6643:	26C0  F8      		RET	M		;error - unbalanced quotes
6644:	26C1  1A      		LD	A,(DE)		;first character of parse buffer
6645:	26C2  D627    		SUB	QUOTE
6646:	26C4  2035    		JR	NZ,PARG50	;invalid literal string but may be expression
6647:							;involving a literal
6648:	26C6  68      		LD	L,B		;l - character count of	parse buffer
6649:	26C7  67      		LD	H,A		;clear
6650:	26C8  19      		ADD	HL,DE		;
6651:	26C9  2B      		DEC	HL		;hl - pointer to last char in parse buffer
6652:	26CA  7E      		LD	A,(HL)		;
6653:	26CB  D627    		SUB	QUOTE		;ensure	literal	string ends with quote
6654:	26CD  202C    		JR		NZ,PARG50
6655:	26CF  77      		LD	(HL),A		;clear trailing quote
6656:	26D0  48      		LD	C,B		;c - character count of	parse buffer
6657:	26D1  47      		LD	B,A		;clear
6658:	26D2  0D      		DEC	C		;subtract the quote characters from the	count
6659:	26D3  0D      		DEC	C
6660:	26D4  0D      		DEC	C		;extra dec set error flag nz for '' string
6661:	26D5  F8      		RET	M		;inform	caller of null string
6662:	26D6  0C      		INC	C		;c - actual string length
6663:	26D7  79      		LD	A,C		;spare copy
6664:	26D8  13      		INC	DE		;point to second character of parse buffer
6665:	26D9  2A912F  		LD	HL,(ARGBPT)	;caller	wants evaluated	arg stored here
6666:	26DC  EB      		EX	DE,HL
6667:	26DD  EDB0    		LDIR
6668:	26DF  EB      		EX	DE,HL
6669:	26E0  2B      		DEC	HL
6670:	26E1  5E      		LD	E,(HL)
6671:	26E2  2B      		DEC	HL
6672:	26E3  56      		LD	D,(HL)
6673:	26E4  23      		INC	HL
6674:	26E5  23      		INC	HL		;point to where to store next arg
6675:	26E6  3D      		DEC	A		;argument length 1?
6676:	26E7  2001    		JR	NZ,PARG00
6677:	26E9  57      		LD	D,A
6678:	26EA  4F      	PARG00:	LD	C,A
6679:	26EB  0C      		INC	C		;account for increment
6680:	26EC  3A8F2F  		LD	A,(ARGBC)	;fetch current argument byte counter
6681:	26EF  81      		ADD	A,C
6682:	26F0  183C    		JR	PARG90
6683:	26F2  CD2312  	PARG10:	CALL	MREG		;check for register specified
6684:	26F5  2004    		JR	NZ,PARG50	;nz - invalid register name
6685:	26F7  79      		LD	A,C
6686:	26F8  87      		ADD	A,A
6687:	26F9  380D    		JR	C,PARG60	;sign bit reset	- 16 bit register pair
6688:	26FB  210000  	PARG50:	LD	HL,00
6689:	26FE  45      		LD	B,L
6690:	26FF  112930  		LD	DE,PRSBF	;reinit	starting address of parse buffer
6691:	2702  CDC418  		CALL	XVAL
6692:	2705  2816    		JR	Z,PARG70
6693:	2707  C9      		RET
6694:	2708  7E      	PARG60:	LD	A,(HL)
6695:	2709  2B      		DEC	HL
6696:	270A  6E      		LD	L,(HL)
6697:	270B  67      		LD	H,A
6698:	270C  3A2930  		LD	A,(PRSBF)	;check paren flag for indirection
6699:	270F  A7      		AND	A
6700:	2710  2005    		JR	NZ,PARG65	;nz - parens not removed
6701:	2712  13      		INC	DE		;bump past trailing null
6702:	2713  7E      		LD	A,(HL)
6703:	2714  23      		INC	HL
6704:	2715  66      		LD	H,(HL)
6705:	2716  6F      		LD	L,A
6706:	2717  0680    	PARG65:	LD	B,80H
6707:	2719  CDC418  		CALL	XVAL
6708:	271C  C0      		RET	NZ
6709:	271D  EB      	PARG70:	EX	DE,HL
6710:	271E  2A912F  		LD	HL,(ARGBPT)
6711:	2721  3A8F2F  		LD	A,(ARGBC)
6712:	2724  14      		INC	D
6713:	2725  15      		DEC	D
6714:	2726  2803    		JR	Z,PARG80
6715:	2728  72      		LD	(HL),D
6716:	2729  23      		INC	HL
6717:	272A  3C      		INC	A
6718:	272B  73      	PARG80:	LD	(HL),E
6719:	272C  23      		INC	HL
6720:	272D  3C      		INC	A
6721:	272E  328F2F  	PARG90:	LD	(ARGBC),A
6722:	2731  22912F  		LD	(ARGBPT),HL
6723:	2734  EB      		EX	DE,HL
6724:	2735  AF      		XOR	A
6725:	2736  C9      		RET
6727:	2737  47      	OUTBYT:	LD	B,A		;save spare copy
6728:	2738  CD1F26  		CALL	OTHXSP		;hex - display
6729:	273B  CD2226  		CALL	RSPACE
6730:	273E  78      		LD	A,B		;display byte in ascii
6731:	273F  CD4828  		CALL	ASCI		;display ascii equivalent
6732:	2742  0E03    		LD	C,3
6733:	2744  C32926  		JP	SPACES		;solicit input three spaces right
6734:			
6735:	2747  CD6A26  	RBYTE:	CALL	ISTR
6736:	274A  3AD62F  		LD	A,(INBFNC)	;number	of chars in input buffer
6737:	274D  3D      		DEC	A		;test for input	buffer count of	zero
6738:	274E  13      		INC	DE		;assume	zero - examine next
6739:	274F  F8      		RET	M		;no input means examine next
6740:	2750  1B      		DEC	DE		;incorrect assumption
6741:	2751  3AD72F  		LD	A,(INBF)	;check first char of input buffer
6742:	2754  FE2E    		CP	'.'
6743:	2756  C8      		RET	Z		;period	ends command
6744:	2757  FE3D    		CP	'='		;new address?
6745:	2759  2014    		JR	NZ,BYTE10
6746:	275B  AF      		XOR	A		;clear equal sign so prsr ignores it
6747:	275C  32D72F  		LD	(INBF),A
6748:	275F  CD7626  		CALL	IRSM		;fetch new address to examine
6749:	2762  201D    		JR	NZ,BYTE30	;error
6750:	2764  3AD62F  		LD	A,(INBFNC)
6751:	2767  D602    		SUB	2
6752:	2769  3816    		JR	C,BYTE30	;c - error - equal sign was only char of input
6753:	276B  EB      		EX	DE,HL		;return new address in de
6754:	276C  37      		SCF			;ensure nz set for caller - no replacement data
6755:							;was entered
6756:	276D  9F      		SBC	A,A
6757:	276E  C9      		RET
6758:	276F  FE5E    	BYTE10:	CP	'^'		;
6759:	2771  2004    		JR	NZ,BYTE15	;nz - not up arrow means need more input
6760:	2773  1B      		DEC	DE		;dec current memory pointer
6761:	2774  37      		SCF	 		;set nz - no replacement data entered
6762:	2775  9F      		SBC	A,A
6763:	2776  C9      		RET
6764:	2777  CD7626  	BYTE15:	CALL	IRSM		;resume	input from console
6765:	277A  C8      		RET	Z		;no errors on input
6766:	277B  3AD62F  		LD	A,(INBFNC)	;check number of chars input
6767:	277E  A7      		AND	A
6768:	277F  28C6    		JR	Z,RBYTE		;none - user hit control x or backspaced to
6769:							;beginning of buffer
6770:	2781  CD7C0D  	BYTE30:	CALL	EXXX
6771:	2784  37      		SCF
6772:	2785  9F      		SBC	A,A		;set nz - no replacement
6773:	2786  C9      		RET
6775:			;******************************************************************************
6776:			;*
6777:			;*	bdos function 10 replacement to	make romming this program easier since
6778:			;*	only two console i/o routines (ttyi and	ttyo) are required. this
6779:			;*	routine	supports backspace, line delete, and tab expansion.
6780:			;*
6781:			;*	all input stored in input buffer inbf.
6782:			;*
6783:			;*
6784:			;*	iedtbc:	solicit	console	for new	input and initialize b and c registers
6785:			;*		for max	size and input and no special line terminator.
6786:			;*
6787:			;*
6788:			;*	iedt:	solicit	console	for new	input using non-default	byte count for
6789:			;*		buffer or non-standard terminator.
6790:			;*
6791:			;*		called:	 b - max number	of characters to receive
6792:			;*			 c - special terminator	other than carriage return
6793:			;*
6794:			;*
6795:			;*	iedt00:	resume input - used by routines	which call iedt	with a buffer
6796:			;*		count of 1 to check for	special	character as the first char
6797:			;*		received (such as exam looking for period).
6798:			;*
6799:			;*		called:	 b - max number	of characters to receive
6800:			;*			 c - special terminator	other than carriage return
6801:			;*
6802:			;******************************************************************************
6803:			
6804:			
6805:	2787  0652    	IEDTBC:	LD	B,INBFSZ
6806:	2789  AF      		XOR	A
6807:	278A  4F      		LD	C,A
6808:	278B  32FC2E  		LD	(STRNGF),A
6809:	278E  AF      	IEDT:	XOR	A
6810:	278F  1652    		LD	D,INBFSZ
6811:	2791  21D72F  		LD	HL,INBF
6812:	2794  77      	IEDT00:	LD	(HL),A
6813:	2795  23      		INC	HL
6814:	2796  15      		DEC	D
6815:	2797  20FB    		JR	NZ,IEDT00
6816:	2799  328F2F  		LD	(ARGBC),A	;init number of	arguments tally
6817:	279C  21932F  		LD	HL,ARGBF
6818:	279F  22912F  		LD	(ARGBPT),HL	;init pointer to start of buffer
6819:	27A2  21D72F  	IEDT03:	LD	HL,INBF		;start of input	buffer
6820:	27A5  32EB2E  		LD	(QUOFLG),A
6821:	27A8  CDD225  	IEDT05:	CALL	INCHAR		;read char from	console
6822:	27AB  32FF2E  		LD	(TRMNTR),A	;assume line terminator until proven otherwise
6823:	27AE  FE0D    		CP	CR		;end of	line?
6824:	27B0  CA3628  		JP	Z,IEDT90	;z - end (jr changed to jp:  eg 3.3.8a)
6825:	27B3  5F      		LD	E,A
6826:	27B4  FE27    		CP	QUOTE
6827:	27B6  3AEB2E  		LD	A,(QUOFLG)
6828:	27B9  2009    		JR	NZ,IEDT10
6829:	27BB  EE27    		XOR	QUOTE
6830:	27BD  32EB2E  		LD	(QUOFLG),A
6831:	27C0  3E27    		LD	A,QUOTE
6832:	27C2  1868    		JR	IEDT60
6833:	27C4  A7      	IEDT10:	AND	A		;quote flag on?
6834:	27C5  7B      		LD	A,E		;recover input character
6835:	27C6  280B    		JR	Z,IEDT15	;off - check terminator
6836:	27C8  3ABC29  		LD	A,(LCMD)
6837:	27CB  CD0726  		CALL	IXLT
6838:	27CE  FE52    		CP	'R'
6839:	27D0  7B      		LD	A,E
6840:	27D1  2003    		JR	NZ,IEDT20
6841:	27D3  B9      	IEDT15:	CP	C		;compare with auxiliary terminator
6842:	27D4  2860    		JR	Z,IEDT90	;z - end
6843:	27D6  FE09    	IEDT20:	CP	TAB
6844:	27D8  200F    		JR	NZ,IEDT35	;nz - not tab check backspace
6845:	27DA  CD2226  	IEDT25:	CALL	RSPACE		;space out until char position mod 8 = zero
6846:	27DD  77      		LD	(HL),A		;store space in buffer as we expand tab
6847:	27DE  23      		INC	HL
6848:	27DF  14      		INC	D
6849:	27E0  3E07    		LD	A,7
6850:	27E2  A2      		AND	D
6851:	27E3  20F5    		JR	NZ,IEDT25
6852:	27E5  3600    		LD	(HL),0		;set end of line null
6853:	27E7  1848    		JR	IEDT70
6854:	27E9  1E01    	IEDT35:	LD	E,1		;assume	one backspace required
6855:	27EB  FE08    		CP	BS
6856:	27ED  280C    		JR	Z,IEDT40	;z - correct assumption
6857:	27EF  FE18    		CP	CTLX		;erase line?
6858:	27F1  2039    		JR	NZ,IEDT60	;nz - process normal input character
6859:			
6860:	27F3  AF      		XOR	A		;+ eg 3.3.8b
6861:	27F4  B2      		OR	D		;+ See if ^X with empty buffer
6862:	27F5  CA100C  		JP	Z,Z8E		;+ Abandon current command if so
6863:			
6864:	27F8  5A      		LD	E,D		;backspace count is number of chars in buffer
6865:			
6866:	27F9  1804    		JR	IEDT50		;+
6867:			
6868:	27FB  AF      	IEDT40:	XOR	A		;test if already at beginning of buffer
6869:	27FC  B2      		OR	D
6870:	27FD  28A9    		JR	Z,IEDT05	;z - at	beginning so leave cursor as is
6871:	27FF  CD3D28  	IEDT50:	CALL	BKSP		;transmit bs - space - bs string
6872:	2802  15      		DEC	D		;sub one from input buffer count
6873:	2803  2B      		DEC	HL		;rewind	buffer pointer on notch
6874:	2804  7E      		LD	A,(HL)		;check for control characters
6875:	2805  3600    		LD	(HL),0
6876:	2807  FE27    		CP	QUOTE		;check for backspacing over a quote
6877:	2809  200A    		JR	NZ,IEDT55
6878:	280B  3AEB2E  		LD	A,(QUOFLG)	;toggle quote flag so we keep track of balance
6879:							;factor
6880:	280E  EE27    		XOR	QUOTE
6881:	2810  32EB2E  		LD	(QUOFLG),A
6882:	2813  1805    		JR	IEDT58
6883:	2815  FE20    	IEDT55:	CP	' '
6884:	2817  DC3D28  		CALL	C,BKSP		;c - control char requires extra bs for caret
6885:	281A  1D      	IEDT58:	DEC	E		;dec backspace count
6886:	281B  20E2    		JR	NZ,IEDT50	;more backspacing
6887:	281D  3AFC2E  		LD	A,(STRNGF)	;string	function flag on?
6888:	2820  A7      		AND	A
6889:	2821  2885    		JR	Z,IEDT05	;off - get next	input char
6890:	2823  AF      		XOR	A		;did we	backspace to start of buffer?
6891:	2824  B2      		OR	D		;test via character count
6892:	2825  2081    		JR	NZ,IEDT05	;not rewound all the way
6893:	2827  32D62F  		LD	(INBFNC),A	;set a zero byte count so caller knows
6894:	282A  15      		DEC	D		;something is fishy
6895:	282B  C9      		RET
6896:	282C  77      	IEDT60:	LD	(HL),A		;store char in inbf
6897:	282D  23      		INC	HL		;bump inbf pointer
6898:	282E  3600    		LD	(HL),0		;end of line
6899:	2830  14      		INC	D		;bump number of	chars in buffer
6900:	2831  7A      	IEDT70:	LD	A,D		;current size
6901:	2832  90      		SUB	B		;versus	max size requested by caller
6902:	2833  DAA827  		JP	C,IEDT05	;more room in buffer
6903:	2836  21D62F  	IEDT90:	LD	HL,INBFNC	;store number of characters received ala
6904:							;bdos function 10
6905:	2839  72      		LD	(HL),D
6906:	283A  23      		INC	HL		;point to first	char in	buffer
6907:	283B  15      		DEC	D		;set m flag if length is zero
6908:	283C  C9      		RET			;sayonara
6909:			
6910:			
6911:			
6912:			
6913:	283D  CD4328  	BKSP:	CALL	BKSP00
6914:	2840  CD2226  		CALL	RSPACE
6915:	2843  3E08    	BKSP00:	LD	A,BS
6916:	2845  C3B225  		JP	TTYO
6917:			
6918:			
6919:	2848  E67F    	ASCI:	AND	7FH		;Convert contents of accumulator to ascii
6920:	0000          		IF	HAZELTINE	;Hazeltine terminal?
6923:				ELSE			;Non-hazeltine terminal
6924:	284A  FE7F    		CP	DEL		;	check for del
6925:	284C  2805    		JR	Z,ASCI00	;	yes - translate to '.'
6926:				ENDIF			;Any terminal - other characters
6927:	284E  FE20    		CP	20H		;	check for control character
6928:	2850  D2B225  		JP	NC,TTYO		;	no - output as is
6929:	2853          	ASCI00:				;	yes - translate to '.'
6930:			;	if	hazeltine
6931:	2853  3E2E    		LD	A,'.'		;Non-printables replaced with dot
6932:			;	else
6933:			;	ld	a,tilde		;Non-printables replaced with squiggle
6934:			;	endif
6935:	2855  C3B225  	       	JP	TTYO
6936:			
6937:			
6938:			
6939:	2858  CD5C28  	BCDX:	CALL	BCDX00
6940:	285B  C0      		RET	NZ
6941:	285C  ED6F    	BCDX00:	RLD
6942:	285E  EB      		EX	DE,HL
6943:	285F  29      		ADD	HL,HL
6944:	2860  44      		LD	B,H
6945:	2861  4D      		LD	C,L
6946:	2862  29      		ADD	HL,HL
6947:	2863  29      		ADD	HL,HL
6948:	2864  09      		ADD	HL,BC
6949:	2865  4F      		LD	C,A
6950:	2866  3E09    		LD	A,9
6951:	2868  B9      		CP	C
6952:	2869  D8      		RET	C
6953:	286A  AF      		XOR	A
6954:	286B  47      		LD	B,A
6955:	286C  09      		ADD	HL,BC
6956:	286D  EB      		EX	DE,HL
6957:	286E  8F      		ADC	A,A
6958:	286F  C9      		RET
6959:			
6960:			
6961:			
6962:	2870  CD1026  	NPRINT:	CALL	CRLF
6963:	2873  1A      	PRINT:	LD	A,(DE)
6964:	2874  A7      		AND	A
6965:	2875  C8      		RET	Z
6966:	2876  CDB225  		CALL	TTYO
6967:	2879  13      		INC	DE
6968:	287A  18F7    		JR	PRINT
6969:			
6970:			
6971:	287C  7E      	PRINTB:	LD	A,(HL)
6972:	287D  A7      		AND	A
6973:	287E  C8      		RET	Z
6974:	287F  CDB225  		CALL	TTYO
6975:	2882  23      		INC	HL
6976:	2883  0D      		DEC	C
6977:	2884  20F6    		JR	NZ,PRINTB
6978:	2886  C9      		RET
6979:			
6980:			
6981:			
6982:	2887  010000  	HOME:	LD	BC,00
6983:			
6984:			
6985:			;----------------------------------------------------------------------------
6986:			;
6987:			;	xycp:	Cursor-positioning routine.
6988:			;
6989:			;	Two versions are supplied and either can be selected during
6990:			;	assembly according to the setting of ATERM.
6991:			;
6992:			;	aterm	equ	TRUE		Selects ANSI screen driver
6993:			;	aterm	equ	FALSE		Selects default screen driver
6994:			;
6995:			;	In either  case, this routine is invoked with the row in B and
6996:			;	the column in C.
6997:			;
6998:			;----------------------------------------------------------------------------
6999:			
7000:	0000          	    IF	ASMB
7002:			    ELSE
7003:	288A          	XYCP:
7004:			    ENDIF
7005:			
7006:	0000          	    IF ATERM
7060:			    ELSE
7061:			
7062:			;	Default screen driver - ras
7063:			
7064:	288A  C5      		PUSH	BC		;Enter with row in b and column in c
7065:	288B  D5      		PUSH	DE
7066:	288C  E5      		PUSH	HL
7067:	288D  21112F  		LD	HL,MXYCP
7068:	2890  3A152F  		LD	A,(ROW)		;Add in row offset
7069:	2893  80      		ADD	A,B
7070:	2894  47      		LD	B,A		;Save row character
7071:	2895  3A162F  		LD	A,(COLUMN)	;Add column bias
7072:	2898  81      		ADD	A,C
7073:	2899  4F      		LD	C,A
7074:	289A  5E      		LD	E,(HL)		;Number of chars in cursor addressing string
7075:	289B          	XYCP00:
7076:	289B  23      		INC	HL
7077:	289C  7E      		LD	A,(HL)
7078:	289D  CDB225  		CALL	TTYO
7079:	28A0  1D      		DEC	E
7080:	28A1  20F8    		JR	NZ,XYCP00
7081:	28A3  3A102F  		LD	A,(ROWB4X)
7082:	28A6  A7      		AND	A
7083:	28A7  2003    		JR	NZ,XYCP10
7084:	28A9  78      		LD	A,B
7085:	28AA  41      		LD	B,C
7086:	28AB  4F      		LD	C,A
7087:	28AC          	XYCP10:
7088:	28AC  78      		LD	A,B
7089:	28AD  CDB225  		CALL	TTYO
7090:	28B0  79      		LD	A,C
7091:	28B1  CDB225  		CALL	TTYO
7092:	28B4  E1      		POP	HL
7093:	28B5  D1      		POP	DE
7094:	28B6  C1      		POP	BC
7095:	28B7  C9      		RET
7096:			
7097:			    ENDIF
7098:			
7099:	FFFF          	    IF	NOT COMPACT			;..then leave room for patching
7100:	290A          		ORG	XYCP+128		;  the object code
7101:			    ENDIF
7102:			
7103:	290A          	NREL:					;end of	relocatable code
7105:			
7106:	290A          	ZOPNM:
7107:	290A  484C    		DEFB	'HL'
7108:	290C  4120    		DEFB	'A '
7109:	290E  4820    		DEFB	'H '
7110:	2910  4C20    		DEFB	'L '
7111:	2912  4420    		DEFB	'D '
7112:	2914  4520    		DEFB	'E '
7113:	2916  4220    		DEFB	'B '
7114:	2918  4320    		DEFB	'C '
7115:	291A  4958    	SIX:	DEFB	'IX'
7116:	291C  5350    		DEFB	'SP'
7117:	291E  5020    		DEFB	'P '
7118:	2920  5220    		DEFB	'R '
7119:	2922  4920    		DEFB	'I '
7120:	2924  4146    		DEFB	'AF'
7121:	2926  4243    		DEFB	'BC'
7122:	2928  4445    		DEFB	'DE'
7123:	292A  4959    	SIY:	DEFB	'IY'
7124:	292C  5A20    		DEFB	'Z '
7125:	292E  4E43    		DEFB	'NC'
7126:	2930  4E5A    		DEFB	'NZ'
7127:	2932  5045    		DEFB	'PE'
7128:	2934  504F    		DEFB	'PO'
7129:	2936  4D20    		DEFB	'M '
7130:	2938  5043    		DEFB	'PC'
7131:			
7132:	0008          	RIX	EQU	(SIX-ZOPNM)/2		;relative position - ix
7133:	0010          	RIY	EQU	(SIY-ZOPNM)/2		;		     iy
7134:			
7135:	0018          	ZOPNML	EQU	($-ZOPNM)/2
7136:			
7137:	0030          	ZOPJTB	EQU	 $-NREL			;nrel to jump table bias for loader
7138:			
7139:	293A          	ZOPRJT:
7140:	293A  3D24    		DEFW	OPN600			;18 - hl/ix/iy test
7141:	293C  1324    		DEFW	OPN400			;19 - register specified in bits 0-2
7142:	293E  1324    		DEFW	OPN400			;1a - register specified in bits 3-5
7143:	2940  7D23    		DEFW	OPN100			;1b - relative jump
7144:	2942  9A23    		DEFW	OPN200			;1c - nn
7145:	2944  DE23    		DEFW	OPN300			;1d - nnnn
7146:	2946  8924    		DEFW	OPN700			;1e - restart
7147:	2948  9824    		DEFW	OPN800			;1f - bit number
7148:			
7149:	294A  F52F    	ZASMIO:	DEFW	ZASMBF
7150:			
7151:	0009          	ZOPJTL	EQU	($-ZOPRJT)/2		;length	of operand jump	table
7152:			
7153:	294C          	JTCMD:
7154:	294C  CD1C    		DEFW	IFCB			; i
7155:	294E  A415    		DEFW	ASMBLR			; a
7156:	2950  5410    		DEFW	USYM			; u
7157:	2952  5912    		DEFW	NPRT			; n
7158:	2954  850D    		DEFW	JDBG			; j
7159:	2956  1C20    		DEFW	ZASM			; z
7160:	2958  B60F    		DEFW	EXAM			; e
7161:	295A  8E11    		DEFW	RGST			; r
7162:	295C  2714    		DEFW	GO			; g
7163:	295E  601C    		DEFW	YFIL			; y
7164:	2960  3B1C    		DEFW	MOVB			; m
7165:	2962  831F    		DEFW	VERIFY			; v
7166:	2964  CC1B    		DEFW	PSWDSP			; p
7167:	2966  E712    		DEFW	BREAK			; b
7168:	2968  4A13    		DEFW	CBREAK			; c
7169:	296A  201F    		DEFW	FIND			; f
7170:	296C  EE0F    		DEFW	HSYM			; h
7171:	296E  4015    		DEFW	STEP			; s
7172:	2970  AC13    		DEFW	OBREAK			; o
7173:	2972  301D    		DEFW	LLDR			; l
7174:	2974  EC10    		DEFW	DUMP			; d
7175:	2976  5912    		DEFW	QPRT			; q
7176:	2978  AD1F    		DEFW	XREG			; x
7177:	297A  F513    		DEFW	KDMP			; k
7178:	297C  C71E    		DEFW	WRIT			; w
7179:	297E  7A1C    		DEFW	CUSER			; >
7180:	2980  9B1C    		DEFW	QEVAL			; ?
7181:			;	defw	gadr			; #
7182:	2982          	CMD:
7183:			;	defb	'#?>WKXQDLOSHFCB'
7184:	2982  3F3E574B		DEFB	'?>WKXQDLOSHFCB'
	      5851444C
	      4F534846
	      4342
7185:	2990  50564D59		DEFB	'PVMYGREZJNUAI'
	      4752455A
	      4A4E5541
	      49
7186:	001B          	NCMD	EQU	$-CMD		;number	of commands
7187:			
7188:	299D          	BPEMSG:
7189:	299D  2A455252		DEFB	'*ERROR*'
	      4F522A
7190:	29A4          	BPMSG:
7191:	29A4  2A42502A		DEFB	'*BP* @ '
	      204020
7192:	29AB  00      		DEFB	0
7193:	29AC          	PROMPT:
7194:	29AC  2A200800		DEFB	'*',' ',bs,0
7195:			
7196:	29B0  3D3E    	MRROW:	DEFB	'=','>'		;backspaces taken out
7197:	29B2  00      		DEFB	00
7198:			
7199:	29B3  3F3F    	MXXXX:	DEFB	'??'
7200:	29B5  203F3F20	MXX:	DEFB	' ??  '
	      20
7201:			
7202:			
7203:	29BA  20      	ASMFLG:	DEFB	' '
7204:	29BB  00      		DEFB	0
7205:			
7206:	29BC  20      	LCMD:	DEFB	' '
7207:	29BD  203F3F  	EMXXX:	DEFB	' ??'
7208:	29C0  00      		DEFB	0
7209:			
7210:	29C1          	MLDG:
7211:	29C1  4C6F6164		DEFB	'Loading: '
	      696E673A
	      20
7212:	29CA  00      		DEFB	0
7213:			
7214:	29CB          	MFILNF:
7215:	29CB  46696C65		DEFB	'File Not Found'
	      204E6F74
	      20466F75
	      6E64
7216:	29D9  0D0A00  		DEFB	CR,LF,00
7217:			
7218:			
7219:	29DC          	MLODM:
7220:	29DC  4C6F6164		DEFB	'Loaded:  '
	      65643A20
	      20
7221:	29E5  00      		DEFB	0
7222:	29E6          	MLODPG:
7223:			
7224:	29E6  50616765		DEFB	'Pages:   '
	      733A2020
	      20
7225:	29EF  00      		DEFB	0
7226:			
7227:	29F0          	MSNTX:
7228:	29F0  53796E74		DEFB	'Syntax Error'
	      61782045
	      72726F72
7229:	29FC  0D0A00  		DEFB	CR,LF,0
7230:			
7231:	29FF  4F757420	MMEMXX:	DEFB	'Out Of Memory'
	      4F66204D
	      656D6F72
	      79
7232:	2A0C  00      		DEFB	0
7233:			
7234:	2A0D  202D2043	MCNTU:	DEFB	' - Continue? '
	      6F6E7469
	      6E75653F
	      20
7235:	2A1A  00      		DEFB	0
7236:			
7237:	2A1B          	MIREG:
7238:	2A1B  49523A20		DEFB	'IR: '
7239:	2A1F  00      		DEFB	0
7241:			
7242:	2A20  09192B  	Z80FD:	DEFB	009H,019H,02BH
7243:	2A23  232939E1		DEFB	023H,029H,039H,0E1H
7244:	2A27  E3E5E9F9		DEFB	0E3H,0E5H,0E9H,0F9H
7245:	000B          	Z80FDL	EQU	$-Z80FD
7246:			
7247:	2A2B  21222A36	Z80F4:	DEFB	021H,022H,02AH,036H,0CBH
	      CB
7248:	0005          	Z80F4L	EQU	$-Z80F4
7249:			
7250:			
7251:	2A30  C0E9C9D8	Z801:	DEFB	0C0H,0E9H,0C9H,0D8H
7252:	2A34  D0C8E8E0		DEFB	0D0H,0C8H,0E8H,0E0H
7253:	2A38  F8F0    		DEFB	0F8H,0F0H
7254:	000A          	Z801L	EQU	$-Z801
7255:			
7256:			
7257:	2A3A  36C6CED3	Z802:	DEFB	036H,0C6H,0CEH,0D3H
7258:	2A3E  D6DBDEE6		DEFB	0D6H,0DBH,0DEH,0E6H
7259:	2A42  EEF6FE  		DEFB	0EEH,0F6H,0FEH
7260:	2A45  183830  	Z802C:	DEFB	018H,038H,030H
7261:	2A48  282010  		DEFB	028H,020H,010H
7262:	0011          	Z802L	EQU	$-Z802
7263:	0006          	Z802CL	EQU	$-Z802C
7264:			
7265:			
7266:	2A4B          	Z80R:
7267:	2A4B  01112122	Z803:	DEFB	001H,011H,021H,022H
7268:	2A4F  2A31323A		DEFB	02AH,031H,032H,03AH
7269:			
7270:	2A53  CD      	Z803S:	DEFB	0CDH
7271:	2A54  DCD4CCC4		DEFB	0DCH,0D4H,0CCH,0C4H
7272:	2A58  ECE4FCF4		DEFB	0ECH,0E4H,0FCH,0F4H
7273:			
7274:	0009          	Z803SL	EQU	$-Z803S			;number	of call	instructions
7275:			
7276:	2A5C  C3      	Z803C:	DEFB	0C3H
7277:	2A5D  DAD2CAC2		DEFB	0DAH,0D2H,0CAH,0C2H
7278:	2A61  EAE2FAF2		DEFB	0EAH,0E2H,0FAH,0F2H
7279:			
7280:	001A          	Z803L	EQU	$-Z803			;number	of 3 byte instructions
7281:	0012          	Z803CL	EQU	$-Z803S			;number	of 3 byte pc mod instructions
7282:			
7283:	2A65  434B53  	Z80ED:	DEFB	043H,04BH,053H
7284:	2A68  5B737B  		DEFB	05BH,073H,07BH
7285:			
7286:	0006          	Z80EDL	EQU	$-Z80ED
7287:			
7288:	0020          	Z80RL	EQU	$-Z80R			;number	relocatable z80	instructions
7289:			
7290:	2A6B          	Z80F3:
7291:	2A6B  3435464E		DEFB	034H,035H,046H,04EH
7292:	2A6F  565E666E		DEFB	056H,05EH,066H,06EH
7293:	2A73  70717273		DEFB	070H,071H,072H,073H
7294:	2A77  7475777E		DEFB	074H,075H,077H,07EH
7295:	2A7B  868E969E		DEFB	086H,08EH,096H,09EH
7296:	2A7F  A6AEB6BE		DEFB	0A6H,0AEH,0B6H,0BEH
7297:	0018          	Z80F3L	EQU	$-Z80F3
7299:			;***********************************************************************
7300:			;*
7301:			;*
7302:			;*
7303:			;*
7304:			;*
7305:			;***********************************************************************
7306:			
7307:	2A84          		ORG	($+3) AND 0FFFCH
7308:	2A84          	ZOPCPT:
7309:	2A84  221C1C15		DEFB	022H,01CH,01CH,015H	;nop	ld	ld	inc	00 - 03
7310:	2A88  150C1C31		DEFB	015H,00CH,01CH,031H	;inc	dec	ld	rlca	04 - 07
7311:	2A8C  10001C0C		DEFB	010H,000H,01CH,00CH	;ex	add	ld	dec	08 - 0b
7312:	2A90  150C1C36		DEFB	015H,00CH,01CH,036H	;inc	dec	ld	rrca	0c - 0f
7313:	2A94  0E1C1C15		DEFB	00EH,01CH,01CH,015H	;djnz	ld	ld	inc	10 - 13
7314:	2A98  150C1C2F		DEFB	015H,00CH,01CH,02FH	;inc	dec	ld	rla	14 - 17
7315:	2A9C  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	18 - 1b
7316:	2AA0  150C1C34		DEFB	015H,00CH,01CH,034H	;inc	dec	ld	rra	1c - 1f
7317:	2AA4  1B1C1C15		DEFB	01BH,01CH,01CH,015H	;jr	ld	ld	inc	20 - 23
7318:	2AA8  150C1C0B		DEFB	015H,00CH,01CH,00BH	;inc	dec	ld	daa	24 - 27
7319:	2AAC  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	28 - 2b
7320:	2AB0  150C1C0A		DEFB	015H,00CH,01CH,00AH	;inc	dec	ld	cpl	2c - 2f
7321:	2AB4  1B1C1C15		DEFB	01BH,01CH,01CH,015H	;jr	ld	ld	inc	30 - 33
7322:	2AB8  150C1C3A		DEFB	015H,00CH,01CH,03AH	;inc	dec	ld	scf	34 - 37
7323:	2ABC  1B001C0C		DEFB	01BH,000H,01CH,00CH	;jr	add	ld	dec	38 - 3b
7324:	2AC0  150C1C04		DEFB	015H,00CH,01CH,004H	;inc	dec	ld	ccf	3c - 3f
7325:			
7326:			
7327:	2AC4  1426391C		DEFB	014H,026H,039H,01CH	;in	out	sbc	ld	ed 40
7328:	2AC8  212D131C		DEFB	021H,02DH,013H,01CH	;neg	retn	im	ld
7329:	2ACC  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7330:	2AD0  222C221C		DEFB	022H,02CH,022H,01CH	;....	reti	...	ld
7331:	2AD4  1426391C		DEFB	014H,026H,039H,01CH	;in	out	sbc	ld
7332:	2AD8  2222131C		DEFB	022H,022H,013H,01CH	;...	...	im	ld
7333:	2ADC  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7334:	2AE0  2222131C		DEFB	022H,022H,013H,01CH	;...	...	im	ld
7335:	2AE4  14263922		DEFB	014H,026H,039H,022H	;in	out	sbc	...
7336:	2AE8  22220237		DEFB	022H,022H,002H,037H	;...	...	...	rrd
7337:	2AEC  14260122		DEFB	014H,026H,001H,022H	;in	out	adc	...
7338:	2AF0  44454632		DEFB	044H,045H,046H,032H	;defb*	defw*	ddb*	rld
7339:	2AF4  4347391C		DEFB	043H,047H,039H,01CH	;org*	equ*	sbc	ld	ed 70
7340:	2AF8  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7341:	2AFC  1426011C		DEFB	014H,026H,001H,01CH	;in	out	adc	ld
7342:	2B00  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...	ed 7f
7343:			
7344:			
7345:	2B04  1F081828		DEFB	01FH,008H,018H,028H	;ldi	cpi	ini	outi
7346:	2B08  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7347:	2B0C  1D061627		DEFB	01DH,006H,016H,027H	;ldd	cpd	ind	outd
7348:	2B10  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7349:	2B14  20091925		DEFB	020H,009H,019H,025H	;ldir	cpir	inir	otir
7350:	2B18  22222222		DEFB	022H,022H,022H,022H	;...	...	...	...
7351:	2B1C  1E071724		DEFB	01EH,007H,017H,024H	;lddr	cpdr	indr	otdr
7352:	2B20  22222244		DEFB	022H,022H,022H,044H	;...	....	....	defb*
7353:			
7354:			
7355:	2B24  2B291A1A		DEFB	02BH,029H,01AH,01AH	;ret	pop	jp	jp	c0 - c3
7356:	2B28  032A0038		DEFB	003H,02AH,000H,038H	;call	push	add	rst	c4 - c7
7357:	2B2C  2B2B1A22		DEFB	02BH,02BH,01AH,022H	;ret	ret	jp	...	c8 - cb
7358:	2B30  03030138		DEFB	003H,003H,001H,038H	;call	call	adc	rst	cc - cf
7359:	2B34  2B291A26		DEFB	02BH,029H,01AH,026H	;ret	pop	jp	out	d0 - d3
7360:	2B38  032A3E38		DEFB	003H,02AH,03EH,038H	;call	push	sub	rst	d4 - d7
7361:	2B3C  2B111A14		DEFB	02BH,011H,01AH,014H	;ret	exx	jp	in	d8 - db
7362:	2B40  03223938		DEFB	003H,022H,039H,038H	;call	...	sbc	rst	dc - df
7363:	2B44  2B291A10		DEFB	02BH,029H,01AH,010H	;ret	pop	jp	ex	e0 - e3
7364:	2B48  032A0238		DEFB	003H,02AH,002H,038H	;call	push	and	rst	e4 - e7
7365:	2B4C  2B1A1A10		DEFB	02BH,01AH,01AH,010H	;ret	jp	jp	ex	e8 - eb
7366:	2B50  03223F38		DEFB	003H,022H,03FH,038H	;call	...	xor	rst	ec - ef
7367:	2B54  2B291A0D		DEFB	02BH,029H,01AH,00DH	;ret	pop	jp	di	f0 - f3
7368:	2B58  032A2338		DEFB	003H,02AH,023H,038H	;call	push	or	rst	f4 - f7
7369:	2B5C  2B1C1A0F		DEFB	02BH,01CH,01AH,00FH	;ret	ld	jp	ei	f8 - fb
7370:	2B60  03220538		DEFB	003H,022H,005H,038H	;call	...	cp	rst	fc - ff
7371:			
7372:	2B64  00013E39		DEFB	000H,001H,03EH,039H	;add	adc	sub	sbc
7373:	2B68  023F2305		DEFB	002H,03FH,023H,005H	;and	xor	or	cp
7374:			
7375:			
7376:	2B6C  30352E33		DEFB	030H,035H,02EH,033H	;rlc	rrc	rl	rr
7377:	2B70  3B3C223D		DEFB	03BH,03CH,022H,03DH	;sla	sra	...	srl
7378:	2B74  22404142		DEFB	022H,040H,041H,042H	;...	bit	res	set
7379:			
7380:			
7381:	2B78  22222212		DEFB	022H,022H,022H,012H	;...	...	...	halt
7382:			
7383:			
7384:	2B7C  1C1C1C1C		DEFB	01CH,01CH,01CH,01CH	;ld	ld	ld	ld
7385:	2B80  1C1C1C1C		DEFB	01CH,01CH,01CH,01CH	;ld	ld	ld	ld
7386:			
7388:			;****************************************************************************
7389:			;*
7390:			;*			table of first operands
7391:			;*
7392:			;****************************************************************************
7393:			
7394:	2B84          	ZOPND1:
7395:	2B84  FF0E8E0E		DEFB	0FFH,00EH,08EH,00EH	;00 - 03
7396:	2B88  060606FF		DEFB	006H,006H,006H,0FFH	;04 - 07
7397:	2B8C  0D18010E		DEFB	00DH,018H,001H,00EH	;08 - 0b
7398:	2B90  070707FF		DEFB	007H,007H,007H,0FFH	;0c - 0f
7399:	2B94  1B0F8F0F		DEFB	01BH,00FH,08FH,00FH	;10 - 13
7400:	2B98  040404FF		DEFB	004H,004H,004H,0FFH	;14 - 17
7401:	2B9C  1B18010F		DEFB	01BH,018H,001H,00FH	;18 - 1b
7402:	2BA0  050505FF		DEFB	005H,005H,005H,0FFH	;1c - 1f
7403:	2BA4  13189D18		DEFB	013H,018H,09DH,018H	;20 - 23
7404:	2BA8  020202FF		DEFB	002H,002H,002H,0FFH	;24 - 27
7405:	2BAC  11181818		DEFB	011H,018H,018H,018H	;28 - 2b
7406:	2BB0  030303FF		DEFB	003H,003H,003H,0FFH	;2c - 2f
7407:	2BB4  12099D09		DEFB	012H,009H,09DH,009H	;30 - 33
7408:	2BB8  989898FF		DEFB	098H,098H,098H,0FFH	;34 - 37
7409:	2BBC  07180109		DEFB	007H,018H,001H,009H	;38 - 3b
7410:	2BC0  010101FF		DEFB	001H,001H,001H,0FFH	;3c - 3f
7411:			
7412:	2BC4  0687009D		DEFB	006H,087H,000H,09DH	;40 - 43
7413:	2BC8  FFFF1F0C		DEFB	0FFH,0FFH,01FH,00CH	;44 - 47
7414:	2BCC  0787000E		DEFB	007H,087H,000H,00EH	;48 - 4b
7415:	2BD0  FFFFFF0B		DEFB	0FFH,0FFH,0FFH,00BH	;4c - 4f
7416:	2BD4  0487009D		DEFB	004H,087H,000H,09DH	;50 - 53
7417:	2BD8  FFFF1F01		DEFB	0FFH,0FFH,01FH,001H	;54 - 57
7418:	2BDC  0587000F		DEFB	005H,087H,000H,00FH	;58 - 5b
7419:	2BE0  FFFF1F01		DEFB	0FFH,0FFH,01FH,001H	;5c - 5f
7420:	2BE4  028700FF		DEFB	002H,087H,000H,0FFH	;60 - 63
7421:	2BE8  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;64 - 67
7422:	2BEC  038700FF		DEFB	003H,087H,000H,0FFH	;68 - 6b
7423:	2BF0  1C1D1DFF		DEFB	01CH,01DH,01DH,0FFH	;6c - 6f	defb  defw  ddb
7424:	2BF4  1D1D009D		DEFB	01DH,01DH,000H,09DH	;70 - 73	org   equ
7425:	2BF8  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;74 - 77
7426:	2BFC  01870009		DEFB	001H,087H,000H,009H	;78 - 7b
7427:	2C00  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;7c - 7f
7428:			
7429:	2C04  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a0 - bf
7430:	2C08  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a4 - a7
7431:	2C0C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a8 - ab
7432:	2C10  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;ac - af
7433:	2C14  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b0 - b3
7434:	2C18  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b4 - b7
7435:	2C1C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b8 - bb
7436:	2C20  FFFF0FFF		DEFB	0FFH,0FFH,00FH,0FFH	;bc - bf
7437:			
7438:	2C24  130E131D		DEFB	013H,00EH,013H,01DH	;c0 - c3
7439:	2C28  130E011E		DEFB	013H,00EH,001H,01EH	;c4 - c7
7440:	2C2C  11FF11FF		DEFB	011H,0FFH,011H,0FFH	;c8 - cb
7441:	2C30  111D011E		DEFB	011H,01DH,001H,01EH	;cc - cf
7442:	2C34  120F129C		DEFB	012H,00FH,012H,09CH	;d0 - d3
7443:	2C38  120F1C1E		DEFB	012H,00FH,01CH,01EH	;d4 - d7
7444:	2C3C  07FF0701		DEFB	007H,0FFH,007H,001H	;d8 - db
7445:	2C40  07FF011E		DEFB	007H,0FFH,001H,01EH	;dc - df
7446:	2C44  15181589		DEFB	015H,018H,015H,089H	;e0 - e3
7447:	2C48  15181C1E		DEFB	015H,018H,01CH,01EH	;e4 - e7
7448:	2C4C  1498140F		DEFB	014H,098H,014H,00FH	;e8 - eb
7449:	2C50  14FF1C1E		DEFB	014H,0FFH,01CH,01EH	;ec - ef
7450:	2C54  0A0D0AFF		DEFB	00AH,00DH,00AH,0FFH	;f0 - f3
7451:	2C58  0A0D1C1E		DEFB	00AH,00DH,01CH,01EH	;f4 - f7
7452:	2C5C  160916FF		DEFB	016H,009H,016H,0FFH	;f8 - fb
7453:	2C60  16FF1C1E		DEFB	016H,0FFH,01CH,01EH	;fc - ff
7454:			
7455:			
7456:	2C64  01011901		DEFB	001H,001H,019H,001H	;8 bit logic and arithmetic
7457:	2C68  19191919		DEFB	019H,019H,019H,019H	;
7458:			
7459:			
7460:	2C6C  19191919		DEFB	019H,019H,019H,019H	;shift and rotate
7461:	2C70  19191919		DEFB	019H,019H,019H,019H	;
7462:	2C74  FF1F1F1F		DEFB	0FFH,01FH,01FH,01FH	;bit - res - set
7463:			
7464:	2C78  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;filler
7465:			
7466:	2C7C  1A1A1A1A		DEFB	01AH,01AH,01AH,01AH	;8 bit load
7467:	2C80  1A1A1A1A		DEFB	01AH,01AH,01AH,01AH	;
7468:			
7470:			;***********************************************************************
7471:			;*
7472:			;*			table of second	operands
7473:			;*
7474:			;***********************************************************************
7475:			
7476:			
7477:	2C84          	ZOPND2:
7478:	2C84  FF1D01FF		DEFB	0FFH,01DH,001H,0FFH	;00 - 03
7479:	2C88  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;04 - 07
7480:	2C8C  0D0E8EFF		DEFB	00DH,00EH,08EH,0FFH	;08 - 0b
7481:	2C90  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;0c - 0f
7482:	2C94  FF1D01FF		DEFB	0FFH,01DH,001H,0FFH	;10 - 13
7483:	2C98  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;14 - 17
7484:	2C9C  FF0F8FFF		DEFB	0FFH,00FH,08FH,0FFH	;18 - 1b
7485:	2CA0  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;1c - 1f
7486:	2CA4  1B1D18FF		DEFB	01BH,01DH,018H,0FFH	;20 - 23
7487:	2CA8  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;24 - 27
7488:	2CAC  1B189DFF		DEFB	01BH,018H,09DH,0FFH	;28 - 2b
7489:	2CB0  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;2c - 2f
7490:	2CB4  1B1D01FF		DEFB	01BH,01DH,001H,0FFH	;30 - 33
7491:	2CB8  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;34 - 37
7492:	2CBC  1B099DFF		DEFB	01BH,009H,09DH,0FFH	;38 - 3b
7493:	2CC0  FFFF1CFF		DEFB	0FFH,0FFH,01CH,0FFH	;3c - 3f
7494:			
7495:			
7496:	2CC4  87060E0E		DEFB	087H,006H,00EH,00EH	;40 - 43
7497:	2CC8  FFFFFF01		DEFB	0FFH,0FFH,0FFH,001H	;44 - 47
7498:	2CCC  87070E9D		DEFB	087H,007H,00EH,09DH	;48 - 4b
7499:	2CD0  FFFFFF01		DEFB	0FFH,0FFH,0FFH,001H	;4c - 4f
7500:	2CD4  87040F0F		DEFB	087H,004H,00FH,00FH	;50 - 53
7501:	2CD8  FFFFFF0C		DEFB	0FFH,0FFH,0FFH,00CH	;54 - 57
7502:	2CDC  87050F9D		DEFB	087H,005H,00FH,09DH	;58 - 5b
7503:	2CE0  FFFFFF0B		DEFB	0FFH,0FFH,0FFH,00BH	;5c - 5f
7504:	2CE4  870200FF		DEFB	087H,002H,000H,0FFH	;60 - 63
7505:	2CE8  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;64 - 67
7506:	2CEC  870300FF		DEFB	087H,003H,000H,0FFH	;68 - 6b
7507:	2CF0  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;6c - 6f
7508:	2CF4  FFFF0909		DEFB	0FFH,0FFH,009H,009H	;70 - 73
7509:	2CF8  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;74 - 77
7510:	2CFC  8701099D		DEFB	087H,001H,009H,09DH	;78 - 7b
7511:	2D00  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH
7512:			
7513:	2D04  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a0 - bf
7514:	2D08  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a4 - a7
7515:	2D0C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;a8 - ab
7516:	2D10  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;ac - af
7517:	2D14  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b0 - b3
7518:	2D18  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b4 - b7
7519:	2D1C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;b8 - bb
7520:	2D20  FFFF0FFF		DEFB	0FFH,0FFH,00FH,0FFH	;bc - bf
7521:			
7522:	2D24  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;c0 - c3
7523:	2D28  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;c4 - c7
7524:	2D2C  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;c8 - cb
7525:	2D30  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;cc - cf
7526:	2D34  FFFF1D01		DEFB	0FFH,0FFH,01DH,001H	;d0 - d3
7527:	2D38  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;d4 - d7
7528:	2D3C  FFFF1D9C		DEFB	0FFH,0FFH,01DH,09CH	;d8 - db
7529:	2D40  1DFF1CFF		DEFB	01DH,0FFH,01CH,0FFH	;dc - df
7530:	2D44  FFFF1D18		DEFB	0FFH,0FFH,01DH,018H	;e0 - e3
7531:	2D48  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;e4 - e7
7532:	2D4C  FFFF1D00		DEFB	0FFH,0FFH,01DH,000H	;e8 - eb
7533:	2D50  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;ec - ef
7534:	2D54  FFFF1DFF		DEFB	0FFH,0FFH,01DH,0FFH	;f0 - f3
7535:	2D58  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;f4 - f7
7536:	2D5C  FF181DFF		DEFB	0FFH,018H,01DH,0FFH	;f8 - fb
7537:	2D60  1DFFFFFF		DEFB	01DH,0FFH,0FFH,0FFH	;fc - ff
7538:			
7539:	2D64  1919FF19		DEFB	019H,019H,0FFH,019H	;8 bit logic and arithmetic
7540:	2D68  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;
7541:			
7542:	2D6C  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;shift and rotate
7543:	2D70  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH	;
7544:	2D74  FF191919		DEFB	0FFH,019H,019H,019H	;bit - res - set
7545:			
7546:	2D78  FFFFFFFF		DEFB	0FFH,0FFH,0FFH,0FFH
7547:			
7548:	2D7C  19191919		DEFB	019H,019H,019H,019H	;8 bit load
7549:	2D80  19191919		DEFB	019H,019H,019H,019H
7551:			
7552:			;***********************************************************************
7553:			;*
7554:			;*			table of op code names
7555:			;*
7556:			;***********************************************************************
7557:			
7558:			
7559:	2D84          	ZOPCNM:
7560:	2D84  41444420		DEFB	'ADD ADC AND CALL'
	      41444320
	      414E4420
	      43414C4C
7561:	2D94  43434620		DEFB	'CCF CP  CPD CPDR'
	      43502020
	      43504420
	      43504452
7562:	2DA4  43504920		DEFB	'CPI CPIRCPL DAA '
	      43504952
	      43504C20
	      44414120
7563:	2DB4  44454320		DEFB	'DEC DI  DJNZEI  '
	      44492020
	      444A4E5A
	      45492020
7564:	2DC4  45582020		DEFB	'EX  EXX HALTIM  '
	      45585820
	      48414C54
	      494D2020
7565:	2DD4  494E2020		DEFB	'IN  INC IND INDR'
	      494E4320
	      494E4420
	      494E4452
7566:	2DE4  494E4920		DEFB	'INI INIRJP  JR  '
	      494E4952
	      4A502020
	      4A522020
7567:	2DF4  4C442020		DEFB	'LD  LDD LDDRLDI '
	      4C444420
	      4C444452
	      4C444920
7568:	2E04  4C444952		DEFB	'LDIRNEG NOP OR  '
	      4E454720
	      4E4F5020
	      4F522020
7569:	2E14  4F544452		DEFB	'OTDROTIROUT OUTD'
	      4F544952
	      4F555420
	      4F555444
7570:	2E24  4F555449		DEFB	'OUTIPOP PUSHRET '
	      504F5020
	      50555348
	      52455420
7571:	2E34  52455449		DEFB	'RETIRETNRL  RLA '
	      5245544E
	      524C2020
	      524C4120
7572:	2E44  524C4320		DEFB	'RLC RLCARLD RR  '
	      524C4341
	      524C4420
	      52522020
7573:	2E54  52524120		DEFB	'RRA RRC RRCARRD '
	      52524320
	      52524341
	      52524420
7574:	2E64  52535420		DEFB	'RST SBC SCF SLA '
	      53424320
	      53434620
	      534C4120
7575:	2E74  53524120		DEFB	'SRA SRL SUB XOR '
	      53524C20
	      53554220
	      584F5220
7576:	2E84  42495420		DEFB	'BIT RES SET ORG '
	      52455320
	      53455420
	      4F524720
7577:	2E94  44454642		DEFB	'DEFBDEFWDDB EQU '
	      44454657
	      44444220
	      45515520
7578:			
7579:			
7580:			
7581:			
7582:	2EA4          	OP1000:
7583:	2EA4  FDDDEDCB		DEFB	 0FDH,0DDH,0EDH,0CBH
7584:			
7585:			
7586:			
7587:	2EA8  88      	PSWBIT:	DEFB	10001000B		;minus
7588:	2EA9  80      		DEFB	10000000B		;positive
7589:	2EAA  0C      		DEFB	00001100B		;even parity
7590:	2EAB  04      		DEFB	00000100B		;odd parity
7591:	2EAC  48      		DEFB	01001000B		;zero
7592:	2EAD  40      		DEFB	01000000B		;not zero
7593:	2EAE  09      		DEFB	00001001B		;carry
7594:	2EAF  01      		DEFB	00000001B		;no carry
7595:			
7596:	2EB0  12071311	PSWMAP:	DEFB	18,07,19,17,21,20,10,22
	      15140A16
7597:	0008          	PSWCNT	EQU	$-PSWMAP
7598:			
7599:			
7600:	2EB8          	REGMAP:
7601:	2EB8  87010706		DEFB	87H,01H,07H,06H,05H,04H
	      0504
7602:	2EBE  03029593		DEFB	03H,02H,95H,93H,91H,18H
	      9118
7603:	2EC4  19818385		DEFB	19H,81H,83H,85H,97H
	      97
7604:			
7605:	2EC9          	REGPTR:
7606:	2EC9  0D0E0F00		DEFB	0DH,0EH,0FH,00H
7607:	2ECD  8D8E8F80		DEFB	8DH,8EH,8FH,80H
7608:	2ED1  0A090810		DEFB	0AH,09H,08H,10H
7609:			
7610:	2ED5  F5F7    	SIOTBL:	DEFB	0F5H,0F7H
7611:			
7612:	2ED7  FF      	SYMFLG:	DEFB	0FFH		;symbol	table flag   00	- table	present
7613:							;		     ff	- no table
7614:			
7615:	2ED8          	BSIZ:				;dump block size storage
7616:	2ED8  00      	BSIZLO:	DEFB	0		;     lo order
7617:	2ED9  01      	BSIZHI:	DEFB	1		;     hi order
7618:	2EDA  0001    	BLKPTR:	DEFW	100H		;dump block address
7619:			
7620:	2EDC  0001    	LOADB:	DEFW    100H		;z8e load bias for lldr command
7621:	2EDE  0000    	LOADN:	DEFW	00		;end of load address
7622:			
7623:	2EE0          	ASMBPC:				;next pc location for assembly
7624:	2EE0  0001    	ZASMPC:	DEFW	100H		;next pc location for disassemble
7625:							;default at load time: start of	tpa
7626:	2EE2  0000    	ZASMFL:	DEFW	00		;first disassembled address on jdbg screen
7627:			
7628:			
7629:	2EE4          	FROM:
7630:	2EE4          	OPRN01:
7631:	2EE4          	RLBIAS:
7632:	2EE4          	LINES:
7633:	2EE4          	EXAMPT:
7634:	2EE4          	ENDW:
7635:	2EE4  00      	ZASMNX:	DEFB	0		;address of next instruction to	disassemble
7636:	2EE5  00      	OPRX01:	DEFB	0
7637:	2EE6          	BIAS:
7638:	2EE6          	BIASLO:
7639:	2EE6  00      	ZASMCT:	DEFB	0		;disassembly count
7640:	2EE7          	BIASHI:
7641:	2EE7  00      	OPRN02:	DEFB	0
7642:	2EE8          	OPRX02:
7643:	2EE8  0000    	ZASMWT:	DEFW	0		;disassembly count - working tally
7644:	2EEA  00      	OPNFLG:	DEFB	0		;00 - operand 1   ff - operand 2   zasm
7645:							;and input character storage for interactive
7646:							;disassembly
7647:	2EEB  00      	QUOFLG:	DEFB	0
7648:	2EEC  FF      	WFLAG:	DEFB	0FFH		;trace subroutine flag:	nz - trace subs
7649:							;			 z - no	trace
7650:			
7651:	2EED          	NSTEP:
7652:	2EED  00      	NSTEPL:	DEFB	0
7653:	2EEE  00      	NSTEPH:	DEFB	0
7654:			
7655:	2EEF  00      	SBPS:	DEFB	0		;number	of step	breakpoints
7656:	2EF0  00      	BPS:	DEFB	0		;number	of normal breakpoints
7657:			
7658:	2EF1  00      	ZMFLAG:	DEFB	0
7659:	2EF2  00      	ZASMF:	DEFB	0
7660:	2EF3          	EXECBF:				;execute buffer	for relocated code
7661:	2EF3          	JLINES:
7662:	2EF3          	PARENF:
7663:	2EF3  00      	NUMENT:	DEFB	0		;number	of digits entered
7664:	2EF4  00      	DELIM:	DEFB	0		;argument delimeter character
7665:	2EF5  00      		DEFB	0
7666:	2EF6  00      	BASE10:	DEFB	0
7667:	2EF7  00      	JMP2JP:	DEFB	0
7668:	2EF8  00      	JMP2:	DEFB	0
7669:	2EF9          	DWRITE:
7670:	2EF9  00      	CFLAG:	DEFB	0
7671:			
7672:	2EFA          	IKEY:
7673:	2EFA          	ZASMKV:
7674:	2EFA  00      	SJMP:	DEFB	0
7675:	2EFB          	MEXP:
7676:	2EFB  00      	JMPLO:	DEFB	0
7677:	2EFC          	STRNGF:
7678:	2EFC  00      	JMPHI:	DEFB	0
7679:	2EFD          	TIMER:
7680:	2EFD  00      	FIRST:	DEFB	0
7681:	2EFE  00      	REGTRM:	DEFB	0
7682:	2EFF  00      	TRMNTR: DEFB	0
7683:	2F00  0000    	ISYMPT:	DEFW	0
7684:			
7685:	2F02          	JROPND:
7686:	2F02  0000    	PASS2:	DEFW	0
7687:			
7688:	2F04  0000    	FNDSYM:	DEFW	0
7689:			
7690:	0000          	    IF	ASMB
7692:			    ELSE
7693:	2F06          	MAXLEN:
7694:			    ENDIF
7695:	2F06  0E00    		DEFW	14
7696:			
7697:	2F08  3E00    	MAXLIN:	DEFW	62
7698:			
7699:	2F0A  00      	FWNDOW:	DEFB	00
7700:			
7701:	2F0B  00      	NLMASK:	DEFB	00
7702:			
7703:	0000          	    IF	ASMB
7705:			    ELSE
7706:	2F0C          	CASE:
7707:			    ENDIF
7708:	2F0C  00      		DEFB	000H		;flag to indicate case of output
7709:	2F0D  FF      		DEFB	0FFH		;flag to indicate case of output
7710:							;nz - lower   z - upper
7711:			
7712:	2F0E  FF      	JSTEPF:	DEFB	0FFH		;00 -   screen is intact, if user wants j
7713:							;       single step no need to repaint screen,
7714:							;       just move arrow.
7715:							;01   - user wants single-step j command
7716:							;else - j screen corrupted by non-j command
7717:			
7718:	2F0F  03      	LASTRO:	DEFB	03
7719:			
7720:	0000          	    IF	ASMB
7722:			    ELSE
7723:	2F10          	ROWB4X:
7724:			    ENDIF
7725:			;     IF JTERM			;my terminal uses xy addressing
7726:	2F10  00      		DEFB	0
7727:			;     ELSE			;most others use yx
7728:			; 	DEFB	1
7729:			;     ENDIF
7730:			
7731:	0000          	    IF	ASMB
7733:			    ELSE
7734:	2F11          	MXYCP:
7735:			    ENDIF
7736:			;     IF JTERM
7737:			; 	DEFB	1,9		;jrs special (Datapoint 8227)
7738:			;     ELSE
7739:			;     IF Z80DS
7740:	2F11  011B    	    	DEFB	1,ESC
7741:			;     ELSE
7742:			; 	DEFB	2,1BH,'='	;ADM 3a in "standard" version
7743:			; 	DEFB	0,0,0,0,0,0,0,0
7744:			;     ENDIF
7745:			;     ENDIF
7746:			
7747:	2F13  00      	XYROW:	DEFB	0
7748:	2F14  00      	XYCOL:	DEFB	0
7749:			
7750:	0000          	    IF	ASMB
7752:			    ELSE
7753:	2F15          	ROW:
7754:			    ENDIF
7755:	0000          	    IF JTERM				;my terminal uses no bias for
7757:			    ELSE
7758:	2F15  20      		DEFB	' '			;bias for most other terminals
7759:			    ENDIF
7760:	0000          	    IF	ASMB
7762:			    ELSE
7763:	2F16          	COLUMN:
7764:			    ENDIF
7765:	0000          	    IF JTERM				;see above
7767:			    ELSE
7768:	2F16  20      		DEFB	' '
7769:			    ENDIF
7770:			
7771:	2F17  0000    	WNWTAB:	DEFW	0
7772:	2F19  0000    	WNWSIZ:	DEFW	0
7773:			
7774:	2F1B  0000    	PORT:	DEFW	0
7775:			
7776:	2F1D .. 2F52 00	BRKTBL:	DEFS	(MAXBP+2)*3
7777:	2F53 .. 2F72 00	PSCTBL:	DEFS	MAXBP*2
7778:			
7779:			
7780:	2F73          	REGCON:
7781:	2F73          	AFREG:
7782:	2F73  00      	FREG:	DEFB	00
7783:	2F74  00      		DEFB	00
7784:	2F75  0000    	BCREG:	DEFW	00
7785:	2F77  0000    	DEREG:	DEFW	00
7786:	2F79  0000    	HLREG:	DEFW	00
7787:	2F7B  0000    	AFPREG:	DEFW	00
7788:	2F7D  0000    	BCPREG:	DEFW	00
7789:	2F7F  0000    	DEPREG:	DEFW	00
7790:	2F81  0000    	HLPREG:	DEFW	00
7791:	2F83          	PCREG:
7792:	2F83  00      	PCREGL:	DEFB	00
7793:	2F84  01      	PCREGH:	DEFB	01
7794:	2F85  0000    	SPREG:	DEFW	00
7795:	2F87  0000    	IXREG:	DEFW	00
7796:	2F89  0000    	IYREG:	DEFW	00
7797:			
7798:	0018          	REGSIZ	EQU	$-REGCON
7799:			
7800:	2F8B  00      	RREG:	DEFB	00
7801:	2F8C  00      	IREG:	DEFB	00
7802:			
7803:			
7804:	2F8D  0000    	FSTART:	DEFW	0
7805:	2F8F  0000    	ARGBC:	DEFW	0
7806:	2F91  932F    	ARGBPT:	DEFW	ARGBF
7807:			
7808:	2F93          	REGSAV	EQU	$		;storage for register contents in between bps
7809:							;while jdbg is in control
7810:			
7811:	2FAB          	WINDOW	EQU	REGSAV+REGSIZ	;memory window save area
7812:			
7813:	003E          	ARGBSZ	EQU	62
7814:			
7815:	2F93 .. 2FD0 00	ARGBF:	DEFS	ARGBSZ
7816:			
7817:	2FAD          	FCB	EQU     ARGBF+ARGBSZ-36 ;cp/m file control block
7818:	2FAE          	FCBNAM	EQU	FCB+1		;start of file name in fcb
7819:	2FB6          	FCBTYP	EQU	FCBNAM+8	;start of file type in fcb
7820:	2FB9          	FCBEXT	EQU	FCBTYP+3	;current extent	number
7821:	2FD1          	NFCB	EQU	$		;last byte of fcb plus one
7822:			
7823:	00A4          	GPBSIZ	EQU	164		;size of general purpose buffer
7824:			
7825:	2FD1          	SYMBUF:
7826:	2FD1          	OBJBUF:				;object	code buffer
7827:	2FD1 .. 3074 00		DEFS	GPBSIZ
7828:			;	REPT	GPBSIZ
7829:			;	DEFB	0
7830:			;	ENDM
7831:	0052          	INBFSZ	EQU	GPBSIZ/2
7832:	2FD5          	INBFMX	EQU	OBJBUF+4	;input buffer -	max byte count storage
7833:	2FD6          	INBFNC	EQU	INBFMX+1	;	      -	number chars read in
7834:	2FD7          	INBF	EQU	INBFNC+1	;	      -	starting address
7835:	0051          	INBFL	EQU	INBFSZ-1	;	      -	last relative position
7836:	3028          	NINBF	EQU	INBF+INBFL	;	      -	address	of last	char
7837:			
7838:	0052          	PRSBFZ	EQU	GPBSIZ/2
7839:	3029          	PRSBF	EQU	INBF+INBFSZ	;parse buffer -	starting address
7840:	307A          	LPRSBF	EQU	PRSBF+PRSBFZ-1	;	      -	last char of parse buf
7841:	307B          	NPRSBF	EQU	LPRSBF+1	;	      -	end address plus one
7842:			
7843:	3075          	NZASM	EQU	$		;end of disassembly buffer
7844:	2FF5          	ZASMBF	EQU	NZASM-128	;start of disassembly buffer
7845:			
7846:	3075 .. 309C 00		DEFS	40
7847:	309D          	STACK:
7848:	2500          	NMEM	EQU	((($+255) AND 0FF00H)-Z8EORG) AND 0FF00H
7849:			;	was	(256*(($+255)/256)-z8eorg) and 0ff00h
7850:			
7851:	0000          		IF	M80
7853:				ENDIF
7854:	309D          		END



Statistics:

     9	passes
     0	jr promotions
   948	symbols
     0	bytes



Symbol Table:

afpreg          2f7b     intrdi         =fe0f+    rfsym00          3d8     
afreg           2f73     intren         =fdfe+    rfsym10          3e9     
argbc           2f8f     iobuf          =  80+    rfsym20          3f8     
argbf           2f93     ireg            2f8c     rfsym21          414     
argbpt          2f91     irsm            2676     rfsym22          431     
argbsz         =  3e+    irt            =  c9+    rfsym23          43e     
asci            2848     istr            266a     rfsym25          455     
asci00          2853     isym            1a07     rfsym30          46a     
asm000          15aa     isym00          1a12     rfsym35          490     
asm005          15b3     isympt          2f00     rfsym40          49a     
asm010          15b6     ixlt            2607     rfsym45          4a2     
asm015          15c6     ixreg           2f87     rfsym50          4b6     
asm030          15f7     iyreg           2f89     rgdisp           f76     
asm040          160c     jdbg             d85     rgst            118e     
asm050          1616     jdbg00           d8b     rgst00          11b2     
asm060          1628     jdbg01           daa     rgst10          11cd     
asm070          162e     jdbg02           dae     rgst15          11d6     
asm085          166f     jdbg03           dc9     rgst20          11f1     
asm090          1671     jdbg05           dcc     rgst22          11f9     
asm095          1690     jdbg08           ddd     rgst25          120e     
asmb           =   0+    jdbg10           ded     rgst30          1213     
asmblr          15a4     jdbg15           df2     rgst40          121a     
asmbpc          2ee0     jdbg20           e0c     rix            =   8+    
asmflg          29ba     jdbg25           e17     riy            =  10+    
asmxxl          1a7a     jdbg28           e33     rlbias          2ee4+    
asmxxo          1a7e     jdbg2a           dba     rldrom         =fe79+    
asmxxp          1a82+    jdbg30           e38     rlstsz         =  11+    
asmxxs          1a86     jdbg35           e44     rlstxx           8f7     
asmxxt          1a8a     jdbg40           e4e     rm80sz         =   8+    
asmxxu          1693     jdbg42           e64     rm80xx           928     
asmxxv          1a8e     jdbg45           e75     row             2f15     
asmxxx          1a90     jdbg50           e9b     rowb4x          2f10     
aterm          =   0+    jdbg55           eaa     rpr325           514     
base10          2ef6     jdbg60           eb3     rpr330           52b     
bbcalret       =fd5a+    jdbg65           ebc     rpr335           537     
bbconin        =fd94+    jdbg70           ee5     rpr340           549+    
bbconout       =fd9f+    jdbg75           eec     rpr342           556     
bbconst        =fdaa+    jdbg78           f21     rpr345           55e     
bbcpboot       =fcc9+    jdbg80           f25     rpr350           575     
bbcptime       =fcc3+    jdbg90           f28     rpr351           582     
bbcrtcini      =fc03+    jdbg95           f36     rpr352           595     
bbcrtfill      =fc09+    jlines          2ef3     rpr355           599     
bbcurset       =fc21+    jmp2            2ef8     rpr357           59e     
bbdiv16        =fce1+    jmp2jp          2ef7     rpr370           5b5     
bbdmaset       =fcb7+    jmphi           2efc     rpr4             5bc     
bbdriveid      =fcf9+    jmplo           2efb     rpr410           5d3     
bbdsksel       =fcbd+    jropnd          2f02     rpr420           5de     
bbeidck        =fd23+    jstepf          2f0e     rpr421           5fe     
bbepmngr       =fd1d+    jtcmd           294c     rpr425           612     
bbexec         =fd29+    jterm          =   0+    rpr430           61f     
bbfdrvsel      =fcdb+    kdmp            13f5     rpr435           63a     
bbfhome        =fc81+    kdmp00          1418     rpr438           645     
bbflopio       =fc93+    kdmp20          141f     rpr440           652     
bbfread        =fc87+    lastro          2f0f     rpr450           664     
bbfwrite       =fc8d+    lbin            1d82     rprn             4bf     
bbhdboot       =fd11+    lbin00          1d85     rprn00           4ff     
bbhdgeo        =fd0b+    lbin20          1da5     rprnaa           4d4     
bbhdinit       =fcf3+    lbin22          1daa     rprnbb           4dd     
bbhdrd         =fd05+    lbin25          1dd4     rprncc           4f6+    
bbhdwr         =fcff+    lbin30          1dd9     rprnsz         =   a+    
bbinictc       =fc57+    lbin35          1ddc     rprnxx           909     
bbjtobnk       =fc00+    lbin40          1deb     rreg            2f8b     
bbldpart       =fd17+    lcmd            29bc     rslr             66b     
bbmul16        =fce7+    lf             =   a+    rslrsz         =  13+    
bboffcal       =fced+    lfcb            1e25     rslrxx           914     
bbprcvblk      =fc6f+    lfcb00          1e3d     rslv            179d     
bbprnchr       =fc99+    lfcb10          1e56     rslv00          17a4     
bbpsndblk      =fc63+    lfcb20          1e5b     rslv10          17b0     
bbrdtime       =fca5+    lfcb30          1e64+    rslv20          17b4     
bbrdvdsk       =fc75+    lfcb90          1e6f     rslv25          17d1     
bbresctc       =fc5d+    lfcb95          1e84     rslv30          17d7     
bbsecset       =fcb1+    lfcb96          1e86     rslv35          17e6     
bbsidset       =fcd5+    lines           2ee4     rslv40          17ee     
bbstack        =feb4+    lldr            1d30     rslv50          17f9     
bbstbase       =fe90+    lldr00          1d46     rslv60          1809     
bbsttim        =fc9f+    lldr05          1d71     rslv70          1823     
bbtrkset       =fcab+    lldr10          1d79     rspace          2622     
bbu0ini        =fc39+    load             6f0     rst38          =  cf+    
bbu1ini        =fc51+    load00           701     rstvec           103     
bbu1rx         =fc45+    load20           79e     rtin            2693     
bbu1st         =fc4b+    load30           7a6     sbps            2eef     
bbu1tx         =fc3f+    load40           7ab     sconin         =fc2d+    
bbuplchr       =fc69+    load50           7e9     sconout        =fc27+    
bbvcpmbt       =fccf+    load60           7f3     sconst         =fc33+    
bbvoid         =fd6a+    loadb           2edc     sintvec        =fff0+    
bbwrvdsk       =fc7b+    loadn           2ede     siotbl          2ed5+    
bcde            2559     lopn            1e8c     six             291a     
bcdx            2858     lopn00          1e93+    siy             292a     
bcdx00          285c     lopn10          1e9b     sjmp            2efa     
bcpreg          2f7d     lprsbf         =307a+    slr            =ffff+    
bcreg           2f75     m80            =   0+    space5          2627     
bdos           =   5+    maxbp          =  10+    spaces          2629     
bdwrit          2346     maxlen          2f06     spreg           2f85     
bias            2ee6     maxlin          2f08     srch            1f72     
biashi          2ee7     mbannr           105     srch00          1f75     
biaslo          2ee6     mcntu           2a0d     srch10          1f7f     
bidprn           938+    mexp            2efb     stack           309d     
binx            2651     mfilnf          29cb     star             939     
binx00          2655     mhex             93c     step            1540     
bksp            283d     minvof           989     step20          1568     
bksp00          2843     mireg           2a1b+    step40          1578     
bldf            2362     mldg            29c1     step50          158b     
bldf00          2373     mlodm           29dc     stlone         =ffff+    
blkptr          2eda     mlodpg          29e6     strngf          2efc     
bpemsg          299d     mmemxx          29ff     symbuf          2fd1     
bphn             c75     mmgetp         =fd78+    symflg          2ed7     
bphn10           cc2     mmpmap         =fd6b+    syscmlo        =feb4+    
bphn20           cd6     mnvmem           9cf     syscom         =fc00+    
bphn30           cf7     movb            1c3b     sytimr         =fe19+    
bphn35           d04     movb00          1c59     tab            =   9+    
bphn50           d1e     mreg            1223     tilde          =  7e+    
bphn60           d34     mreg00          123a     timer           2efd     
bphn90           d53     mreg05          1242     totsym           880     
bpmsg           29a4     mreg10          124b     trmntr          2eff     
bps             2ef0     mreg50          1257     true           =ffff+    
bpxxx            d6d     mrrow           29b0     tsym             931     
break           12e7     msntx           29f0     tsymbb           95c     
brk10           12ed     msymbb           941     tsymhi           931     
brk30           12fd     msymld           9a7     tsymlo           932     
brk40           1304     msymnf           970     ttyi            2592     
brk50           1316     mxx             29b5+    ttyo            25b2     
brk60           131a     mxxxx           29b3     ttyq            2572     
brk70           1322     mxycp           2f11     u0isr          =fe25+    
brk80           132b     mz8eld           9bb     u1isr          =fe59+    
brktbl          2f1d     nchr             7fa     u1nul          =fe70+    
bs             =   8+    ncmd           =  1b+    uastav         =fe84+    
bsiz            2ed8     newlin          2630     uastkb         =fe86+    
bsizhi          2ed9     nfcb           =2fd1+    uisre          =fe4e+    
bsizlo          2ed8     ninbf          =3028+    uisri          =fe32+    
byte10          276f     nint             1b3     usym            1054     
byte15          2777     nint00           1f2     usym10          106e     
byte30          2781     nint03           20b     usym20          1091     
bytes            9e7     nint05           21d     usym25          10a5     
case            2f0c     nint10           22c     usym40          10b2     
cbreak          134a     nint15           240     usymbl           933     
cbrk10          136f     nint20           24a     vconin         =fc15+    
cbrk20          1376     nint22           257     vconout        =fc0f+    
cbrk30          137f     nint25           25f     vconst         =fc1b+    
cflag           2ef9     nint30           276     verf00          1f8a     
clok             fa9     nint35           282     verf10          1fa5     
clok10           faf     nint40           287     verify          1f83     
closef          2327     nint45           295     voidisr        =fe22+    
cmd             2982     nint50           29c     wflag           2eec     
column          2f16     nint55           2a2     window         =2fab+    
comask           104+    nint60           2a7     wnwsiz          2f19     
compact        =   0+    nint70           2c5     wnwtab          2f17     
cr             =   d+    nint71           2d2     writ            1ec7     
crdureg        =fc27+    nint75           2cd     writ10          1edf     
cret            261a     nint80           2e2     writ20          1eeb+    
crlf            2610     nint85           310     writ30          1ef1     
ctlc           =   3+    nint90           312     writ40          1f03     
ctlx           =  18+    nint95           32d     writ50          1f0c     
curs             f82     nlmask          2f0b     write           232f     
curs00           f8a+    nmem           =2500+    wrt10           2343     
curs20           f8f+    nprint          2870     xreg            1fad     
curs30           f99+    nprsbf         =307b+    xreg00          1fb3     
curs40           f9b     nprt            1259     xreg05          1fd6     
cuser           1c7a     nrel            290a     xreg10          1ff1     
cusok           1c95     nstep           2eed     xreg20          1ffe     
del            =  7f+    nsteph          2eee+    xreg30          200d     
delay          =fd85+    nstepl          2eed+    xsym            254a     
delim           2ef4     nsym             93a     xsym00          254f     
depreg          2f7f     nsymhi           93a     xval            18c4     
dereg           2f77     nsymlo           93b     xval00          18c9     
disisr          1d20     ntpa             9e5     xval05          18d8     
dly1           =fd89+    nument          2ef3+    xval10          18f7     
dly2           =fd87+    nzasm          =3075+    xval15          18fd     
dump            10ec     objbuf          2fd1     xval20          1906     
dump00          10fb     obreak          13ac     xval25          1915     
dump15          110c     obrk00          13b2     xval30          1927     
dump20          1115     obrk10          13d9     xval35          1932     
dump25          111a     obrk20          13e8     xval40          195b     
dump30          111e     op1000          2ea4     xval50          1960     
dump40          1131     opn             21aa     xval55          196f     
dump50          1143     opn010          21b1     xval60          1973     
dump55          1150     opn012          21b4     xval61          198a     
dump60          115e     opn014          21bc     xval62          1997     
dump70          1161     opn015          21c8     xval65          19a0     
dump80          1168     opn020          21d3     xval90          19ac     
dwrite          2ef9     opn030          21db     xval95          19bc     
efilnf          1ebe     opn035          21f0     xycol           2f14+    
ememxx          1eb6     opn040          21f9     xycp            288a     
emxxx           29bd     opn041          2200+    xycp00          289b     
enaisr          1d28     opn042          2206     xycp10          28ac     
endw            2ee4     opn043          2212     xyrow           2f13+    
eof            =  1a+    opn044          221b     yfil            1c60     
eprint          1ec1     opn045          226c     yfil00          1c67     
esc            =  1b+    opn046          2275     yfil10          1c6d     
esntx           1eb1     opn048          2295     yfil20          1c75     
exam             fb6     opn049          22a8     z801            2a30     
exam00           fbd     opn050          22b2     z801l          =   a+    
exam10           fd2     opn055          22bb     z802            2a3a     
exampt          2ee4     opn060          22c5     z802c           2a45     
execbf          2ef3     opn065          22d5     z802cl         =   6+    
exicpm          25fb     opn080          22f1     z802l          =  11+    
exxx             d7c     opn085          2306     z803            2a4b     
fadr            2520     opn090          230d     z803c           2a5c     
fadr00          252b     opn095          2319     z803cl         =  12+    
fadr10          253d     opn100          237d     z803l          =  1a+    
fadr20          2541     opn105          238a     z803s           2a53     
fadr30          2547     opn200          239a     z803sl         =   9+    
false          =   0+    opn205          23ab     z80ds          =ffff+    
fcb            =2fad+    opn210          23b3     z80ed           2a65     
fcb5c          =  5c+    opn215          23c9     z80edl         =   6+    
fcbext         =2fb9+    opn220          23d5     z80f3           2a6b     
fcbnam         =2fae+    opn300          23de     z80f3l         =  18+    
fcbtyp         =2fb6+    opn310          23ea     z80f4           2a2b     
feof             683     opn315          23eb     z80f4l         =   5+    
feof10           6b5     opn316          23f9     z80fd           2a20     
feof20           6bd     opn320          240d     z80fdl         =   b+    
feof50           6e9     opn400          2413     z80r            2a4b     
fin            =fdc4+    opn410          2420     z80rl          =  20+    
find            1f20     opn500          2429     z8e              c10     
find00          1f2b+    opn600          243d     z8e00            c30     
find40          1f4a     opn605          2448     z8e10            c35     
find50          1f51     opn606          2453     z8e16            c4e     
find60          1f6b     opn610          246f+    z8e20            c5b     
first           2efd+    opn620          2477     z8eb             9e3     
fndsym          2f04     opn700          2489     z8ebh            9e4     
formf          =   c+    opn800          2498     z8ecmd           c14     
fout           =fde1+    opn810          24a3     z8ej            1e1a     
freg            2f73     opn820          24ae     z8eorg           c00     
from            2ee4+    opn830          24b3     z8esp            c12     
fstart          2f8d+    opnflg          2eea     zasc10          2512     
fstat          =fdb5+    opnm            175f     zasc20          2514     
fstr00           8dc     opnm00          1777     zascii          2505     
fstr10           8e3     opnm10          1782+    zasm            201c     
fstr20           8f4     opnm20          1787     zasm0           202f     
fstrng           8da     opnm30          178d     zasm00          203f     
fsym            19c8     opnm40          1796     zasm05          2049     
fsym00          19cb     opnv            1ab8     zasm06          2053     
fsym10          19e6     opnv00          1ac2     zasm08          2061     
fsym20          19f4     oprn            182a     zasm10          2064     
fsym30          19ff     oprn00          182d     zasm15          2068     
fwndow          2f0a     oprn01          2ee4     zasm18          2070     
g001            1432     oprn02          2ee7     zasm20          207c     
g002            1438     oprn20          183c     zasm25          208d     
g100            143e     oprn25          1846     zasm30          2098     
g300            1456     oprn30          1857     zasm35          20a0     
g400            146b     oprn35          1873     zasm40          20bf     
g500            146e     oprn40          1884     zasm42          20d1     
g505            1488     oprn50          18a6     zasm45          20d7+    
g518            1498     oprn70          18ab     zasm50          20db     
g520            149b     oprn80          18b3     zasm55          20f3     
g550            14db     oprn85          18b6     zasm60          2104     
g555            14fc     oprtor          1ab0     zasm65          210e     
g600            1505     oprx01          2ee5+    zasm70          2124     
go              1427     oprx02          2ee8+    zasm75          2135     
gpbsiz         =  a4+    othxsp          261f     zasm80          2139     
hazeltine      =   0+    outadr          2639     zasm85          2147     
hex              832     outbyt          2737     zasm90          214c     
hex00            835     outhex          2643     zasm92          2172     
hex10            83c     parenf          2ef3     zasm95          217d     
hex30            869     parg            26b4     zasm97          218e     
hexc             81f     parg00          26ea     zasm99          219e     
hexc00           829     parg10          26f2     zasmbf         =2ff5+    
hlpreg          2f81     parg50          26fb     zasmct          2ee6     
hlreg           2f79     parg60          2708     zasmf           2ef2     
home            2887     parg65          2717     zasmfl          2ee2     
hsym             fee     parg70          271d     zasmio          294a     
hsym10          1005     parg80          272b     zasmkv          2efa     
iarg            26a9     parg90          272e     zasmnx          2ee4     
ibl00           1d1a     pass2           2f02     zasmpc          2ee0     
iblank          1d18     pbin            10d0     zasmwt          2ee8     
ibld            1698     pbin00          10d4     zbuf             9e8     
ibld00          16a3     pcreg           2f83     zbufnm           9e9     
ibld10          16b6     pcregh          2f84     zdlm            1aa5     
ibld20          16be     pcregl          2f83     zdlm00          1aa8     
ibld30          16ca     pcrlf           10c7     zdread           802     
ibld40          16da     port            2f1b     zfnf             8af     
ibld50          16e6     print           2873     zhex            24d2     
ibld55          16eb     printb          287c     zhex00          24dc     
ibld60          1710     prompt          29ac     zhex10          24e0     
ibld65          173d     prsbf          =3029+    zhex20          24ef     
ibld70          1746     prsbfz         =  52+    zlen00          1ac8     
ibld75          174a     prsr            1a2b     zlen10          1ae9     
ibld80          1750     prsr10          1a35     zlen15          1aee     
ibld90          1759+    prsr20          1a42     zlen20          1af6     
iedt            278e     prsr30          1a54     zlen30          1b09     
iedt00          2794     prsr50          1a63     zlen40          1b1f     
iedt03          27a2     prsr60          1a73     zlen50          1b2f     
iedt05          27a8     psctbl          2f53     zlen55          1b5b     
iedt10          27c4     pstrng           935     zlen58          1b67     
iedt15          27d3     psw00           1bd1     zlen60          1b6e     
iedt20          27d6     psw10           1bea     zlen65          1b8a     
iedt25          27da     psw50           1c08+    zlen70          1b93     
iedt35          27e9     psw55           1c0c     zlen80          1ba6     
iedt40          27fb     psw60           1c35     zlen85          1bb1     
iedt50          27ff     pswbit          2ea8     zmem             8b8     
iedt55          2815     pswcnt         =   8+    zmflag          2ef1     
iedt58          281a     pswdsp          1bcc     zmqf            24fa     
iedt60          282c     pswmap          2eb0     zndx            24b9     
iedt70          2831     putc            10df     zndx00          24cd     
iedt90          2836     putc00          10e3+    znmbuf           9f8     
iedtbc          2787     qev01           1cca     zoff             8ce     
ifcb            1ccd     qeval           1c9b     zopcnm          2d84     
ifcb00          1cd7     qprt            1259     zopcpt          2a84     
ifcb02          1ced     qprt00          127c     zopjtb         =  30+    
ifcb12          1d08     qprt10          128a     zopjtl         =   9+    
ijp            =  c3+    qprt20          12a8     zopnd1          2b84     
ikey            2efa     qprt30          12af     zopnd2          2c84     
ilcs            25fe     qprt50          12c9     zopnm           290a     
ilin            265e     qprt60          12e0     zopnml         =  18+    
imem            1ea7     quoflg          2eeb     zoprjt          293a     
in00            2697     quote          =  27+    zstx             890     
in10            26a1     rbyte           2747     zsym             335     
inbf           =2fd7+    regcon          2f73     zsym00           388     
inbfl          =  51+    regmap          2eb8     zsym05           395     
inbfmx         =2fd5+    regptr          2ec9     zsym10           3a7     
inbfnc         =2fd6+    regsav         =2f93+    zwnw             f44     
inbfsz         =  52+    regsiz         =  18+    zwnw05           f46+    
inchar          25d2     regtrm          2efe     zwnw10           f4c     
init             a40     relchr           937     zwnw20           f5f     
inop           =   0+    rfsym            3c8     
