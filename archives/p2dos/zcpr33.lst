ZAS Relocating Macro Assembler (v3.05                             page    1
                                                            
                                                            

  0000           ; PROGRAM:      ZCPR
  0000           ; VERSION:      3.3
  0000           ; DERIVATION:   ZCPR30
  0000           ; AUTHOR:       Jay Sage
  0000           ; DATE:         May 28, 1987
  0000           
  0000           ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000           ; distribution and duplication permitted for non-commercial purposes only.
  0000           ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000           ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000           ; conjunction with any hardware or software product, is expressly prohibited
  0000           ; unless authorized in writing by Echelon.
  0000           ;
  0000           ; Echelon specifically disclaims any warranties, expressed or implied,
  0000           ; including but not limited to implied warranties of merchantability and
  0000           ; fitness for a particular purpose.  In no event will Echelon be liable for
  0000           ; any loss of profit or any other commercial damage, including but not limited
  0000           ; to special, incidental, consequential, or other damages.
  0000           ;
  0000           ; Echelon can be contacted at:
  0000           ;      Echelon, Inc.
  0000           ;      885 N. San Antonio Road
  0000           ;      Los Altos, California  USA  94022
  0000           ;      (415) 948-3820
  0000           
  0000           
  0000           ;-----------------------------------------------------------------------------
  0000           ;
  0000           ;                  A C K N O W L E D G M E N T S
  0000           ;
  0000           ;-----------------------------------------------------------------------------
  0000           
  0000           ; Many people have played a role in the development of ZCPR in general and
  0000           ; ZCPR33 in particular.  It all started when "The CCP Group," including
  0000           ; Richard Conn, Ron Fowler, Keith Petersen, Frank Wancho, Charlie Strom, and
  0000           ; Bob Mathias decided that by rewriting the CP/M command processor to take
  0000           ; advantage of Zilog-specific opcodes they could save enough code to enhance
  0000           ; some of the features.   Richard Conn then extended that development through
  0000           ; ZCPR2 to ZCPR3 (3.0).  Just a little over two years ago, I took the first
  0000           ; step to enhance ZCPR3 by making it get the maximum drive and user values
  0000           ; from the environment instead of hard coding them in.   This version was
  0000           ; distributed privately as ZCPR31.  Along the way to what is now ZCPR
  0000           ; version 3.3 a number of others have made valuable contributions: Steve
  0000           ; Kitahata, Michael Bate, Bruce Morgen, Roger Warren, Dreas Nielsen, Bob Freed,
  0000           ; Al Hawley, Howard Goldstein, and many others who have stimulated developments
  0000           ; by pointing out problems or asking questions.
  0000           
  0000           ; I would like particularly to acknowledge two people who have played a very
  0000           ; significant role in these developments.  One is Al Hawley.  He introduced
  0000           ; the idea of having the DUOK flag in the environment control how the CPR
  0000           ; would respond to the DU: form of directory reference.  He also originated
  0000           ; the idea of using the high bit of the first character of each command name
  0000           ; to control whether or not it would be wheel restricted.  Finally, he
  0000           ; contributed the basic structure of the highly efficient, elegant, and more
  0000           ; general number evaluation routines in the code.
  0000           
ZAS Relocating Macro Assembler (v3.05                             page    2
                                                            
                                                            

  0000           ; My biggest debt of gratitude is to Howard Goldstein.  His role in the
  0000           ; development of ZCPR33 goes back about a year, when he contributed the first
  0000           ; correct implementation of the minpath feature.  More recently, during the
  0000           ; period of intense development since Echelon expressed its interest in my
  0000           ; writing the official 3.3 version, he and I have shared an especially
  0000           ; enjoyable and fruitful relationship.  Most of the newest ideas have been
  0000           ; worked out jointly, and Howard has done a great deal to keep my code and
  0000           ; concepts on track.  He discovered many ways to pare the code down and, more
  0000           ; importantly, uncovered numerous subtle bugs.  He recoded the SAVE command
  0000           ; to make it more compact and reliable.
  0000           ;
  0000           ;                                               Jay Sage
  0000           ;                                               May 28,1987
  0000           
  0000           ;-----------------------------------------------------------------------------
  0000           ;
  0000           ;               U S E R    C O N F I G U R A T I O N
  0000           ;
  0000           ;-----------------------------------------------------------------------------
  0000           
  0000           ; The following MACLIB statements load all the user-selected equates
  0000           ; which are used to customize ZCPR33 for the user's working environment.
  0000           ; NOTE -- TRUE & FALSE are defined in Z3BASE.
  0000+                  MACLIB  COMMON.ASM
  0000+          ;
  0000+          ; Here just some common symbol...
  0000+          ;
  0000+          
  0016+=         VERS    EQU     22              ; VERSION 2.2 (CP/M related)
  0000+          ;
  0000+          ; MSIZE EQU     63              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  003C+=         MSIZE   EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0000+          ; MSIZE EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0400+=         RESROOM EQU     1024            ; RESERVED ROOM SPACE BELOW MONITOR (FC00)
  0600+=         BIOSTDS EQU     1536            ; BIOS STANDARD SIZE
  0A00+=         BIOREAS EQU     BIOSTDS+RESROOM ; BIOS REAL SIZE
  0400+=         ZSTDOVR EQU     1024            ; ZCPR STANDARD OVERHEAD SIZE
  0000+=         ZIOPKG  EQU     0               ; ZCPR IO PACKAGE SIZE
  0800+=         ZRESPKG EQU     2048            ; ZCPR RESIDENT CMD PKG SIZE
  0200+=         ZFLOPKG EQU     512             ; ZCPR FLOW CMD PACKAGE SIZE
  01C8+=         ZDSSTSZ EQU     01C8H           ; ZDS Stamper reserved space
  0000+          
  1200+=         EXTRABIAS       EQU     RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG  ; ...
  0000+                  ;
  0000+                  ;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  0000+                  ;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  0000+                  ;
  8E00+=         BIAS    EQU     ((MSIZE-20)*1024)-EXTRABIAS
  C200+=         CCP     EQU     3400H+BIAS      ; BASE OF CCP
  CA06+=         BDOS    EQU     CCP+0806H       ; BASE OF BDOS
  CA00+=         BDOSB   EQU     CCP+0800H       ; BDOS base offset
  D800+=         BIOS    EQU     CCP+1600H       ; BASE OF BIOS
  E200+=         ZBUFBAS EQU     BIOS+BIOREAS    ; BASE OF ZCPR3 BUFFERS
  0000+                  ;
  0000+                  ;       some other equs...
  0000+                  ;
ZAS Relocating Macro Assembler (v3.05                             page    3
                                                            
                                                            

  000D+=         CR      EQU     0DH             ; CARRIAGE RETURN
  000A+=         LF      EQU     0AH             ; LINE FEED;
  000C+=         FF      EQU     0CH             ; FORM FEED (clear screen)
  FFFF+=         TRUE    EQU     -1
  0000+=         FALSE   EQU     0
  0000+          
  0000+=         INTRON  EQU     FALSE           ; Interrupts disabled
  0000+                  ;
  0000+                  ; define which kind of date stamper must be embedded in
  0000+                  ; RCP
  0000+                  ;
  FFFF+=         STMPP2  EQU     TRUE            ; P2DOS date stamper
  0000+=         STMPZS  EQU     FALSE           ; ZSDOS date stamper
  FFFF+=         HASEDS  EQU     (STMPP2+STMPZS) ; set a flag for embedded date stamper
  0000+                  ;
  0000+                  ; path for ZCPR3 used on cold boot
  0000+                  ;
  0024+=         IDISK1  EQU     '$'             ; 1st: current disk, current user
  0024+=         IUSER1  EQU     '$'
  0024+=         IDISK2  EQU     '$'             ; 2nd: current disk, user 15
  000F+=         IUSER2  EQU     15
  0001+=         IDISK3  EQU     'A'-'@'         ; 3rd: disk A, current user
  0024+=         IUSER3  EQU     '$'
  0001+=         IDISK4  EQU     'A'-'@'         ; 4th: disk A, user 15
  000F+=         IUSER4  EQU     15
  0000+          
  0000+          ; COMMON.ASM [EOF]
  0000+                  MACLIB  Z3BASE.LIB
  0000+          ; Z3BASE - Dynamic Configuration
  0000+          ;
  0000+          ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000+          ; distribution and duplication permitted for non-commercial purposes only.
  0000+          ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000+          ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000+          ; conjunction with any hardware or software product, is expressly prohibited
  0000+          ; unless authorized in writing by Echelon.
  0000+          ;
  0000+          ; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  0000+          ; for Z-Com.  All segment addresses are automatically derived when the
  0000+          ; CCP equate is set.  The benefit of this is that reconfiguration of the
  0000+          ; system after initial installation is greatly eased.
  0000+          ;
  0000+          ; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  0000+          ; previous version of Z3BASE can be used to assemble the Z33 Command
  0000+          ; Processor.  No new symbols are needed.  So, if you have an existing
  0000+          ; Z3BASE, go ahead and use it.
  0000+          ;
  0000+          ; Instructions:
  0000+          ;
  0000+          ; The user should first design the ZCPR3 memory usage using the chart
  0000+          ; below.  (Echelon recommends the chart be filled out, even though it is
  0000+          ; not read by the assembler, so that your system will be self-documenting.)
  0000+          ; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  0000+          ; and change the SEGn equates which follow in the file to ensure that the
  0000+          ; system segments and buffers are placed at the proper addresses.
  0000+          ;
ZAS Relocating Macro Assembler (v3.05                             page    4
                                                            
                                                            

  0000+          ; This file has been customized for use with AMPRO hard disk systems.  The
  0000+          ; target configuration has support for hard disks up to 49 Meg, extended
  0000+          ; IOP support, and 28-entry NDR.
  0000+          ;
  0000+          ;****************************************************************
  0000+          ;*                                                              *
  0000+          ;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System          *
  0000+          ;*                                                              *
  0000+          ;*      Segments:                                               *
  0000+          ;*                                                              *
  0000+          ;*      Segment         Function                                *
  0000+          ;*      -------         --------                                *
  0000+          ;*      ZSDOS           ZSDOS 1.1                               *
  0000+          ;*      CBIOSZ          ZDS BIOS with additional                *
  0000+          ;*                      ZCPR3 initialization routines           *
  0000+          ;*      ZCPR3           Echelon Z80 Command Processor           *
  0000+          ;*                      Replacement, Version 3.3 (ZCPR3)        *
  0000+          ;*      *.ENV           All Environment Descriptors             *
  0000+          ;*      *.FCP           All Flow Command Packages               *
  0000+          ;*      *.NDR           All Named Directory Definition Files    *
  0000+          ;*      *.RCP           All Resident Command Packages           *
  0000+          ;*      *.IOP           All Input/Output Packages               *
  0000+          ;*                                                              *
  0000+          ;*                                                              *
  0000+          ;* Memory Map of System (for CCP EQU 0BC00H):                   *
  0000+          ;*                                                              *
  0000+          ;*      Address Range     Size  Function                        *
  0000+          ;*      -------------   ------- --------                        *
  0000+          ;*          0 -   FF    256 b   Standard CP/M Buffers except    *
  0000+          ;*        100 - C2FF    ~48 K   Transient Program Area          *
  0000+          ;*       C200 - C9FF      2 K   ZCPR 3.3 Command Processor      *
  0000+          ;*       CA00 - D7FF    3.5 K   ZSDOS                           *
  0000+          ;*       D800 - E1FF    2.5 K   BIOS with disk buffers          *
  0000+          ;*       E200 - E9FF      2 K   Resident Command Package        *
  0000+          ;*       0000 - 0000    1.5 K   Input/Output Package            *
  0000+          ;*       EA00 - EBFF     .5 K   Flow Command Package            *
  0000+          ;*       EC00 - ECFF    256 b   Environment Descriptor          *
  0000+          ;*                              Bytes 00H-7FH:  Z3 Parameters   *
  0000+          ;*                              Bytes 80H-FFH:  Z3 TCAP         *
  0000+          ;*       ED00 - ED7F    128 b   ZCPR3 Shell Stack               *
  0000+          ;*       ED80 - EDCF     80 b   ZCPR3 Message Buffers           *
  0000+          ;*       EDD0 - EDF3     36 b   ZCPR3 External FCB              *
  0000+          ;*       EDF4 - EDFE     11 b   ZCPR3 External Path             *
  0000+          ;*       EDFF             1 b   Wheel Byte                      *
  0000+          ;*       EE00 - EEFF    256 B   Memory-Based Named Directory    *
  0000+          ;*       EF00 - EFCF    208 B   Multiple Command Line Buffer    *
  0000+          ;*       EFD0 - EFFF     48 b   ZCPR3 External Stack            *
  0000+          ;****************************************************************
  0000+          
  0000+          ; include       macro   filename
  0000+          ;
  0000+          ;        if     zas
  0000+          ;       .in             filename
  0000+          ;        else   ;slr assembler
  0000+          ;       include filename
  0000+          ;        endif  ;zas
ZAS Relocating Macro Assembler (v3.05                             page    5
                                                            
                                                            

  0000+          ;
  0000+          ;        endm
  0000+          
  0000+          ; FALSE equ     0
  0000+          ; TRUE  equ     NOT FALSE
  0000+          
  0021+=         Z3REV   EQU     33      ; ZCPR3 REV NUMBER
  0000+          ; MSIZE EQU     54      ; SIZE OF CPM SYSTEM
  0000+          
  0000+=         BASE    EQU     0
  0000+          
  0000+          ; CCP   EQU     0BC00H  ; ZCPR3 COMMAND PROCESSOR
  0000+          
  E200+=         SEG1    EQU     ZBUFBAS ; where the things starts
  0000+          
  0000+          ;
  0000+          ; RCP definition.  Set RCPS to 0 to eliminate RCP
  0000+          ;
  0000+          
  0010+=         RCPS    EQU     16              ; 16 128-byte Blocks (2K bytes)
  0000+          
  0000+                   IF     RCPS NE 0
  E200+=         RCP     EQU     SEG1            ; RESIDENT COMMAND PACKAGE
  0000+                   ELSE
  0000+          RCP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG2    EQU     SEG1+(RCPS*128)
  0000+          
  0000+          ;
  0000+          ; IOP definition.  Set IOPS to 0 to eliminate IOP
  0000+          ;
  0000+          ; IOPS  EQU     12              ; 12 128-byte Blocks (1.5K bytes)
  0000+=         IOPS    EQU     0               ; 12 128-byte Blocks (1.5K bytes)
  0000+          
  0000+                   IF     IOPS NE 0
  0000+          IOP     EQU     SEG2            ; REDIRECTABLE I/O PACKAGE
  0000+                   ELSE
  0000+=         IOP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG3    EQU     SEG2+(IOPS*128)
  0000+          
  0000+          ;
  0000+          ; FCP definition.  Set FCPS to 0 to eliminate FCP
  0000+          ;
  0000+          
  0004+=         FCPS    EQU     4       ; 4 128-byte Blocks (0.5K bytes)
  0000+          
  0000+                   IF     FCPS NE 0
  EA00+=         FCP     EQU     SEG3
  0000+                   ELSE
  0000+          FCP     EQU     0
  0000+                   ENDIF
  0000+          
  E838+=         ZDSSTPR EQU     (FCP-ZDSSTSZ)   ; Z80 Darkstar P2DOS Stamper
ZAS Relocating Macro Assembler (v3.05                             page    6
                                                            
                                                            

  0000+          
  EC00+=         SEG10   EQU     SEG3+(FCPS*128)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
  0000+          ; Echelon recommends you work this out so that your ENV begins at address
  0000+          ; FE00h, but this is only a recommendation and not mandatory.
  0000+          ;
  0000+          
  EC00+=         Z3ENV   EQU     SEG10   ; ENVIRONMENT DESCRIPTORS
  0002+=         Z3ENVS  EQU     2       ; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
  0000+          
  ED00+=         SEG4    EQU     SEG10+(Z3ENVS*128)
  0000+          
  0000+          ;
  0000+          ; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
  0000+          ;
  0000+          
  0004+=         SHSTKS  EQU     4       ; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
  0020+=         SHSIZE  EQU     32      ; SIZE OF A SHELL STACK ENTRY
  0000+                                  ;   (STACK SIZE = SHSTKS * SHSIZE)
  0000+                   IF SHSTKS NE 0
  ED00+=         SHSTK   EQU     SEG4
  0000+                   ELSE
  0000+          SHSTK   EQU     0
  0000+                   ENDIF
  0000+          
  ED80+=         SEG5    EQU     SEG4+(SHSTKS*SHSIZE)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
  0000+          ;
  ED80+=         Z3MSG   EQU     SEG5            ; ZCPR3 MESSAGE BUFFER
  0000+          
  EDD0+=         SEG6    EQU     SEG5+80
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDD0+=         EXTFCB  EQU     SEG6            ; ZCPR3 EXTERNAL FCB
  0000+          
  EDF4+=         SEG7    EQU     SEG6+36
  0000+          
  0000+          ;
  0000+          ; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
  0000+          ; used with this Z3BASE.LIB file.
  0000+          ;
  0000+          
  EDF4+=         EXPATH  EQU     SEG7            ; EXTERNAL PATH
  0005+=         EXPATHS EQU     5               ; 5 2-byte Path Elements
  0000+                                          ;  (PATH SIZE = EXPATHS*2 + 1)
  0000+          
  EDFF+=         SEG8    EQU     SEG7+(EXPATHS*2)+1
  0000+          
  0000+          ;
ZAS Relocating Macro Assembler (v3.05                             page    7
                                                            
                                                            

  0000+          ; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDFF+=         Z3WHL   EQU     SEG8            ; WHEEL BYTE ADDRESS
  0000+          
  EE00+=         SEG9    EQU     SEG8+1
  0000+          
  0000+          ;
  0000+          ; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
  0000+          ; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
  0000+          ; equate below.
  0000+          ;
  001C+=         Z3NDIRS EQU     28              ; 28 18-byte Named Directory Elements permitted
  0000+                                          ;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
  0000+                   IF     Z3NDIRS NE 0
  EE00+=         Z3NDIR  EQU     SEG9            ; ZCPR3 NAMED DIRECTORY AREA
  0000+                   ELSE
  0000+          Z3NDIR  EQU     0
  0000+                   ENDIF
  0000+          
  EF00+=         SEG11   EQU     SEG9+256        ; add 512 for 28-entry NDR
  0000+                                          ; add 256 for 14-entry NDR ("standard")
  0000+                                          ; add 0 if Z3NDIRS is set to 0
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EF00+=         Z3CL    EQU     SEG11   ; ZCPR3 COMMAND LINE BUFFER
  00D0+=         Z3CLS   EQU     208     ; SIZE OF COMMAND LINE BUFFER
  0000+          
  EFD0+=         SEG12   EQU     SEG11+Z3CLS
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EFD0+=         EXTSTK  EQU     SEG12   ; ZCPR3 EXTERNAL STACK
  0000+          
  0000+          ; end of Z3BASE.LIB
  0000+          
  0000+                  MACLIB  Z33HDR.LIB
  0000+          
  0000+          ; Z33HDR.LIB
  0000+          
  0000+          ; This is the configuration file for the ZCPR Version 3.3 command processor.
  0000+          ; You should read through this file and set the equates according to the
  0000+          ; features you want to implement.  Since the command processor is limited to
  0000+          ; no more than 2K (2048 bytes), it is impossible to include all features.
  0000+          
  0000+          ; Basic definitions
  0000+          
  0000+=         NO      EQU     0
  FFFF+=         YES     EQU     NOT NO
  0000+=         OFF     EQU     NO
  FFFF+=         ON      EQU     YES
ZAS Relocating Macro Assembler (v3.05                             page    8
                                                            
                                                            

  0000+          
  0000+=         REL     EQU     NO              ; This equate MUST be set to YES if assembling
  0000+                                          ; to a REL file, and it MUST be set to NO if
  0000+                                          ; assembling to a HEX or COM file.
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       R E S I D E N T    C O M M A N D S    S E L E C T I O N
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          ; Commands to include in the command processor
  0000+          
  0000+          ; The primary function of the command processor is to interpret user commands.
  0000+          ; Providing resident command functions is secondary.  As the command processor
  0000+          ; has evolved to provide ever more advanced command processing functions, there
  0000+          ; has been correspondingly less room for resident command code in the
  0000+          ; processor.  We recommend that you opt for most if not all of the advanced
  0000+          ; processing features and leave the resident command code to the resident
  0000+          ; command processor (RCP) module and to transient programs (COM files).
  0000+          ;
  0000+          ; There are some interrelations between a number of the possible resident
  0000+          ; commands.  Some are so close (LIST and TYPE) that a single equate controls
  0000+          ; both functions.  Others like DIR and ERA share code (both display file
  0000+          ; listings).  It is efficient to select or deselect them together.  The RCP
  0000+          ; has the room to provide more elaborate capabilities.  Therefore, it makes
  0000+          ; sense to choose for the CPR those resident commands that are intrinsically
  0000+          ; simple, (e.g., NOTE) or which depend on intrinsic command processing code
  0000+          ; (e.g., GET, GO, JUMP).
  0000+          
  0000+          
  0000+=         DIRON   EQU     NO      ; DIR command to display disk directory
  0000+=         ERAON   EQU     NO      ; ERA command for deleting files
  FFFF+=         GETON   EQU     YES     ; GET command for loading a file to a general address
  FFFF+=         GOON    EQU     YES     ; GO command to execute code in TPA (at 100h)
  FFFF+=         JUMPON  EQU     YES     ; JUMP command to execute code at a general address
  0000+=         LTON    EQU     NO      ; LIST and TYPE commands for file printing and display
  0000+=         NOTEON  EQU     NO      ; NOTE command for comments in multiple command lines
  0000+=         RENON   EQU     NO      ; REN command for changing names of files
  0000+=         SAVEON  EQU     NO      ; SAVE command for saving TPA to files
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Wheel control over accessibility of commands
  0000+          
  0000+          ; To prevent unauthorized users from performing certain dangerous or sensitive
  0000+          ; operations on the computer, ZCPR33 provides the capability of disabling the
  0000+          ; operation of certain commands when the wheel byte is off.  In ZCPR30, an
  0000+          ; attempt to use one of these wheel-protected commands when the wheel byte was
  0000+          ; off resulted in an error message.  In ZCPR33 things work differently.  In the
  0000+          ; same situation, the command simply disappears.  In this way a transient
  0000+          ; program or extended command processor function can take over and deal with
  0000+          ; the attempt to use the command in a much more flexible way.
  0000+          ;
  0000+          ; Wheel-protected commands in ZCPR30 had extra code to intercept the function
ZAS Relocating Macro Assembler (v3.05                             page    9
                                                            
                                                            

  0000+          ; and disable it.  In ZCPR33, wheel protection is enabled and disabled in a
  0000+          ; different way.  To wheel-protect a command the high bit of the first
  0000+          ; character in the command name is set.  The command table scanner in ZCPR33
  0000+          ; will not recognize these commands when the wheel byte is off.  Since the same
  0000+          ; command scanner is used to scan the commands in the RCP and FCP (flow control
  0000+          ; package), commands there can be wheel protected in the same way.  For skilled
  0000+          ; computer operators it is very easy to use a debugger, file patcher, or disk
  0000+          ; utility to enable and disable wheel protection without having to reassemble
  0000+          ; the CPR, RCP, or FCP.
  0000+          ;
  0000+          ; Because of the way the command scanner works, once one command is wheel
  0000+          ; protected, there is no further code penalty in protecting other commands.
  0000+          ; Therefore, we recommend protecting all possibly sensitive commands or none.
  0000+          
  0000+          
  0000+=         WDIR    EQU     NO      ; Wheel-protect DIR
  0000+=         WERA    EQU     NO      ;   "      "    ERA
  0000+=         WGET    EQU     NO      ;   "      "    GET
  0000+=         WGO     EQU     NO      ;   "      "    GO
  0000+=         WJUMP   EQU     NO      ;   "      "    JUMP
  0000+=         WREN    EQU     NO      ;   "      "    REN
  0000+=         WSAVE   EQU     NO      ;   "      "    SAVE
  0000+=         WLT     EQU     NO      ;   "      "    LIST and TYPE
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command names
  0000+          
  0000+          ; The CTABLE macro, which constructs the command dispatch table, includes a
  0000+          ; line for each command, the first parameter of which is the name of the
  0000+          ; command.  These names may be changed if you wish.  But make sure that you
  0000+          ; do not use a name that is longer than the maximum allowed length.  If you
  0000+          ; do, the name will be truncated and a nonfatal error will occur during
  0000+          ; assembly.  DO NOT CHANGE ANY PARAMETER OTHER THAN THE COMMAND NAME.  Lower
  0000+          ; case letters will be converted to upper case.  The macro COMMAND is defined
  0000+          ; in Z33MAC.LIB.
  0000+          
  0004+=         CMDSIZE EQU     4               ; Maximum length of command names
  0000+          
  0000+          ; Command table         name,   enable, wheel,  jump_addr
  0000+          ;                               [ DO NOT CHANGE THESE PARAMETERS ]
  0000+          CTABLE  MACRO
  0000+                  COMMAND         DIR,    DIRON,  WDIR,   DIR
  0000+                  COMMAND         ERA,    ERAON,  WERA,   ERA
  0000+                  COMMAND         GET,    GETON,  WGET,   GET
  0000+                  COMMAND         GO,     GOON,   WGO,    GO
  0000+                  COMMAND         JUMP,   JUMPON, WJUMP,  JUMP
  0000+                  COMMAND         LIST,   LTON,   WLT,    LIST
  0000+                  COMMAND         NOTE,   NOTEON, FALSE,  NOTE
  0000+                  COMMAND         REN,    RENON,  WREN,   REN
  0000+                  COMMAND         SAVE,   SAVEON, WSAVE,  SAVE
  0000+                  COMMAND         TYPE,   LTON,   WLT,    TYPE
  0000+                  ENDM
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   10
                                                            
                                                            

  0000+          ; DIR command options
  0000+          
  FFFF+=         WIDE    EQU     YES             ; Wide display for 80-column terminals
  007C+=         FENCE   EQU     '|'             ; Separator to use between columns of names
  0041+=         ALLCHAR EQU     'A'             ; Option letter (must be upper case) for
  0000+                                          ; showing SYS and DIR files
  0053+=         SYSCHAR EQU     'S'             ; Option letter (must be upper case) for
  0000+                                          ; showing only SYS files
  FFFF+=         SLASHFL EQU     YES             ; Allow forms "DIR /S" and "DIR /A"?
  FFFF+=         WHLDIR  DEFL    YES             ; Allow display of SYS files only if wheel set
  0000+          
  0000+          ; Do not change
  0000+          
  0000+=         WHLDIR  DEFL    WHLDIR AND DIRON
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; ERA command options
  0000+          
  0000+          ; There are options that control whether or not and in what way the user will
  0000+          ; be prompted before files are erased.  If ERAOK is off, then there will never
  0000+          ; by any prompting.  If ERAOK is on and INSPFL is off, then the user will be
  0000+          ; prompted before all deletions.  If INSPFL is also on, then the user will be
  0000+          ; prompted only when the prompt option character is included on the command
  0000+          ; line.  If this character is defined to be a blank space, then any character
  0000+          ; will turn on prompting.
  0000+          
  FFFF+=         ERAOK   EQU     ON              ; Enable prompting before files are erased
  FFFF+=         INSPFL  EQU     ON              ; Enable command-line inspection flag
  0020+=         INSPCH  EQU     ' '             ; Character to use (must be upper case) to
  0000+                                          ; invoke inspection. If this is set to
  0000+                                          ; ' ' (space character), then any character
  0000+                                          ; after the files spec will turn on the
  0000+                                          ; inspect option.
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; GET command options
  0000+          
  FFFF+=         FULLGET EQU     YES             ; If yes, no memory checks are performed with
  0000+                                          ; the GET command (files can even overwrite the
  0000+                                          ; command processor or page 0).
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; SAVE command options
  0000+          
  0020+=         SECTCH  EQU     ' '             ; Option character (must be upper case) to
  0000+                                          ; select saving of sectors.  If set to ' '
  0000+                                          ; (space), then any character will select the
  0000+                                          ; sector-save option.
  0000+          
  FFFF+=         BELLFL  EQU     YES             ; If yes, bell will ring for SAVE and REN
  0000+                                          ; commands when the file already exists.
  0000+          
  0000+          ;-----------------------------------------------------------------------------
ZAS Relocating Macro Assembler (v3.05                             page   11
                                                            
                                                            

  0000+          
  0000+          ; TYPE command options
  0000+          
  FFFF+=         PAGEFL  EQU     YES             ; If enabled, normally page the output.  If not
  0000+                                          ; enabled, page output only when paging toggle
  0000+                                          ; character is present.
  0050+=         PAGECH  EQU     'P'             ; Option character (must be upper case) to
  0000+                                          ; toggle paging.  If it is set to ' '
  0000+                                          ; (space), then any character will toggle
  0000+                                          ; the paging mode
  0000+          
  0000+          
  0000+          ;=============================================================================
  0000+          ;
  0000+          ;       C O M M A N D    P R O C E S S I N G    O P T I O N S
  0000+          ;
  0000+          ;=============================================================================
  0000+          
  0000+          ; ZCPR33 has many more command processing options than did ZCPR30.  These are
  0000+          ; controlled by the following equates.
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Environment access
  0000+          
  0000+          ; In ZCPR30 the command processor knew about its environment only at the time
  0000+          ; it was assembled.  Therefore, all aspects of the environment were fixed.
  0000+          ; Loading a new ENV module might change the way a transient program would
  0000+          ; function (for example by changing the maximum drive and user values that
  0000+          ; would be accepted), but the command processor would not recognize these
  0000+          ; changes.  ZCPR33 can be made to recognize dynamically several possible
  0000+          ; changes in the environment.
  0000+          
  FFFF+=         DUENV           EQU     YES     ; If enabled, the CPR will get the values of
  0000+                                          ; the maximum drive and user to recognize from
  0000+                                          ; the environment descriptor
  0000+          
  FFFF+=         ADUENV          EQU     YES     ; If enabled, the CPR will use the DUOK flag
  0000+                                          ; byte in the environment to determine
  0000+                                          ; whether or not to accept DU: references
  0000+          
  0000+=         INCLENV         EQU     NO      ; If enabled, inclusion of the DU in the
  0000+                                          ; prompt will be controlled by the DUOK flag
  0000+          
  0000+          ; The following three functions, if enabled, allow one to dynamically trade off
  0000+          ; buffer space between named directories, resident commands, and flow control.
  0000+          ; By executing a command like "LDR NEW.ENV,NEW.RCP,NEW.FCP,NEW.NDR" one can
  0000+          ; temporarily expand the capabilities of one module at the expense of another.
  0000+          ; To use these capabilities, the three buffers must be contiguous in memory.
  0000+          ; Since making such changes can be risky, it is recommended that it be done
  0000+          ; only with aliases, so that all necessary changes get made automatically and
  0000+          ; at the same time.
  0000+          
  FFFF+=         FCPENV          EQU     YES     ; If enabled, the CPR will determine the address
  0000+                                          ; of the FCP (flow command package) from the
  0000+                                          ; environment descriptor.
ZAS Relocating Macro Assembler (v3.05                             page   12
                                                            
                                                            

  0000+          
  FFFF+=         RCPENV          EQU     YES     ; If enabled, the CPR will determine the address
  0000+                                          ; of the RCP (resident command package) from
  0000+                                          ; the environment descriptor.
  0000+          
  FFFF+=         NDRENV          EQU     YES     ; If enabled, the CPR will determine the address
  0000+                                          ; of the NDR (named directory registers) from
  0000+                                          ; the environment descriptor.
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Control over types of files to load and run as transient programs.
  0000+          
  0000+          COMTYP  MACRO                   ; The file type for executable files (this will
  0000+                  DB      'COM'           ; be changed only in the most unusual
  0000+                  ENDM                    ; situtations).  This file type will also apply
  0000+                                          ; to the extended command processor.
  0000+          
  0000+=         ATTCHK  EQU     NO              ; If enabled, the command processor can be made
  0000+                                          ; to recognize as executable files only those
  0000+                                          ; with particular attributes (defined by the
  0000+                                          ; COMATT equate below).
  0000+          
  0000+=         COMATT  EQU     0               ; 0 = system, 80h = DIR (01h will give both,
  0000+                                          ; but in that case setting ATTCHK to false will
  0000+                                          ; give the same result with less code).
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Batch processing using the submit facility.  This takes up quite a bit of
  0000+          ; space in the command processor, and you may wish to omit it.  Most of the
  0000+          ; type of processing that submit can do can be accomplished using either the
  0000+          ; the memory-based ZEX batch processor or command-line scripts (aliases).
  0000+          
  0000+=         SUBON   EQU     NO              ; If enabled, the command processor will
  0000+                                          ; process submit files.
  0000+          
  0001+=         SUBNOISE EQU    1               ; If 0, submit lines, like command lines
  0000+                                          ; generated by aliases, will not be echoed
  0000+                                          ; to the screen.  If 1, then echoing will
  0000+                                          ; be controlled by the ENV QUIET flag. If more
  0000+                                          ; than 1, submit command lines will always
  0000+                                          ; be echoed.
  0000+          
  0000+=         SUBCLUE EQU     NO              ; If yes, use the flag returned by the DOS
  0000+                                          ; as a clue to the existence of a submit file
  0000+                                          ; (some versions of ZRDOS -- including 1.7 --
  0000+                                          ; do not return the correct value, in which
  0000+                                          ; case 'no' should be used here).  The speed
  0000+                                          ; advantage to using 'yes' is probably not
  0000+                                          ; great.
  0000+          
  005D+=         SPRMPT  EQU     ']'             ; CPR prompt indicating submit command
  0000+          
  0000+          SUBTYP  MACRO                   ; The file type for the '$$$' file used by the
  0000+                  DB      'SUB'           ; submit processor (this will very rarely be
ZAS Relocating Macro Assembler (v3.05                             page   13
                                                            
                                                            

  0000+                  ENDM                    ; changed)
  0000+          
  0000+          ; WARNING -- the following equate should not be changed from 'A' unless you
  0000+          ; know what you are doing!
  0000+          
  0041+=         SUBDRV  EQU     'A'             ; Drive to use for submit file (normally this
  0000+                                          ; will be 'A', but in special cases, such as
  0000+                                          ; when there is a RAM disk, you might want to
  0000+                                          ; specify another drive)
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; PATH options -- ZCPR searches for user programs along a path of directories
  0000+          ; specified in the path buffer.  Because of the efficiency it adds, the
  0000+          ; minpath (minimum path) is not an option in ZCPR33 but is always in effect.
  0000+          ; This minimum path eliminates duplicate references that can arise in several
  0000+          ; ways and otherwise cause a useless search of a directory a second or third
  0000+          ; time.
  0000+          
  FFFF+=         DRVPREFIX       EQU     YES     ; If enabled, an explicit DU: or DIR: prefix on
  0000+                                          ; a command verb will be recognized and made
  0000+                                          ; the first element of the command search path.
  0000+          
  0000+=         SCANCUR         EQU     NO      ; If enabled, the currently logged directory
  0000+                                          ; will always be added to the beginning of the
  0000+                                          ; symbolic path (we advise disabling this
  0000+                                          ; option -- you can always include '$$' in the
  0000+                                          ; path, but then you can omit it when you wish
  0000+                                          ; and you can control its position in the path,
  0000+                                          ; searching your main directories first).  See
  0000+                                          ; the Z33 User Guide for special precautions
  0000+                                          ; required when SCANCUR is off.
  0000+          
  0000+          ; In order to save space in the CPR for valuable code, the minpath can be
  0000+          ; built in a memory buffer external to the CPR.  If your symbolic path has
  0000+          ; no more than 10 elements, the minpath will automatically be built at the
  0000+          ; bottom of the external stack.  Otherwise, if you want an external minpath,
  0000+          ; you must set the EXTMPATH symbol to yes and supply the address of the memory
  0000+          ; to use.  The memory requirement is twice the length of the symbolic path
  0000+          ; (see Z3BASE.LIB or run SHOW to get this value) plus 2 if SCANCUR is enabled
  0000+          ; plus 2 if DRVPREFIX is enabled, plus 1 for the ending null.
  0000+          
  0000+=         EXTMPATH        DEFL    NO      ; If yes, the minpath will be built in a buffer
  0000+                                          ; external to the command processor at an
  0000+                                          ; address supplied in the next definition.
  0000+          
  0000+=         EXTMPATHADR     DEFL    0       ; If EXPMPATH is enabled, provide the address
  0000+                                          ; of the external buffer here.
  0000+          
  0000+          ; Do not change the following code
  0000+          
  0000+                   IF     ( EXPATHS LE 10 )
  FFFF+=         EXTMPATH        DEFL    YES     ; Automatic placement of minpath
  EFD0+=         EXTMPATHADR     DEFL    EXTSTK  ; ..at bottom of external stack
  0000+                   ENDIF
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   14
                                                            
                                                            

  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Control over the acceptance and display of drive/user and named directory
  0000+          ; forms.  With the options provided in ZCPR33 it is quite easy to provide a
  0000+          ; fully secure system with the DU form enabled.  The DU form is often the only
  0000+          ; one recognized by non-ZCPR programs and is often more convenient and natural
  0000+          ; to use.  We, therefore, recommend that both DU and DIR forms be allowed and
  0000+          ; displayed.  Processing of DIR forms will not be carried out, obviously, if
  0000+          ; the named directory register (NDR) is not implemented in the system.
  0000+          
  FFFF+=         ACCPTDU         EQU     YES     ; Accept DU: form in command lines
  FFFF+=         ACCPTDIR        EQU     YES     ; Accept DIR: form in command lines
  0000+=         DUFIRST         EQU     NO      ; If enabled, the DU form will be checked
  0000+                                          ; before the DIR form.
  0000+          
  FFFF+=         INCLDU          EQU     YES     ; Include DU in prompt
  FFFF+=         INCLDIR         EQU     YES     ; Include DIR in prompt
  0000+          
  0000+          
  0000+          ; Do not change the following
  0000+          
  FFFF+=         INCLDIR         DEFL    INCLDIR AND (Z3NDIR NE 0)
  FFFF+=         ACCPTDIR        DEFL    ACCPTDIR AND (Z3NDIR NE 0)
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Security matters
  0000+          
  0000+          
  FFFF+=         PWCHECK EQU     YES             ; If enabled, passwords on named directories
  0000+                                          ; will be checked for DIR forms in the command
  0000+                                          ; verb and the first two command-line tokens.
  0000+                                          ; If disabled, passwords will not be checked
  0000+                                          ; even if a directory has a password defined.
  0000+          
  FFFF+=         PWNOECHO EQU    YES             ; If yes, the BIOS conout routine will be
  0000+                                          ; disabled during password input so that the
  0000+                                          ; password will not be echoed to the screen.
  0000+                                          ; This does involves poking in the BIOS and
  0000+                                          ; could in rare instances cause problems.
  0000+          
  0000+=         WDU     EQU     NO              ; If enabled, the DU: and DIR: forms will not
  0000+                                          ; be allowed for changing the logged directory
  0000+                                          ; unless the wheel byte is set.
  0000+          
  FFFF+=         WPASS   EQU     YES             ; If enabled, password checking of named
  0000+                                          ; directories is bypassed when the wheel byte
  0000+                                          ; is set.
  0000+          
  0000+=         WPREFIX EQU     NO              ; If set, this option will effectively turn
  0000+                                          ; off DRVPREFIX when the wheel byte is off.
  0000+                                          ; Explicit drive prefixes will then be allowed
  0000+                                          ; only when the wheel byte is set.  Otherwise
  0000+                                          ; they will be ignored except that ECPs will
  0000+                                          ; not be invoked if a prefix was present.
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   15
                                                            
                                                            

  0000+          ; Do not change the next lines
  0000+          
  FFFF+=         PWCHECK DEFL    PWCHECK AND ( Z3NDIR NE 0 )
  FFFF+=         PWNOECHO DEFL   PWNOECHO AND PWCHECK
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Advanced command processing options
  0000+          
  0000+=         HIGHUSER        EQU     NO      ; If yes, the command processor will log into
  0000+                                          ; user numbers higher than 15 (up to 31).
  0000+                                          ; WARNING: BECAUSE CP/M USES A SINGLE BYTE AT
  0000+                                          ; ADDRESS 0004H TO KEEP BOTH DRIVE AND USER,
  0000+                                          ; PROGRAMS THAT USE THAT BYTE TO DETERMINE
  0000+                                          ; THE DEFAULT DU MAY NOT RUN PROPERLY WHEN ONE
  0000+                                          ; IS LOGGED INTO A USER NUMBER ABOVE 15.
  0000+          
  FFFF+=         SKIPPATH        EQU     YES     ; If yes, command verbs with an explicit DU: or
  0000+                                          ; DIR: prefix will not use the search path; if
  0000+                                          ; the command is not found in the specified
  0000+                                          ; directory, the error handler will be invoked
  0000+                                          ; immediately (no path and no ECP).
  0000+          
  FFFF+=         FASTECP         EQU     YES     ; If yes, command verbs with leading spaces will
  0000+                                          ; be executed directly by the ECP (saves the
  0000+                                          ; time of searching the path for a COM file
  0000+                                          ; when one knows the command is for the ECP).
  0000+          
  FFFF+=         ALTSPACE        EQU     YES     ; If yes, the alternate character, ECPCHAR, can
  0000+                                          ; also be used to invoke ECP processing
  0000+                                          ; immediately (FASTECP must be enabled).
  0000+          
  0000+=         ALTONLY         EQU     NO      ; If ALTSPACE is on, then if ALTONLY is also
  0000+                                          ; on, the alternate character the only one that
  0000+                                          ; will invoke fast ECP processing (spaces will
  0000+                                          ; not).
  0000+          
  002F+=         ECPCHAR         EQU     '/'     ; Alternate (or required) character for fast ECP
  0000+                                          ; invocation.
  0000+          
  FFFF+=         ALTCOLON        EQU     YES     ; If enabled, an alternate character (period
  0000+                                          ; recommended) can be used in place of a colon
  0000+                                          ; to make the CPR skip resident commands and
  0000+                                          ; add the current directory to the search path.
  0000+          
  002E+=         ALTCHAR         EQU     '.'     ; Character that serves as an alias for leading
  0000+                                          ; colon if it is the first non-blank character
  0000+                                          ; in the command.
  0000+          
  FFFF+=         BADDUECP        EQU     YES     ; If yes, pass commands that try to log into a
  0000+                                          ; bad directory to the ECP for processing; if
  0000+                                          ; set to NO, invoke the error handler
  0000+                                          ; immediately under these circumstances.
  0000+          
  0000+          ; WARNING -- do not change the following equate from 'no' unless you
  0000+          ; know what you are doing!
ZAS Relocating Macro Assembler (v3.05                             page   16
                                                            
                                                            

  0000+          
  0000+=         SHELLIF         EQU     NO      ; If yes, flow control processing can take
  0000+                                          ; place in shell aliases (complex command
  0000+                                          ; sequences being used as a shell).  The
  0000+                                          ; penalty is that each time the shell runs,
  0000+                                          ; the entire flow control system is
  0000+                                          ; reinitialized.  Flow control information
  0000+                                          ; will not persist across shell invocations.
  0000+                                          ; If SHELLIF is off, flow commands in shell
  0000+                                          ; aliases will not be recognized as FCP
  0000+                                          ; commands (they will be flushed) and,
  0000+                                          ; therefore, should not be used.
  0000+          
  0000+          ; Do not change the following
  0000+          
  FFFF+=         SKIPPATH        DEFL    SKIPPATH AND DRVPREFIX
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Extended command processing
  0000+          
  0000+          ; The extended command processor comes into effect when a way to process a
  0000+          ; command verb has still not been found after the entire search path for a
  0000+          ; COM file has been exhausted.  The entire user command is taken as the
  0000+          ; command tail on the extended command processor.  In ZCPR30 one could either
  0000+          ; have extended command processing OR error handling.  In ZCPR33 one can, and
  0000+          ; should, have both.
  0000+          
  FFFF+=         ROOTONLY        EQU     YES     ; If yes, the command processor looks for the
  0000+                                          ; ECP only in the directory specified as the
  0000+                                          ; last one in the path instead of scanning the
  0000+                                          ; entire path for the ECP.
  0000+          
  0000+          ; The following macro defines the name of the ECP.  Rename your favorite
  0000+          ; ECP (ours is ARUNZ) to CMDRUN.COM or whatever name you put in below.
  0000+          
  0000+          ECPNAME MACRO
  0000+                  DB      0               ; Drive (do not change this from 0)
  0000+                  DB      'CMDRUN  '      ; Name of ECP program (exactly 8 characters)
  0000+                  ;       '--------'      ; (Eight-character space marker)
  0000+                  ENDM
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Miscellaneous equates
  0000+          
  0000+          
  003B+=         CMDSEP  EQU     ';'             ; Separator between multiple commands
  0000+          
  0000+          ; The following two equates are used only if the equates to get this
  0000+          ; information from the environment descriptor are not enabled.
  0000+          
  000F+=         MAXUSR  EQU     15              ; Maximum user number accessible
  000F+=         MAXDISK EQU     15              ; Maximum number of disks accessible
  0000+          
  0000+=         SUPRES  EQU     FALSE           ; Supresses user number in prompt for user 0
ZAS Relocating Macro Assembler (v3.05                             page   17
                                                            
                                                            

  0000+          
  003E+=         CPRMPT  EQU     '>'             ; CPR prompt indicating user command
  0000+          
  0048+=         NUMBASE EQU     'H'             ; Character used to designate a hexadecimal
  0000+                                          ; number in the SAVE command
  0000+          
  0024+=         CURIND  EQU     '$'             ; Symbol in symbolic path for current disk
  0000+                                          ; or user
  0000+          
  003B+=         COMMENT EQU     ';'             ; Lines beginning with this character are
  0000+                                          ; treated as comments
  0000+          
  0000+          ; Definition equates
  0000+          
  0000+=         WHEEL   DEFL    WERA OR WREN OR WLT OR WGO OR WSAVE OR WGET OR WJUMP OR WDIR
  0000+          
  EDF4+=         PATH    EQU     EXPATH          ; Definition from Z3BASE.LIB
  0000+          
  0000+          ; End of Z33HDR.LIB
  0000+          
  0000+          
  0000           
  0000           ; Check that the configuration includes the required facilities
  0000           
  0000           ; A ZCPR33 system is assumed to include certain minimal features, including
  0000           ; an external file control block, external path, shell stack, message buffer,
  0000           ; external environment descriptor, multiple command line, and external stack.
  0000           ; If wheel checking is enabled in the Z33HDR.LIB file, then there must be
  0000           ; an address defined for the wheel byte in the Z3BASE.LIB file.
  0000           
  0000 =         ERRFLAG DEFL    EXTFCB EQ 0                     ; External command FCB
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ EXPATH EQ 0 ]      ; Symbolic path
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ SHSTK  EQ 0 ]      ; Shell stack
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ Z3MSG  EQ 0 ]      ; Message buffer
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ Z3ENV  EQ 0 ]      ; Environment descriptor
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ Z3CL   EQ 0 ]      ; Multiple command line
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ EXTSTK EQ 0 ]      ; External stack
  0000                    IF     WHEEL OR WDU OR WPASS OR WPREFIX OR WHLDIR
  0000 =         ERRFLAG DEFL    ERRFLAG OR [ Z3WHL  EQ 0 ]      ; Wheel byte
  0000                    ENDIF  ;wheel or wdu or wpass or wprefix or whldir
  0000           
  0000                    IF     ERRFLAG
  0000           
  0000                   *** NOT ALL REQUIRED ZCPR3 FACILITIES ARE SUPPORTED ***
  0000           
  0000                    ELSE   ; go ahead with the assembly
  0000           
  0000           
  0000           ;-----------------------------------------------------------------------------
  0000           ;
  0000           ;               D E F I N I T I O N S    S E C T I O N
  0000           ;
  0000           ;-----------------------------------------------------------------------------
  0000           
  0000           
  0000           ; ----------   Macro definitions
ZAS Relocating Macro Assembler (v3.05                             page   18
                                                            
                                                            

  0000           
  0000+                  MACLIB  Z33MAC.LIB              ; Library of macros for ZCPR33
  0000+          
  0000+          ; Z33MAC.LIB : Macros for use with ZCPR33
  0000+          
  0000+          ; General purpose macros
  0000+          
  0000+          PUTREG   MACRO
  0000+                  PUSH    HL              ; Save registers in order
  0000+                  PUSH    DE
  0000+                  PUSH    BC
  0000+                   ENDM
  0000+          
  0000+          GETREG   MACRO
  0000+                  POP     BC              ; Restore registers in order
  0000+                  POP     DE
  0000+                  POP     HL
  0000+                   ENDM
  0000+          
  0000+          SWAP     MACRO
  0000+                  RRCA                    ; Exchange nibbles
  0000+                  RRCA
  0000+                  RRCA
  0000+                  RRCA
  0000+                   ENDM
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for forming option bytes
  0000+          
  0000+          ; This macro generates a byte with bits corresponding to up to 8 option
  0000+          ; flags.  The bits are filled in the order of the parameters and are right
  0000+          ; justified in the byte.
  0000+          
  0000+          OPTFLAG MACRO   F1,F2,F3,F4,F5,F6,F7,F8
  0000+          
  0000+          FLAG    DEFL    0               ;; initial value
  0000+          
  0000+                  IRP     TEMP,<F1,F2,F3,F4,F5,F6,F7,F8>
  0000+          
  0000+                   IF     NOT NUL TEMP
  0000+          FLAG    DEFL    FLAG SHL 1
  0000+                   IF     TEMP
  0000+          FLAG    DEFL    FLAG OR 1
  0000+                   ENDIF  ;;temp
  0000+                   ENDIF  ;;not nul temp
  0000+          
  0000+                   ENDM                   ;; irp
  0000+          
  0000+                  DEFB    LOW FLAG
  0000+          
  0000+                   ENDM                   ;; optflag
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for directory scanning
ZAS Relocating Macro Assembler (v3.05                             page   19
                                                            
                                                            

  0000+          
  0000+          ; This macro resolves the command token for possible directory references.
  0000+          ; FORM1 and FORM2 can each be either "DU" or "DIR".  FORM2 can also be null.
  0000+          ; The two forms are scanned for in the indicated order.
  0000+          
  0000+          ; This macro preserves the pointer to the FCB in DE and to the next
  0000+          ; character in the line in HL.  On return, the FCB pointer has been restored,
  0000+          ; and the command string pointer is still on the stack.  The routines DUSCAN
  0000+          ; and DIRSCAN are called as needed.
  0000+          
  0000+          RESOLVE MACRO   FORM1,FORM2
  0000+          
  0000+                  LOCAL   RESOLVED
  0000+          
  0000+                  PUSH    HL              ; Save pointer to command string
  0000+                  PUSH    DE              ; Save pointer to FCB
  0000+                  CALL    FORM1&SCAN      ; Scan for the first directory form
  0000+          
  0000+                   IF     NOT NUL FORM2
  0000+          
  0000+                  JR      Z,GOTIT         ; Resolved successfully, so jump ahead
  0000+          
  0000+                  POP     DE              ; Restore pointers for use by second call
  0000+                  POP     HL
  0000+                  PUSH    HL              ; Save them again
  0000+                  PUSH    DE
  0000+                  CALL    FORM2&SCAN      ; Scan for the second directory form
  0000+          
  0000+                   ENDIF  ;not nul form2
  0000+          
  0000+          GOTIT:
  0000+                  POP     DE              ; Restore pointer to FCB
  0000+          
  0000+                   ENDM   ;resolve
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command table entry definition macro
  0000+          
  0000+          ; Macro to form an entry for one command in the table.  The first parameter is
  0000+          ; the name to be used for the command (no quotes); the second parameter is the
  0000+          ; flag that indicates whether or not the command is to be enabled; the third
  0000+          ; parameter is the wheel control flag; and the last parameter is the jump
  0000+          ; address to the code that carries out the command.  The command names are
  0000+          ; automatically padded out to the correct length (they will be truncated and
  0000+          ; an error message will result if a command name is too long).  The characters
  0000+          ; in the command name are automatically converted to upper case.
  0000+          
  0000+          COMMAND MACRO CMDNAME,ENABLEFLAG,WHEELFLAG,ADDRESS
  0000+          
  0000+                   IF     ENABLEFLAG      ;; Generate command only if enabled
  0000+          
  0000+          WHLMASK DEFL    WHEELFLAG       ;; Initialize variables
  0000+          COUNT   DEFL    CMDSIZE         ;; Initialize to size of each command name
  0000+          
  0000+                  IRPC    CHAR,CMDNAME    ;; Repeat over letters in command name
ZAS Relocating Macro Assembler (v3.05                             page   20
                                                            
                                                            

  0000+          
  0000+          COUNT   DEFL    COUNT - 1       ;; Count down characters in name
  0000+          
  0000+                   IF     [ COUNT LT CMDSIZE ]
  0000+          
  0000+                          ;; If character is lower case, convert to upper case
  0000+          
  0000+                   IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ] + 80H
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ]
  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ELSE   ;;NOT LOWER CASE
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    '&CHAR' + 80H   ;; IF CONTROLLED BY WHEEL, SET HIGH BIT
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    '&CHAR'         ;; IF NOT RESTRICTED, LEAVE HIGH BIT CLEAR
  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ENDIF  ;;LOWER CASE
  0000+          
  0000+                   ENDIF  ;;[ COUNT LT CMDSIZE ]
  0000+          
  0000+          WHLMASK DEFL    FALSE           ;; TURN OFF HIGH-BIT SETTING AFTER FIRST CHAR
  0000+          
  0000+                  ENDM    ;IRPC
  0000+          
  0000+                          ;; PAD COMMAND NAME WITH BLANKS
  0000+          
  0000+                   IF     [ COUNT GT CMDSIZE ]    ;; IF WE UNDERFLOWED
  0000+                  *** COMMAND NAME "&CMDNAME" IS TOO LONG / TRUNCATED ***
  0000+                   ELSE
  0000+                  REPT    COUNT
  0000+                  DEFB    ' '
  0000+                  ENDM
  0000+                   ENDIF  ;[ COUNT GT CMDSIZE ]
  0000+          
  0000+                  DW      ADDRESS         ;; DISPATCH ADDRESS FOR COMMAND
  0000+          
  0000+                   ENDIF  ;ENABLE
  0000+          
  0000+                  ENDM    ;COMMAND
  0000+          
  0000+          ; End Z33MAC.LIB
  0000+          
  0000+          
  0000           
  0000           
  0000           ; ----------   ASCII definitions
  0000           
  0003 =         CTRLC   EQU     03H
  0007 =         BELL    EQU     07H
ZAS Relocating Macro Assembler (v3.05                             page   21
                                                            
                                                            

  0009 =         TAB     EQU     09H
  0000           ; LF    EQU     0AH
  0000           ; CR    EQU     0DH
  0000           
  0000           
  0000           ; ----------   Operating system addresses
  0000           
  0000 =         WBOOT   EQU     BASE+0000H      ; CP/M warm boot address
  0004 =         UDFLAG  EQU     BASE+0004H      ; User number in high nybble, disk in low
  0000           ; BDOS  EQU     BASE+0005H      ; BDOS function call entry point
  005C =         TFCB    EQU     BASE+005CH      ; Default FCB buffer
  006C =         TFCB2   EQU     TFCB+16         ; 2nd FCB
  0080 =         TBUFF   EQU     BASE+0080H      ; Default disk I/O buffer
  0100 =         TPA     EQU     BASE+0100H      ; Base of TPA
  0000           ; BIOS  EQU     CCP+0800H+0E00H ; BIOS location
  0000           
  0000           
  0000           ; ----------   Error codes
  0000           
  0000           ; ZCPR33 uses the error byte at the beginning of the message buffer as a flag
  0000           ; to show what kind of error occurred.  Advanced error handlers will be able
  0000           ; to help the user further by suggesting the possible cause of the error.
  0000           ; Error code 6 for an ECP error is determined by the code and cannot be
  0000           ; changed (without increasing code length).
  0000           
  0001 =         ECDUCHG         EQU     1       ; Directory change error -- attempt to change
  0000                                           ; ..logged directory when under control of
  0000                                           ; ..wheel byte and wheel is off
  0000           
  0002 =         ECBADDIR        EQU     2       ; Bad directory specification -- logging of
  0000                                           ; ..user number beyond legal range,
  0000                                           ; ..nonexistent named directory
  0000           
  0003 =         ECBADPASS       EQU     3       ; Bad password -- incorrect password entered
  0000           
  0000           
  0005 =         ECBADCMD        EQU     5       ; Bad command form -- wildcard or file type
  0000                                           ; ..present in command verb
  0000           
  0006 =         ECECPERR        EQU     6       ; ECP error --  command could not be executed
  0000                                           ; ..by ECP, error handling was forced by a
  0000                                           ; ..transient for its own reasons
  0000                                           ; (DO NOT CHANGE FROM 6)
  0000           
  0007 =         ECNOCMD         EQU     7       ; Command file not found -- command that skips
  0000                                           ; ..ECP could not be executed, GET could not
  0000                                           ; ..find file to load
  0000           
  0008 =         ECAMBIG         EQU     8       ; Ambiguous file specification where not
  0000                                           ; ..allowed (SAVE, GET, REN)
  0000           
  0009 =         ECBADNUM        EQU     9       ; Bad numerical value -- not a number where
  0000                                           ; ..number expected, number out of range
  0000           
  000A =         ECNOFILE        EQU     10      ; File not found -- REN, TYPE, LIST could not
  0000                                           ; ..find a specified file
ZAS Relocating Macro Assembler (v3.05                             page   22
                                                            
                                                            

  0000           
  000B =         ECDISKFULL      EQU     11      ; Disk directory or data area full
  0000           
  000C =         ECTPAFULL       EQU     12      ; TPA overflow error
  0000           
  0000           
  0000           ; ----------   Multiple command line equates
  0000           
  0000           ; The multiple command line buffer is located in a protected area in memory so
  0000           ; that it is not overwritten during warm boots.  It includes some pointers so
  0000           ; that when ZCPR33 starts it can tell where to start reading the command line.
  0000           ; BUFSIZ and CHRCNT are not used by ZCPR33 but are provided so that the BDOS
  0000           ; line input function can be used to read in a command line.
  0000           
  EF00 =         NXTCHR  EQU     Z3CL            ; Address where pointer to next command to
  0000                                           ; ..process is kept
  EF02 =         BUFSIZ  EQU     Z3CL+2          ; Address where size of buffer is kept
  EF03 =         CHRCNT  EQU     Z3CL+3          ; Address where length of string actually in
  0000                                           ; ..the buffer is kept (not always reliable)
  EF04 =         CMDLIN  EQU     Z3CL+4          ; Address of beginning of command line buffer
  00D0 =         BUFLEN  EQU     Z3CLS           ; Length of command line buffer
  0000           
  0000           
  0000           ; ----------   Command file control block
  0000           
  0000           ; In ZCPR33 the file control block for commands must be located in protected
  0000           ; memory.  This not only frees up valuable space in the command processor for
  0000           ; code but also makes it possible for programs to determine by what name they
  0000           ; were invoked.
  0000           
  EDD0 =         CMDFCB  EQU     EXTFCB
  0000           
  0000           
  0000           ; ----------   External CPR stack
  0000           
  F000 =         STACK   EQU     EXTSTK+48       ; Set top-of-stack address
  EFD0 =         PWLIN   EQU     EXTSTK          ; Place line at bottom of stack
  0000           
  0000           
  0000           ; ----------  Environment
  0000           
  EC28 =         QUIETFL EQU     Z3ENV+28H       ; Quiet flag
  EC2C =         MAXDRENV EQU    Z3ENV+2CH       ; Maximum drive value
  EC2D =         MAXUSRENV EQU   Z3ENV+2DH       ; Maximum user value
  EC2E =         DUOKFL  EQU     Z3ENV+2EH       ; Flag indicating acceptance of DU: form
  EC33 =         CRTTXT0 EQU     Z3ENV+33H       ; Address of number of lines of text on the
  0000                                           ; ..screen of CRT0
  0000           
  0000           
  0000           ; ----------  Message buffer
  0000           
  ED80 =         ECFLAG          EQU     Z3MSG           ; Error return code flag
  ED81 =         IFPTRFL         EQU     Z3MSG+1         ; Pointer to current IF level
  ED82 =         IFSTATFL        EQU     Z3MSG+2         ; Flow control status byte
  ED83 =         CMDSTATFL       EQU     Z3MSG+3         ; Command status flag
  ED84 =         CMDPTR          EQU     Z3MSG+4         ; Pointer to currently running command
ZAS Relocating Macro Assembler (v3.05                             page   23
                                                            
                                                            

  ED87 =         ZEXINPFL        EQU     Z3MSG+7         ; ZEX input status/control flag
  ED88 =         ZEXRUNFL        EQU     Z3MSG+8         ; ZEX running flag
  ED90 =         ERRCMD          EQU     Z3MSG+10H       ; Error handling command line
  EDAC =         XSUBFLAG        EQU     Z3MSG+2CH       ; XSUB input redirection flag
  EDAD =         SUBFLAG         EQU     Z3MSG+2DH       ; Submit running flag
  EDAE =         CURUSR          EQU     Z3MSG+2EH       ; Currently logged user
  EDAF =         CURDR           EQU     Z3MSG+2FH       ; Currently logged drive
  0000           
  0000           
  0000           ;-----------------------------------------------------------------------------
  0000           ;
  0000           ;               C O D E    M O D U L E S    S E C T I O N
  0000           ;
  0000           ;-----------------------------------------------------------------------------
  0000           
ZAS Relocating Macro Assembler (v3.05                             page   24
                                                            
                                                            

  0000                   PAGE
  0000           
  0000           ; ZCPR33-1.Z80
  0000           
  0000           ;=============================================================================
  0000           ;
  0000           ;    E N T R Y    P O I N T S    A N D    H E A D E R    S T R U C T U R E
  0000           ;
  0000           ;=============================================================================
  0000           
  0000                    IF     NOT REL         ; If generating absolute code
  C200                   ORG     CCP
  C200                    ENDIF  ;not rel
  C200           
  C200           
  C200           ; ENTRY POINTS INTO ZCPR33
  C200           ;
  C200           ; For compatibility with CP/M, two entry points are provided here.  In
  C200           ; standard CP/M if the code is entered from the first entry point, then the
  C200           ; command in the resident command buffer is executed; if entered from the
  C200           ; second entry point, the command line is flushed.  With ZCPR33 and its
  C200           ; multiple command line buffer, these two entry points function identically
  C200           ; and go to the same address.
  C200           ;
  C200           ; We have kept the entry points in their standard locations but have used a
  C200           ; relative jump for the second entry point and replaced the last byte with the
  C200           ; version number.  In this way the version number occupies a position that
  C200           ; would otherwise contain the page number at which the CPR runs.  It will
  C200           ; always be possible, therefore, to distinguish ZCPR33 and later versions
  C200           ; from other command processors.  The first jump is kept as an absolute jump
  C200           ; so that 1) the code will be compatible with Z-COM and Z3-DOT-COM and 2) the
  C200           ; execution address of a CPR module can always be determined.
  C200           
  C200           ENTRY:
  C200 C339C2            JP      ZCPR
  C203           
  C203 1834              JR      ZCPR
  C205           
  C205           VERSION:
  C205 33                DEFB    33H             ; Version ID squeezed in here (offset = 5)
  C206           
  C206           ;-----------------------------------------------------------------------------
  C206           
  C206           ; Configuration information
  C206           
  C206           OPTIONS:                        ; (offset = 6)
  C206             OPTFLAG BADDUECP,ROOTONLY,NDRENV,FCPENV,RCPENV,INCLENV,ADUENV,DUENV
  C206           
  0000 =         FLAG    DEFL    0
  C206           
  C206                   IRP     TEMP,<BADDUECP,ROOTONLY,NDRENV,FCPENV,RCPENV,INCLENV,ADUENV,DUENV>
  C206           
  C206                    IF     NOT NUL TEMP
  C206           FLAG    DEFL    FLAG SHL 1
  C206                    IF     TEMP
  C206           FLAG    DEFL    FLAG OR 1
ZAS Relocating Macro Assembler (v3.05                             page   25
                                                            
                                                            

  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206                    ENDM
  C206           
  C206                    IF     NOT NUL BADDUECP
  0000 =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     BADDUECP
  0001 =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL ROOTONLY
  0002 =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     ROOTONLY
  0003 =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL NDRENV
  0006 =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     NDRENV
  0007 =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL FCPENV
  000E =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     FCPENV
  000F =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL RCPENV
  001E =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     RCPENV
  001F =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL INCLENV
  003E =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     INCLENV
  C206           FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL ADUENV
  007C =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     ADUENV
ZAS Relocating Macro Assembler (v3.05                             page   26
                                                            
                                                            

  007D =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206           
  C206                    IF     NOT NUL DUENV
  00FA =         FLAG    DEFL    FLAG SHL 1
  C206                    IF     DUENV
  00FB =         FLAG    DEFL    FLAG OR 1
  C206                    ENDIF
  C206                    ENDIF
  C206           
  C206                    ENDM
  C206           
  C206 FB                DEFB    LOW FLAG
  C207           
  C207                    ENDM
  C207             OPTFLAG HIGHUSER,DRVPREFIX,SCANCUR,INCLDIR,INCLDU,DUFIRST,ACCPTDIR,ACCPTDU
  C207           
  0000 =         FLAG    DEFL    0
  C207           
  C207                   IRP     TEMP,<HIGHUSER,DRVPREFIX,SCANCUR,INCLDIR,INCLDU,DUFIRST,ACCPTDIR,ACCPTDU>
  C207           
  C207                    IF     NOT NUL TEMP
  C207           FLAG    DEFL    FLAG SHL 1
  C207                    IF     TEMP
  C207           FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207                    ENDM
  C207           
  C207                    IF     NOT NUL HIGHUSER
  0000 =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     HIGHUSER
  C207           FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL DRVPREFIX
  0000 =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     DRVPREFIX
  0001 =         FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL SCANCUR
  0002 =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     SCANCUR
  C207           FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
ZAS Relocating Macro Assembler (v3.05                             page   27
                                                            
                                                            

  C207                    IF     NOT NUL INCLDIR
  0004 =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     INCLDIR
  0005 =         FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL INCLDU
  000A =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     INCLDU
  000B =         FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL DUFIRST
  0016 =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     DUFIRST
  C207           FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL ACCPTDIR
  002C =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     ACCPTDIR
  002D =         FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207           
  C207                    IF     NOT NUL ACCPTDU
  005A =         FLAG    DEFL    FLAG SHL 1
  C207                    IF     ACCPTDU
  005B =         FLAG    DEFL    FLAG OR 1
  C207                    ENDIF
  C207                    ENDIF
  C207           
  C207                    ENDM
  C207           
  C207 5B                DEFB    LOW FLAG
  C208           
  C208                    ENDM
  C208             OPTFLAG NO,PWCHECK,PWNOECHO,WDU,WPASS,WPREFIX,FASTECP,SKIPPATH
  C208           
  0000 =         FLAG    DEFL    0
  C208           
  C208                   IRP     TEMP,<NO,PWCHECK,PWNOECHO,WDU,WPASS,WPREFIX,FASTECP,SKIPPATH>
  C208           
  C208                    IF     NOT NUL TEMP
  C208           FLAG    DEFL    FLAG SHL 1
  C208                    IF     TEMP
  C208           FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   28
                                                            
                                                            

  C208           
  C208                    ENDM
  C208           
  C208                    IF     NOT NUL NO
  0000 =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     NO
  C208           FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL PWCHECK
  0000 =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     PWCHECK
  0001 =         FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL PWNOECHO
  0002 =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     PWNOECHO
  0003 =         FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL WDU
  0006 =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     WDU
  C208           FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL WPASS
  000C =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     WPASS
  000D =         FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL WPREFIX
  001A =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     WPREFIX
  C208           FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL FASTECP
  0034 =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     FASTECP
  0035 =         FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page   29
                                                            
                                                            

  C208                    ENDIF
  C208           
  C208           
  C208                    IF     NOT NUL SKIPPATH
  006A =         FLAG    DEFL    FLAG SHL 1
  C208                    IF     SKIPPATH
  006B =         FLAG    DEFL    FLAG OR 1
  C208                    ENDIF
  C208                    ENDIF
  C208           
  C208                    ENDM
  C208           
  C208 6B                DEFB    LOW FLAG
  C209           
  C209                    ENDM
  C209           
  FFFF =         ATTDIR  DEFL    [ COMATT EQ 80H ] OR [ COMATT EQ 01H ] OR [ NOT ATTCHK ]
  FFFF =         ATTSYS  DEFL    [ COMATT EQ 00H ] OR [ COMATT EQ 01H ] OR [ NOT ATTCHK ]
  FFFF =         SUBQUIET DEFL   [ SUBNOISE EQ 1 ]
  0000 =         SUBECHO DEFL    [ SUBNOISE GT 1 ]
  C209           
  C209             OPTFLAG SHELLIF,ATTSYS,ATTDIR,ATTCHK,SUBECHO,SUBQUIET,SUBCLUE,SUBON
  C209           
  0000 =         FLAG    DEFL    0
  C209           
  C209                   IRP     TEMP,<SHELLIF,ATTSYS,ATTDIR,ATTCHK,SUBECHO,SUBQUIET,SUBCLUE,SUBON>
  C209           
  C209                    IF     NOT NUL TEMP
  C209           FLAG    DEFL    FLAG SHL 1
  C209                    IF     TEMP
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209                    ENDM
  C209           
  C209                    IF     NOT NUL SHELLIF
  0000 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     SHELLIF
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL ATTSYS
  0000 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     ATTSYS
  0001 =         FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL ATTDIR
  0002 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     ATTDIR
  0003 =         FLAG    DEFL    FLAG OR 1
ZAS Relocating Macro Assembler (v3.05                             page   30
                                                            
                                                            

  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL ATTCHK
  0006 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     ATTCHK
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL SUBECHO
  000C =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     SUBECHO
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL SUBQUIET
  0018 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     SUBQUIET
  0019 =         FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL SUBCLUE
  0032 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     SUBCLUE
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209           
  C209                    IF     NOT NUL SUBON
  0064 =         FLAG    DEFL    FLAG SHL 1
  C209                    IF     SUBON
  C209           FLAG    DEFL    FLAG OR 1
  C209                    ENDIF
  C209                    ENDIF
  C209           
  C209                    ENDM
  C209           
  C209 64                DEFB    LOW FLAG
  C20A           
  C20A                    ENDM
  C20A           
  C20A           ; Byte with information about the alternate colon option.  If the byte is
  C20A           ; zero, the option is not supported.  Otherwise the byte contains the
  C20A           ; prefix character that serves as an alias for a colon prefix.  Offset = 10.
  C20A           
  C20A                    IF     ALTCOLON
  C20A 2E                DEFB    ALTCHAR
  C20B                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   31
                                                            
                                                            

  C20B                   DEFB    0
  C20B                    ENDIF  ;altcolon
  C20B           
  C20B           ; Byte with information about the FASTECP implementation (option bit above
  C20B           ; indicates whether the feature is enabled at all).  If no character appears
  C20B           ; here (zero byte), then only a leading space can be used.  Otherwise, the
  C20B           ; first seven bits contain the character, and the high bit, if set, indicates
  C20B           ; that ONLY this character will be recognized and not a space.  Offset = 11.
  C20B           
  C20B                    IF     FASTECP AND ALTSPACE
  C20B                    IF     ALTONLY
  C20B                   DEFB    ECPCHAR + 80H
  C20B                    ELSE   ;not altonly
  C20B 2F                DEFB    ECPCHAR
  C20C                    ENDIF  ;altonly
  C20C                    ELSE   ;no alternate character
  C20C                   DEFB    0
  C20C                    ENDIF  ;fastecp and altspace
  C20C           
  C20C 00000000          DEFB    0,0,0,0                 ; Space reserved for expansion
  C210           
  C210           ;-----------------------------------------------------------------------------
  C210           
  C210           ; Entry points to file name parsing code.
  C210           
  C210           ; Entry point REPARSE.  A call to this point can be used to parse a command
  C210           ; line tail into the default file control blocks at 5CH and 6CH.  Each time
  C210           ; the parser is called it leaves the starting address of the second token in
  C210           ; the PARESPTR address below so that successive calls to the routine reparse
  C210           ; the command tail one token later.  A program can load its own pointer into
  C210           ; PARSEPTR as well.  Offset = 16 (10h).
  C210           
  C210           REPARSE:
  C211 =         PARSEPTR EQU    $+1             ; Pointer for in-the-code modification
  C210 210000            LD      HL,0
  C213 C320C4            JP      PARSETAIL
  C216           
  C216           ; Entry point SCAN.  A call to this point can be used to parse a single token
  C216           ; pointed to by HL into the FCB pointed to by DE.  Offset 22 (16h).
  C216           
  C216           SCAN:
  C216 C33BC4            JP      SCANNER
  C219           
  C219           ;-----------------------------------------------------------------------------
  C219           
  C219           ; BUFFERS
  C219           ;
  C219           ; In this area various data items are kept.  First comes the list of commands
  C219           ; supported by ZCPR33; then comes the name of the extended command processor
  C219           ; (ECP).  By putting these items here, an 'H' command in the RCP or a utility
  C219           ; like SHOW.COM can find this information and report it to the user.
  C219           
  C219           
  C219           ; ----------   RESIDENT COMMAND TABLE
  C219           
  C219           ; The command table entry is structured as follows:  First there is a byte
ZAS Relocating Macro Assembler (v3.05                             page   32
                                                            
                                                            

  C219           ; which indicates the number of characters in each command.  Then there is a
  C219           ; series of entries comprising the name of a command followed by the address
  C219           ; of the entry point to the code for carrying out that command.  Finally,
  C219           ; there is a null byte (00h) to mark the end of the table.  Offset = 25 (19h).
  C219           
  C219           
  C219           CMDTBL:
  C219 04                DEFB    CMDSIZE         ; Length of command names
  C21A                   CTABLE                  ; Define table via macro in Z33HDR.LIB
  C21A                   COMMAND         DIR,    DIRON,  WDIR,   DIR
  C21A           
  C21A                    IF     DIRON
  C21A           
  C21A           WHLMASK DEFL    WDIR
  C21A           COUNT   DEFL    CMDSIZE
  C21A           
  C21A                   IRPC    CHAR,DIR
  C21A           
  C21A           COUNT   DEFL    COUNT - 1
  C21A           
  C21A                    IF     [ COUNT LT CMDSIZE ]
  C21A           
  C21A           
  C21A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C21A                    ELSE
  C21A                   DEFB    [ '&CHAR' AND 5FH ]
  C21A                    ENDIF
  C21A           
  C21A                    ELSE
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    '&CHAR' + 80H
  C21A                    ELSE
  C21A                   DEFB    '&CHAR'
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A           WHLMASK DEFL    FALSE
  C21A           
  C21A                   ENDM    ;IRPC
  C21A           
  C21A           
  C21A                    IF     [ COUNT GT CMDSIZE ]
  C21A                   *** COMMAND NAME "DIR" IS TOO LONG / TRUNCATED ***
  C21A                    ELSE
  C21A                   REPT    COUNT
  C21A                   DEFB    ' '
  C21A                   ENDM
  C21A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C21A           
ZAS Relocating Macro Assembler (v3.05                             page   33
                                                            
                                                            

  C21A                   DW      DIR
  C21A           
  C21A                    ENDIF  ;ENABLE
  C21A           
  C21A                   ENDM    ;COMMAND
  C21A                   COMMAND         ERA,    ERAON,  WERA,   ERA
  C21A           
  C21A                    IF     ERAON
  C21A           
  C21A           WHLMASK DEFL    WERA
  C21A           COUNT   DEFL    CMDSIZE
  C21A           
  C21A                   IRPC    CHAR,ERA
  C21A           
  C21A           COUNT   DEFL    COUNT - 1
  C21A           
  C21A                    IF     [ COUNT LT CMDSIZE ]
  C21A           
  C21A           
  C21A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C21A                    ELSE
  C21A                   DEFB    [ '&CHAR' AND 5FH ]
  C21A                    ENDIF
  C21A           
  C21A                    ELSE
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    '&CHAR' + 80H
  C21A                    ELSE
  C21A                   DEFB    '&CHAR'
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A           WHLMASK DEFL    FALSE
  C21A           
  C21A                   ENDM    ;IRPC
  C21A           
  C21A           
  C21A                    IF     [ COUNT GT CMDSIZE ]
  C21A                   *** COMMAND NAME "ERA" IS TOO LONG / TRUNCATED ***
  C21A                    ELSE
  C21A                   REPT    COUNT
  C21A                   DEFB    ' '
  C21A                   ENDM
  C21A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C21A           
  C21A                   DW      ERA
  C21A           
  C21A                    ENDIF  ;ENABLE
  C21A           
ZAS Relocating Macro Assembler (v3.05                             page   34
                                                            
                                                            

  C21A                   ENDM    ;COMMAND
  C21A                   COMMAND         GET,    GETON,  WGET,   GET
  C21A           
  C21A                    IF     GETON
  C21A           
  0000 =         WHLMASK DEFL    WGET
  0004 =         COUNT   DEFL    CMDSIZE
  C21A           
  C21A                   IRPC    CHAR,GET
  C21A           
  C21A           COUNT   DEFL    COUNT - 1
  C21A           
  C21A                    IF     [ COUNT LT CMDSIZE ]
  C21A           
  C21A           
  C21A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C21A                    ELSE
  C21A                   DEFB    [ '&CHAR' AND 5FH ]
  C21A                    ENDIF
  C21A           
  C21A                    ELSE
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    '&CHAR' + 80H
  C21A                    ELSE
  C21A                   DEFB    '&CHAR'
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A                    ENDIF
  C21A           
  C21A           WHLMASK DEFL    FALSE
  C21A           
  C21A                   ENDM    ;IRPC
  C21A           
  0003 =         COUNT   DEFL    COUNT - 1
  C21A           
  C21A                    IF     [ COUNT LT CMDSIZE ]
  C21A           
  C21A           
  C21A                    IF     [ 'G' GE 'a' ] AND [ 'G' LE 'z' ]
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    [ 'G' AND 5FH ] + 80H
  C21A                    ELSE
  C21A                   DEFB    [ 'G' AND 5FH ]
  C21A                    ENDIF
  C21A           
  C21A                    ELSE
  C21A           
  C21A                    IF     WHLMASK
  C21A                   DEFB    'G' + 80H
ZAS Relocating Macro Assembler (v3.05                             page   35
                                                            
                                                            

  C21A                    ELSE
  C21A 47                DEFB    'G'
  C21B                    ENDIF
  C21B           
  C21B                    ENDIF
  C21B           
  C21B                    ENDIF
  C21B           
  0000 =         WHLMASK DEFL    FALSE
  C21B           
  C21B           
  0002 =         COUNT   DEFL    COUNT - 1
  C21B           
  C21B                    IF     [ COUNT LT CMDSIZE ]
  C21B           
  C21B           
  C21B                    IF     [ 'E' GE 'a' ] AND [ 'E' LE 'z' ]
  C21B           
  C21B                    IF     WHLMASK
  C21B                   DEFB    [ 'E' AND 5FH ] + 80H
  C21B                    ELSE
  C21B                   DEFB    [ 'E' AND 5FH ]
  C21B                    ENDIF
  C21B           
  C21B                    ELSE
  C21B           
  C21B                    IF     WHLMASK
  C21B                   DEFB    'E' + 80H
  C21B                    ELSE
  C21B 45                DEFB    'E'
  C21C                    ENDIF
  C21C           
  C21C                    ENDIF
  C21C           
  C21C                    ENDIF
  C21C           
  0000 =         WHLMASK DEFL    FALSE
  C21C           
  C21C           
  0001 =         COUNT   DEFL    COUNT - 1
  C21C           
  C21C                    IF     [ COUNT LT CMDSIZE ]
  C21C           
  C21C           
  C21C                    IF     [ 'T' GE 'a' ] AND [ 'T' LE 'z' ]
  C21C           
  C21C                    IF     WHLMASK
  C21C                   DEFB    [ 'T' AND 5FH ] + 80H
  C21C                    ELSE
  C21C                   DEFB    [ 'T' AND 5FH ]
  C21C                    ENDIF
  C21C           
  C21C                    ELSE
  C21C           
  C21C                    IF     WHLMASK
  C21C                   DEFB    'T' + 80H
ZAS Relocating Macro Assembler (v3.05                             page   36
                                                            
                                                            

  C21C                    ELSE
  C21C 54                DEFB    'T'
  C21D                    ENDIF
  C21D           
  C21D                    ENDIF
  C21D           
  C21D                    ENDIF
  C21D           
  0000 =         WHLMASK DEFL    FALSE
  C21D           
  C21D                   ENDM    ;IRPC
  C21D           
  C21D           
  C21D                    IF     [ COUNT GT CMDSIZE ]
  C21D                   *** COMMAND NAME "GET" IS TOO LONG / TRUNCATED ***
  C21D                    ELSE
  C21D                   REPT    COUNT
  C21D                   DEFB    ' '
  C21D                   ENDM
  C21D 20                DEFB    ' '
  C21E                   ENDM
  C21E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C21E           
  C21E F4C7              DW      GET
  C220           
  C220                    ENDIF  ;ENABLE
  C220           
  C220                   ENDM    ;COMMAND
  C220                   COMMAND         GO,     GOON,   WGO,    GO
  C220           
  C220                    IF     GOON
  C220           
  0000 =         WHLMASK DEFL    WGO
  0004 =         COUNT   DEFL    CMDSIZE
  C220           
  C220                   IRPC    CHAR,GO
  C220           
  C220           COUNT   DEFL    COUNT - 1
  C220           
  C220                    IF     [ COUNT LT CMDSIZE ]
  C220           
  C220           
  C220                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C220           
  C220                    IF     WHLMASK
  C220                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C220                    ELSE
  C220                   DEFB    [ '&CHAR' AND 5FH ]
  C220                    ENDIF
  C220           
  C220                    ELSE
  C220           
  C220                    IF     WHLMASK
  C220                   DEFB    '&CHAR' + 80H
  C220                    ELSE
  C220                   DEFB    '&CHAR'
ZAS Relocating Macro Assembler (v3.05                             page   37
                                                            
                                                            

  C220                    ENDIF
  C220           
  C220                    ENDIF
  C220           
  C220                    ENDIF
  C220           
  C220           WHLMASK DEFL    FALSE
  C220           
  C220                   ENDM    ;IRPC
  C220           
  0003 =         COUNT   DEFL    COUNT - 1
  C220           
  C220                    IF     [ COUNT LT CMDSIZE ]
  C220           
  C220           
  C220                    IF     [ 'G' GE 'a' ] AND [ 'G' LE 'z' ]
  C220           
  C220                    IF     WHLMASK
  C220                   DEFB    [ 'G' AND 5FH ] + 80H
  C220                    ELSE
  C220                   DEFB    [ 'G' AND 5FH ]
  C220                    ENDIF
  C220           
  C220                    ELSE
  C220           
  C220                    IF     WHLMASK
  C220                   DEFB    'G' + 80H
  C220                    ELSE
  C220 47                DEFB    'G'
  C221                    ENDIF
  C221           
  C221                    ENDIF
  C221           
  C221                    ENDIF
  C221           
  0000 =         WHLMASK DEFL    FALSE
  C221           
  C221           
  0002 =         COUNT   DEFL    COUNT - 1
  C221           
  C221                    IF     [ COUNT LT CMDSIZE ]
  C221           
  C221           
  C221                    IF     [ 'O' GE 'a' ] AND [ 'O' LE 'z' ]
  C221           
  C221                    IF     WHLMASK
  C221                   DEFB    [ 'O' AND 5FH ] + 80H
  C221                    ELSE
  C221                   DEFB    [ 'O' AND 5FH ]
  C221                    ENDIF
  C221           
  C221                    ELSE
  C221           
  C221                    IF     WHLMASK
  C221                   DEFB    'O' + 80H
  C221                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   38
                                                            
                                                            

  C221 4F                DEFB    'O'
  C222                    ENDIF
  C222           
  C222                    ENDIF
  C222           
  C222                    ENDIF
  C222           
  0000 =         WHLMASK DEFL    FALSE
  C222           
  C222                   ENDM    ;IRPC
  C222           
  C222           
  C222                    IF     [ COUNT GT CMDSIZE ]
  C222                   *** COMMAND NAME "GO" IS TOO LONG / TRUNCATED ***
  C222                    ELSE
  C222                   REPT    COUNT
  C222                   DEFB    ' '
  C222                   ENDM
  C222 20                DEFB    ' '
  C223 20                DEFB    ' '
  C224                   ENDM
  C224                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C224           
  C224 EAC7              DW      GO
  C226           
  C226                    ENDIF  ;ENABLE
  C226           
  C226                   ENDM    ;COMMAND
  C226                   COMMAND         JUMP,   JUMPON, WJUMP,  JUMP
  C226           
  C226                    IF     JUMPON
  C226           
  0000 =         WHLMASK DEFL    WJUMP
  0004 =         COUNT   DEFL    CMDSIZE
  C226           
  C226                   IRPC    CHAR,JUMP
  C226           
  C226           COUNT   DEFL    COUNT - 1
  C226           
  C226                    IF     [ COUNT LT CMDSIZE ]
  C226           
  C226           
  C226                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C226           
  C226                    IF     WHLMASK
  C226                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C226                    ELSE
  C226                   DEFB    [ '&CHAR' AND 5FH ]
  C226                    ENDIF
  C226           
  C226                    ELSE
  C226           
  C226                    IF     WHLMASK
  C226                   DEFB    '&CHAR' + 80H
  C226                    ELSE
  C226                   DEFB    '&CHAR'
ZAS Relocating Macro Assembler (v3.05                             page   39
                                                            
                                                            

  C226                    ENDIF
  C226           
  C226                    ENDIF
  C226           
  C226                    ENDIF
  C226           
  C226           WHLMASK DEFL    FALSE
  C226           
  C226                   ENDM    ;IRPC
  C226           
  0003 =         COUNT   DEFL    COUNT - 1
  C226           
  C226                    IF     [ COUNT LT CMDSIZE ]
  C226           
  C226           
  C226                    IF     [ 'J' GE 'a' ] AND [ 'J' LE 'z' ]
  C226           
  C226                    IF     WHLMASK
  C226                   DEFB    [ 'J' AND 5FH ] + 80H
  C226                    ELSE
  C226                   DEFB    [ 'J' AND 5FH ]
  C226                    ENDIF
  C226           
  C226                    ELSE
  C226           
  C226                    IF     WHLMASK
  C226                   DEFB    'J' + 80H
  C226                    ELSE
  C226 4A                DEFB    'J'
  C227                    ENDIF
  C227           
  C227                    ENDIF
  C227           
  C227                    ENDIF
  C227           
  0000 =         WHLMASK DEFL    FALSE
  C227           
  C227           
  0002 =         COUNT   DEFL    COUNT - 1
  C227           
  C227                    IF     [ COUNT LT CMDSIZE ]
  C227           
  C227           
  C227                    IF     [ 'U' GE 'a' ] AND [ 'U' LE 'z' ]
  C227           
  C227                    IF     WHLMASK
  C227                   DEFB    [ 'U' AND 5FH ] + 80H
  C227                    ELSE
  C227                   DEFB    [ 'U' AND 5FH ]
  C227                    ENDIF
  C227           
  C227                    ELSE
  C227           
  C227                    IF     WHLMASK
  C227                   DEFB    'U' + 80H
  C227                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   40
                                                            
                                                            

  C227 55                DEFB    'U'
  C228                    ENDIF
  C228           
  C228                    ENDIF
  C228           
  C228                    ENDIF
  C228           
  0000 =         WHLMASK DEFL    FALSE
  C228           
  C228           
  0001 =         COUNT   DEFL    COUNT - 1
  C228           
  C228                    IF     [ COUNT LT CMDSIZE ]
  C228           
  C228           
  C228                    IF     [ 'M' GE 'a' ] AND [ 'M' LE 'z' ]
  C228           
  C228                    IF     WHLMASK
  C228                   DEFB    [ 'M' AND 5FH ] + 80H
  C228                    ELSE
  C228                   DEFB    [ 'M' AND 5FH ]
  C228                    ENDIF
  C228           
  C228                    ELSE
  C228           
  C228                    IF     WHLMASK
  C228                   DEFB    'M' + 80H
  C228                    ELSE
  C228 4D                DEFB    'M'
  C229                    ENDIF
  C229           
  C229                    ENDIF
  C229           
  C229                    ENDIF
  C229           
  0000 =         WHLMASK DEFL    FALSE
  C229           
  C229           
  0000 =         COUNT   DEFL    COUNT - 1
  C229           
  C229                    IF     [ COUNT LT CMDSIZE ]
  C229           
  C229           
  C229                    IF     [ 'P' GE 'a' ] AND [ 'P' LE 'z' ]
  C229           
  C229                    IF     WHLMASK
  C229                   DEFB    [ 'P' AND 5FH ] + 80H
  C229                    ELSE
  C229                   DEFB    [ 'P' AND 5FH ]
  C229                    ENDIF
  C229           
  C229                    ELSE
  C229           
  C229                    IF     WHLMASK
  C229                   DEFB    'P' + 80H
  C229                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   41
                                                            
                                                            

  C229 50                DEFB    'P'
  C22A                    ENDIF
  C22A           
  C22A                    ENDIF
  C22A           
  C22A                    ENDIF
  C22A           
  0000 =         WHLMASK DEFL    FALSE
  C22A           
  C22A                   ENDM    ;IRPC
  C22A           
  C22A           
  C22A                    IF     [ COUNT GT CMDSIZE ]
  C22A                   *** COMMAND NAME "JUMP" IS TOO LONG / TRUNCATED ***
  C22A                    ELSE
  C22A                   REPT    COUNT
  C22A                   DEFB    ' '
  C22A                   ENDM
  C22A                   ENDM
  C22A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C22A           
  C22A DEC7              DW      JUMP
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   COMMAND         LIST,   LTON,   WLT,    LIST
  C22C           
  C22C                    IF     LTON
  C22C           
  C22C           WHLMASK DEFL    WLT
  C22C           COUNT   DEFL    CMDSIZE
  C22C           
  C22C                   IRPC    CHAR,LIST
  C22C           
  C22C           COUNT   DEFL    COUNT - 1
  C22C           
  C22C                    IF     [ COUNT LT CMDSIZE ]
  C22C           
  C22C           
  C22C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C22C                    ELSE
  C22C                   DEFB    [ '&CHAR' AND 5FH ]
  C22C                    ENDIF
  C22C           
  C22C                    ELSE
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    '&CHAR' + 80H
  C22C                    ELSE
  C22C                   DEFB    '&CHAR'
  C22C                    ENDIF
  C22C           
ZAS Relocating Macro Assembler (v3.05                             page   42
                                                            
                                                            

  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C           WHLMASK DEFL    FALSE
  C22C           
  C22C                   ENDM    ;IRPC
  C22C           
  C22C           
  C22C                    IF     [ COUNT GT CMDSIZE ]
  C22C                   *** COMMAND NAME "LIST" IS TOO LONG / TRUNCATED ***
  C22C                    ELSE
  C22C                   REPT    COUNT
  C22C                   DEFB    ' '
  C22C                   ENDM
  C22C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C22C           
  C22C                   DW      LIST
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   COMMAND         NOTE,   NOTEON, FALSE,  NOTE
  C22C           
  C22C                    IF     NOTEON
  C22C           
  C22C           WHLMASK DEFL    FALSE
  C22C           COUNT   DEFL    CMDSIZE
  C22C           
  C22C                   IRPC    CHAR,NOTE
  C22C           
  C22C           COUNT   DEFL    COUNT - 1
  C22C           
  C22C                    IF     [ COUNT LT CMDSIZE ]
  C22C           
  C22C           
  C22C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C22C                    ELSE
  C22C                   DEFB    [ '&CHAR' AND 5FH ]
  C22C                    ENDIF
  C22C           
  C22C                    ELSE
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    '&CHAR' + 80H
  C22C                    ELSE
  C22C                   DEFB    '&CHAR'
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
ZAS Relocating Macro Assembler (v3.05                             page   43
                                                            
                                                            

  C22C           WHLMASK DEFL    FALSE
  C22C           
  C22C                   ENDM    ;IRPC
  C22C           
  C22C           
  C22C                    IF     [ COUNT GT CMDSIZE ]
  C22C                   *** COMMAND NAME "NOTE" IS TOO LONG / TRUNCATED ***
  C22C                    ELSE
  C22C                   REPT    COUNT
  C22C                   DEFB    ' '
  C22C                   ENDM
  C22C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C22C           
  C22C                   DW      NOTE
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   COMMAND         REN,    RENON,  WREN,   REN
  C22C           
  C22C                    IF     RENON
  C22C           
  C22C           WHLMASK DEFL    WREN
  C22C           COUNT   DEFL    CMDSIZE
  C22C           
  C22C                   IRPC    CHAR,REN
  C22C           
  C22C           COUNT   DEFL    COUNT - 1
  C22C           
  C22C                    IF     [ COUNT LT CMDSIZE ]
  C22C           
  C22C           
  C22C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C22C                    ELSE
  C22C                   DEFB    [ '&CHAR' AND 5FH ]
  C22C                    ENDIF
  C22C           
  C22C                    ELSE
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    '&CHAR' + 80H
  C22C                    ELSE
  C22C                   DEFB    '&CHAR'
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C           WHLMASK DEFL    FALSE
  C22C           
  C22C                   ENDM    ;IRPC
  C22C           
ZAS Relocating Macro Assembler (v3.05                             page   44
                                                            
                                                            

  C22C           
  C22C                    IF     [ COUNT GT CMDSIZE ]
  C22C                   *** COMMAND NAME "REN" IS TOO LONG / TRUNCATED ***
  C22C                    ELSE
  C22C                   REPT    COUNT
  C22C                   DEFB    ' '
  C22C                   ENDM
  C22C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C22C           
  C22C                   DW      REN
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   COMMAND         SAVE,   SAVEON, WSAVE,  SAVE
  C22C           
  C22C                    IF     SAVEON
  C22C           
  C22C           WHLMASK DEFL    WSAVE
  C22C           COUNT   DEFL    CMDSIZE
  C22C           
  C22C                   IRPC    CHAR,SAVE
  C22C           
  C22C           COUNT   DEFL    COUNT - 1
  C22C           
  C22C                    IF     [ COUNT LT CMDSIZE ]
  C22C           
  C22C           
  C22C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C22C                    ELSE
  C22C                   DEFB    [ '&CHAR' AND 5FH ]
  C22C                    ENDIF
  C22C           
  C22C                    ELSE
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    '&CHAR' + 80H
  C22C                    ELSE
  C22C                   DEFB    '&CHAR'
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C           WHLMASK DEFL    FALSE
  C22C           
  C22C                   ENDM    ;IRPC
  C22C           
  C22C           
  C22C                    IF     [ COUNT GT CMDSIZE ]
  C22C                   *** COMMAND NAME "SAVE" IS TOO LONG / TRUNCATED ***
  C22C                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   45
                                                            
                                                            

  C22C                   REPT    COUNT
  C22C                   DEFB    ' '
  C22C                   ENDM
  C22C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  C22C           
  C22C                   DW      SAVE
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   COMMAND         TYPE,   LTON,   WLT,    TYPE
  C22C           
  C22C                    IF     LTON
  C22C           
  C22C           WHLMASK DEFL    WLT
  C22C           COUNT   DEFL    CMDSIZE
  C22C           
  C22C                   IRPC    CHAR,TYPE
  C22C           
  C22C           COUNT   DEFL    COUNT - 1
  C22C           
  C22C                    IF     [ COUNT LT CMDSIZE ]
  C22C           
  C22C           
  C22C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  C22C                    ELSE
  C22C                   DEFB    [ '&CHAR' AND 5FH ]
  C22C                    ENDIF
  C22C           
  C22C                    ELSE
  C22C           
  C22C                    IF     WHLMASK
  C22C                   DEFB    '&CHAR' + 80H
  C22C                    ELSE
  C22C                   DEFB    '&CHAR'
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C                    ENDIF
  C22C           
  C22C           WHLMASK DEFL    FALSE
  C22C           
  C22C                   ENDM    ;IRPC
  C22C           
  C22C           
  C22C                    IF     [ COUNT GT CMDSIZE ]
  C22C                   *** COMMAND NAME "TYPE" IS TOO LONG / TRUNCATED ***
  C22C                    ELSE
  C22C                   REPT    COUNT
  C22C                   DEFB    ' '
  C22C                   ENDM
  C22C                    ENDIF  ;[ COUNT GT CMDSIZE ]
ZAS Relocating Macro Assembler (v3.05                             page   46
                                                            
                                                            

  C22C           
  C22C                   DW      TYPE
  C22C           
  C22C                    ENDIF  ;ENABLE
  C22C           
  C22C                   ENDM    ;COMMAND
  C22C                   ENDM
  C22C 00                DEFB    0               ; End of table
  C22D           
  C22D           ; ----------  NAME FOR EXTENDED COMMAND PROCESSOR
  C22D           
  C22D           ; The name of the extended command processor is placed here after the command
  C22D           ; table so that utilities like SHOW or an RCP 'H' command can find it.
  C22D           
  C22D           ECPFCB:
  C22D                   ECPNAME                 ; From Z33HDR.LIB
  C22D 00                DB      0               ; Drive (do not change this from 0)
  C22E 434D445255        DB      'CMDRUN  '      ; Name of ECP program (exactly 8 characters)
  C236                   ;       '--------'      ; (Eight-character space marker)
  C236                   ENDM
  C236           
  C236           
  C236           ; ----------   FILE TYPE FOR TRANSIENT COMMANDS (usually COM)
  C236           
  C236           ; This file type also applies to the extended command processor name.
  C236           
  C236           COMMSG:
  C236                   COMTYP                  ; From Z33HDR.LIB
  C236 434F4D            DB      'COM'           ; be changed only in the most unusual
  C239                   ENDM                    ; situtations).  This file type will also apply
  C239           
  C239           
  C239           
  C239           ; ----------   SUBMIT FILE CONTROL BLOCK
  C239           
  C239                    IF     SUBON           ; If submit facility enabled ...
  C239           
  C239           SUBFCB:
  C239                   DEFB    SUBDRV-'A'+1    ; Explicit drive for submit file
  C239                   DEFB    '$$$     '      ; File name
  C239                   SUBTYP                  ; From Z33HDR.LIB
  C239                   DEFB    0               ; Extent number
  C239                   DEFB    0               ; S1 (user number 0)
  C239           SUBFS2:
  C239                   DEFS    1               ; S2
  C239           SUBFRC:
  C239                   DEFS    1               ; Record count
  C239                   DEFS    16              ; Disk group map
  C239           SUBFCR:
  C239                   DEFS    1               ; Current record number
  C239           
  C239                    ENDIF  ; subon
  C239           
  C239           ; End ZCPR33-1.Z80
  C239           
ZAS Relocating Macro Assembler (v3.05                             page   47
                                                            
                                                            

  C239                   PAGE
  C239           
  C239           ; ZCPR33-2.Z80
  C239           
  C239           ;=============================================================================
  C239           ;
  C239           ;       C O M M A N D    L I N E    P R O C E S S I N G    C O D E
  C239           ;
  C239           ;=============================================================================
  C239           
  C239           ; MAIN ENTRY POINT TO CPR
  C239           
  C239           ; This is the main entry point to the command processor.  On entry the C
  C239           ; register must contain the value of the user/drive to be used as the current
  C239           ; directory.
  C239           
  C239           ZCPR:
  C239 3100F0            LD      SP,STACK        ; Reset stack
  C23C           
  C23C                    IF     PWNOECHO
  C23C 3EC3              LD      A,0C3H          ; Reenable BIOS conout routine
  C23E 320CD8            LD      (BIOS+0CH),A    ; ..after a warmboot
  C241                    ENDIF  ;pwnoecho
  C241           
  C241 060F              LD      B,0FH           ; Keep nibble mask in B
  C243           
  C243           ; If the HIGHUSER option is enabled, we compare the user/drive in the login
  C243           ; byte in C to the values stored in the message buffer.  If, ignoring bit 4
  C243           ; of the user number, they match, then we remain in the current area, which
  C243           ; may be a user area above 15.
  C243           
  C243                    IF     HIGHUSER
  C243           
  C243                   LD      A,C             ; Copy user/drive byte to A
  C243                   AND     B               ; Isolate drive
  C243                   LD      D,A             ; ..and move to D
  C243                   LD      A,C             ; Get full byte back
  C243                   SWAP                    ; Swap nibbles
  C243                   AND     B               ; Isolate user number
  C243                   LD      E,A             ; ..and move to E
  C243                   LD      HL,(CURUSR)     ; Get old curdr/curusr into HL
  C243                   SBC     HL,DE           ; Subtract new values from old (carry is clear)
  C243                   EX      DE,HL           ; Switch new values into HL, diff into DE
  C243                   LD      A,D             ; Combine two parts of difference
  C243                   OR      E
  C243                   AND     B               ; Ignore bit for high user numbers
  C243                   JR      Z,ZCPR1         ; Skip update if no change in DU
  C243                   LD      (CURUSR),HL     ; Update values of current drive and user
  C243           ZCPR1:
  C243           
  C243                    ELSE   ;not highuser
  C243           
  C243 79                LD      A,C             ; Copy user/drive byte to A
  C244 A0                AND     B               ; Isolate drive
  C245 67                LD      H,A             ; ..and move to H
  C246 79                LD      A,C             ; Get full byte back
ZAS Relocating Macro Assembler (v3.05                             page   48
                                                            
                                                            

  C247                   SWAP                    ; Swap nibbles
  C247 0F                RRCA                    ; Exchange nibbles
  C248 0F                RRCA
  C249 0F                RRCA
  C24A 0F                RRCA
  C24B                    ENDM
  C24B A0                AND     B               ; Isolate user number
  C24C 6F                LD      L,A             ; ..and move to L
  C24D 22AEED            LD      (CURUSR),HL     ; ..and save them
  C250           
  C250                    ENDIF  ;highuser
  C250           
  C250           ; This block of code is executed when submit processing is enabled.  We log
  C250           ; into user area 0, where the submit file is kept, and we search the
  C250           ; designated drive for the file.  The result is kept in SUBFLAG.  This code
  C250           ; only has to be executed on reentry to the command processor at the main
  C250           ; entry point.  Commands that do not reboot but simply return to the CPR will
  C250           ; execute without the disk reset and file search required here.  Ron Fowler
  C250           ; pointed out a shortcut based on the fact that after a disk reset, the A
  C250           ; regiser contains a value of 0 if there is no file on drive A with a '$' in
  C250           ; the file name and 0FFH if there is such a file.  Thus if A = 0, there can
  C250           ; be no '$$$.SUB' file on drive A.  This trick is, unfortunately, not reliable
  C250           ; under some versions of ZRDOS.  Therefore, an option has been included to
  C250           ; use or not use this shortcut.
  C250           
  C250                    IF     SUBON           ; If submit facility enabled ..
  C250           
  C250                   CALL    DEFLTDMA        ; Set DMA address to 80H
  C250                   LD      A,0             ; Log into user area 0
  C250                   CALL    SETUSER
  C250                   LD      C,0DH           ; Reset disk system (returns 0FFH if a $$$.SUB
  C250                   CALL    BDOSSAVE        ; ..file might exist in user 0)
  C250                   LD      DE,SUBFCB       ; Point to submit file FCB with explicit drive
  C250           
  C250                    IF     SUBCLUE
  C250                   CALL    NZ,SRCHFST      ; Search only if flag says it could exist
  C250                    ELSE   ;not subclue
  C250                   CALL    SRCHFST         ; Search for the file unconditionally
  C250                    ENDIF  ;subclue
  C250           
  C250                   LD      (SUBFLAG),A     ; Set flag for result (0 = no $$$.SUB)
  C250           
  C250                    ELSE   ;not subon
  C250           
  C250 0E0D              LD      C,0DH           ; Reset disk system
  C252 CD10C6            CALL    BDOSSAVE
  C255           
  C255                    ENDIF  ; subon
  C255           
  C255 181D              JR      NEXTCMD         ; Go to entry point for processing next command
  C257           
  C257           
  C257           ;-----------------------------------------------------------------------------
  C257           
  C257           ; NEW COMMAND LINE ENTRY POINT
  C257           
ZAS Relocating Macro Assembler (v3.05                             page   49
                                                            
                                                            

  C257           ; This entry point is used when ZCPR33 finds the command line empty.  A call to
  C257           ; READBUF gets the next command line from the following possible sources in
  C257           ; this order:
  C257           ;       1) a running ZEX script
  C257           ;       2) the submit file $$$.SUB (if enabled)
  C257           ;       3) the shell stack
  C257           ;       4) the user
  C257           ; If the line comes from the shell stack, then the shell bit in the command
  C257           ; status flag is set.
  C257           
  C257           RESTART:
  C257 3100F0            LD      SP,STACK        ; Reset stack
  C25A AF                XOR     A
  C25B 3283ED            LD      (CMDSTATFL),A   ; Reset ZCPR3 command status flag
  C25E 3C                INC     A               ; Set ZEX message byte to 1 to
  C25F 3287ED            LD      (ZEXINPFL),A    ; ..indicate command prompt
  C262                    IF     SUBON
  C262                   LD      (XSUBFLAG),A    ; Ditto for XSUB flag
  C262                    ENDIF  ;subon
  C262 2104EF            LD      HL,CMDLIN       ; HL --> beginning of command line buffer
  C265 2200EF            LD      (NXTCHR),HL     ; Save as pointer to next character to process
  C268 3600              LD      (HL),0          ; Zero out command line (in case of warm boot)
  C26A E5                PUSH    HL              ; Save pointer to command line
  C26B CDE7C6            CALL    READBUF         ; Input command line (ZEX, submit, shell,
  C26E                                           ; ..or user)
  C26E E1                POP     HL              ; Get back pointer to command line
  C26F 7E                LD      A,(HL)          ; Check for comment line
  C270 FE3B              CP      COMMENT         ; Begins with comment character?
  C272 28E3              JR      Z,RESTART       ; If so, go back for another line
  C274                                           ; Otherwise, fall through
  C274           
  C274           ;-----------------------------------------------------------------------------
  C274           
  C274           ; COMMAND CONTINUATION PROCESSING ENTRY POINT
  C274           
  C274           ; This is the entry point for continuing the processing of an existing command
  C274           ; line.  The current drive and user values as known to the CPR are combined
  C274           ; and made into the user/drive byte that CP/M keeps at location 0004.  If the
  C274           ; HIGHUSER option is enabled, the user number for this byte is forced to be
  C274           ; in the range 0..15.  Next the command status flag is processed.  The error
  C274           ; and ECP bits in the actual flag are reset, and the original flag is checked
  C274           ; for an ECP error return (both ECP bit and error bit set).  In that case,
  C274           ; control is transferred to the error handler.
  C274           
  C274           NEXTCMD:
  C274 2AAEED            LD      HL,(CURUSR)     ; Get currently logged drive and user
  C277 7D                LD      A,L             ; Work on user number
  C278                    IF      HIGHUSER
  C278                   AND     0FH             ; Keep value modulo 16
  C278                    ENDIF  ;highuser
  C278                   SWAP                    ; Get user into high nibble
  C278 0F                RRCA                    ; Exchange nibbles
  C279 0F                RRCA
  C27A 0F                RRCA
  C27B 0F                RRCA
  C27C                    ENDM
ZAS Relocating Macro Assembler (v3.05                             page   50
                                                            
                                                            

  C27C B4                OR      H               ; ..and drive into low nibble
  C27D 320400            LD      (UDFLAG),A      ; Set user/disk flag in page 0
  C280           
  C280 3E02              LD      A,2             ; Turn ZEX input redirection off
  C282 3287ED            LD      (ZEXINPFL),A
  C285                    IF     SUBON
  C285                   LD      (XSUBFLAG),A    ; Turn off XSUB input redirection
  C285                    ENDIF  ;subon
  C285           
  C285 2183ED            LD      HL,CMDSTATFL    ; Point to the command status flag (CSF)
  C288 7E                LD      A,(HL)          ; Get a copy into register A
  C289 CB8E              RES     1,(HL)          ; Reset the actual error bit
  C28B CB96              RES     2,(HL)          ; Reset the actual ECP bit
  C28D E606              AND     110B            ; Select ECP and error bits in original flag
  C28F FE06              CP      110B            ; Test for an ECP error
  C291 CA8AC3            JP      Z,ERROR         ; Process ECP error with error handler
  C294           
  C294           NEXTCMD1:
  C294 3100F0            LD      SP,STACK        ; Reset stack
  C297 CD18C9            CALL    LOGCURRENT      ; Return to default directory
  C29A 2A00EF            LD      HL,(NXTCHR)     ; Point to first character of next command
  C29D E5                PUSH    HL              ; Save pointer to next character to process
  C29E           
  C29E           ; We have to capitalize the command line each time because an alias or other
  C29E           ; command line generator may have stuck some new text in.  The code is shorter
  C29E           ; if we simply capitalize the entire command rather than trying to capitalize
  C29E           ; only the one command we are about to execute.
  C29E           
  C29E           CAPBUF:                         ; Capitalize the command line
  C29E 7E                LD      A,(HL)          ; Get character
  C29F CDD8C5            CALL    UCASE           ; Convert to upper case
  C2A2 77                LD      (HL),A          ; Put it back
  C2A3 23                INC     HL              ; Point to next one
  C2A4 B7                OR      A               ; See if end of line (marked with null)
  C2A5 20F7              JR      NZ,CAPBUF       ; If not, loop back
  C2A7           
  C2A7 E1                POP     HL              ; Restore pointer to next character to process
  C2A8           
  C2A8           NEXTCMD3:
  C2A8           
  C2A8           ; ZCPR33 provides a convenience feature to make it easier to enter a leading
  C2A8           ; colon to force the current directory to be scanned and to make the CPR skip
  C2A8           ; resident commands.  If ALTCOLON is active, an alternate character can be
  C2A8           ; entered as the first character of a command.  The default (and recommended)
  C2A8           ; alternative character is the period (it could not have any other meaning
  C2A8           ; here).  If FASTECP (see below) is not enabled or if ALTONLY is enabled,
  C2A8           ; leading spaces on the command line are skipped before looking for the
  C2A8           ; alternate character for the colon
  C2A8           
  C2A8                    IF     [ NOT FASTECP ] OR [ FASTECP AND ALTONLY ]
  C2A8                   CALL    SKSP
  C2A8                    ENDIF  ;[ not fastecp ] or [ fastecp and altonly ]
  C2A8           
  C2A8                    IF     ALTCOLON        ; If allowing alias character for leading colon
  C2A8                                           ; Set B = ':' and C = alias character ('.')
  C2A8 012E3A            LD      BC,':' shl 8 + altchar
ZAS Relocating Macro Assembler (v3.05                             page   51
                                                            
                                                            

  C2AB 7E                LD      A,(HL)          ; Get first character in new command line
  C2AC B9                CP      C               ; If first character is ALTCHAR, treat as ':'
  C2AD 2001              JR      NZ,NEXTCMD3A    ; Branch if not '.'
  C2AF 70                LD      (HL),B          ; Else replace with colon
  C2B0           NEXTCMD3A:
  C2B0                    ENDIF  ;altcolon
  C2B0           
  C2B0           
  C2B0           ; ZCPR33 supports three new options that can speed up command processing.
  C2B0           ; FASTECP allows commands with a leading space to bypass the search for
  C2B0           ; resident commands or transient commands (COM files) along the path and go
  C2B0           ; directly to the extended command processor.  With SKIPPATH enabled, when
  C2B0           ; a command is prefixed by an explicit directory specification (but not a
  C2B0           ; lone colon), searching of the path and invocation of the ECP are disabled.
  C2B0           ; If the command is not found in the specified directory, the error handler
  C2B0           ; is invoked immediately.  Finally, if BADDUECP is enabled, when an attempt
  C2B0           ; is made to log into an invalid directory, the command is sent directly to
  C2B0           ; the ECP, which can provide special handling.  To implement these three
  C2B0           ; features, the first actual character of the command line is saved as a
  C2B0           ; flag in FIRSTCHAR.  My apologies for the complexity of these nested
  C2B0           ; conditionals.
  C2B0           
  C2B0                    IF     FASTECP OR SKIPPATH OR BADDUECP
  C2B0           
  C2B0                           ; With FASTECP we store the first actual
  C2B0                           ; ..character and then skip over spaces (unless ALTONLY is
  C2B0                           ; ..enabled, in which case we skipped spaces above)
  C2B0           
  C2B0                    IF     FASTECP
  C2B0           
  C2B0                    IF     ALTSPACE        ; If allowing alias character for leading space
  C2B0                                           ; Set B = ' ' and C = alias character ('/')
  C2B0 012F20            LD      BC,' ' shl 8 + ecpchar
  C2B3 7E                LD      A,(HL)          ; Get first character in new command line
  C2B4 B9                CP      C               ; If first character is ECPCHAR treat as ' '
  C2B5 2001              JR      NZ,NEXTCMD3B    ; Branch if not '/' (alternate character)
  C2B7 70                LD      (HL),B          ; Else replace with space
  C2B8           NEXTCMD3B:
  C2B8                    ENDIF  ;altspace
  C2B8           
  C2B8 7E                LD      A,(HL)          ; Get first character in command line
  C2B9 3288C8            LD      (FIRSTCHAR),A   ; Save it in flag
  C2BC CD51C6            CALL    SKSP            ; Then skip leading spaces
  C2BF                    ENDIF  ;fastecp
  C2BF           
  C2BF                           ; With SKIPPATH but not FASTECP we store the first
  C2BF                           ; ..character of the command (spaces were skipped above)
  C2BF           
  C2BF                    IF     [ NOT FASTECP ] AND SKIPPATH
  C2BF                   LD      (FIRSTCHAR),A   ; Store first nonspace character
  C2BF                    ENDIF  ;[ not fastecp ] and skippath
  C2BF           
  C2BF                           ; With only BADDUECP (and neither SKIPPATH nor FASTECP)
  C2BF                           ; ..we store a null in the FIRSTCHAR flag
  C2BF           
  C2BF                    IF     [ NOT FASTECP ] AND [ NOT SKIPPATH ]
ZAS Relocating Macro Assembler (v3.05                             page   52
                                                            
                                                            

  C2BF                   XOR     A
  C2BF                   LD      (FIRSTCHAR),A
  C2BF                    ENDIF  ;[ not fastecp ] and [ not skippath ]
  C2BF           
  C2BF                    ENDIF  ;fastecp or skippath or badduecp
  C2BF           
  C2BF           ; Resume processing of the command line
  C2BF           
  C2BF B7                OR      A               ; Now at end of line?
  C2C0 2895              JR      Z,RESTART       ; If so, get a new command line
  C2C2 FE03              CP      CTRLC           ; Flush ^C to prevent error-handler
  C2C4 2891              JR      Z,RESTART       ; ..invocation on warm boots
  C2C6           
  C2C6 FE3B              CP      CMDSEP          ; Is it a command separator?
  C2C8 2003              JR      NZ,NEXTCMD4     ; If not, skip ahead to process the command
  C2CA 23                INC     HL              ; If it is, skip over it
  C2CB 18DB              JR      NEXTCMD3        ; ..and process next command
  C2CD           
  C2CD           NEXTCMD4:
  C2CD           
  C2CD           ; Unless we are now running the external error handler, the following code
  C2CD           ; saves the address of the current command in Z3MSG+4 for use by programs
  C2CD           ; to determine the command line with which they were invoked.
  C2CD           
  C2CD 3A83ED            LD      A,(CMDSTATFL)   ; Get command status flag
  C2D0 CB4F              BIT     1,A             ; Test for error handler invocation
  C2D2 2003              JR      NZ,NEXTCMD5     ; If so, skip over next instruction
  C2D4 2284ED            LD      (CMDPTR),HL
  C2D7           
  C2D7           NEXTCMD5:
  C2D7 CDCFC3            CALL    PARSER          ; Parse entire command line, then look for
  C2DA                                           ; ..the command
  C2DA           
  C2DA           ;=============================================================================
  C2DA           
  C2DA           ;               C O M M A N D    S E A R C H    C O D E
  C2DA           
  C2DA           ;=============================================================================
  C2DA           
  C2DA           ; CODE FOR FINDING AND RUNNING THE COMMAND
  C2DA           
  C2DA           ; Here is the code for running a command.  Commands are searched for and
  C2DA           ; processed in the following order:
  C2DA           ;
  C2DA           ;       1) flow control package (FCP) commands and IF state testing
  C2DA           ;       2) resident command package (RCP)
  C2DA           ;       3) command processor (CPR)
  C2DA           ;       4) transient (COM file or extended command processor)
  C2DA           ;       5) external error handler
  C2DA           ;       6) internal error message and processing
  C2DA           ;
  C2DA           ; Special notes:
  C2DA           ;
  C2DA           ;    a) If the current command is a shell command, special handling of flow
  C2DA           ;       control is required.  If SHELLIF is enabled so that flow commands are
  C2DA           ;       allowed in shell alias scripts, then we reset the flow state to its
ZAS Relocating Macro Assembler (v3.05                             page   53
                                                            
                                                            

  C2DA           ;       initial condition (none) with each shell invocation (and after each
  C2DA           ;       command is run, we reset the shell bit in the code after CALLPROG).
  C2DA           ;       In this case shells will run regardless of flow state, and residual
  C2DA           ;       conditionals from the last running of the shell are flushed.  Each
  C2DA           ;       shell input sequence begins afresh.  On the other hand, if SHELLIF is
  C2DA           ;       off, flow control commands inside a shell script must be flushed so
  C2DA           ;       that they do not interfere with user entered commands.
  C2DA           ;    b) Directory prefixes are ignored for flow commands, since all flow control
  C2DA           ;       processing must pass through the FCP (the command must run even when
  C2DA           ;       the current flow state is false).
  C2DA           ;    c) If the command is not found in the FCP, then the current flow state is
  C2DA           ;       tested.  If it is false, the command is flushed and the code branches
  C2DA           ;       back to get the next command.
  C2DA           ;    d) If the command had a directory prefix (a colon alone is sufficient),
  C2DA           ;       then steps #2 and #3 are skipped over,and the command is processed
  C2DA           ;       immediately as a transient program.
  C2DA           ;    e) In ZCPR33, unlike ZCPR30, RCP commands are scanned before CPR commands.
  C2DA           ;       This has been done so that more powerful RCP commands can supercede
  C2DA           ;       CPR commands.
  C2DA           ;    f) If the SKIPPATH option is enabled, when an explicit directory is
  C2DA           ;       specified with a command (but not just a colon), searching of the path
  C2DA           ;       is bypassed.  If the FASTECP option is enabled, commands with leading
  C2DA           ;       spaces are sent directly to the ECP for processing.
  C2DA           ;    g) If no external command can be found, ZCPR33 performs extensive error
  C2DA           ;       handling.  If the command error occurred while looking for a shell
  C2DA           ;       program, then the shell stack is popped.  Otherwise, ZCPR33 tries to
  C2DA           ;       invoke an external, user-specified error handling command line.  If
  C2DA           ;       none was specified or if the error handler invoked by that command
  C2DA           ;       line cannot be found, the internal error message (step #6) is displayed.
  C2DA           
  C2DA           
  C2DA           ;-----------------------------------------------------------------------------
  C2DA           
  C2DA           RUNCMD:
  C2DA                    IF     SHELLIF         ; If shells reininitialize flow control...
  C2DA                   LD      A,(CMDSTATFL)   ; Get command status flag
  C2DA                   BIT     0,A             ; Shell bit set?
  C2DA                   JR      Z,FCPCMD        ; If not a shell, process command
  C2DA                   XOR     A               ; Otherwise, shell is running, so
  C2DA                   LD      (IFPTRFL),A     ; ..reinitialize the IF system and continue
  C2DA                    ENDIF  ;shellif
  C2DA           
  C2DA           
  C2DA           ; ---------- Module <<1>>: Flow Control Processing
  C2DA           
  C2DA           ; An option is supported here to allow the address of the FCP to be obtained
  C2DA           ; from the environment descriptor.  This is logically consistent with the
  C2DA           ; pholosopy of the Z-System and is useful when one wants to have a single block
  C2DA           ; of FCP/RCP memory that can be allocated dynamically between FCP and RCP
  C2DA           ; functions.
  C2DA           
  C2DA           FCPCMD:
  C2DA           
  C2DA                    IF     FCP NE 0        ; Omit code if FCP not implemented
  C2DA           
  C2DA                    IF     FCPENV          ; If getting FCP address from Z3ENV
ZAS Relocating Macro Assembler (v3.05                             page   54
                                                            
                                                            

  C2DA           
  C2DA 1E12              LD      E,12H           ; Offset in Z3ENV to FCP address
  C2DC CD7AC6            CALL    PKGOFF          ; Set HL to FCP+5
  C2DF 2816              JR      Z,RUNCMD1       ; Skip if no FCP present
  C2E1           
  C2E1                    ELSE   ; using fixed FCP address
  C2E1           
  C2E1                   LD      HL,FCP+5        ; Get address from Z3BASE.LIB
  C2E1           
  C2E1                    ENDIF  ;fcpenv
  C2E1           
  C2E1           
  C2E1           ; If flow control processing is not allowed in shell aliases (scripts running
  C2E1           ; as shell commands), then we have to make sure that we flush any flow control
  C2E1           ; commmands, otherwise the CPR will attempt to execute them as transients,
  C2E1           ; with dire consequences.  In the code below we check the shell bit.  If it
  C2E1           ; is not set, we proceed normally.  If it is set, we scan for flow commands
  C2E1           ; and then jump past the flow testing to RUNFCP2, where the code will flush
  C2E1           ; the command if it was a flow command and execute it unconditionally if not.
  C2E1           
  C2E1                    IF     NOT SHELLIF
  C2E1 3A83ED            LD      A,(CMDSTATFL)   ; Get command status flag
  C2E4 CB47              BIT     0,A             ; If shell bit not set,
  C2E6 2805              JR      Z,RUNFCP1       ; ..we do normal processing
  C2E8 CD94C7            CALL    CMDSCAN         ; Otherwise, check for flow command
  C2EB 1808              JR      RUNFCP2         ; ..and flush if so using code below
  C2ED                    ENDIF  ;not shellif
  C2ED           
  C2ED           RUNFCP1:
  C2ED CD94C7            CALL    CMDSCAN         ; Scan command table in the module
  C2F0 2856              JR      Z,CALLPROG      ; Run if found (with no leading CRLF)
  C2F2           
  C2F2           ; This is where we test the current IF state.  If it is false, we skip this
  C2F2           ; command.
  C2F2           
  C2F2 CD8BC6            CALL    IFTEST          ; Check current IF status
  C2F5           
  C2F5           RUNFCP2:                        ; If false, skip this command and go on to next
  C2F5                    IF     DRVPREFIX       ; If DRVPREFIX we can use code below
  C2F5 2836              JR      Z,JPNEXTCMD     ; ..to save a byte
  C2F7                    ELSE                   ; Otherwise, we have to do an
  C2F7                   JP      Z,NEXTCMD       ; ..absolute jump
  C2F7                    ENDIF  ;drvprefix
  C2F7           
  C2F7                    ENDIF  ;fcp ne 0
  C2F7           
  C2F7           
  C2F7           RUNCMD1:
  C2F7                    IF     FASTECP OR BADDUECP
  C2F7 3A88C8            LD      A,(FIRSTCHAR)   ; If FIRSTCHAR flag set for ECP invocation,
  C2FA FE20              CP      ' '             ; ..then go straight to transient processing
  C2FC 2832              JR      Z,COM
  C2FE                    ENDIF  ;fastecp or badduecp
  C2FE           
  C2FF =         COLON   EQU     $+1             ; Flag for in-the-code modification
  C2FE 3E00              LD      A,0             ; If command had a directory prefix (even just
ZAS Relocating Macro Assembler (v3.05                             page   55
                                                            
                                                            

  C300 B7                OR      A               ; ..a colon) then skip over resident commands
  C301 2014              JR      NZ,COMDIR
  C303           
  C303           
  C303           ; ---------- Module <<2>>: RCP Processing
  C303           
  C303           ; An option is supported here to allow the address of the RCP to be obtained
  C303           ; from the environment descriptor.  This is logically consistent with the
  C303           ; pholosopy of the Z-System and is useful when one wants to have a single block
  C303           ; of FCP/RCP memory that can be allocated dynamically between FCP and RCP
  C303           ; functions.
  C303           
  C303                    IF     RCP NE 0        ; Omit code if RCP not implemented
  C303           
  C303           RCPCMD:
  C303           
  C303                    IF     RCPENV          ; If getting address of rcp from Z3ENV
  C303           
  C303 1E0C              LD      E,0CH           ; Offset in Z3ENV to RCP address
  C305 CD7AC6            CALL    PKGOFF          ; Set HL to address of RCP+5
  C308 2805              JR      Z,CPRCMD        ; Skip if no RCP
  C30A           
  C30A                    ELSE   ; using fixed RCP address
  C30A           
  C30A                   LD      HL,RCP+5        ; Get address from Z3BASE.LIB
  C30A           
  C30A                    ENDIF  ; rcpenv
  C30A           
  C30A CD94C7            CALL    CMDSCAN         ; Check for command in RCP
  C30D 2836              JR      Z,CALLPROGLF    ; If so, run it (with leading CRLF)
  C30F           
  C30F                    ENDIF  ;rcp ne 0
  C30F           
  C30F           
  C30F           ; ---------- Module <<3>>: CPR-Resident Command Processing
  C30F           
  C30F           CPRCMD:
  C30F           
  C30F 2119C2            LD      HL,CMDTBL       ; Point to CPR-resident command table
  C312 CD94C7            CALL    CMDSCAN         ; ..and scan for the command
  C315 2831              JR      Z,CALLPROG      ; If found, run it (with no leading CRLF)
  C317           
  C317           
  C317           
  C317           ; ---------- Module <<4>>: Transient Command Processing
  C317           
  C317           COMDIR:                         ; Test for DU: or DIR: only (directory change)
  C317           
  C317                    IF     DRVPREFIX
  C317           
  C317 3AD1ED            LD      A,(CMDFCB+1)    ; Any command name?
  C31A FE20              CP      ' '
  C31C 2012              JR      NZ,COM          ; If so, must be transient or error
  C31E           
  C31E                           ; Entry point for change of directory only
  C31E           
ZAS Relocating Macro Assembler (v3.05                             page   56
                                                            
                                                            

  C31E                    IF     WDU             ; If controlled by wheel..
  C31E           
  C31E                   LD      A,(Z3WHL)       ; Get wheel byte
  C31E                   OR      A               ; If wheel on, go on ahead
  C31E                   JR      NZ,COMDIR1
  C31E           
  C31E                    IF     BADDUECP
  C31E                   LD      (COLON),A       ; Pretend there is no colon
  C31E                   LD      A,' '           ; Force invocation of ECP
  C31E                   LD      (FIRSTCHAR),A
  C31E                   JR      COM
  C31E                    ELSE   ;not badduecp
  C31E                   LD      A,ECDUCHG
  C31E                   JR      Z,ERROR
  C31E                    ENDIF  ;badduecp
  C31E           
  C31E                    ENDIF  ; wdu
  C31E           
  C31E           COMDIR1:
  C31E 2A13C9            LD      HL,(TEMPUSR)    ; Get temporary drive and user bytes
  C321           
  C321                    IF     NOT HIGHUSER    ; If only users 0..15 can be logged
  C321 7D                LD      A,L             ; Get user number and
  C322 FE10              CP      16              ; ..make sure not above 15
  C324 3062              JR      NC,BADDIRERR    ; If out of range, invoke error handling
  C326                    ENDIF  ;not highuser
  C326           
  C326 25                DEC     H               ; Shift drive to range 0..15
  C327 22AEED            LD      (CURUSR),HL     ; Make the temporary DU into the current DU
  C32A CD18C9            CALL    LOGCURRENT      ; Log into the new current directory
  C32D           JPNEXTCMD:
  C32D C374C2            JP      NEXTCMD         ; Resume command line processing
  C330           
  C330                    ELSE   ;not drvprefix
  C330           
  C330                    IF     BADDUECP
  C330                   XOR     A               ; Pretend there is no colon
  C330                   LD      (COLON),A
  C330                   LD      A,' '           ; Force invocation of ECP
  C330                   LD      (FIRSTCHAR),A
  C330                    ELSE   ;not badduecp
  C330                   LD      A,ECDUCHG
  C330                   JR      Z,ERROR
  C330                    ENDIF  ;badduecp
  C330           
  C330                    ENDIF  ;drvprefix
  C330           
  C330           
  C330           COM:                            ; Process transient command
  C330           
  C330 3A83ED            LD      A,(CMDSTATFL)   ; Check command status flag to see if
  C333 E602              AND     2               ; ..error handler is running
  C335 3287ED            LD      (ZEXINPFL),A    ; Store result in ZEX control flag (2 will turn
  C338                                           ; ..ZEX input redirection off (0 = on)
  C338                    IF     SUBON
  C338                   LD      (XSUBFLAG),A    ; Turn off XSUB input redirection also
ZAS Relocating Macro Assembler (v3.05                             page   57
                                                            
                                                            

  C338                    ENDIF  ;subon
  C338           
  C338 210001            LD      HL,TPA          ; Set default execution/load address
  C33B 3E03              LD      A,3             ; Dynamically load type-3 and above ENVs
  C33D CD18C8            CALL    MLOAD           ; Load memory with file specified in cmd line
  C340 3A83ED            LD      A,(CMDSTATFL)   ; Check command status flag to see if
  C343 E604              AND     100B            ; ..ECP running (and suppress leading CRLF)
  C345           
  C345           ; CALLPROG is the entry point for the execution of the loaded program.  At
  C345           ; alternate entry point CALLPROGLF if the zero flag is set, a CRLF is sent to
  C345           ; the console before running the program.
  C345           
  C345           CALLPROGLF:
  C345 CCE3C5            CALL    Z,CRLF          ; Leading new line
  C348           
  C348           CALLPROG:
  C348                           ; Copy command tail into TBUFF
  C348           
  C349 =         TAILSV  EQU     $+1             ; Pointer for in-the-code modification
  C348 210000            LD      HL,0            ; Address of first character of command tail
  C34B 118000            LD      DE,TBUFF        ; Point to TBUFF
  C34E D5                PUSH    DE              ; Save pointer
  C34F 01007E            LD      BC,7E00H        ; C=0 (byte counter) and B=7E (max bytes)
  C352 13                INC     DE              ; Point to first char
  C353           TAIL:
  C353 7E                LD      A,(HL)          ; Get character from tail
  C354 CD58C6            CALL    TSTEOL          ; Check for EOL
  C357 280E              JR      Z,TAIL1         ; Jump if we are done
  C359 12                LD      (DE),A          ; Put character into TBUFF
  C35A 23                INC     HL              ; Advance pointers
  C35B 13                INC     DE
  C35C 0C                INC     C               ; Increment character count
  C35D 10F4              DJNZ    TAIL            ; If room for more characters, continue
  C35F CDF7C5            CALL    PRINT           ; Display overflow message
  C362 07                DB      BELL            ; ..ring bell
  C363 4F7666EC          DB      'Ovf','l'+80h   ; ..then continue anyway
  C367           TAIL1:
  C367 AF                XOR     A               ; Store ending zero
  C368 12                LD      (DE),A
  C369 E1                POP     HL              ; Get back pointer to character count byte
  C36A 71                LD      (HL),C          ; Store the count
  C36B           
  C36B           ; Run loaded transient program
  C36B           
  C36B CD1BC6            CALL    DEFLTDMA        ; Set DMA to 0080h standard value
  C36E           
  C36E           ; Perform automatic installation of Z3 programs (unless type-2 environment)
  C36E           
  C36E 2A84C3            LD      HL,(EXECADR)    ; Get current execution address
  C371 CD40C6            CALL    Z3CHK           ; See if file is a Z3 program
  C374 200A              JR      NZ,NOINSTALL    ; Branch if not
  C376           
  C376 FE02              CP      2               ; If type-2 (internal) environment
  C378 2806              JR      Z,NOINSTALL     ; ..do not perform installation
  C37A           
  C37A 23                INC     HL              ; Advance to place for ENV address
ZAS Relocating Macro Assembler (v3.05                             page   58
                                                            
                                                            

  C37B 3600              LD      (HL),LOW Z3ENV  ; Put in low byte of environment address
  C37D 23                INC     HL
  C37E 36EC              LD      (HL),HIGH Z3ENV ; Put in high byte
  C380           
  C380           NOINSTALL:
  C380           
  C380           ; Execution of the program occurs here by calling it as a subroutine
  C380           
  C380 2100EC            LD      HL,Z3ENV        ; Pass environment address to program in HL
  C384 =         EXECADR EQU     $+1             ; Pointer for in-line code modification
  C383 CD0000            CALL    0               ; Call transient
  C386           
  C386           ; Return from execution
  C386           
  C386                    IF     SHELLIF         ; If flow processing allowed in shells...
  C386                   LD      HL,CMDSTATFL    ; Reset the shell bit in the command status
  C386                   RES     0,(HL)          ; ..flag so multiple-command shells will work
  C386                    ENDIF  ;shellif
  C386           
  C386                                           ; Continue command processing
  C386                    IF     DRVPREFIX       ; If DRVPREFIX we can save a byte by
  C386 18A5              JR      JPNEXTCMD       ; ..doing a two-step relative jump
  C388                    ELSE                   ; Otherwise, we just have to do
  C388                   JP      NEXTCMD         ; ..the absolute jump
  C388                    ENDIF  ;drvprefix
  C388           
  C388           
  C388           ; ---------- Module <<5>>: External Error Handler Processing
  C388           
  C388           BADDIRERR:
  C388 3E02              LD      A,ECBADDIR      ; Error code for bad directory specification
  C38A           
  C38A           ERROR:
  C38A           
  C38A           ; If we are returning from an external command to process an error, we want
  C38A           ; to leave the error return code as it was set by the transient program.
  C38A           
  C38A 2183ED            LD      HL,CMDSTATFL    ; Point to command status flag
  C38D CB5E              BIT     3,(HL)          ; Check transient error flag bit
  C38F 2003              JR      NZ,ERROR1       ; If set, leave error code as set externally
  C391 3280ED            LD      (ECFLAG),A      ; Otherwise, save error code from A register
  C394           
  C394           ERROR1:
  C394 CB96              RES     2,(HL)          ; Reset the ECP bit to prevent recursion of
  C396                                           ; ..error handler by programs that don't
  C396                                           ; ..clear the bit
  C396 CB46              BIT     0,(HL)          ; Was error in attempting to run a shell?
  C398 2018              JR      NZ,ERRSH        ; If so, pop shell stack
  C39A           
  C39A           ; The following code is included to avoid a catastrophic infinite loop when
  C39A           ; the external error handler cannot be found.  After one unsuccessful try,
  C39A           ; the internal code is invoked.
  C39A           
  C39A CB4E              BIT     1,(HL)          ; Was an error handler already called?
  C39C 2021              JR      NZ,ERRINTRNL    ; If so, use internal error handler
  C39E           
ZAS Relocating Macro Assembler (v3.05                             page   59
                                                            
                                                            

  C39E           ; If the current IF state is false, we would like to ignore the error and just
  C39E           ; go on with the next command.  Unfortunately, for some errors (e.g., a bad
  C39E           ; command format such as a command with a wildcard character) the error handler
  C39E           ; is invoked before the pointer in the multiple command line buffer is set up
  C39E           ; to the next command.  In that case, we fall into an infinite loop.  We also
  C39E           ; must not allow the external error handler to run, since it will not run and
  C39E           ; we will again fall into an infinite loop.  The present code is not so bad, of
  C39E           ; course, since even a command in a false part of a command sequence should not
  C39E           ; have a true error in it.  We have already put in code to bypass password
  C39E           ; checking during a false IF state, since a command with a password is not an
  C39E           ; invalid command.
  C39E           
  C39E                    IF     FCP NE 0
  C39E CD8BC6            CALL    IFTEST          ; If we are in a false IF state, external
  C3A1 281C              JR      Z,ERRINTRNL     ; ..handler will not run, so use built-in
  C3A3                    ENDIF  ;fcp ne 0
  C3A3           
  C3A3 CBCE              SET     1,(HL)          ; Set command status flag for error invocation
  C3A5 2190ED            LD      HL,ERRCMD       ; Point to error handler command line
  C3A8 7E                LD      A,(HL)          ; Check first byte for presence of an
  C3A9 B7                OR      A               ; ..error command line
  C3AA 2813              JR      Z,ERRINTRNL     ; If no error handler, use built-in one
  C3AC 2200EF            LD      (NXTCHR),HL     ; Else, use error command line as next command
  C3AF C394C2            JP      NEXTCMD1        ; Run command without resetting status flag
  C3B2           
  C3B2           
  C3B2           ; ---------- Module <<6>>: Resident Error Handler Code
  C3B2           
  C3B2           ; If the error is with the invocation of a shell command, we pop the bad shell
  C3B2           ; command off the stack to prevent recursion of the error.  We then use the
  C3B2           ; the internal error handler to echo the bad shell command.
  C3B2           
  C3B2           ERRSH:
  C3B2           
  C3B2 1100ED            LD      DE,SHSTK        ; Point to current entry in shell stack
  C3B5 2120ED            LD      HL,SHSTK+SHSIZE ; Point to next entry in stack
  C3B8 016000            LD      BC,[SHSTKS-1]*SHSIZE    ; Bytes to move
  C3BB EDB0              LDIR                    ; Pop the stack
  C3BD AF                XOR     A               ; Clear the last entry position
  C3BE 12                LD      (DE),A
  C3BF           
  C3BF           ERRINTRNL:
  C3BF                    IF     SUBON
  C3BF                   CALL    SUBKIL          ; Terminate active submit file if any
  C3BF                    ENDIF  ;subon
  C3BF           
  C3BF CDE3C5            CALL    CRLF            ; New line
  C3C2 2A84ED            LD      HL,(CMDPTR)     ; Point to beginning of bad command
  C3C5 CDFDC5            CALL    PRINTHL         ; Echo it to console
  C3C8 CDF7C5            CALL    PRINT           ; Print '?'
  C3CB BF                DEFB    '?'+80h
  C3CC C357C2            JP      RESTART         ; Restart CPR
  C3CF           
  C3CF           ; End ZCPR33-2.Z80
  C3CF           
ZAS Relocating Macro Assembler (v3.05                             page   60
                                                            
                                                            

  C3CF                   PAGE
  C3CF           
  C3CF           ; ZCPR33-3.Z80
  C3CF           
  C3CF           ;=============================================================================
  C3CF           ;
  C3CF           ;          C O M M A N D    L I N E     P A R S I N G    C O D E
  C3CF           ;
  C3CF           ;=============================================================================
  C3CF           
  C3CF           ; This code parses the command line pointed to by HL.  The command verb is
  C3CF           ; parsed, placing the requested program name into the command file control
  C3CF           ; block.  The drive and user bytes are set.  If an explicit DU or DIR was
  C3CF           ; given, the COLON flag is set so that the processor knows about this later
  C3CF           ; when the command search path is built.
  C3CF           
  C3CF           PARSER:
  C3CF 11D0ED            LD      DE,CMDFCB       ; Point to the command FCB
  C3D2 D5                PUSH    DE
  C3D3 CD5DC6            CALL    INITFCB         ; Initialize the FCB
  C3D6 D1                POP     DE
  C3D7 32E0C3            LD      (DUERRFLAG),A   ; Store zero (INITFCB ends with A=0) into flag
  C3DA CD3BC4            CALL    SCANNER         ; Parse first token on command line into FCB
  C3DD 2021              JR      NZ,BADCMD       ; Invoke error handler if '?' in command
  C3DF           
  C3E0 =         DUERRFLAG EQU   $+1             ; Pointer for in-the-code modification
  C3DF 3E00              LD      A,0             ; See if bad DU/DIR specified with command verb
  C3E1 B7                OR      A
  C3E2           
  C3E2                    IF     BADDUECP
  C3E2 2816              JR      Z,PARSER1       ; If DU/DIR is OK, skip ahead
  C3E4 3A83ED            LD      A,(CMDSTATFL)   ; If ECP already running
  C3E7 CB57              BIT     2,A             ; ..skip ahead
  C3E9 200F              JR      NZ,PARSER1
  C3EB 3AD1ED            LD      A,(CMDFCB+1)    ; If not a directory change command
  C3EE D620              SUB     ' '             ; ..invoke error handler
  C3F0 2096              JR      NZ,BADDIRERR
  C3F2                                           ; If bad directory change attempt,
  C3F2 320FC4            LD      (TMPCOLON),A    ; ..pretend there is no colon (A=0)
  C3F5 3E20              LD      A,' '           ; ..and force immediate ECP invocation
  C3F7 3288C8            LD      (FIRSTCHAR),A   ; ..when command is processed
  C3FA                    ELSE                   ; If errors not processed by ECP then
  C3FA                   JR      NZ,BADDIRERR    ; ..invoke error handler
  C3FA                    ENDIF  ; badduecp
  C3FA           
  C3FA           PARSER1:
  C3FA 11D9ED            LD      DE,CMDFCB+9     ; Make sure no explicit file type was given
  C3FD 1A                LD      A,(DE)          ; Get first character of file type
  C3FE FE20              CP      ' '             ; Must be blank
  C400           BADCMD:
  C400 3E05              LD      A,ECBADCMD      ; Error code for illegal command form
  C402 2086              JR      NZ,ERROR        ; If not, invoke error handler
  C404           
  C404 E5                PUSH    HL              ; Save pointer to next byte of command
  C405 2136C2            LD      HL,COMMSG       ; Place default file type (COM) into FCB
  C408 010300            LD      BC,3
ZAS Relocating Macro Assembler (v3.05                             page   61
                                                            
                                                            

  C40B EDB0              LDIR
  C40D E1                POP     HL              ; Get command line pointer back
  C40E           
  C40E           ; The following block of code is arranged so that the COLON flag is set only
  C40E           ; when an explicit directory specification is detected in the command verb.
  C40E           ; Other parses also change the TMPCOLON flag, but only when passing here does
  C40E           ; the flag get transferred to COLON.
  C40E           
  C40F =         TMPCOLON EQU    $+1             ; Pointer for in-the-code modification
  C40E 3E00              LD      A,0             ; ..by SCANNER routine
  C410 32FFC2            LD      (COLON),A       ; If explicit DU/DIR, set COLON flag
  C413           
  C413           ; Find the end of this command and set up the pointer to the next command.
  C413           
  C413 E5                PUSH    HL              ; Save command line pointer
  C414 2B                DEC     HL              ; Adjust for preincrementing below
  C415           PARSER2:                        ; Find end of this command
  C415 23                INC     HL              ; Point to next character
  C416 7E                LD      A,(HL)          ; ..and get it
  C417 CD58C6            CALL    TSTEOL          ; Test for end of command
  C41A 20F9              JR      NZ,PARSER2      ; Keep looping if not
  C41C           
  C41C 2200EF            LD      (NXTCHR),HL     ; Set pointer to next command
  C41F E1                POP     HL              ; Get back pointer to current command tail
  C420           
  C420           ; This block of code parses two tokens in the command line into the two
  C420           ; default FCBs at 5Ch and 6Ch.  It also sets a pointer to the command tail
  C420           ; for later copying into the command tail buffer at 80h.  This code is used
  C420           ; first when attempting to parse a normal command line and possibly again
  C420           ; later when the entire user's command is treated as a tail to the extended
  C420           ; command processor.  The resident JUMP and SAVE commands use it also, and
  C420           ; the entry point is available at location CCP+9 for use by other programs.
  C420           
  C420           PARSETAIL:
  C420 2249C3            LD      (TAILSV),HL     ; Save pointer to command tail
  C423           
  C423                                           ; Process first token
  C423           
  C423 115C00            LD      DE,TFCB         ; Point to first default FCB
  C426 D5                PUSH    DE              ; Save pointer while initializing
  C427 CD5DC6            CALL    INITFCB         ; Initialize both default FCBs
  C42A D1                POP     DE
  C42B CD51C6            CALL    SKSP            ; Skip over spaces in command line
  C42E C43BC4            CALL    NZ,SCANNER      ; If not end of line, parse the token
  C431                                           ; ..into first FCB
  C431 2211C2            LD      (PARSEPTR),HL   ; Save pointer to second token for reparsing
  C434           
  C434                                           ; Process second token
  C434           
  C434 CD51C6            CALL    SKSP            ; Skip over spaces
  C437 C8                RET     Z               ; Done if end of line or end of command
  C438 116C00            LD      DE,TFCB2        ; Point to second default FCB
  C43B                                           ; ..and fall through to SCANNER routine
  C43B           
  C43B           ;-----------------------------------------------------------------------------
  C43B           
ZAS Relocating Macro Assembler (v3.05                             page   62
                                                            
                                                            

  C43B           ; This routine processes a command line token pointed to by HL.  It attempts
  C43B           ; to interpret the token according to the form [DU:|DIR:]NAME.TYP and places
  C43B           ; the corresponding values into the FCB pointed to by DE.  On exit, HL points
  C43B           ; to the delimiter encountered at the end of the token.  The Z flag is set if
  C43B           ; a wild card was detected in the token.
  C43B           
  C43B           SCANNER:
  C43B AF                XOR     A               ; Initialize various flags
  C43C 320FC4            LD      (TMPCOLON),A    ; Set no colon
  C43F ED4BAEED          LD      BC,(CURUSR)     ; Get current drive and user into BC
  C443 04                INC     B               ; Shift drive range from 0..15 to 1..16
  C444 ED4313C9          LD      (TEMPUSR),BC    ; Initialize temporary DU
  C448           
  C448 CDAAC4            CALL    SCANFLD8        ; Extract possible file name
  C44B FE3A              CP      ':'             ; Was terminating character a colon?
  C44D 202B              JR      NZ,SCANTYPE     ; If not, go on to extract file type
  C44F 320FC4            LD      (TMPCOLON),A    ; Otherwise, set colon and process DU/DIR
  C452 23                INC     HL              ; Point to character after colon
  C453           
  C453           ; Code for resolving directory specifications (macro RESOLVE is defined in
  C453           ; Z33MAC.LIB).  RESOLVE returns with a nonzero value and a NZ flag setting
  C453           ; if the DU/DIR specification cannot be resolved.  There are quite a few
  C453           ; possibilities here.
  C453           
  C453                           ; Case where both forms are accepted
  C453           
  C453                    IF     ACCPTDIR AND ACCPTDU
  C453                    IF     DUFIRST
  C453                   RESOLVE DU,DIR          ; Check DU: form before DIR: form
  C453                    ELSE
  C453                   RESOLVE DIR,DU          ; Check DIR: form before DU: form
  C453           
  C453           
  C453 E5                PUSH    HL              ; Save pointer to command string
  C454 D5                PUSH    DE              ; Save pointer to FCB
  C455 CD1AC5            CALL    DIRSCAN ; Scan for the first directory form
  C458           
  C458                    IF     NOT NUL DU
  C458           
  C458 2807              JR      Z,GOTIT         ; Resolved successfully, so jump ahead
  C45A           
  C45A D1                POP     DE              ; Restore pointers for use by second call
  C45B E1                POP     HL
  C45C E5                PUSH    HL              ; Save them again
  C45D D5                PUSH    DE
  C45E CD7DC5            CALL    DUSCAN  ; Scan for the second directory form
  C461           
  C461                    ENDIF  ;not nul form2
  C461           
  C461           GOTIT:
  C461 D1                POP     DE              ; Restore pointer to FCB
  C462           
  C462                    ENDM   ;resolve
  C462                    ENDIF  ;dufirst
  C462                    ENDIF  ;accptdir and accptdu
  C462           
ZAS Relocating Macro Assembler (v3.05                             page   63
                                                            
                                                            

  C462                           ; Cases of only one form accepted
  C462           
  C462                    IF     ACCPTDU AND NOT ACCPTDIR
  C462                   RESOLVE DU,             ; Check only DU: form
  C462                    ENDIF  ;accptdu and not accptdir
  C462           
  C462                    IF     ACCPTDIR AND NOT ACCPTDU
  C462                   RESOLVE DIR,            ; Check only DIR: form
  C462                    ENDIF  ;accptdir and not accptdu
  C462           
  C462                           ; Case of neither form accepted
  C462           
  C462                    IF     NOT ACCPTDIR AND NOT ACCPTDU
  C462                   PUSH    HL              ; Save pointer to command string
  C462                   INC     DE              ; Point to first character of name
  C462                   LD      A,(DE)          ; Get it
  C462                   DEC     DE              ; Restore the pointer
  C462                   SUB     ' '             ; If no name is there, A=0 and Z flag set
  C462                    ENDIF  ;not accptdir and not accptdu
  C462           
  C462 D5                PUSH    DE              ; Save pointer to FCB again
  C463 F5                PUSH    AF              ; Save bad directory flag
  C464 3A14C9            LD      A,(TEMPDR)      ; Set designated drive
  C467 12                LD      (DE),A          ; ..into FCB
  C468 13                INC     DE              ; Point to file name field
  C469 CD63C6            CALL    IFCB            ; Perform partial init (set user code)
  C46C F1                POP     AF              ; Get bad directory flag back
  C46D 32E0C3            LD      (DUERRFLAG),A   ; Save flag in parser code
  C470 2803              JR      Z,SCANNER1      ; Branch if valid directory specified
  C472 1B                DEC     DE              ; Back up to record count byte
  C473 1B                DEC     DE
  C474 12                LD      (DE),A          ; Store error flag there (NZ if error)
  C475           SCANNER1:
  C475 D1                POP     DE              ; Get FCB pointer back
  C476 E1                POP     HL              ; Restore pointer to command string
  C477 CDAAC4            CALL    SCANFLD8        ; Scan for file name
  C47A           
  C47A           ; This code processes the file type specification in the token
  C47A           
  C47A           SCANTYPE:
  C47A 7E                LD      A,(HL)          ; Get ending character of file name field
  C47B EB                EX      DE,HL           ; Switch FCB pointer into HL
  C47C 010800            LD      BC,8            ; Offset to file type field
  C47F 09                ADD     HL,BC
  C480 EB                EX      DE,HL           ; Switch pointers back
  C481           
  C481 0603              LD      B,3             ; Maximum characters in file type
  C483 FE2E              CP      '.'             ; See if file type specified
  C485 2006              JR      NZ,SCANTYPE2    ; If not, skip over file type parsing
  C487           
  C487 23                INC     HL              ; Point to character after '.'
  C488 D5                PUSH    DE              ; Save pointer to FCB file type
  C489 CDB6C4            CALL    SCANFIELD       ; Parse file type into FCB
  C48C D1                POP     DE
  C48D           
  C48D           SCANTYPE2:
ZAS Relocating Macro Assembler (v3.05                             page   64
                                                            
                                                            

  C48D EB                EX      DE,HL           ; Swap pointers again
  C48E 010500            LD      BC,5            ; Offset from file type to S1 field in FCB
  C491 09                ADD     HL,BC
  C492 EB                EX      DE,HL           ; Swap pointers back
  C493 3A13C9            LD      A,(TEMPUSR)     ; Get specified user number
  C496 12                LD      (DE),A          ; ..and store in S1 byte of FCB
  C497           
  C497           SCAN3:                          ; Skip to space character, character after an
  C497                                           ; ..equal sign, or to end of command
  C497 7E                LD      A,(HL)          ; Get next character
  C498 FE21              CP      ' '+1           ; Done if less than space
  C49A 380A              JR      C,SCAN4
  C49C CD58C6            CALL    TSTEOL          ; Done if end of line or end of command
  C49F 2805              JR      Z,SCAN4
  C4A1 23                INC     HL              ; Skip on to next character
  C4A2 FE3D              CP      '='             ; If not equal sign
  C4A4 20F1              JR      NZ,SCAN3        ; ..keep scanning
  C4A6           
  C4A6           SCAN4:                          ; Set zero flag if '?' in filename.typ
  C4A6           
  C4A7 =         QMCNT   EQU     $+1             ; Pointer for in-the-code modification
  C4A6 3E00              LD      A,0             ; Number of question marks
  C4A8 B7                OR      A               ; Set zero flag
  C4A9 C9                RET
  C4AA           
  C4AA           ; This routine invokes SCANFIELD for a file name field.  It initializes the
  C4AA           ; question mark count and preserves the FCB pointer.
  C4AA           
  C4AA           SCANFLD8:
  C4AA AF                XOR     A               ; Initialize question mark count
  C4AB 32A7C4            LD      (QMCNT),A
  C4AE D5                PUSH    DE              ; Save pointer to FCB
  C4AF 0608              LD      B,8             ; Scan up to 8 characters
  C4B1 CDB6C4            CALL    SCANFIELD
  C4B4 D1                POP     DE              ; Restore pointer to FCB
  C4B5 C9                RET
  C4B6           
  C4B6           ; This routine scans a command-line token pointed to by HL for a field whose
  C4B6           ; maximum length is given by the contents of the B register.  The result is
  C4B6           ; placed into the FCB buffer pointed to by DE.  The FCB must have had its name
  C4B6           ; and type fields initialized before this routine is called.  Wild cards of
  C4B6           ; '?' and '*' are expanded.  On exit, HL points to the terminating delimiter.
  C4B6           
  C4B6           SCANFIELD:
  C4B6 CD72C7            CALL    SDELM           ; Done if delimiter encountered
  C4B9 C8                RET     Z
  C4BA 13                INC     DE              ; Point to next byte in FCB
  C4BB FE2A              CP      '*'             ; Is character a wild card?
  C4BD 2008              JR      NZ,SCANFLD1     ; Continue if not
  C4BF           
  C4BF 3E3F              LD      A,'?'           ; Process '*' by filling with '?'s
  C4C1 12                LD      (DE),A
  C4C2 CDD7C4            CALL    QCOUNTINC       ; Increment count of question marks
  C4C5 1807              JR      SCANFLD2        ; Skip so HL pointer left on '*'
  C4C7           
  C4C7           SCANFLD1:                       ; Not wildcard character '*'
ZAS Relocating Macro Assembler (v3.05                             page   65
                                                            
                                                            

  C4C7 12                LD      (DE),A          ; Store character in FCB
  C4C8 23                INC     HL              ; Point to next character in command line
  C4C9 FE3F              CP      '?'             ; Check for question mark (wild)
  C4CB CCD7C4            CALL    Z,QCOUNTINC     ; Increment question mark count
  C4CE           SCANFLD2:
  C4CE 10E6              DJNZ    SCANFIELD       ; Decrement char count until limit reached
  C4D0           SCANFLD3:
  C4D0 CD72C7            CALL    SDELM           ; Skip until delimiter
  C4D3 C8                RET     Z               ; Zero flag set if delimiter found
  C4D4 23                INC     HL              ; Pt to next char in command line
  C4D5 18F9              JR      SCANFLD3
  C4D7           
  C4D7           
  C4D7           ; Subroutine to increment the count of question mark characters in the
  C4D7           ; parsed file name.
  C4D7           
  C4D7           QCOUNTINC:
  C4D7 E5                PUSH    HL
  C4D8 21A7C4            LD      HL,QMCNT        ; Point to count
  C4DB 34                INC     (HL)            ; Increment it
  C4DC E1                POP     HL
  C4DD C9                RET
  C4DE           
  C4DE           ;-----------------------------------------------------------------------------
  C4DE           
  C4DE           ; Validate the password pointed to by HL.  Prompt user for password entry
  C4DE           ; and return zero if it is correct.
  C4DE           
  C4DE                    IF     PWCHECK
  C4DE           
  C4DE           PASSCK:
  C4DE E5                PUSH    HL              ; Save pointer to password
  C4DF CDF7C5            CALL    PRINT           ; Prompt user
  C4E2 0D0A50573F        DEFB    CR,LF,'PW?',' '+80h
  C4E8 21D0EF            LD      HL,PWLIN        ; Set up buffer for user input
  C4EB 010A09            LD      BC,90AH         ; Set 0ah (BDOS readln function) in C
  C4EE 70                LD      (HL),B          ; ..and 9 (max character count) in B
  C4EF EB                EX      DE,HL           ; Switch buffer pointer to DE
  C4F0           
  C4F0                    IF     PWNOECHO
  C4F0 3EC9              LD      A,0C9H          ; Disable BIOS conout routine to
  C4F2 320CD8            LD      (BIOS+0CH),A    ; ..suppress password echoing
  C4F5 CD10C6            CALL    BDOSSAVE        ; Get user input
  C4F8 3EC3              LD      A,0C3H          ; Reenable BIOS conout routine
  C4FA 320CD8            LD      (BIOS+0CH),A
  C4FD                    ELSE   ;not pwnoecho
  C4FD                   CALL    BDOSSAVE        ; Get user input
  C4FD                    ENDIF  ;pwnoecho
  C4FD           
  C4FD EB                EX      DE,HL           ; Restore pointer to HL
  C4FE 23                INC     HL              ; Point to count of characters entered
  C4FF 7E                LD      A,(HL)          ; Get character count
  C500 23                INC     HL              ; Point to first character
  C501 E5                PUSH    HL              ; Save pointer while marking end of input
  C502 CD1FC7            CALL    ADDAH           ; Advance HL to just past last character
  C505 3620              LD      (HL),' '        ; Place space there
ZAS Relocating Macro Assembler (v3.05                             page   66
                                                            
                                                            

  C507 D1                POP     DE              ; Restore pointer to beginning of user input
  C508 E1                POP     HL              ; Restore pointer to password from NDR
  C509 0608              LD      B,8             ; Maximum characters to compare
  C50B           PWCK:
  C50B 1A                LD      A,(DE)          ; Get next user character
  C50C CDD8C5            CALL    UCASE           ; Capitalize it
  C50F BE                CP      (HL)            ; Compare to NDR
  C510 C0                RET     NZ              ; No match
  C511 FE20              CP      ' '             ; If last user character matched space in
  C513 C8                RET     Z               ; ..NDR, then we have a complete match
  C514 23                INC     HL              ; If not done, point to next characters
  C515 13                INC     DE
  C516 10F3              DJNZ    PWCK            ; (flags not affected by DJNZ)
  C518 AF                XOR     A               ; Set zero flag and
  C519 C9                RET                     ; ..return Z to show success
  C51A           
  C51A                    ENDIF  ; pwcheck
  C51A           
  C51A           ;-----------------------------------------------------------------------------
  C51A           
  C51A           ; This code attempts to interpret the token in the FCB pointed to by register
  C51A           ; pair DE as a DIR (named directory) prefix.  If it is successful, the drive
  C51A           ; and user values are stored in TEMPDR and TEMPUSR, the zero flag is set, and
  C51A           ; a value of zero is returned in register A.
  C51A           ;
  C51A           ; If the named directory is found to be password restricted, then the user is
  C51A           ; asked for the password (unless the directory is the one currently logged or
  C51A           ; the current IF state is false).  If an incorrect password is entered, the
  C51A           ; error handler is generally invoked directly.  The exception to this is when
  C51A           ; the transient program bit is set in the command status flag (this bit would
  C51A           ; be set by a non-CPR program that calls REPARSE).  In this case the default
  C51A           ; directory is returned, the zero flag is reset, and a nonzero value in
  C51A           ; returned in register A to show a bad directory.  In addition, the code in
  C51A           ; SCANNER will set record-count byte in the FCB to a nonzero value so that
  C51A           ; the calling program can detect the error.  [Note: if DU processing is also
  C51A           ; allowed and it follows DIR processing, DUSCAN will also be called.  Unless
  C51A           ; there is a passworded directory with a DU form, this will cause no trouble.]
  C51A           
  C51A                    IF     ACCPTDIR
  C51A           
  C51A           DIRSCAN:
  C51A           
  C51A           ; If the DU form is not allowed, we have to detect a colon-only condition here.
  C51A           ; Otherwise DUSCAN will take care of it.
  C51A           
  C51A 13                INC     DE              ; Point to first byte of directory form
  C51B           
  C51B                    IF     NOT ACCPTDU
  C51B                   LD      A,(DE)          ; Get first character of directory
  C51B                   SUB     ' '             ; If it is a blank space
  C51B                   RET     Z               ; ..we have a successful directory resolution
  C51B                    ENDIF  ;not accptdu
  C51B           
  C51B EB                EX      DE,HL           ; Switch pointer to FCB to HL
  C51C           
  C51C                    IF     NDRENV          ; If getting NDR address for Z3ENV
ZAS Relocating Macro Assembler (v3.05                             page   67
                                                            
                                                            

  C51C 1E15              LD      E,15H           ; Offset to NDR address
  C51E E5                PUSH    HL              ; Preserve pointer to FCB
  C51F CD7AC6            CALL    PKGOFF          ; Get NDR address from ENV into DE
  C522 E1                POP     HL
  C523 2855              JR      Z,DIRERR        ; Branch if no NDR implemented
  C525                    ELSE   ; using fixed address of NDR buffer
  C525                   LD      DE,Z3NDIR       ; Point to first entry in NDR
  C525                    ENDIF  ; ndrenv
  C525           
  C525           DIRSCAN1:
  C525 1A                LD      A,(DE)          ; Get next character
  C526 B7                OR      A               ; Zero if end of NDR
  C527 2851              JR      Z,DIRERR
  C529 13                INC     DE              ; Point to name of directory
  C52A 13                INC     DE
  C52B E5                PUSH    HL              ; Save pointer to name we are looking for
  C52C D5                PUSH    DE              ; Save pointer to NDR entry
  C52D 0608              LD      B,8             ; Number of characters to compare
  C52F           
  C52F           DIRSCAN2:
  C52F 1A                LD      A,(DE)
  C530 BE                CP      (HL)
  C531 2004              JR      NZ,DIRSCAN3     ; If no match, quit and go on to next DIR
  C533 23                INC     HL              ; Point to next characters to compare
  C534 13                INC     DE
  C535 10F8              DJNZ    DIRSCAN2        ; Count down
  C537           
  C537           DIRSCAN3:
  C537 D1                POP     DE              ; Restore pointers
  C538 E1                POP     HL
  C539 2808              JR      Z,DIRSCAN4      ; Branch if we have good match
  C53B           
  C53B EB                EX      DE,HL           ; Advance to next entry in NDR
  C53C 011000            LD      BC,16           ; 8 bytes for name + 8 bytes for password
  C53F 09                ADD     HL,BC
  C540 EB                EX      DE,HL
  C541 18E2              JR      DIRSCAN1        ; Continue comparing
  C543           
  C543           ; If ACCPTDU is enabled, we can share similar code in DUSCAN and do not need
  C543           ; the code here.
  C543           
  C543                    IF     NOT ACCPTDU
  C543           DIRERR:                         ; No match found
  C543                   DEC     A
  C543                   RET
  C543                    ENDIF  ;not accptdu
  C543           
  C543           DIRSCAN4:                       ; Match found
  C543 EB                EX      DE,HL           ; Switch pointer to NDR entry into HL
  C544 E5                PUSH    HL              ; ..and save it for later
  C545 2B                DEC     HL              ; Point to user corresponding to the DIR
  C546 4E                LD      C,(HL)          ; Get user value into C
  C547 2B                DEC     HL              ; Point to drive
  C548 46                LD      B,(HL)          ; Get it into B
  C549           
  C549                    IF     PWCHECK
ZAS Relocating Macro Assembler (v3.05                             page   68
                                                            
                                                            

  C549           
  C549 2AAEED            LD      HL,(CURUSR)     ; Get current drive/user into HL
  C54C 24                INC     H               ; Shift drive to range 1..16
  C54D AF                XOR     A               ; Clear carry flag
  C54E ED42              SBC     HL,BC           ; Compare
  C550 E1                POP     HL              ; Restore pointer to NDR entry
  C551 287A              JR      Z,SETDU         ; If same, accept values without PW checking
  C553           
  C553           ; If WPASS is set, then password checking is bypassed when the wheel byte is
  C553           ; set.
  C553           
  C553                    IF     WPASS
  C553 3AFFED            LD      A,(Z3WHL)       ; Get wheel byte
  C556 B7                OR      A               ; If wheel byte set
  C557 2074              JR      NZ,SETDU        ; ..skip checking passwords
  C559                    ENDIF  ;wpass
  C559           
  C559           ; This code is a bit tricky.  We do not want to be asked for passwords for
  C559           ; named directory references in commands when the current IF state is false.
  C559           ; So, first we check to see if there is a password on the directory.  If not,
  C559           ; we proceed to set the temporary DU to the specified directory.  If there is
  C559           ; a password, we check the current IF state.  If it is false, we do not check
  C559           ; passwords and pretend there was no password.  However, we leave the current
  C559           ; directory in effect.  This will work properly in all but one rare
  C559           ; circumstance.  When the command is an 'OR' command with a reference to a
  C559           ; passworded named directory (e.g., "OR EXIST SECRET:FN.FT"), the password
  C559           ; will not be requested and the current directory will be used instead of the
  C559           ; specified one.
  C559           
  C559 C5                PUSH    BC              ; Save requested drive/user
  C55A 010800            LD      BC,8            ; Point to password in NDR
  C55D 09                ADD     HL,BC
  C55E 7E                LD      A,(HL)          ; Get first character of password
  C55F FE20              CP      ' '             ; Is there a password?
  C561           
  C561                    IF     FCP EQ 0        ; If FCP not implemented ...
  C561           
  C561                   CALL    NZ,PASSCK       ; Perform password checking if pw present
  C561           
  C561                    ELSE   ;fcp ne 0       ; FCP implemented ...
  C561           
  C561 2809              JR      Z,DIRSCAN5      ; If no pw, skip ahead
  C563 CD8BC6            CALL    IFTEST          ; Otherwise, test current IF state
  C566 C1                POP     BC              ; Restore BC in case we return now
  C567 C8                RET     Z               ; If false IF in effect, fake success without
  C568                                           ; ..checking password (but TEMPDR/TEMPUSR not
  C568                                           ; ..set)
  C568 C5                PUSH    BC              ; Otherwise, save BC again
  C569 CDDEC4            CALL    PASSCK          ; Perform password checking
  C56C           
  C56C                    ENDIF  ;fcp eq 0
  C56C           
  C56C           DIRSCAN5:
  C56C C1                POP     BC              ; Restore requested drive/user
  C56D 285E              JR      Z,SETDU         ; If not bad password, set it up
  C56F 3A83ED            LD      A,(CMDSTATFL)   ; See if external invocation (disable
ZAS Relocating Macro Assembler (v3.05                             page   69
                                                            
                                                            

  C572 CB5F              BIT     3,A             ; ..error handling if so)
  C574 C0                RET     NZ              ; Return NZ to show bad directory
  C575 3E03              LD      A,ECBADPASS     ; Error code for bad password
  C577 C38AC3            JP      ERROR
  C57A           
  C57A                    ELSE   ;not pwcheck
  C57A           
  C57A                   POP     HL              ; Clean up stack
  C57A                    IF     ACCPTDU         ; If we cannot fall through, branch
  C57A                   JR      SETDU
  C57A                    ENDIF  ;accptdu
  C57A           
  C57A                    ENDIF  ;pwcheck
  C57A           
  C57A                    IF     NOT ACCPTDU     ; If NOT ACCPTDU, we have to supply code here
  C57A           SETDU:
  C57A                   LD      (TEMPUSR),BC
  C57A                   XOR     A               ; Set Z to flag success
  C57A                   RET
  C57A                    ENDIF  ;not accptdu
  C57A           
  C57A                    ENDIF  ;accptdir
  C57A           
  C57A           ;-----------------------------------------------------------------------------
  C57A           
  C57A           ; This code attempts to interpret the token in the FCB pointed to by register
  C57A           ; pair DE as a DU (drive/user) prefix.  If it is successful, the drive and
  C57A           ; user values are stored in TEMPDR and TEMPUSR, the zero flag is set, and a
  C57A           ; value of zero is returned in register A.  Otherwise the zero flag is reset
  C57A           ; and a nonzero value is returned in register A.
  C57A           ;
  C57A           ; The ADUENV option allows acceptance of the DU form to be controlled by the
  C57A           ; DUOK flag in the environment descriptor.  An additional feature of this code
  C57A           ; when the ADUENV option is enabled is that a DU value is always accepted,
  C57A           ; even if DUOK is off and even if it is outside the normally allowed range,
  C57A           ; if it corresponds to a named directory with no password.  The currently
  C57A           ; logged directory is unconditionally acceptable (if you got there once, you
  C57A           ; can stay as long as you like without further hassles).
  C57A           
  C57A                    IF     ACCPTDU         ; Allow DU: form
  C57A           
  C57A           DIRERR:                         ; This code may do double duty for DIRSCAN
  C57A                                           ; ..above
  C57A           DUERR:
  C57A AF                XOR     A               ; Return NZ to show failure
  C57B 3D                DEC     A
  C57C C9                RET
  C57D           
  C57D           DUSCAN:
  C57D EB                EX      DE,HL           ; Switch FCB pointer to HL
  C57E 23                INC     HL              ; Point to first byte of file name in FCB
  C57F           
  C57F ED4BAEED          LD      BC,(CURUSR)     ; Preset C to current user, B to current drive
  C583 7E                LD      A,(HL)          ; Get possible drive specification
  C584 D641              SUB     'A'             ; Otherwise convert to number 0..15
  C586 3806              JR      C,DUSCAN1       ; If < 0, leave B as is
ZAS Relocating Macro Assembler (v3.05                             page   70
                                                            
                                                            

  C588 FE10              CP      16
  C58A 3002              JR      NC,DUSCAN1      ; If > 15, leave B as is
  C58C 47                LD      B,A             ; Otherwise use value given
  C58D 23                INC     HL              ; ..and point to next character
  C58E           
  C58E           DUSCAN1:
  C58E 04                INC     B               ; Shift drive to range 1..16
  C58F 7E                LD      A,(HL)          ; Get possible user specification
  C590 FE20              CP      ' '
  C592 280B              JR      Z,DUSCAN2       ; If none present, leave C as is
  C594 C5                PUSH    BC              ; Save DU values in BC
  C595 CD2FC7            CALL    DECIMAL1        ; Get specified decimal user number into BC
  C598 E1                POP     HL              ; Restore values to HL
  C599 38DF              JR      C,DUERR         ; Return NZ if invalid decimal conversion
  C59B 78                LD      A,B             ; Get high byte of result
  C59C B7                OR      A               ; Make sure it is zero
  C59D C0                RET     NZ              ; If not, return NZ to show bad user number
  C59E 44                LD      B,H             ; DU value is now in BC
  C59F           
  C59F           ; If the specified directory is the currently logged directory, accept it
  C59F           ; even if it is out of range and/or password protected.
  C59F           
  C59F           DUSCAN2:
  C59F 2AAEED            LD      HL,(CURUSR)     ; Get current drive/user into HL
  C5A2 24                INC     H               ; Shift drive to range 1..16
  C5A3 AF                XOR     A               ; Clear carry flag
  C5A4 ED42              SBC     HL,BC           ; Compare values
  C5A6 2825              JR      Z,SETDU
  C5A8           
  C5A8           ; If the specified DU corresponds to a named directory with no password, or
  C5A8           ; if WPASS is enabled so that password checking is not performed when the
  C5A8           ; wheel byte is set, then accept it.
  C5A8           
  C5A8                    IF     Z3NDIR NE 0
  C5A8           
  C5A8 CDCDC6            CALL    DU2DIR          ; See if there is a matching named directory
  C5AB 280F              JR      Z,DUSCAN3       ; If not, skip on
  C5AD           
  C5AD                    IF     PWCHECK         ; If passwords are being checked...
  C5AD           
  C5AD                    IF     WPASS
  C5AD 3AFFED            LD      A,(Z3WHL)       ; Get wheel byte
  C5B0 B7                OR      A               ; If wheel byte set, skip checking passwords
  C5B1 201A              JR      NZ,SETDU        ; ..and accept the DU values
  C5B3                    ENDIF  ;wpass
  C5B3           
  C5B3 110900            LD      DE,9            ; Advance to password
  C5B6 19                ADD     HL,DE
  C5B7 7E                LD      A,(HL)          ; Get first character of password
  C5B8 FE20              CP      ' '
  C5BA 2811              JR      Z,SETDU         ; If none, we have a valid DU
  C5BC           
  C5BC                    ELSE   ;not pwcheck
  C5BC           
  C5BC                   JR      SETDU           ; Set the DU
  C5BC           
ZAS Relocating Macro Assembler (v3.05                             page   71
                                                            
                                                            

  C5BC                    ENDIF  ;pwcheck
  C5BC           
  C5BC                    ENDIF  ;z3ndir ne 0
  C5BC           
  C5BC           DUSCAN3:
  C5BC                    IF     ADUENV          ; Check DUOK flag in ENV
  C5BC 3A2EEC            LD      A,(DUOKFL)      ; Get flag
  C5BF B7                OR      A               ; If DU not accepted
  C5C0 28B8              JR      Z,DUERR         ; ..skip over the DU scan
  C5C2                    ENDIF  ;aduenv
  C5C2           
  C5C2                    IF     DUENV           ; If getting max drive and user from ENV
  C5C2 2A2CEC            LD      HL,(MAXDRENV)   ; Get max drive into L and max user into H
  C5C5 7D                LD      A,L             ; Test drive value
  C5C6 B8                CP      B
  C5C7 38B1              JR      C,DUERR
  C5C9 7C                LD      A,H             ; Test user value
  C5CA B9                CP      C
  C5CB 38AD              JR      C,DUERR
  C5CD                    ELSE                   ; Using fixed values of max DU
  C5CD                   LD      A,MAXDISK
  C5CD                   CP      B
  C5CD                   JR      C,DUERR
  C5CD                   LD      A,MAXUSR
  C5CD                   CP      C
  C5CD                   JR      C,DUERR
  C5CD                    ENDIF  ;duenv
  C5CD           
  C5CD           SETDU:
  C5CD ED4313C9          LD      (TEMPUSR),BC
  C5D1 AF                XOR     A               ; Set Z to flag success
  C5D2 C9                RET
  C5D3           
  C5D3                    ENDIF  ; accptdu
  C5D3           
  C5D3           ; End ZCPR33-3.Z80
  C5D3           
ZAS Relocating Macro Assembler (v3.05                             page   72
                                                            
                                                            

  C5D3                   PAGE
  C5D3           
  C5D3           ; ZCPR33-4.Z80
  C5D3           
  C5D3           ;=============================================================================
  C5D3           ;
  C5D3           ;       G E N E R A L    S U B R O U T I N E S    S E C T I O N
  C5D3           ;
  C5D3           ;=============================================================================
  C5D3           
  C5D3           
  C5D3           ;-----------------------------------------------------------------------------
  C5D3           ;
  C5D3           ;       CHARACTER I/O BDOS ROUTINES
  C5D3           ;
  C5D3           ;-----------------------------------------------------------------------------
  C5D3           
  C5D3           ; Get uppercase character from console (with ^S processing).  Registers B,
  C5D3           ; D, H, and L are preserved.  The character is returned in A.
  C5D3           
  C5D3           CONIN:
  C5D3 0E01              LD      C,1             ; BDOS conin function
  C5D5 CD10C6            CALL    BDOSSAVE
  C5D8                                           ; Fall through to UCASE
  C5D8           
  C5D8           ;--------------------
  C5D8           
  C5D8           ; Convert character in A to upper case.  All registers except A are preserved.
  C5D8           
  C5D8           UCASE:
  C5D8 E67F              AND     7FH             ; Mask out msb
  C5DA FE61              CP      61H             ; Less than lower-case 'a'?
  C5DC D8                RET     C               ; If so, return
  C5DD FE7B              CP      7BH             ; Greater than lower-case 'z'?
  C5DF D0                RET     NC              ; If so, return
  C5E0 E65F              AND     5FH             ; Otherwise capitalize
  C5E2 C9                RET
  C5E3           
  C5E3           ;----------------------------------------
  C5E3           
  C5E3           ; Output CRLF
  C5E3           
  C5E3           CRLF:
  C5E3 CDF7C5            CALL    PRINT
  C5E6 0D                DB      CR
  C5E7 8A                DB      LF OR 80H
  C5E8 C9                RET
  C5E9           
  C5E9           ;----------------------------------------
  C5E9           
  C5E9           ; Output character in A to the console.  All registers are preserved.
  C5E9           
  C5E9           CONOUT:
  C5E9 D5                PUSH    DE
  C5EA C5                PUSH    BC
  C5EB 0E02              LD      C,2             ; BDOS conout function
ZAS Relocating Macro Assembler (v3.05                             page   73
                                                            
                                                            

  C5ED           OUTPUT:                         ; Entry point for LCOUT below
  C5ED 5F                LD      E,A
  C5EE CD10C6            CALL    BDOSSAVE
  C5F1 C1                POP     BC
  C5F2 D1                POP     DE
  C5F3 C9                RET
  C5F4           
  C5F4           ;----------------------------------------
  C5F4           
  C5F4           ; Print the character string immediately following the call to this routine.
  C5F4           ; The string terminates with a character whose high bit is set or with a null.
  C5F4           ; At entry point PRINTC the string is automatically preceded by a
  C5F4           ; carriage-return-linefeed sequence.  All registers are preserved except A.
  C5F4           
  C5F4           PRINTC:
  C5F4 CDE3C5            CALL    CRLF            ; New line
  C5F7           
  C5F7           PRINT:
  C5F7 E3                EX      (SP),HL         ; Get pointer to string
  C5F8 CDFDC5            CALL    PRINTHL         ; Print string
  C5FB E3                EX      (SP),HL         ; Restore HL and set return address
  C5FC C9                RET
  C5FD           
  C5FD           ;----------------------------------------
  C5FD           
  C5FD           ; Print the character string pointed to by HL.  Terminate on character with
  C5FD           ; the high bit set or on a null character.  On return HL points to the byte
  C5FD           ; after the last character displayed.  All other registers except A are
  C5FD           ; preserved.
  C5FD           
  C5FD           PRINTHL:
  C5FD 7E                LD      A,(HL)          ; Get a character
  C5FE 23                INC     HL              ; Point to next byte
  C5FF B7                OR      A               ; End of string null?
  C600 C8                RET     Z
  C601 F5                PUSH    AF              ; Save flags
  C602 E67F              AND     7FH             ; Mask out msb
  C604 CDE9C5            CALL    CONOUT          ; Print character
  C607 F1                POP     AF              ; Get flags
  C608 F8                RET     M               ; String terminated by msb set
  C609 18F2              JR      PRINTHL
  C60B           
  C60B           
  C60B           ;-----------------------------------------------------------------------------
  C60B           ;
  C60B           ;       FILE I/O BDOS ROUTINES
  C60B           ;
  C60B           ;-----------------------------------------------------------------------------
  C60B           
  C60B           ; Read a record from a file to be listed or typed
  C60B           
  C60B                    IF     LTON            ; Only needed for LIST and TYPE functions
  C60B           
  C60B           READF:
  C60B                   LD      DE,TFCB
  C60B                   JR      READ
ZAS Relocating Macro Assembler (v3.05                             page   74
                                                            
                                                            

  C60B           
  C60B                    ENDIF  ; lton
  C60B           
  C60B           ;----------------------------------------
  C60B           
  C60B           ; Read a record from the command file named in CMDFCB
  C60B           
  C60B           READCMD:
  C60B 11D0ED            LD      DE,CMDFCB
  C60E           
  C60E           ; Read a record from file whose FCB is pointed to by DE
  C60E           
  C60E           READ:
  C60E 0E14              LD      C,14H           ; Read-sequential function
  C610                                           ; Fall through to BDOSSAVE
  C610           
  C610           ;--------------------
  C610           
  C610           ; Call BDOS for read and write operations.  The flags are set appropriately.
  C610           ; The BC, DE, and HL registers are preserved.
  C610           
  C610           BDOSSAVE:
  C610                   PUTREG
  C610 E5                PUSH    HL              ; Save registers in order
  C611 D5                PUSH    DE
  C612 C5                PUSH    BC
  C613                    ENDM
  C613 CD06CA            CALL    BDOS
  C616                   GETREG
  C616 C1                POP     BC              ; Restore registers in order
  C617 D1                POP     DE
  C618 E1                POP     HL
  C619                    ENDM
  C619 B7                OR      A               ; Set flags
  C61A           NOTE:                           ; This return is used for NOTE command, too
  C61A C9                RET
  C61B           
  C61B           
  C61B           ;-----------------------------------------------------------------------------
  C61B           ;
  C61B           ;       MISCELLANEOUS BDOS ROUTINES
  C61B           ;
  C61B           ;-----------------------------------------------------------------------------
  C61B           
  C61B           ; Set DMA address.  At the entry point DEFLTDMA the address is set to the
  C61B           ; default value of 80H.  At the entry point DMASET it is set to the value
  C61B           ; passed in the DE registers.
  C61B           
  C61B           DEFLTDMA:
  C61B 118000            LD      DE,TBUFF
  C61E           DMASET:
  C61E 0E1A              LD      C,1AH
  C620 18EE              JR      BDOSSAVE
  C622           
  C622           ;----------------------------------------
  C622           
ZAS Relocating Macro Assembler (v3.05                             page   75
                                                            
                                                            

  C622           ; Log in the drive value passed in the A register (A=0).
  C622           
  C622           SETDRIVE:
  C622 5F                LD      E,A
  C623 0E0E              LD      C,0EH
  C625 18E9              JR      BDOSSAVE
  C627           
  C627           ;----------------------------------------
  C627           
  C627           ; Open a file.  At entry point OPENCMD the file is the one specified in
  C627           ; CMDFCB, and the current record is set to zero.  At entry point OPEN
  C627           ; the file whose FCB is pointed to by DE is used.
  C627           
  C627           OPENCMD:
  C627 AF                XOR     A               ; Set current record to 0
  C628 32F0ED            LD      (CMDFCB+32),A
  C62B 11D0ED            LD      DE,CMDFCB       ; Command file control block
  C62E                                           ; Fall through to open
  C62E           
  C62E           OPEN:
  C62E 0E0F              LD      C,0FH           ; BDOS open function
  C630                                           ; Fall through to BDOSTEST
  C630           
  C630           ;--------------------
  C630           
  C630           ; Invoke BDOS for disk functions.  This routine increments the return code in
  C630           ; register A so that the zero flag is set if there was an error.  Registers
  C630           ; BC, DE, and HL are preserved.
  C630           
  C630           BDOSTEST:
  C630 CD10C6            CALL    BDOSSAVE
  C633 3C                INC     A               ; Set zero flag for error return
  C634 C9                RET
  C635           
  C635           ;----------------------------------------
  C635           
  C635           ; Close file whose FCB is pointed to by DE.
  C635           
  C635                    IF     SAVEON OR SUBON
  C635           CLOSE:
  C635                   LD      C,10H
  C635                   JR      BDOSTEST
  C635                    ENDIF  ;saveon or subon
  C635           
  C635           ;----------------------------------------
  C635           
  C635           ; Search for first matching file.  At entry point SRCHFST1 the first default FCB
  C635           ; is used.  At entry point SRCHFST the FCB pointed to by DE is used.
  C635           
  C635                    IF     DIRON OR ERAON OR RENON OR SAVEON
  C635           SRCHFST1:
  C635                   LD      DE,TFCB         ; Use first default FCB
  C635                    ENDIF  ;diron or eraon or renon or saveon
  C635           
  C635           SRCHFST:
  C635 0E11              LD      C,11H
ZAS Relocating Macro Assembler (v3.05                             page   76
                                                            
                                                            

  C637 18F7              JR      BDOSTEST
  C639           
  C639           ;-----------------------------------------------------------------------------
  C639           
  C639           ; Search for next matching file whose FCB is pointed to by DE.
  C639           
  C639                    IF     DIRON OR ERAON  ; Only needed by DIR and ERA functions
  C639           SRCHNXT:
  C639                   LD      C,12H
  C639                   JR      BDOSTEST
  C639                    ENDIF  ; diron or eraon
  C639           
  C639           ;-----------------------------------------------------------------------------
  C639           
  C639           ; Kill any submit file that is executing.
  C639           
  C639                    IF     SUBON
  C639           
  C639           SUBKIL:
  C639                   LD      HL,SUBFLAG      ; Check for submit file in execution
  C639                   LD      A,(HL)
  C639                   OR      A               ; 0=no
  C639                   RET     Z               ; If none executing, return now
  C639                                           ; Kill submit file
  C639                   XOR     A
  C639                   LD      (HL),A          ; Zero submit flag
  C639                   CALL    SETUSER         ; Log in user 0
  C639                   LD      DE,SUBFCB       ; Delete submit file
  C639                                           ; ..by falling through to delete routine
  C639           
  C639                    ENDIF  ; subon
  C639           
  C639           ;--------------------
  C639           
  C639           ; Delete file whose FCB is pointed to by DE.
  C639           
  C639                    IF     ERAON OR RENON OR SAVEON OR SUBON
  C639           DELETE:
  C639                   LD      C,13H
  C639                   JR      BDOSSAVE
  C639                    ENDIF  ;eraon or renon or saveon or subon
  C639           
  C639           ;-----------------------------------------------------------------------------
  C639           
  C639           ; Get and set user number.  Registers B, D, H, and L are preserved.  Register
  C639           ; E is also preserved at entry point SETUSER1.
  C639           
  C639           GETUSER:
  C639 3EFF              LD      A,0FFH          ; Get current user number
  C63B           SETUSER:
  C63B 5F                LD      E,A             ; User number in E
  C63C           SETUSER1:
  C63C 0E20              LD      C,20H           ; Get/Set BDOS function
  C63E 18D0              JR      BDOSSAVE
  C640           
  C640           
ZAS Relocating Macro Assembler (v3.05                             page   77
                                                            
                                                            

  C640           ;-----------------------------------------------------------------------------
  C640           ;
  C640           ;       GENERAL UTILITY ROUTINES
  C640           ;
  C640           ;-----------------------------------------------------------------------------
  C640           
  C640           
  C640           ; This subroutine checks to see if a program loaded at an address given by HL
  C640           ; has a Z3ENV header.  If the header is not present, the zero flag is reset.
  C640           ; If it is present, the zero flag is set, and on return HL points to the
  C640           ; environment-type byte and A contains that byte.
  C640           
  C640           Z3CHK:
  C640 1103EC            LD      DE,Z3ENV+3      ; Point to 'Z3ENV' string in ENV
  C643 23                INC     HL              ; Advance three bytes to possible program
  C644 23                INC     HL              ; ..header
  C645 23                INC     HL
  C646 0605              LD      B,5             ; Characters to compare
  C648           Z3CHK1:                         ; Check for Z3 ID header
  C648 1A                LD      A,(DE)          ; Get character from ENV descriptor
  C649 BE                CP      (HL)            ; Compare it to loaded file
  C64A C0                RET     NZ              ; Quit now if mismatch
  C64B 23                INC     HL              ; If same, advance to next characters
  C64C 13                INC     DE              ; ..and continue comparing
  C64D 10F9              DJNZ    Z3CHK1          ; (flags not affected by DJNZ)
  C64F 7E                LD      A,(HL)          ; Return the environment type in A
  C650 C9                RET                     ; Return Z if all 5 characters match
  C651           
  C651           ;----------------------------------------
  C651           
  C651           ; Subroutine to skip over spaces in the buffer pointed to by HL.  On return,
  C651           ; the zero flag is set if we encountered the end of the line or a command
  C651           ; separator character.
  C651           
  C651           SKSP:
  C651 7E                LD      A,(HL)          ; Get next character
  C652 23                INC     HL              ; Point to the following character
  C653 FE20              CP      ' '             ; Space?
  C655 28FA              JR      Z,SKSP          ; If so, keep skipping
  C657 2B                DEC     HL              ; Back up to non-space
  C658                                           ; ..and fall through
  C658           
  C658           ;--------------------
  C658           
  C658           ; Subroutine to check if character is the command separator or marks the end
  C658           ; of the line.
  C658           
  C658           TSTEOL:
  C658 B7                OR      A               ; End of command line?
  C659 C8                RET     Z               ; Return with zero flag set
  C65A FE3B              CP      CMDSEP          ; Command separator?
  C65C C9                RET                     ; Return with flag set appropriately
  C65D           
  C65D           ;----------------------------------------
  C65D           
  C65D           ; Initialize complete FCB pointed to by DE
ZAS Relocating Macro Assembler (v3.05                             page   78
                                                            
                                                            

  C65D           
  C65D           INITFCB:
  C65D AF                XOR     A
  C65E 12                LD      (DE),A          ; Set default disk (dn byte is 0)
  C65F 13                INC     DE              ; Point to file name field
  C660 CD63C6            CALL    IFCB            ; Fill 1st part of FCB
  C663                                           ; Fall through to IFCB to run again
  C663           
  C663           ;--------------------
  C663           
  C663           ; Initialize part of FCB whose file name field is pointed to by DE on entry.
  C663           ; The file name and type are set to space characters; the EX, S2, RC, and the
  C663           ; following CR (current record ) or DN (disk number) fields are set to zero.
  C663           ; The S1 byte is set to the current user number.  On exit, DE points to the
  C663           ; byte at offset 17 in the FCB (two bytes past the record count byte).
  C663           
  C663           IFCB:
  C663 060B              LD      B,11            ; Store 11 spaces for file name and type
  C665 3E20              LD      A,' '
  C667 CD75C6            CALL    FILL
  C66A AF                XOR     A
  C66B 12                LD      (DE),A          ; Set extent byte to zero
  C66C 13                INC     DE
  C66D 3AAEED            LD      A,(CURUSR)
  C670 12                LD      (DE),A          ; Set S1 byte to current user
  C671 13                INC     DE
  C672 0603              LD      B,3             ; Store 3 zeroes
  C674 AF                XOR     A               ; Fall thru to fill
  C675           
  C675           ;--------------------
  C675           
  C675           ; Fill memory pointed to by DE with character in A for B bytes
  C675           
  C675           FILL:
  C675 12                LD      (DE),A          ; Fill with byte in A
  C676 13                INC     DE              ; Point to next
  C677 10FC              DJNZ    FILL
  C679 C9                RET
  C67A           
  C67A           ;----------------------------------------
  C67A           
  C67A           ; Subroutine to display the 'no file' error message for the built-in
  C67A           ; commands DIR, ERA, LIST, TYPE, and/or REN.
  C67A           
  C67A                    IF     DIRON OR ERAON
  C67A           
  C67A           PRNNF:
  C67A                   CALL    PRINTC          ; No file message
  C67A                   DEFB    'No Fil','e'+80h
  C67A                   RET
  C67A                    ENDIF ; diron or eraon
  C67A           
  C67A           ;----------------------------------------
  C67A           
  C67A           ; Calculate address of command table in package from Z3ENV.  On entry, E
  C67A           ; contains the offset to the address of the package in the environment.  On
ZAS Relocating Macro Assembler (v3.05                             page   79
                                                            
                                                            

  C67A           ; exit, DE points to the beginning of the package and HL points to the fifth
  C67A           ; byte (where the command table starts in the RCP and FCP modules).  The zero
  C67A           ; flag is set on return if the package is not supported.
  C67A           
  C67A                    IF     FCPENV OR RCPENV OR NDRENV
  C67A           PKGOFF:
  C67A 2100EC            LD      HL,Z3ENV        ; Point to beginning of ENV descriptor
  C67D 1600              LD      D,0             ; Make DE have offset
  C67F 19                ADD     HL,DE           ; ..and add it
  C680 7E                LD      A,(HL)          ; Get low byte of package address
  C681 23                INC     HL              ; Point to high byte
  C682 66                LD      H,(HL)          ; ..and get it
  C683 6F                LD      L,A             ; Move full address into HL
  C684 B4                OR      H               ; Set zero flag if no package
  C685 110500            LD      DE,5            ; Offset to start of table
  C688 EB                EX      DE,HL           ; Preserve start address of package in DE
  C689 19                ADD     HL,DE           ; Pointer to 5th byte of package in HL
  C68A C9                RET                     ; Return with zero flag set appropriately
  C68B           
  C68B                    ENDIF  ;fcpenv or rcpenv or ndrenv
  C68B           
  C68B           ;----------------------------------------
  C68B           
  C68B           ; This subroutine checks to see if we are in a false IF state.  If that is
  C68B           ; the case, the routine returns with the zero flag set.  If there is not active
  C68B           ; IF state or if it is true, then the zero flag is reset.
  C68B           
  C68B                    IF     FCP NE 0        ; Omit code if FCP not implemented
  C68B           
  C68B           IFTEST:
  C68B ED4B81ED          LD      BC,(IFPTRFL)    ; Current IF pointer into C, IF status into B
  C68F 79                LD      A,C             ; See if any IF in effect
  C690 B7                OR      A
  C691 2802              JR      Z,IFTEST1       ; Branch if no IF state is active
  C693 A0                AND     B               ; Mask the current IF status
  C694 C9                RET
  C695           IFTEST1:
  C695 3D                DEC     A               ; Reset the zero flag
  C696 C9                RET
  C697           
  C697                    ENDIF  ;fcp ne 0
  C697           
  C697           ;----------------------------------------
  C697           
  C697           ; Print the command prompt with DU and/or DIR (but without any trailing
  C697           ; character).  This is also the code in which the current drive and user
  C697           ; will be stored.  The conditional assemblies are somewhat involved because
  C697           ; of the possibilities of either or both of the DU or DIR forms being omitted
  C697           ; from the prompt.
  C697           
  C697           PROMPT:
  C697 CDE3C5            CALL    CRLF
  C69A           
  C69A                    IF     INCLDU          ; If drive/user in prompt
  C69A           
  C69A 2AAEED            LD      HL,(CURUSR)     ; Get current drive/user into HL
ZAS Relocating Macro Assembler (v3.05                             page   80
                                                            
                                                            

  C69D           
  C69D           ; If INCLENV is enabled, the drive and user (DU) will be included in the
  C69D           ; prompt based on the state of the DUOK flag in the environment.  If INCLENV
  C69D           ; is disabled, the DU form will always be included if INCLDU is on.
  C69D           
  C69D                    IF     INCLENV
  C69D                   LD      A,(DUOKFL)      ; If ENV disallows DU,
  C69D                   OR      A               ; ..then don't show it in
  C69D                   JR      Z,PROMPT2       ; ..the prompt, either
  C69D                    ENDIF  ;inclenv
  C69D           
  C69D 7C                LD      A,H             ; Get current drive
  C69E C641              ADD     A,'A'           ; Convert to ascii A-P
  C6A0 CDE9C5            CALL    CONOUT
  C6A3 7D                LD      A,L             ; Get current user
  C6A4           
  C6A4                    IF     SUPRES          ; If suppressing user # report for user 0
  C6A4                   OR      A
  C6A4                   JR      Z,PROMPT2
  C6A4                    ENDIF
  C6A4           
  C6A4 FE0A              CP      10              ; User < 10?
  C6A6 3808              JR      C,PROMPT1
  C6A8           
  C6A8                    IF     HIGHUSER        ; If allowing users 16..31
  C6A8           
  C6A8                   LD      C,'0'-1
  C6A8           PROMPT0:
  C6A8                   INC     C
  C6A8                   SUB     10
  C6A8                   JR      NC,PROMPT0
  C6A8                   ADD     A,10
  C6A8                   LD      B,A
  C6A8                   LD      A,C
  C6A8                   CALL    CONOUT
  C6A8                   LD      A,B
  C6A8           
  C6A8                    ELSE   ;using only standard user numbers 0..15
  C6A8           
  C6A8 D60A              SUB     10              ; Subtract 10 from user number
  C6AA F5                PUSH    AF              ; Save low digit
  C6AB CDF7C5            CALL    PRINT           ; Display a '1' for tens digit
  C6AE B1                DEFB    '1' or 80h
  C6AF F1                POP     AF
  C6B0           
  C6B0                    ENDIF  ;highuser
  C6B0           
  C6B0           PROMPT1:
  C6B0 C630              ADD     A,'0'           ; Output 1's digit (convert to ascii)
  C6B2 CDE9C5            CALL    CONOUT
  C6B5           PROMPT2:
  C6B5                    ENDIF  ; incldu
  C6B5           
  C6B5                                           ; Display named directory
  C6B5           
  C6B5                    IF     INCLDIR
ZAS Relocating Macro Assembler (v3.05                             page   81
                                                            
                                                            

  C6B5           
  C6B5                    IF     INCLDU
  C6B5 44                LD      B,H             ; Copy drive/user from HL to BC
  C6B6 4D                LD      C,L             ; ..(saves a byte)
  C6B7                    ELSE
  C6B7                   LD      BC,(CURUSR)     ; Get current drive and user into BC
  C6B7                    ENDIF  ;incldu
  C6B7           
  C6B7 04                INC     B               ; Switch drive to range 1..16
  C6B8 CDCDC6            CALL    DU2DIR          ; See if there is a corresponding DIR form
  C6BB C8                RET     Z               ; If not, return now
  C6BC           
  C6BC                    IF     INCLDU          ; Separate DU and DIR with colon
  C6BC           
  C6BC                    IF     INCLENV
  C6BC                   LD      A,(DUOKFL)      ; If not displaying DU, then
  C6BC                   OR      A               ; ..don't send separator, either
  C6BC                   LD      A,':'           ; Make the separator
  C6BC                   CALL    NZ,CONOUT       ; ..and send if permitted
  C6BC                    ELSE
  C6BC CDF7C5            CALL    PRINT           ; Put in colon separator
  C6BF BA                DEFB    ':' or 80h
  C6C0                    ENDIF  ;inclenv
  C6C0           
  C6C0                    ENDIF  ; incldu
  C6C0           
  C6C0 0608              LD      B,8             ; Max of 8 chars in DIR name
  C6C2           PROMPT3:
  C6C2 23                INC     HL              ; Point to next character in DIR name
  C6C3 7E                LD      A,(HL)          ; ..and get it
  C6C4 FE20              CP      ' '             ; Done if space
  C6C6 C8                RET     Z
  C6C7 CDE9C5            CALL    CONOUT          ; Print character
  C6CA 10F6              DJNZ    PROMPT3         ; Count down
  C6CC           
  C6CC                    ENDIF  ; incldir
  C6CC           
  C6CC C9                RET
  C6CD           
  C6CD           ;-----------------------------------------------------------------------------
  C6CD           
  C6CD           ; Subroutine to convert DU value in BC into pointer to a matching entry in
  C6CD           ; the NDR.  If there is no match, the routine returns with the zero flag set.
  C6CD           ; If a match is found, the zero flag is reset, and the code returns with HL
  C6CD           ; pointing to the byte before the directory name.
  C6CD           
  C6CD                    IF     Z3NDIR NE 0
  C6CD           
  C6CD           DU2DIR:
  C6CD           
  C6CD                    IF     NDRENV          ; If getting NDR address from environment
  C6CD 1E15              LD      E,15H           ; Offset to NDR in Z3ENV
  C6CF CD7AC6            CALL    PKGOFF          ; Get address of NDR into DE
  C6D2 EB                EX      DE,HL           ; ..and switch into HL
  C6D3 C8                RET     Z               ; If no NDR, return with zero flag set
  C6D4 1804              JR      DU2DIR2
ZAS Relocating Macro Assembler (v3.05                             page   82
                                                            
                                                            

  C6D6                    ELSE
  C6D6                   LD      HL,Z3NDIR-17    ; Scan directory for match
  C6D6                    ENDIF  ;ndrenv
  C6D6           
  C6D6           DU2DIR1:                        ; Advance to next entry in NDR
  C6D6 111100            LD      DE,16+1         ; Skip user (1 byte) and name/pw (16 bytes)
  C6D9 19                ADD     HL,DE
  C6DA           
  C6DA           DU2DIR2:
  C6DA 7E                LD      A,(HL)          ; End of NDR?
  C6DB B7                OR      A
  C6DC C8                RET     Z               ; If so, return with zero flag set
  C6DD           
  C6DD 23                INC     HL              ; Point to user number in NDR entry
  C6DE B8                CP      B               ; Compare drive values
  C6DF 20F5              JR      NZ,DU2DIR1      ; If mismatch, back for another try
  C6E1 7E                LD      A,(HL)          ; Get user number
  C6E2 91                SUB     C               ; ..and compare
  C6E3 20F1              JR      NZ,DU2DIR1      ; If mismatch, back for another try
  C6E5 3D                DEC     A               ; Force NZ to show successful match
  C6E6 C9                RET
  C6E7           
  C6E7                    ENDIF  ;z3ndir ne 0
  C6E7           
  C6E7           ;-----------------------------------------------------------------------------
  C6E7           
  C6E7           ; This routine gets the next line of input for the command buffer.  The
  C6E7           ; following order of priority is followed:
  C6E7           ;       If ZEX is active, the next line is obtained from ZEX
  C6E7           ;       If a submit file is running, its last record provides the input
  C6E7           ;       If there is a command line on the shell stack, use it
  C6E7           ;       Finally, if none of the above, the input is obtained from the user
  C6E7           
  C6E7           READBUF:
  C6E7           
  C6E7 3A88ED            LD      A,(ZEXRUNFL)    ; Get ZEX-running flag
  C6EA B7                OR      A
  C6EB 2018              JR      NZ,USERINPUT    ; If ZEX running, go directly to user input
  C6ED           
  C6ED                    IF     SUBON           ; If submit facility is enabled, check for it
  C6ED           
  C6ED                   LD      A,(SUBFLAG)     ; Test for submit file running
  C6ED                   OR      A
  C6ED                   JR      Z,SHELLINPUT    ; If not, go on to possible shell input
  C6ED           
  C6ED                   XOR     A               ; Log into user 0
  C6ED                   CALL    SETUSER
  C6ED                   CALL    DEFLTDMA        ; Initialize DMA pointer
  C6ED                   LD      DE,SUBFCB       ; Point to submit file FCB
  C6ED                   CALL    OPEN            ; Try to open file
  C6ED                   JR      Z,READBUF1      ; Branch if open failed
  C6ED           
  C6ED                   LD      HL,SUBFRC       ; Point to record count in submit FCB
  C6ED                   LD      A,(HL)          ; Get the number of records in file
  C6ED                   DEC     A               ; Reduce to number of last record
  C6ED                   LD      (SUBFCR),A      ; ..and put into current record field
ZAS Relocating Macro Assembler (v3.05                             page   83
                                                            
                                                            

  C6ED                   CALL    READ            ; Attempt to read submit file
  C6ED                   JR      NZ,READBUF1     ; Branch if read failed
  C6ED           
  C6ED                   DEC     (HL)            ; Reduce file record cound
  C6ED                   DEC     HL              ; Point to S2 byte of FCB (yes, this is req'd!)
  C6ED                   LD      (HL),A          ; Stuff a zero in there (A=0 from call to READ)
  C6ED                   CALL    CLOSE           ; Close the submit file one record smaller
  C6ED                   JR      Z,READBUF1      ; Branch if close failed
  C6ED           
  C6ED           ; Now we copy the line read from the file into the multiple command line
  C6ED           ; buffer
  C6ED           
  C6ED                   LD      DE,CHRCNT       ; Point to command length byte in command buffer
  C6ED                   LD      HL,TBUFF        ; Point to sector read in from submit file
  C6ED           
  C6ED                    IF     BUFLEN GT 7FH   ; If command line buffer is longer than record,
  C6ED                   LD      BC,80H          ; ..then copy entire record from $$$.SUB file
  C6ED                    ELSE   ;buflen le 7fh  ; Otherwise copy only enough to fill
  C6ED                   LD      BC,BUFLEN+1     ; ..the command line buffer
  C6ED                    ENDIF  ;buflen gt 7fh
  C6ED           
  C6ED                   LDIR                    ; Transfer line from submit file to buffer
  C6ED           
  C6ED           ; We now deal with various options that control the display of commands fed
  C6ED           ; to the command processor from a submit file.
  C6ED           
  C6ED                    IF     SUBNOISE GT 0   ; If subnoise = 0 we omit all this display code
  C6ED           
  C6ED                    IF     SUBNOISE EQ 1   ; If subnoise = 1 we follow the quiet flag
  C6ED                   LD      A,(QUIETFL)
  C6ED                   OR      A
  C6ED                   JR      NZ,READBUF0     ; If quiet, skip echoing the command
  C6ED                    ENDIF  ;subnoise eq 1
  C6ED           
  C6ED                   CALL    PROMPT          ; Print prompt
  C6ED                   CALL    PRINT           ; Print submit prompt trailer
  C6ED                   DEFB    SPRMPT OR 80H
  C6ED                   LD      HL,CMDLIN       ; Print command line
  C6ED                   CALL    PRINTHL
  C6ED           
  C6ED                    ENDIF  ;subnoise gt 0
  C6ED           
  C6ED           READBUF0:
  C6ED                   CALL    BREAK           ; Check for abort (any char)
  C6ED                   RET     NZ              ; If no ^C, return to caller and run
  C6ED           
  C6ED           READBUF1:
  C6ED                   CALL    SUBKIL          ; Kill submit file and abort
  C6ED                   JP      RESTART         ; Restart CPR
  C6ED           
  C6ED                    ENDIF  ; subon
  C6ED           
  C6ED           SHELLINPUT:
  C6ED 2100ED            LD      HL,SHSTK        ; Point to shell stack
  C6F0 7E                LD      A,(HL)          ; Check first byte
  C6F1 FE21              CP      ' '+1           ; See if any entry
ZAS Relocating Macro Assembler (v3.05                             page   84
                                                            
                                                            

  C6F3 3810              JR      C,USERINPUT     ; Get user input if none
  C6F5           
  C6F5 1104EF            LD      DE,CMDLIN       ; Point to first character of command line
  C6F8 012000            LD      BC,SHSIZE       ; Copy shell line into command line buffer
  C6FB EDB0              LDIR                    ; Do copy
  C6FD EB                EX      DE,HL           ; HL points to end of line
  C6FE 3E01              LD      A,1             ; Set command status flag to show
  C700 3283ED            LD      (CMDSTATFL),A   ; ..that a shell has been invoked
  C703 1817              JR      READBUF3        ; Store ending zero and exit
  C705           
  C705           USERINPUT:
  C705 CD97C6            CALL    PROMPT          ; Print prompt
  C708 CDF7C5            CALL    PRINT           ; Print prompt trailer
  C70B BE                DEFB    CPRMPT OR 80H
  C70C 0E0A              LD      C,0AH           ; Read command line from user
  C70E 1102EF            LD      DE,BUFSIZ       ; Point to buffer size byte of command line
  C711 CD06CA            CALL    BDOS
  C714           
  C714                                           ; Store null at end of line
  C714           
  C714 2103EF            LD      HL,CHRCNT       ; Point to character count
  C717 7E                LD      A,(HL)          ; ..and get its value
  C718 23                INC     HL              ; Point to first character of command line
  C719 CD1FC7            CALL    ADDAH           ; Make pointer to byte past end of command line
  C71C           READBUF3:
  C71C 3600              LD      (HL),0          ; Store ending zero
  C71E C9                RET
  C71F           
  C71F           ;-----------------------------------------------------------------------------
  C71F           
  C71F           ; Check for any character from the user console.  Return with the character
  C71F           ; in A.  If the character is a control-C, then the zero flag will be set.
  C71F           
  C71F                    IF     SUBON OR DIRON OR ERAON OR LTON
  C71F           
  C71F           BREAK:
  C71F                   LD      C,0BH           ; BDOS console status function
  C71F                   CALL    BDOSSAVE        ; Call BDOS and set flags
  C71F                   CALL    NZ,CONIN        ; Get input character if there is one
  C71F                   CP      'C'-'@'         ; Check for abort
  C71F                   RET
  C71F           
  C71F                    ENDIF  ; subon or diron or eraon or lton
  C71F           
  C71F           ;-----------------------------------------------------------------------------
  C71F           
  C71F           ; Add A to HL (HL=HL+A)
  C71F           
  C71F           ADDAH:
  C71F 85                ADD     A,L
  C720 6F                LD      L,A
  C721 D0                RET     NC
  C722 24                INC     H
  C723 C9                RET
  C724           
  C724           ;-----------------------------------------------------------------------------
ZAS Relocating Macro Assembler (v3.05                             page   85
                                                            
                                                            

  C724           
  C724           ; The routine NUMBER evaluates a string in the first FCB as either a decimal
  C724           ; or, if terminated with the NUMBASE hexadecimal marker, a HEX number.  If the
  C724           ; conversion is successful, the value is returned as a 16-bit quantity in BC.
  C724           ; If an invalid character is encountered in the string, the routine returns
  C724           ; with the carry flag set and HL pointing to the offending character.
  C724           
  C724                    IF     SAVEON
  C724           
  C724           NUMBER:
  C724                   LD      HL,TFCB+8       ; Set pointer to end of number string
  C724                   LD      BC,8            ; Number of characters to scan
  C724                   LD      A,NUMBASE       ; Scan for HEX identifier
  C724                   CPDR                    ; Do the search
  C724                   JR      NZ,DECIMAL      ; Branch if HEX identifier not found
  C724           
  C724                   INC     HL              ; Point to HEX marker
  C724                   LD      (HL),' '        ; Replace HEX marker with valid terminator
  C724                                           ; ..and fall through to HEXNUM
  C724           
  C724                    ENDIF  ;saveon
  C724           
  C724           ;----------------------------------------
  C724           
  C724           ; At this entry point the character string in the first default FCB is
  C724           ; converted as a hexadecimal number (there must NOT be a HEX marker).
  C724           
  C724           HEXNUM:
  C724 215D00            LD      HL,TFCB+1       ; Point to string in first FCB
  C727           
  C727           ; At this entry point the character string pointed to by HL is converted
  C727           ; as a hexadecimal number (there must be NO HEX marker at the end).
  C727           
  C727           HEXNUM1:
  C727 111000            LD      DE,16           ; HEX radix base
  C72A 1806              JR      RADBIN          ; Invoke the generalized conversion routine
  C72C           
  C72C           ;----------------------------------------
  C72C           
  C72C           ; This entry point performs decimal conversion of the string in the first
  C72C           ; default FCB.
  C72C           
  C72C           DECIMAL:
  C72C 215D00            LD      HL,TFCB+1       ; Set pointer to number string
  C72F           
  C72F           ; This entry point performs decimal conversion of the string pointed to
  C72F           ; by HL.
  C72F           
  C72F           DECIMAL1:
  C72F 110A00            LD      DE,10           ; Decimal radix base
  C732                                           ; Fall through to generalized
  C732                                           ; ..radix conversion routine
  C732           
  C732           ; This routine converts the string pointed to by HL using the radix passed in
  C732           ; DE.  If the conversion is successful, the value is returned in BC.  HL points
  C732           ; to the character that terminated the number, and A contains that character.
ZAS Relocating Macro Assembler (v3.05                             page   86
                                                            
                                                            

  C732           ; If an invalid character is encountered, the routine returns with the carry
  C732           ; flag set, and HL points to the offending character.
  C732           
  C732           RADBIN:
  C732 010000            LD      BC,0            ; Initialize result
  C735           RADBIN1:
  C735 B7                OR      A               ; Make sure carry is reset
  C736 CD72C7            CALL    SDELM           ; Test for delimiter (returns Z if delimiter)
  C739 C8                RET     Z               ; Return if delimiter encountered
  C73A           
  C73A D630              SUB     '0'             ; See if less than '0'
  C73C D8                RET     C               ; Return with carry set if so
  C73D FE0A              CP      10              ; See if in range '0'..'9'
  C73F 3805              JR      C,RADBIN2       ; Branch if it is valid
  C741 FE11              CP      'A'-'0'         ; Bad character if < 'A'
  C743 D8                RET     C               ; ..so we return with carry set
  C744 D607              SUB     7               ; Convert to range 10..15
  C746           RADBIN2:
  C746 BB                CP      E               ; Compare to radix in E
  C747 3F                CCF                     ; Carry should be set; this will clear it
  C748 D8                RET     C               ; If carry now set, we have an error
  C749           
  C749 23                INC     HL              ; Point to next character
  C74A C5                PUSH    BC              ; Push the result we are forming onto the stack
  C74B E3                EX      (SP),HL         ; Now HL=result, (sp)=source pointer
  C74C CD58C7            CALL    MPY16           ; HLBC = previous$result * radix
  C74F 2600              LD      H,0             ; Discard high 16 bits and
  C751 6F                LD      L,A             ; ..move current digit into HL
  C752 09                ADD     HL,BC           ; Form new result
  C753 4D                LD      C,L             ; Move it into BC
  C754 44                LD      B,H
  C755 E1                POP     HL              ; Get string pointer back
  C756 18DD              JR      RADBIN1         ; Loop until delimiter
  C758           
  C758           ;-----------------------------------------------------------------------------
  C758           
  C758           ; This routine multiplies the 16-bit values in DE and HL and returns the
  C758           ; 32-bit result in HLBC (HL has high 16 bits; BC has low 16 bits).  Register
  C758           ; pair AF is preserved.
  C758           
  C758           MPY16:
  C758 08                EX      AF,AF'          ; Save AF
  C759 7C                LD      A,H             ; Transfer factor in HL to A and C
  C75A 4D                LD      C,L
  C75B 210000            LD      HL,0            ; Initialize product
  C75E 0610              LD      B,16            ; Set bit counter
  C760 1F                RRA                     ; Shift AC right so first multiplier bit
  C761 CB19              RR      C               ; ..is in carry flag
  C763           MP161:
  C763 3001              JR      NC,MP162        ; If carry not set, skip the addition
  C765 19                ADD     HL,DE           ; Add multiplicand
  C766           MP162:
  C766 CB1C              RR      H               ; Rotate HL right, low bit into carry
  C768 CB1D              RR      L
  C76A 1F                RRA                     ; Continue rotating through AC, with
  C76B CB19              RR      C               ; ..next multiplier bit moving into carry
ZAS Relocating Macro Assembler (v3.05                             page   87
                                                            
                                                            

  C76D 10F4              DJNZ    MP161           ; Loop through 16 bits
  C76F           
  C76F 47                LD      B,A             ; Move A to B so result is in HLBC
  C770 08                EX      AF,AF'          ; Restore original AF registers
  C771 C9                RET
  C772           
  C772           ;-----------------------------------------------------------------------------
  C772           
  C772           ; This routine checks for a delimiter character pointed to by HL.  It returns
  C772           ; with the character in A and the zero flag set if it is a delimiter.  All
  C772           ; registers are preserved except A.
  C772           
  C772           SDELM:
  C772 7E                LD      A,(HL)          ; Get the character
  C773 D9                EXX                     ; Use alternate register set (shorter code)
  C774 217EC7            LD      HL,DELDAT       ; Point to delimiter list
  C777 010A00            LD      BC,DELEND-DELDAT; Length of delimiter list
  C77A EDB1              CPIR                    ; Scan for match
  C77C D9                EXX                     ; Restore registers
  C77D C9                RET                     ; Returns Z if delimiter
  C77E           
  C77E           DELDAT:                         ; List of delimiter characters
  C77E 20                DB      ' '
  C77F 3D                DB      '='
  C780 5F                DB      '_'
  C781 2E                DB      '.'
  C782 3A                DB      ':'
  C783 3B                DB      ';'
  C784 3C                DB      '<'
  C785 3E                DB      '>'
  C786 2C                DB      ','
  C787 00                DB      0
  C788                    IF     CMDSEP NE ';'
  C788                   DB      CMDSEP
  C788                    ENDIF  ;cmdsep ne ';'
  C788           DELEND:
  C788           
  C788           ;-----------------------------------------------------------------------------
  C788           
  C788           ; Log into DU contained in FCB pointed to by DE.  Registers DE are preserved;
  C788           ; all others are changed.  Explicit values for the temporary drive and user
  C788           ; are extracted from the FCB.  If the record-count byte has an FF in it, that
  C788           ; is a signal that the directory specification was invalid.  We then invoke
  C788           ; the error handler.
  C788           
  C788                    IF     DIRON OR ERAON OR LTON OR RENON OR SAVEON
  C788           
  C788           FCBLOG:
  C788                   PUSH    DE              ; Save pointer to FCB
  C788                   EX      DE,HL
  C788                   LD      A,(HL)          ; Get drive
  C788                   LD      BC,13           ; Offset to S1 field
  C788                   ADD     HL,BC
  C788                   LD      C,(HL)          ; Get user into C
  C788                   OR      A               ; See if drive value was 0
  C788                   JR      NZ,FCBLOG1      ; If not, branch ahead
ZAS Relocating Macro Assembler (v3.05                             page   88
                                                            
                                                            

  C788                   LD      A,(CURDR)       ; Otherwise substitute current drive
  C788                   INC     A               ; ..shifted to range 1..16
  C788           FCBLOG1:
  C788                   LD      B,A             ; Get drive into B
  C788                   LD      (TEMPUSR),BC    ; Set up temporary DU values
  C788                   CALL    LOGTEMP         ; ..and log into it
  C788                   POP     DE              ; Restore pointer to FCB
  C788           
  C788           ; Now check to make sure that the directory specification was valid.
  C788           
  C788                   INC     HL              ; Advance pointer to record-count byte
  C788                   INC     HL
  C788                   LD      A,(HL)          ; See if it is nonzero
  C788                   OR      A
  C788                   JP      NZ,BADDIRERR    ; If so, invoke error handler
  C788           
  C788                   RET                     ; Otherwise return
  C788           
  C788                    ENDIF  ;diron or eraon or lton or renon or saveon
  C788           
  C788           ;-----------------------------------------------------------------------------
  C788           
  C788           ; Log into the temporary directory.  Registers B, H, and L are preserved.
  C788           
  C788           LOGTEMP:
  C788 ED5B13C9          LD      DE,(TEMPUSR)    ; Set D = tempdr, E = tempusr
  C78C CD3CC6            CALL    SETUSER1        ; Register D is preserved during this call
  C78F 7A                LD      A,D             ; Move drive into A
  C790 3D                DEC     A               ; Adjust for drive range 0..15
  C791 C322C6            JP      SETDRIVE        ; Log in new drive and return
  C794           
  C794           ;-----------------------------------------------------------------------------
  C794           
  C794           ; This routine scans the command table pointed to by HL for the command name
  C794           ; stored in the command FCB.  If the command is not found, the routine returns
  C794           ; with the zero flag reset.  If the command is found, the address vector is
  C794           ; stored in EXECADR and the zero flag is set.
  C794           
  C794           CMDSCAN:
  C794 46                LD      B,(HL)          ; Get length of each command
  C795 23                INC     HL              ; Point to first command name
  C796           
  C796           SCANNEXT:
  C796 7E                LD      A,(HL)          ; Check for end of table
  C797 B7                OR      A
  C798 2828              JR      Z,SCANEND       ; Branch if end
  C79A           
  C79A 11D1ED            LD      DE,CMDFCB+1     ; Point to name of requested command
  C79D C5                PUSH    BC              ; Save size of commands in table
  C79E           
  C79E                    IF     WHEEL
  C79E                                           ; Ignore commands with high bit set in first
  C79E                                           ; ..char of command name if wheel is false
  C79E                   LD      A,(Z3WHL)       ; Get the wheel byte
  C79E                   OR      A
  C79E                   LD      C,0FFH          ; Make a mask that passes all characters
ZAS Relocating Macro Assembler (v3.05                             page   89
                                                            
                                                            

  C79E                   JR      Z,SCANCMP       ; Use this mask if wheel not set
  C79E           
  C79E                    ENDIF  ; wheel
  C79E           
  C79E 0E7F              LD      C,7FH           ; Use mask to block high bit if wheel set
  C7A0                                           ; ..or not in use
  C7A0           
  C7A0           SCANCMP:
  C7A0 1A                LD      A,(DE)          ; Compare against table entry
  C7A1           
  C7A1 AE                XOR     (HL)
  C7A2 A1                AND     C               ; Mask high bit of comparison
  C7A3 2015              JR      NZ,SCANSKIP     ; No match, so skip rest of command name
  C7A5           
  C7A5 13                INC     DE              ; Advance to next characters to compare
  C7A6 23                INC     HL
  C7A7 CBB9              RES     7,C             ; Mask out high bit on characters after first
  C7A9 10F5              DJNZ    SCANCMP         ; Count down
  C7AB           
  C7AB 1A                LD      A,(DE)          ; See if next character in input command
  C7AC FE20              CP      ' '             ; ..is a space
  C7AE 200D              JR      NZ,SCANBAD      ; If not, user command is longer than commands
  C7B0                                           ; ..in the command table
  C7B0           
  C7B0                                           ; Matching command found
  C7B0           
  C7B0 C1                POP     BC              ; Clear stack
  C7B1 7E                LD      A,(HL)          ; Get address from table into HL
  C7B2 23                INC     HL
  C7B3 66                LD      H,(HL)
  C7B4 6F                LD      L,A
  C7B5 2284C3            LD      (EXECADR),HL    ; Set execution address
  C7B8 AF                XOR     A               ; Set zero flag to show that command found
  C7B9 C9                RET
  C7BA           
  C7BA           SCANSKIP:
  C7BA 23                INC     HL              ; Skip to next command table entry
  C7BB 10FD              DJNZ    SCANSKIP
  C7BD           
  C7BD           SCANBAD:
  C7BD C1                POP     BC              ; Get back size of each command
  C7BE 23                INC     HL              ; Skip over address vector
  C7BF 23                INC     HL
  C7C0 18D4              JR      SCANNEXT        ; Try scanning next entry in table
  C7C2           
  C7C2           SCANEND:
  C7C2 AF                XOR     A               ; Reset zero flag to show
  C7C3 3D                DEC     A               ; ..that command was not found
  C7C4 C9                RET
  C7C5           
  C7C5           ; End ZCPR33-4.Z80
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page   90
                                                            
                                                            

  C7C5                   PAGE
  C7C5           
  C7C5           ; ZCPR33-5.Z80
  C7C5           
  C7C5           ;=============================================================================
  C7C5           ;
  C7C5           ;               R E S I D E N T    C O M M A N D    C O D E
  C7C5           ;
  C7C5           ;=============================================================================
  C7C5           
  C7C5           ; Command:      DIR
  C7C5           ; Function:     To display a directory of the files on disk
  C7C5           ; Forms:
  C7C5           ;       DIR <afn>       Displays the DIR-attribute files
  C7C5           ;       DIR             Same as DIR *.*
  C7C5           ;       DIR <afn> S     Displays the SYS-attribute files
  C7C5           ;       DIR /S          Same as DIR *.* S
  C7C5           ;       DIR <afn> A     Display both DIR and SYS files
  C7C5           ;       DIR /A          Same as DIR *.* A
  C7C5           
  C7C5                    IF     DIRON
  C7C5           
  C7C5           DIR:
  C7C5                   LD      DE,TFCB         ; Point to target FCB
  C7C5                   PUSH    DE              ; ..and save the pointer for later
  C7C5                   INC     DE              ; Point to file name
  C7C5                   LD      A,(DE)          ; Get first character
  C7C5           
  C7C5                    IF     SLASHFL         ; If allowing "DIR /S" and "DIR /A" formats
  C7C5                   CP      '/'             ; If name does not start with '/'
  C7C5                   JR      NZ,DIR1         ; ..branch and process normally
  C7C5                   INC     DE              ; Point to second character
  C7C5                   LD      A,(DE)          ; Get option character after slash
  C7C5                   LD      (TFCB2+1),A     ; ..and put it into second FCB
  C7C5                   DEC     DE              ; Back to first character
  C7C5                   LD      A,' '           ; Simulate empty FCB
  C7C5                    ENDIF  ;slashfl
  C7C5           
  C7C5           DIR1:
  C7C5                   CP      ' '             ; If space, make all wild
  C7C5                   JR      NZ,DIR2
  C7C5                   LD      B,11
  C7C5                   LD      A,'?'
  C7C5                   CALL    FILL
  C7C5           
  C7C5           DIR2:
  C7C5                   POP     DE              ; Restore pointer to FCB
  C7C5                   CALL    FCBLOG          ; Log in the specified directory
  C7C5           
  C7C5                    IF     WHLDIR
  C7C5                   LD      A,(Z3WHL)       ; Check wheel status
  C7C5                   OR      A               ; If not set, then ignore options
  C7C5                   JR      Z,DIR2A
  C7C5                    ENDIF  ;whldir
  C7C5           
  C7C5                   LD      A,(TFCB2+1)     ; Check for any option letter
ZAS Relocating Macro Assembler (v3.05                             page   91
                                                            
                                                            

  C7C5                   LD      B,1             ; Flag for both DIR and SYS files
  C7C5                   CP      ALLCHAR         ; See if all (SYS and DIR) option letter
  C7C5                   JR      Z,DIRPR         ; Branch if so
  C7C5                   DEC     B               ; B = 0 for SYS files only
  C7C5                   CP      SYSCHAR         ; See if SYS-only option letter
  C7C5                   JR      Z,DIRPR         ; Branch if so
  C7C5           DIR2A:
  C7C5                   LD      B,80H           ; Flag for DIR-only selection
  C7C5                                           ; Drop into DIRPR to print directory
  C7C5           
  C7C5                    ENDIF  ; diron
  C7C5           
  C7C5           ;--------------------
  C7C5           
  C7C5           ; Directory display routine
  C7C5           
  C7C5           ; On entry, if attribute checking is required, the B register is
  C7C5           ; set as follows:
  C7C5           ;       00H for SYS files only
  C7C5           ;       80H for DIR files only
  C7C5           ;       01H for both
  C7C5           
  C7C5                    IF     DIRON OR ERAON
  C7C5           
  C7C5           DIRPR:
  C7C5                    IF     DIRON           ; Attribute checking needed only for DIR
  C7C5                   LD      A,B             ; Get flag
  C7C5                   LD      (SYSTST),A      ; Set system test flag
  C7C5                    ENDIF
  C7C5           
  C7C5                   LD      E,0             ; Set column counter to zero
  C7C5                   PUSH    DE              ; Save column counter (E)
  C7C5                   CALL    SRCHFST1        ; Search for specified file (first occurrence)
  C7C5                   JR      NZ,DIR3
  C7C5                   CALL    PRNNF           ; Print no-file message
  C7C5                   POP     DE              ; Restore DE
  C7C5                   XOR     A               ; Set Z to show no files found
  C7C5                   RET
  C7C5           
  C7C5           ; Entry selection loop.  On entering this code, A contains the offset in the
  C7C5           ; directory block as returned by the search-first or search-next call.
  C7C5           
  C7C5           DIR3:
  C7C5                    IF     DIRON           ; Attribute checking needed only for DIR cmd
  C7C5           
  C7C5                   CALL    GETSBIT         ; Get and test for type of files
  C7C5                   JR      Z,DIR6
  C7C5           
  C7C5                    ELSE   ;not diron
  C7C5           
  C7C5                   DEC     A               ; Adjust returned value from 1..4 to 0..3
  C7C5                   RRCA                    ; Multiply by 32 to convert number to
  C7C5                   RRCA                    ; ..offset into TBUFF
  C7C5                   RRCA
  C7C5                   LD      C,A             ; C = offset to entry in TBUFF
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page   92
                                                            
                                                            

  C7C5                    ENDIF  ;diron
  C7C5           
  C7C5                   POP     DE              ; Restore count of
  C7C5                   LD      A,E             ; ..entries displayed
  C7C5                   INC     E               ; Increment entry counter
  C7C5                   PUSH    DE              ; Save it
  C7C5                   AND     03H             ; Output CRLF if 4 entries printed in line
  C7C5                   JR      NZ,DIR4
  C7C5                   CALL    CRLF            ; New line
  C7C5                   JR      DIR5
  C7C5           DIR4:
  C7C5                   CALL    PRINT
  C7C5           
  C7C5                    IF     WIDE
  C7C5           
  C7C5                   DEFB    '  '            ; 2 spaces
  C7C5                   DEFB    FENCE           ; Then fence char
  C7C5                   DEFB    ' ',' '+80h     ; Then 2 more spaces
  C7C5           
  C7C5                    ELSE   ;not wide
  C7C5           
  C7C5                   DEFB    ' '             ; Space
  C7C5                   DEFB    FENCE           ; Then fence char
  C7C5                   DEFB    ' '+80h         ; Then space
  C7C5           
  C7C5                    ENDIF  ; wide
  C7C5           
  C7C5           DIR5:
  C7C5                   LD      A,1
  C7C5                   CALL    DIRPTR          ; HL now points to 1st byte of file name
  C7C5                   CALL    PRFN            ; Print file name
  C7C5           DIR6:
  C7C5                   CALL    BREAK           ; Check for abort
  C7C5                   JR      Z,DIR7
  C7C5                   CALL    SRCHNXT         ; Search for next file
  C7C5                   JR      NZ,DIR3         ; Continue if file found
  C7C5           
  C7C5           DIR7:
  C7C5                   POP     DE              ; Restore stack
  C7C5                   DEC     A               ; Set NZ flag
  C7C5                   RET
  C7C5           
  C7C5                    ENDIF  ; diron or eraon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5                    IF     DIRON OR ATTCHK OR ERAON
  C7C5           
  C7C5           ; This routine returns a pointer in HL to the directory entry in TBUFF that
  C7C5           ; corresponds to the offset specified in registers C (file offset) and C
  C7C5           ; (byte offset within entry).
  C7C5           
  C7C5           DIRPTR:
  C7C5                   LD      HL,TBUFF
  C7C5                   ADD     A,C             ; Add the two offset contributions
  C7C5                   CALL    ADDAH           ; Set pointer to desired byte
ZAS Relocating Macro Assembler (v3.05                             page   93
                                                            
                                                            

  C7C5                   LD      A,(HL)          ; Get the desired byte
  C7C5                   RET
  C7C5           
  C7C5                    ENDIF  ; diron or attchk or eraon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Test File in FCB for existence, ask user to delete if so, and abort if he
  C7C5           ;  choses not to
  C7C5           
  C7C5                    IF     SAVEON OR RENON
  C7C5           
  C7C5           EXTEST:
  C7C5                   LD      DE,TFCB         ; Point to FCB
  C7C5                   PUSH    DE              ; ..and save it for later
  C7C5                   CALL    FCBLOG          ; Log into specified directory
  C7C5                   CALL    SRCHFST1        ; Look for specified file
  C7C5                   POP     DE              ; Restore pointer
  C7C5                   RET     Z               ; OK if not found, so return
  C7C5                   CALL    PRINTC
  C7C5                    IF     BELLFL
  C7C5                   DEFB    BELL
  C7C5                    ENDIF  ;bellfl
  C7C5                   DEFB    'Erase',' '+80h
  C7C5                   LD      HL,TFCB+1       ; Point to file name field
  C7C5                   CALL    PRFN            ; Print it
  C7C5                   CALL    PRINT           ; Add question mark
  C7C5                   DEFB    '?' or 80h
  C7C5                   CALL    CONIN           ; Get user response
  C7C5                   CP      'Y'             ; Test for permission to erase file
  C7C5                   JP      NZ,RESTART      ; If not, flush the entire command line
  C7C5                   JP      DELETE          ; Delete the file
  C7C5           
  C7C5                    ENDIF  ; saveon or renon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Print file name pointed to by HL
  C7C5           
  C7C5                    IF     DIRON OR RENON OR SAVEON
  C7C5           
  C7C5           PRFN:
  C7C5                   LD      B,8             ; Display 8 characters in name
  C7C5                   CALL    PRFN1
  C7C5                   CALL    PRINT           ; Put in dot
  C7C5                   DEFB    '.' or 80h
  C7C5                   LD      B,3             ; Display 3 characters in type
  C7C5           PRFN1:
  C7C5                   LD      A,(HL)          ; Get character
  C7C5                   INC     HL              ; Point to next
  C7C5                   CALL    CONOUT          ; Print character
  C7C5                   DJNZ    PRFN1           ; Loop through them all
  C7C5                   RET
  C7C5           
  C7C5                    ENDIF  ;diron or renon or saveon
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page   94
                                                            
                                                            

  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; This routine returns NZ if the file has the required attributes and Z if
  C7C5           ; it does not.  It works by performing the 'exclusive or' of the mask passed
  C7C5           ; in register A and the filename attribute obtained by masking out all but
  C7C5           ; the highest bit of the character.  For the 'both' case, setting any bit
  C7C5           ; in the mask other than bit 7 will guarantee a nonzero result.
  C7C5           ;
  C7C5           ;       File name: : X 0 0 0  0 0 0 0   (After 80H mask, X=1 if SYS, 0 if DIR)
  C7C5           ;
  C7C5           ;       SYS-ONLY   : 0 0 0 0  0 0 0 0   (XOR gives 00H if X=0 and 80H if X=1)
  C7C5           ;       DIR-ONLY   : 1 0 0 0  0 0 0 0   (XOR gives 80H if X=0 and 00H if X=1)
  C7C5           ;       BOTH       : 0 0 0 0  0 0 0 1   (XOR gives 01H if X=0 and 81H if X=1)
  C7C5           
  C7C5                    IF     DIRON OR ATTCHK
  C7C5           
  C7C5           GETSBIT:
  C7C5                   DEC     A               ; Adjust to returned value from 1..4 to 0..3
  C7C5                   RRCA                    ; Multiply by 32 to convert number to
  C7C5                   RRCA                    ; ..offset into TBUFF
  C7C5                   RRCA
  C7C5                   LD      C,A             ; Save offset in TBUFF in C
  C7C5                   LD      A,10            ; Add 10 to point to SYS attribute bit
  C7C5                   CALL    DIRPTR          ; A = SYS byte
  C7C5                   AND     80H             ; Look only at attribute bit
  C7C5           SYSTST  EQU     $+1             ; In-the-code variable
  C7C5                   XOR     0               ; If SYSTST=0, SYS only; if SYSTST=80H, DIR
  C7C5                                           ; ..only; if SYSTST=1, both SYS and DIR
  C7C5                   RET                     ; NZ if OK, Z if not OK
  C7C5           
  C7C5                    ENDIF  ;diron or attchk
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Command:      REN
  C7C5           ; Function:     To change the name of an existing file
  C7C5           ; Forms:        REN <New UFN>=<Old UFN>
  C7C5           ; Notes:        If either file spec is ambiguous, or if the source file does
  C7C5           ;               not exist, the error handler will be entered.  If a file with
  C7C5           ;               the new name already exists, the user is prompted for deletion
  C7C5           ;               and ZEX is turned off during the prompt.
  C7C5           
  C7C5                    IF     RENON
  C7C5           
  C7C5           REN:
  C7C5                   LD      HL,TFCB         ; Check for ambiguity in first file name
  C7C5                   CALL    AMBCHK
  C7C5                   CALL    FCBLOG          ; Login to fcb
  C7C5                   LD      HL,TFCB2        ; Check for ambiguity in second file name
  C7C5                   CALL    AMBCHK
  C7C5                   XOR     A               ; Use current drive for 2nd file
  C7C5                   LD      (DE),A
  C7C5                   CALL    SRCHFST         ; Check for old file's existence
  C7C5                   JR      NZ,REN0A        ; Branch if file exists
  C7C5           JPNOFILE:
  C7C5                   LD      A,ECNOFILE      ; Set error code for file not found
ZAS Relocating Macro Assembler (v3.05                             page   95
                                                            
                                                            

  C7C5                   JP      ERROR           ; ..and invoke error handler
  C7C5           REN0A:
  C7C5                   CALL    EXTEST          ; Test for file existence and return if not
  C7C5                   LD      B,12            ; Exchange new and old file names
  C7C5                   PUSH    DE              ; Save pointer to FCB
  C7C5                   LD      HL,TFCB2        ; Point to FCB for old file name
  C7C5           REN0:
  C7C5                   LD      A,(DE)          ; Get character of old name
  C7C5                   LD      C,A             ; ..into C register
  C7C5                   LD      A,(HL)          ; Get character of new name
  C7C5                   LD      (DE),A          ; ..into place in old name
  C7C5                   LD      (HL),C          ; Put character of old name into new name
  C7C5                   INC     HL              ; Advance pointers
  C7C5                   INC     DE
  C7C5                   DJNZ    REN0
  C7C5           
  C7C5           ; Perform rename function
  C7C5           
  C7C5                   POP     DE              ; Restore pointer to FCB
  C7C5                   LD      C,17H           ; BDOS rename function
  C7C5                   JP      BDOSTEST
  C7C5           
  C7C5                    ENDIF  ;renon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Command:      ERA
  C7C5           ; Function:     Erase files
  C7C5           ; Forms:
  C7C5           ;       ERA <afn>       Erase specified files and dislay their names
  C7C5           ;       ERA <afn> I     Display names of files to be erased and prompt for
  C7C5           ;                       inspection before erase is performed. (Character 'I'
  C7C5           ;                       is defined by INSPCH in Z33HDR.LIB; if it is ' ', then
  C7C5           ;                       any character triggers inspection.)
  C7C5           
  C7C5                    IF     ERAON
  C7C5           
  C7C5           ERA:
  C7C5                    IF     INSPFL AND ERAOK; 'I' flag and verification enabled?
  C7C5                   LD      A,(TFCB2+1)     ; Get flag, if any, entered by user
  C7C5                   LD      (ERAFLG),A      ; Save it in code below
  C7C5                    ENDIF  ;erav and eraok
  C7C5           
  C7C5                   LD      DE,TFCB         ; Point to target FCB
  C7C5                   CALL    FCBLOG          ; ..and log into the specified directory
  C7C5           
  C7C5                    IF     DIRON OR ATTCHK ; Attribute checking only in these cases
  C7C5                   LD      B,1             ; Display all matching files
  C7C5                    ENDIF  ;diron or attchk
  C7C5           
  C7C5                   CALL    DIRPR           ; Print directory of erased files
  C7C5                   RET     Z               ; Abort if no files
  C7C5           
  C7C5                    IF     ERAOK           ; Print prompt
  C7C5           
  C7C5                    IF     INSPFL          ; Test verify flag
ZAS Relocating Macro Assembler (v3.05                             page   96
                                                            
                                                            

  C7C5           
  C7C5           ERAFLG  EQU     $+1             ; Address of flag (in-the-code modification)
  C7C5                   LD      A,0
  C7C5                   CP      INSPCH          ; Is it an inspect option?
  C7C5           
  C7C5                    IF     INSPCH NE ' '   ; If an explicit inspect character is specified
  C7C5                   JR      NZ,ERA2         ; ..skip prompt if it is not that character
  C7C5                    ELSE                   ; If INSPCH is the space character
  C7C5                   JR      Z,ERA2          ; ..then skip prompt only if FCB has a space
  C7C5                    ENDIF  ;inspch ne ' '
  C7C5           
  C7C5                    ENDIF  ;inspfl
  C7C5           
  C7C5                   CALL    PRINTC
  C7C5                   DEFB    'OK to Erase','?'+80h
  C7C5                   CALL    CONIN           ; Get reply
  C7C5                   CP      'Y'             ; Yes?
  C7C5                   RET     NZ              ; Abort if not
  C7C5           
  C7C5                    ENDIF  ; eraok
  C7C5           
  C7C5           ERA2:
  C7C5                   LD      DE,TFCB
  C7C5                   JP      DELETE          ; Delete files and return
  C7C5           
  C7C5                    ENDIF                  ; Eraon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Command:      LIST
  C7C5           ; Function:     Print out specified file on the LST: device
  C7C5           ; Forms:        LIST <ufn>      Print file (No Paging)
  C7C5           ; Notes:        The flags which apply to TYPE do not take effect with LIST
  C7C5           
  C7C5                    IF     LTON
  C7C5           
  C7C5           LIST:
  C7C5                   LD      A,0FFH          ; Turn on printer flag
  C7C5                   JR      TYPE0
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5           ; Command:      TYPE
  C7C5           ; Function:     Print out specified file on the CON: Device
  C7C5           ; Forms:        TYPE <ufn>      Print file with default paging option
  C7C5           ;               TYPE <ufn> P    Print file with paging option reversed
  C7C5           
  C7C5           TYPE:
  C7C5                   XOR     A               ; Turn off printer flag
  C7C5           
  C7C5           ; Common entry point for LIST and TYPE functions
  C7C5           
  C7C5           TYPE0:
  C7C5                   LD      (PRFLG),A       ; Set printer/console flag
  C7C5                   LD      A,(TFCB2+1)     ; Check for user page toggle ('P') option
  C7C5                   LD      (PGFLG),A       ; Save it as a flag in code below
ZAS Relocating Macro Assembler (v3.05                             page   97
                                                            
                                                            

  C7C5                   LD      HL,TFCB         ; Point to target file FCB
  C7C5                   CALL    AMBCHK          ; Check for ambiguous file spec (vectors to
  C7C5                                           ; ..error handler if so)
  C7C5                   CALL    FCBLOG          ; Log into specified directory
  C7C5                   CALL    OPEN            ; Open the file
  C7C5           
  C7C5                    IF     RENON           ; If REN on, share code
  C7C5                   JR      Z,JPNOFILE
  C7C5                    ELSE   ;not renon      ; Otherwise repeat code here
  C7C5                   LD      A,ECNOFILE
  C7C5                   JP      Z,ERROR
  C7C5                    ENDIF  ;renon
  C7C5           
  C7C5                   CALL    CRLF            ; New line
  C7C5                   LD      A,(CRTTXT0)     ; Set line count using value from the
  C7C5                                           ; ..environment for CRT0
  C7C5                   INC     A               ; One extra the first time through
  C7C5                   LD      (PAGCNT),A
  C7C5                   LD      BC,080H         ; Set character position and tab count
  C7C5                                           ; (B = 0 = tab, C = 080h = char position)
  C7C5           
  C7C5           ; Main loop for loading next block
  C7C5           
  C7C5           TYPE2:
  C7C5                   LD      A,C             ; Get character count
  C7C5                   CP      80H             ; If not end of disk record
  C7C5                   JR      C,TYPE3         ; ..then skip
  C7C5           
  C7C5                   CALL    READF           ; Read next record of file
  C7C5                   RET     NZ              ; Quit if end of file
  C7C5           
  C7C5                   LD      C,0             ; Reset character count
  C7C5                   LD      HL,TBUFF        ; Point to first character
  C7C5           
  C7C5           ; Main loop for printing characters in TBUFF
  C7C5           
  C7C5           TYPE3:
  C7C5                   LD      A,(HL)          ; Get next character
  C7C5                   AND     7FH             ; Mask out MSB
  C7C5                   CP      1AH             ; Check for end of file (^z)
  C7C5                   RET     Z               ; Quit if so
  C7C5           
  C7C5           ; Output character to CON: or LST: device with tabulation
  C7C5           
  C7C5                   CP      CR              ; If carriage return,
  C7C5                   JR      Z,TYPE4         ; ..branch to reset tab count
  C7C5                   CP      LF              ; If line feed, then output
  C7C5                   JR      Z,TYPE4A        ; ..with no change in tab count
  C7C5                   CP      TAB             ; If tab
  C7C5                   JR      Z,TYPE5         ; ..expand to spaces
  C7C5           
  C7C5           ; Output character and increment character count
  C7C5           
  C7C5                   CALL    LCOUT           ; Output character
  C7C5                   INC     B               ; Increment tab count
  C7C5                   JR      TYPE6
ZAS Relocating Macro Assembler (v3.05                             page   98
                                                            
                                                            

  C7C5           
  C7C5           ; Output CR and reset tab count
  C7C5           
  C7C5           TYPE4:
  C7C5                   LD      B,0             ; Reset tab counter
  C7C5           
  C7C5           ; Output LF and leave tab count as is
  C7C5           
  C7C5           TYPE4A:
  C7C5                   CALL    LCOUT           ; Output <cr> or <lf>
  C7C5                   JR      TYPE6
  C7C5           
  C7C5           ; Process tab character
  C7C5           
  C7C5           TYPE5:
  C7C5                   LD      A,' '           ; Space
  C7C5                   CALL    LCOUT
  C7C5                   INC     B               ; Increment tab count
  C7C5                   LD      A,B
  C7C5                   AND     7
  C7C5                   JR      NZ,TYPE5        ; Loop until column = n * 8 + 7
  C7C5           
  C7C5           ; Continue processing
  C7C5           
  C7C5           TYPE6:
  C7C5                   INC     C               ; Increment character count
  C7C5                   INC     HL              ; Point to next character
  C7C5                   PUSH    BC
  C7C5                   CALL    BREAK           ; Check for user abort
  C7C5                   POP     BC
  C7C5                   RET     Z               ; Quit if so
  C7C5                   JR      TYPE2           ; Else back for more
  C7C5           
  C7C5           ;--------------------
  C7C5           
  C7C5           ; Output character in A to console or list device depending on a flag.
  C7C5           ; Registers are preserved.  This code is used only by the LIST and TYPE
  C7C5           ; commands.
  C7C5           
  C7C5           LCOUT:
  C7C5                   PUSH    AF              ; Save character
  C7C5           PRFLG   EQU     $+1             ; Pointer for in-the-code modification
  C7C5                   LD      A,0             ; ..to determine destination (CON or LST)
  C7C5                   OR      A               ; Z=type, NZ=list
  C7C5                   JR      Z,LC1
  C7C5           
  C7C5                                           ; Output to list device
  C7C5           
  C7C5                   POP     AF              ; Get character back
  C7C5                   PUSH    DE
  C7C5                   PUSH    BC
  C7C5                   LD      C,5             ; LISTOUT function
  C7C5                   JP      OUTPUT
  C7C5           
  C7C5                                           ; Output to console with paging
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page   99
                                                            
                                                            

  C7C5           LC1:
  C7C5                   POP     AF              ; Get character back
  C7C5                   PUSH    AF              ; Save it again for page check
  C7C5                   CALL    CONOUT          ; Output to console
  C7C5                   POP     AF              ; Get character back again
  C7C5                   CP      LF              ; Check for new line (paging)
  C7C5                   RET     NZ              ; If not new line, we are done
  C7C5           
  C7C5                                           ; Paging routines
  C7C5           
  C7C5           PAGER:
  C7C5                   PUSH    HL
  C7C5                   LD      HL,PAGCNT       ; Decrement lines remaining on screen
  C7C5                   DEC     (HL)
  C7C5                   JR      NZ,PAGER1       ; Jump if not end of page
  C7C5           
  C7C5                                           ; New page
  C7C5                   LD      A,(CRTTXT0)     ; Get full page count from environment
  C7C5                   LD      (HL),A          ; Reset count to a full page
  C7C5           PGFLG   EQU     $+1             ; Pointer to in-the-code buffer pgflg
  C7C5                   LD      A,0
  C7C5                   CP      PAGECH          ; Page default override option wanted?
  C7C5           
  C7C5                    IF     PAGECH NE ' '   ; If using explicit character for page toggle
  C7C5           
  C7C5                    IF     PAGEFL          ; If paging is default
  C7C5                   JR      Z,PAGER1        ; ..PAGECH means no paging
  C7C5                    ELSE                   ; If paging not default
  C7C5                   JR      NZ,PAGER1       ; ..PAGECH means please paginate
  C7C5                    ENDIF  ;pagefl
  C7C5           
  C7C5                    ELSE                   ; Any character toggles paging
  C7C5           
  C7C5                    IF     PAGEFL          ; If paging is default
  C7C5                   JR      NZ,PAGER1       ; ..any character means no paging
  C7C5                    ELSE                   ; If paging not default
  C7C5                   JR      Z,PAGER1        ; ..any character means please paginate
  C7C5                    ENDIF  ;pagefl
  C7C5           
  C7C5                    ENDIF  ;pagech ne ' '
  C7C5           
  C7C5                                           ; End of page
  C7C5                   PUSH    BC
  C7C5                   CALL    BIOS+9          ; Wait for user input (BIOS console input)
  C7C5                   POP     BC
  C7C5                   CP      'C'-'@'         ; Did user enter control-c?
  C7C5                   JP      Z,NEXTCMD       ; If so, terminate this command
  C7C5           
  C7C5           PAGER1:
  C7C5                   POP     HL              ; Restore HL
  C7C5                   RET
  C7C5           
  C7C5                    ENDIF  ; lton
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page  100
                                                            
                                                            

  C7C5           ; Command: SAVE
  C7C5           ; Function:  To save the contents of the TPA onto disk as a file
  C7C5           ; Forms:
  C7C5           ;       SAVE <Number of Pages> <ufn>
  C7C5           ;               Save specified number of pages (starting at 100H) from TPA
  C7C5           ;               into specified file
  C7C5           ;
  C7C5           ;       SAVE <Number of Sectors> <ufn> <S>
  C7C5           ;               Like SAVE above, but numeric argument specifies
  C7C5           ;               number of sectors rather than pages
  C7C5           
  C7C5                    IF     SAVEON
  C7C5           
  C7C5           ; Entry point for SAVE command
  C7C5           
  C7C5           SAVE:
  C7C5                   CALL    NUMBER          ; Extract number from command line
  C7C5                   JR      C,BADNUMBER     ; Invoke error handler if bad number
  C7C5                   PUSH    BC              ; Save the number
  C7C5                   CALL    REPARSE         ; Reparse tail after number of sectors/pages
  C7C5                   POP     HL              ; Get sector/page count back into HL
  C7C5                   LD      A,(TFCB2+1)     ; Check sector flag in second FCB
  C7C5                   CP      SECTCH
  C7C5           
  C7C5                    IF     SECTCH NE ' '   ; If using a specific character, then jump
  C7C5                   JR      Z,SAVE0         ; ..if it is that character
  C7C5                    ELSE                   ; If allowing any character (SECTCH=' ')
  C7C5                   JR      NZ,SAVE0        ; ..jump if it is anything other than space
  C7C5                    ENDIF  ;sectch ne ' '
  C7C5           
  C7C5                   ADD     HL,HL           ; Double page count to get sector count
  C7C5           SAVE0:
  C7C5                   LD      A,1             ; Maximum allowed value in H
  C7C5                   CP      H               ; Make sure sector count < 512 (64K)
  C7C5                   JR      C,BADNUMBER     ; If >511, invoke error handler
  C7C5           
  C7C5                   PUSH    HL              ; Save sector count
  C7C5                   LD      HL,TFCB
  C7C5                   CALL    AMBCHK          ; Check for ambiguous file spec (vectors to
  C7C5                                           ; ..error handler if so)
  C7C5           
  C7C5                   CALL    EXTEST          ; Test for existence of file and abort if so
  C7C5                   LD      C,16H           ; BDOS make file function
  C7C5                   CALL    BDOSTEST
  C7C5                   JR      Z,SAVE3         ; Branch if error in creating file
  C7C5           
  C7C5                   POP     BC              ; Get sector count into BC
  C7C5                   LD      HL,TPA-80H      ; Set pointer to one record before TPA
  C7C5           
  C7C5           SAVE1:
  C7C5                   LD      A,B             ; Check for BC = 0
  C7C5                   OR      C
  C7C5                   DEC     BC              ; Count down on sectors (flags unchanged,
  C7C5                                           ; ..B=0FFH if all records written successfully)
  C7C5                   JR      Z,SAVE2         ; If BC=0, save is done so branch
  C7C5           
ZAS Relocating Macro Assembler (v3.05                             page  101
                                                            
                                                            

  C7C5                   PUSH    BC              ; Save sector count
  C7C5                   LD      DE,80H          ; Advance address by one record
  C7C5                   ADD     HL,DE
  C7C5                   PUSH    HL              ; Save address on stack
  C7C5                   EX      DE,HL           ; Put address into DE for BDOS call
  C7C5                   CALL    DMASET          ; Set DMA address for write
  C7C5                   LD      DE,TFCB         ; Write sector
  C7C5                   LD      C,15H           ; BDOS write sector function
  C7C5                   CALL    BDOSSAVE
  C7C5                   POP     HL              ; Get address back into HL
  C7C5                   POP     BC              ; Get sector count back into BC
  C7C5                   JR      Z,SAVE1         ; If write successful, go back for more
  C7C5           
  C7C5                   LD      B,0             ; B=0 if write failed
  C7C5           
  C7C5           SAVE2:
  C7C5                   CALL    CLOSE           ; Close file even if last write failed
  C7C5                   AND     B               ; Combine close return code with
  C7C5                                           ; ..write success flag
  C7C5                   RET     NZ              ; Return if all ok
  C7C5           
  C7C5           SAVE3:                          ; Disk must be full
  C7C5                   LD      A,ECDISKFULL    ; Disk full error code
  C7C5                   JR      JPERROR
  C7C5           
  C7C5                    ENDIF  ; saveon
  C7C5           
  C7C5           ;-----------------------------------------------------------------------------
  C7C5           
  C7C5                    IF     LTON OR SAVEON OR RENON OR GETON
  C7C5           
  C7C5           ; Check file control block pointed to by HL for any wildcard characters ('?').
  C7C5           ; Return to calling program if none found.  Otherwise branch to error handler.
  C7C5           ; The routine also treats an empty file name as ambiguous.
  C7C5           
  C7C5           AMBCHK:
  C7C5 E5                PUSH    HL              ; Save pointer to FCB
  C7C6 23                INC     HL              ; Point to first character in file name
  C7C7 7E                LD      A,(HL)          ; See if first character is a space
  C7C8 FE20              CP      ' '
  C7CA 2809              JR      Z,AMBCHK1       ; If so, branch to error return
  C7CC           
  C7CC 3E3F              LD      A,'?'           ; Set up for scan for question mark
  C7CE 010B00            LD      BC,11           ; Scan 11 characters
  C7D1 EDB1              CPIR
  C7D3 D1                POP     DE              ; Restore pointer to FCB in DE
  C7D4 C0                RET     NZ              ; Return if no '?' found
  C7D5           AMBCHK1:
  C7D5 3E08              LD      A,ECAMBIG       ; Error code for ambiguous file name
  C7D7 1802              JR      JPERROR
  C7D9           
  C7D9                    ENDIF  ;lton or renon or saveon or geton
  C7D9           
  C7D9                    IF     LTON OR RENON OR SAVEON OR GETON OR JUMPON
  C7D9           
  C7D9           BADNUMBER:
ZAS Relocating Macro Assembler (v3.05                             page  102
                                                            
                                                            

  C7D9 3E09              LD      A,ECBADNUM      ; Error code for bad number value
  C7DB           JPERROR:                        ; Local entry point for relative jump
  C7DB C38AC3            JP      ERROR           ; ..to go to error handler
  C7DE           
  C7DE                    ENDIF  ;lton or renon or saveon or geton or jumpon
  C7DE           
  C7DE           ;-----------------------------------------------------------------------------
  C7DE           
  C7DE           ; Command:      JUMP
  C7DE           ; Function:     To execute a program already loaded into some specified memory
  C7DE           ;               address
  C7DE           ; Forms:        JUMP <adr> <tail>
  C7DE           ;               The address is in hex; the tail will be parsed as usual
  C7DE           
  C7DE                    IF     JUMPON
  C7DE           
  C7DE           JUMP:
  C7DE CD24C7            CALL    HEXNUM          ; Get load address into BC
  C7E1 38F6              JR      C,BADNUMBER     ; If bad number, invoke error handling
  C7E3 C5                PUSH    BC              ; ..and save it
  C7E4 CD10C2            CALL    REPARSE         ; Reparse tail after address value
  C7E7 E1                POP     HL              ; Restore execution address to HL
  C7E8 1803              JR      GETPROGLF       ; Perform call via code below
  C7EA           
  C7EA                    ENDIF  ;jumpon
  C7EA           
  C7EA           ;-----------------------------------------------------------------------------
  C7EA           
  C7EA           ; Command:      GO
  C7EA           ; Function:     To Call the program in the TPA without loading
  C7EA           ;               loading from disk. Same as JUMP 100H, but much
  C7EA           ;               more convenient, especially when used with
  C7EA           ;               parameters for programs like STAT. Also can be
  C7EA           ;               allowed on remote-access systems with no problems.
  C7EA           ;
  C7EA           ;Form:          GO <tail>
  C7EA           
  C7EA                    IF     GOON
  C7EA           
  C7EA           GO:
  C7EA 210001            LD      HL,TPA          ; Set up TPA as the execution address
  C7ED           
  C7ED                    ENDIF  ; goon
  C7ED           
  C7ED                    IF     JUMPON OR GOON  ; Common code
  C7ED           
  C7ED           GETPROGLF:
  C7ED 2284C3            LD      (EXECADR),HL
  C7F0 AF                XOR     A               ; Set zero flag to enable leading CRLF
  C7F1 C345C3            JP      CALLPROGLF      ; Perform call (with leading CRLF)
  C7F4           
  C7F4                    ENDIF  ;jumpon or goon
  C7F4           
  C7F4           ;-----------------------------------------------------------------------------
  C7F4           
  C7F4           ; Command:      GET
ZAS Relocating Macro Assembler (v3.05                             page  103
                                                            
                                                            

  C7F4           ; Function:     To load the specified file from disk to the specified address
  C7F4           ; Forms:        GET <adr> <ufn>
  C7F4           ;               Loads the specified file to the specified hexadecimal address
  C7F4           ;               Note that the normal file search path is used to find the file.
  C7F4           ;               If SCANCUR is off, the file may not be found in the current
  C7F4           ;               directory unless a colon is included in the file spec.
  C7F4           
  C7F4                    IF     GETON
  C7F4           
  C7F4           GET:
  C7F4           
  C7F4           ; TMPCOLON was set when the file name was parsed.  We use that as the colon
  C7F4           ; flag so that the file will be loaded from a directory just as if it had
  C7F4           ; been entered as the command name.
  C7F4           
  C7F4                    IF     DRVPREFIX AND [NOT SCANCUR]
  C7F4 3A0FC4            LD      A,(TMPCOLON)    ; Allow GET to load from specified
  C7F7 32FFC2            LD      (COLON),A       ; directory
  C7FA                    ENDIF  ;drvprefix and [not scancur]
  C7FA           
  C7FA 216C00            LD      HL,TFCB2        ; Copy TFCB2 to CMDFCB for load
  C7FD E5                PUSH    HL
  C7FE 11D0ED            LD      DE,CMDFCB
  C801 010E00            LD      BC,14
  C804 EDB0              LDIR
  C806 E1                POP     HL
  C807 CDC5C7            CALL    AMBCHK          ; Make sure file is not ambiguous (vectors
  C80A                                           ; ..to error handler if so)
  C80A           
  C80A           ; If GET fails to find the specified file along the search path, we do not
  C80A           ; want the ECP to be engaged.  To prevent that, we fool the command processor
  C80A           ; by telling it that the ECP is already engaged.
  C80A           
  C80A 2183ED            LD      HL,CMDSTATFL    ; Point to command status flag
  C80D CBD6              SET     2,(HL)          ; Turn on ECP flag to prevent use of ECP
  C80F CD24C7            CALL    HEXNUM          ; Get load address into BC
  C812 38C5              JR      C,BADNUMBER     ; If invalid number, invoke error handler
  C814           
  C814                    IF     NOT FULLGET
  C814                   LD      A,B             ; If trying to load into base page
  C814                   OR      A               ; ..treat as error
  C814                   JR      Z,BADNUMBER
  C814                    ENDIF  ;not fullget
  C814           
  C814 60                LD      H,B             ; Move address into HL
  C815 69                LD      L,C
  C816 3EFF              LD      A,0FFH          ; Disable dynamic loading
  C818                                           ; Fall through to mload
  C818           
  C818                    ENDIF  ; geton
  C818           
  C818           ; End ZCPR33-5.Z80
  C818           
ZAS Relocating Macro Assembler (v3.05                             page  104
                                                            
                                                            

  C818                   PAGE
  C818           
  C818           ; ZCPR33-6.Z80
  C818           
  C818           ;=============================================================================
  C818           ;
  C818           ;   P A T H    S E A R C H    A N D    F I L E    L O A D I N G    C O D E
  C818           ;
  C818           ;=============================================================================
  C818           
  C818           ; This block of code loads a file into memory.  The normal address at which
  C818           ; loading is to begin is passed to the routine in the HL register.  The name
  C818           ; of the file to load is passed in the command file control block.
  C818           ;
  C818           ; This code supports an advanced option that loads files to a dynamic address
  C818           ; specified in the header to the file using a new type-3 environment.  In a
  C818           ; type-3 environment, the execution/load address is stored in the word
  C818           ; following the environment descriptor address.  A value is passed to MLOAD in
  C818           ; the A register that controls this dynamic loading mechanism.  The value
  C818           ; specifies the lowest environment type value for which dynamic loading will
  C818           ; be performed.  This value will be 3 when MLOAD is called for normal COM file
  C818           ; execution and will be 0FFH when chained to from the GET command.  In the
  C818           ; latter case, the user-specified load address must be used.
  C818           ;
  C818           ; MLOAD guards against loading a file over the operating system.  It computes
  C818           ; the lower of the following two addresses: 1) the CPR entry point; 2) the
  C818           ; bottom of protected memory as indicated by the DOS entry address stored at
  C818           ; address 0006H.  If the load would exceed this limit, error handling is
  C818           ; engaged (except for the GET command when FULLGET is enabled).
  C818           
  C818           MLOAD:
  C818 32DBC8            LD      (ENVTYPE),A     ; Set up in-the-code modification below
  C81B 2284C3            LD      (EXECADR),HL    ; Set up execution/load address
  C81E CD1BC6            CALL    DEFLTDMA        ; Set DMA address to 80H for file searches
  C821           
  C821           
  C821           ; This code sets the attributes of COM files which are acceptable.  If both
  C821           ; SYS and DIR type files are acceptable, there is no need to include this code,
  C821           ; and ATTCHK can be set to false.
  C821           
  C821                    IF     ATTCHK          ; Only if attribute checking enabled
  C821                   LD      A,COMATT        ; Attributes specified in Z33HDR.LIB
  C821                   LD      (SYSTST),A      ; Set flag
  C821                    ENDIF  ;attchk
  C821           
  C821           ;-----------------------------------------------------------------------------
  C821           
  C821           ; PATH BUILDING CODE
  C821           
  C821           ; In ZCPR33 the minpath feature, optional in ZCPR30, is always used.  To
  C821           ; minimize the size of the CPR code, however, there is an option to place the
  C821           ; minpath in an external buffer (outside the CPR).  If the path is short
  C821           ; enough, the minpath can be placed at the bottom of the system stack.
  C821           
  C821 11F4ED            LD      DE,PATH         ; Point to first element in user's symbolic path
  C824 21D0EF            LD      HL,MPATH        ; Point to minpath buffer
ZAS Relocating Macro Assembler (v3.05                             page  105
                                                            
                                                            

  C827 AF                XOR     A
  C828 77                LD      (HL),A          ; Initialize to empty minpath
  C829           
  C829           
  C829           ; If DRVPREFIX is enabled, the CPR will recognize an explicit directory
  C829           ; reference in a command.  The first element of the path will then be this
  C829           ; explicit directory.  If no explicit directory was given in the command,
  C829           ; then no entry is made into the search path.  If the WPREFIX option is
  C829           ; on, explicit directory prefixes will be recognized only when the wheel
  C829           ; byte is on.
  C829           
  C829                    IF     DRVPREFIX       ; Pay attention to du:com prefix?
  C829           
  C829 3AFFC2            LD      A,(COLON)       ; See if colon was present in command
  C82C B7                OR      A
  C82D 280C              JR      Z,MAKEPATH2     ; If not, skip ahead
  C82F           
  C82F                    IF     WPREFIX
  C82F                   LD      A,(Z3WHL)       ; See if wheel byte is on
  C82F                   OR      A
  C82F                   JR      Z,MAKEPATH2     ; If not, skip ahead
  C82F                    ENDIF  ;wprefix
  C82F           
  C82F 3AD0ED            LD      A,(CMDFCB)      ; Get drive from command FCB
  C832 77                LD      (HL),A          ; Put drive into minpath
  C833 23                INC     HL              ; Advance pointer
  C834 3ADDED            LD      A,(CMDFCB+13)   ; Get user number from command FCB
  C837 77                LD      (HL),A          ; Put it into minpath
  C838 23                INC     HL              ; Advance pointer to next path element
  C839 AF                XOR     A               ; A=0
  C83A 77                LD      (HL),A          ; Store ending 0 in mpath
  C83B           MAKEPATH2:
  C83B                    ENDIF  ; drvprefix
  C83B           
  C83B           
  C83B           ; If SCANCUR is enabled in Z33HDR.LIB, then we always include the current
  C83B           ; directory automatically, even without a '$$' element in the user's path.
  C83B           ; If WPREFIX is enabled, however, we do not want to allow the current
  C83B           ; directory to be included, but we must make sure that it is included in
  C83B           ; the building of the root path, in case the user's symbolic path is empty.
  C83B           
  C83B                    IF     SCANCUR         ; Scan current directory at all times?
  C83B           
  C83B                   LD      BC,(CURUSR)     ; C = current user, B = current drive
  C83B                   INC     B               ; Set drive to range 1..16
  C83B           
  C83B                    IF     WPREFIX
  C83B           
  C83B                   LD      A,(Z3WHL)       ; See if wheel byte is on
  C83B                   OR      A
  C83B                   JR      NZ,ADDPATH      ; If it is, add element to path; if not,
  C83B                                           ; ..fall through to MAKEPATH3
  C83B                    ELSE   ;not wprefix
  C83B           
  C83B                   JR      ADDPATH         ; Begin loop of placing entries into mpath
  C83B           
ZAS Relocating Macro Assembler (v3.05                             page  106
                                                            
                                                            

  C83B                    ENDIF  ;wprefix
  C83B           
  C83B                    ELSE   ;not scancur
  C83B           
  C83B           ; If SCANCUR is off and ROOTONLY is in effect, we have to make sure that some
  C83B           ; directory values are put into the root path in the case where the user's
  C83B           ; path is completely empty.  To do so, we preset BC for directory A0.
  C83B           
  C83B                    IF     ROOTONLY
  C83B 010001            LD      BC,0100H        ; Setup for drive A (B=1), user 0 (C=0)
  C83E                    ENDIF  ;rootonly
  C83E           
  C83E                    ENDIF  ;scancur
  C83E           
  C83E           
  C83E           ; Convert symbolic entries in user's path into absolute DU values in minpath.
  C83E           ; Entries are read one-by-one from the symbolic path.  If the 'current' drive
  C83E           ; or user indicator is present (default symbol is '$'), then the current
  C83E           ; drive or user value is fetched.  Otherwise the explicit binary value from the
  C83E           ; path is used.  After each absolute DU value is formed, the minpath as it
  C83E           ; exists so far is scanned to see if this DU value is already there.  If it is
  C83E           ; not, then the DU value is appended to the path.  Otherwise it is ignored.
  C83E           
  C83E           MAKEPATH3:
  C83E 1A                LD      A,(DE)          ; Get next symbolic path entry
  C83F B7                OR      A               ; If 0, we are at end of path
  C840 2831              JR      Z,MAKEPATH6
  C842           
  C842 ED4BAEED          LD      BC,(CURUSR)     ; C = current user, B = current drive
  C846 04                INC     B               ; Set drive to range 1..16
  C847 FE24              CP      CURIND          ; Check for current drive symbol (default '$')
  C849 2801              JR      Z,MAKEPATH4     ; If so, leave current drive in B
  C84B 47                LD      B,A             ; Else move specified drive into B
  C84C           MAKEPATH4:
  C84C 13                INC     DE              ; Point to user value in symbolic path
  C84D 1A                LD      A,(DE)          ; Get user
  C84E 13                INC     DE              ; Point to next element in symbolic path
  C84F FE24              CP      CURIND          ; Check for current user symbol (default '$')
  C851 2801              JR      Z,MAKEPATH5     ; If so, leave current drive in C
  C853 4F                LD      C,A             ; Else move specified user into C
  C854           MAKEPATH5:
  C854           
  C854           ; At this point in the code we have a potential path element in BC.  We first
  C854           ; have to scan the minpath we have so far to see if that element is already
  C854           ; there.  In that case we ignore it; otherwise we add it to the end of the path.
  C854           
  C854           ADDPATH:
  C854                                   ; Skip path if directory given explicitly
  C854           
  C854                    IF     SKIPPATH
  C854           
  C854                    IF     WPREFIX
  C854                   LD      A,(Z3WHL)       ; See if wheel byte is on
  C854                   OR      A
  C854                   CALL    NZ,SKIPCHK      ; If not, fall through
  C854                    ELSE   ;not wprefix
ZAS Relocating Macro Assembler (v3.05                             page  107
                                                            
                                                            

  C854 CD23C9            CALL    SKIPCHK         ; See if path should be skipped
  C857                    ENDIF  ;wprefix
  C857           
  C857 20E5              JR      NZ,MAKEPATH3    ; If so, branch out of ADDPATH
  C859           
  C859                    ENDIF  ;skippath
  C859           
  C859 21D0EF            LD      HL,MPATH        ; Point to beginning of minpath
  C85C           
  C85C           ADDPATH1:                       ; Point of reentry
  C85C 7E                LD      A,(HL)          ; Get drive value
  C85D B7                OR      A               ; Check for end of minpath
  C85E 280B              JR      Z,ADDPATH2      ; If end, jump and add BC to minpath
  C860           
  C860 23                INC     HL              ; Increment pointer to user
  C861 B8                CP      B               ; Check for drive match
  C862 7E                LD      A,(HL)          ; Get user from minpath
  C863 23                INC     HL              ; Point to next minpath entry
  C864 20F6              JR      NZ,ADDPATH1     ; If drive was different, loop back again
  C866 B9                CP      C               ; Check for user match
  C867 20F3              JR      NZ,ADDPATH1     ; If user is different, loop back again
  C869 18D3              JR      MAKEPATH3       ; Branch if we have a duplicate
  C86B           
  C86B           ; We have a new DU; add it to minpath
  C86B           
  C86B           ADDPATH2:
  C86B 70                LD      (HL),B          ; Store drive
  C86C 23                INC     HL
  C86D 71                LD      (HL),C          ; Store user
  C86E 23                INC     HL
  C86F 3600              LD      (HL),0          ; Store ending 0
  C871 18CB              JR      MAKEPATH3       ; Continue scanning user's path
  C873           
  C873           ; If the ECP facility is set up to use the root directory, then create a
  C873           ; root path.  BC presently contains the proper DU.
  C873           
  C873           MAKEPATH6:
  C873           
  C873                    IF     ROOTONLY
  C873 212EC9            LD      HL,ROOTPTH      ; Point to special path to contain root
  C876 70                LD      (HL),B          ; Store disk
  C877 23                INC     HL
  C878 71                LD      (HL),C          ; Store user
  C879                    ENDIF  ;rootonly
  C879           
  C879           ;-----------------------------------------------------------------------------
  C879           
  C879           ; This is the code for loading the specified file by searching the minpath.
  C879           
  C879 AF                XOR     A               ; Always use current disk specification in the
  C87A 32D0ED            LD      (CMDFCB),A      ; ..command FCB
  C87D           
  C87D           MLOAD1:
  C87D           
  C87D 21D0EF            LD      HL,MPATH        ; Point to beginning of minpath
  C880           
ZAS Relocating Macro Assembler (v3.05                             page  108
                                                            
                                                            

  C880           MLOAD2:
  C880           
  C880           ; Either the FASTECP or BADDUECP option may have set FIRSTCHAR to a space
  C880           ; character as a signal to go directly to extended command processing.  If
  C880           ; neither option is enabled but SKIPPATH is, then the FIRSTCHAR data is
  C880           ; stored in the routine below where path skipping is implemented.
  C880           
  C880                    IF     FASTECP OR BADDUECP
  C880           
  C880 3A83ED            LD      A,(CMDSTATFL)   ; If ECP is running
  C883 CB57              BIT     2,A             ; ..we branch to look for ECP along path
  C885 2006              JR      NZ,MLOAD2A
  C888 =         FIRSTCHAR EQU   $+1             ; Pointer for in-the-code modification
  C887 3E00              LD      A,0
  C889 FE20              CP      ' '             ; Was command invoked with leading space?
  C88B 2804              JR      Z,ECPRUN        ; If so, go directly to ECP code
  C88D           
  C88D                    ENDIF  ;fastecp or badduecp
  C88D           
  C88D           MLOAD2A:
  C88D 7E                LD      A,(HL)          ; Get drive from path
  C88E B7                OR      A               ; If end of path, command not found
  C88F 2028              JR      NZ,MLOAD3       ; If not end of path, skip over ECP code
  C891           
  C891           ;-----------------------------------------------------------------------------
  C891           
  C891           ; EXTENDED COMMAND PROCESSING
  C891           
  C891           ; At this point we have exhausted the search path.  We now engage the
  C891           ; extended command processor.
  C891           
  C891           ECPRUN:
  C891                    IF     SKIPPATH
  C891 CD23C9            CALL    SKIPCHK         ; See if path should be skipped
  C894 2006              JR      NZ,JNZERROR     ; If so, invoke error handler
  C896                    ENDIF  ;skippath
  C896           
  C896 2183ED            LD      HL,CMDSTATFL    ; Point to command status flag
  C899 7E                LD      A,(HL)          ; ..and get value
  C89A E606              AND     110B            ; Isolate ECP and error handler bits
  C89C           JNZERROR:                       ; If either is set,
  C89C 3E07              LD      A,ECNOCMD       ; Error code for command not found
  C89E C28AC3            JP      NZ,ERROR        ; ..process as an error
  C8A1           
  C8A1 CBD6              SET     2,(HL)          ; Set ECP bit
  C8A3           
  C8A3 212DC2            LD      HL,ECPFCB       ; Copy name of ECP to command FCB
  C8A6 11D0ED            LD      DE,CMDFCB
  C8A9 010C00            LD      BC,12           ; Only 12 bytes required
  C8AC EDB0              LDIR
  C8AE           
  C8AE 2A84ED            LD      HL,(CMDPTR)     ; Get pointer to current command line
  C8B1 CD20C4            CALL    PARSETAIL       ; Parse entire command as the command tail
  C8B4           
  C8B4                    IF     ROOTONLY        ; Look for ECP in root directory only
  C8B4 212EC9            LD      HL,ROOTPTH      ; Point to path containing root directory only
ZAS Relocating Macro Assembler (v3.05                             page  109
                                                            
                                                            

  C8B7 18C7              JR      MLOAD2          ; Search for command
  C8B9                    ELSE   ; not rootonly
  C8B9                   JR      MLOAD1          ; Search the entire minpath for the ECP
  C8B9                    ENDIF  ; rootonly
  C8B9           
  C8B9           ;-----------------------------------------------------------------------------
  C8B9           
  C8B9           MLOAD3:
  C8B9 47                LD      B,A             ; Drive into B
  C8BA 23                INC     HL              ; Point to user number
  C8BB 4E                LD      C,(HL)          ; User into C
  C8BC ED4313C9          LD      (TEMPUSR),BC    ; Save the values
  C8C0 23                INC     HL              ; Point to next entry in path
  C8C1 CD88C7            CALL    LOGTEMP         ; Log in path-specified user/drive
  C8C4           
  C8C4                    IF     ATTCHK          ; If allowing execution only of COM files with
  C8C4                                           ; ..specific attributes
  C8C4           
  C8C4                   LD      DE,CMDFCB       ; Point to command FCB
  C8C4                   CALL    SRCHFST         ; Look for directory entry for file
  C8C4                   JR      Z,MLOAD2A       ; Continue path search if file not found
  C8C4                   PUSH    HL              ; Save path pointer
  C8C4                   CALL    GETSBIT         ; Check system attribute bit
  C8C4                   POP     HL              ; Restore path pointer
  C8C4                   JR      Z,MLOAD2A       ; Continue if attributes do not match
  C8C4                   CALL    OPENCMD         ; Open file for input
  C8C4                   JR      Z,MLOAD2A       ; If open failed, back to next path element
  C8C4           
  C8C4                    ELSE   ;not attchk
  C8C4           
  C8C4 CD27C6            CALL    OPENCMD         ; Open file for input
  C8C7 28C4              JR      Z,MLOAD2A       ; If open failed, back to next path element
  C8C9           
  C8C9                    ENDIF  ; attchk
  C8C9           
  C8C9 CD0BC6            CALL    READCMD         ; Read first record into default DMA address
  C8CC 2044              JR      NZ,MLOAD5       ; Branch if zero-length file
  C8CE AF                XOR     A               ; Set file current record back to zero
  C8CF 32F0ED            LD      (CMDFCB+20H),A
  C8D2 218000            LD      HL,80H          ; Pointer to start of code
  C8D5 CD40C6            CALL    Z3CHK
  C8D8 200E              JR      NZ,MLOAD3A      ; If not Z3 file, branch
  C8DA           
  C8DA           ; The following test is modified by earlier code.  For normal COM file loading,
  C8DA           ; a 3 is inserted for the minimum environment type for dynamic load address
  C8DA           ; determination.  For the GET command, where the user-specified address should
  C8DA           ; be used, a value of 0FFH is put in here so the carry flag will always be set.
  C8DA           
  C8DB =         ENVTYPE EQU     $+1             ; Pointer for in-the-code modification
  C8DA FE03              CP      3               ; See if no higher than a type-3 environment
  C8DC 380A              JR      C,MLOAD3A       ; If higher than type 3, branch
  C8DE           
  C8DE 23                INC     HL              ; Advance to load address word
  C8DF 23                INC     HL
  C8E0 23                INC     HL
  C8E1 7E                LD      A,(HL)          ; Get load address into HL
ZAS Relocating Macro Assembler (v3.05                             page  110
                                                            
                                                            

  C8E2 23                INC     HL
  C8E3 66                LD      H,(HL)
  C8E4 6F                LD      L,A
  C8E5 2284C3            LD      (EXECADR),HL    ; Set new execution/load address
  C8E8           
  C8E8           MLOAD3A:
  C8E8 2A84C3            LD      HL,(EXECADR)    ; Get initial loading address
  C8EB           
  C8EB           ; Load the file, making sure neither CPR nor protected memory is overwritten
  C8EB           
  C8EB           MLOAD4:
  C8EB                    IF     FULLGET
  C8EB 3ADBC8            LD      A,(ENVTYPE)     ; If ENVTYPE is FF (from GET command)
  C8EE 3C                INC     A               ; ..then skip memory limit checking
  C8EF 2810              JR      Z,MLOAD4B
  C8F1                    ENDIF  ;fullget
  C8F1           
  C8F1                    IF     REL
  C8F1                   LD      BC,ENTRY        ; We have to use a relocatable form to get
  C8F1                   DEC     B               ; ..highest page below the CPR
  C8F1                    ELSE   ;not rel
  C8F1 06C1              LD      B,HIGH ENTRY - 1 ; We can use shorter code for absolute form
  C8F3                    ENDIF  ;rel
  C8F3           
  C8F3 3A0700            LD      A,(0007H)       ; Get highest page below
  C8F6 3D                DEC     A               ; ..protected memory
  C8F7 B8                CP      B               ; If A is lower value,
  C8F8 3801              JR      C,MLOAD4A       ; ..branch
  C8FA 78                LD      A,B             ; Otherwise use lower value in B
  C8FB           MLOAD4A:
  C8FB BC                CP      H               ; Are we going to overwrite protected memory?
  C8FC 3E0C              LD      A,ECTPAFULL     ; Get ready with TPA overflow error code
  C8FE DA8AC3            JP      C,ERROR         ; Error if about to overwrite protected memory
  C901           MLOAD4B:
  C901 E5                PUSH    HL              ; Save this load address
  C902 EB                EX      DE,HL           ; Set DMA address
  C903 CD1EC6            CALL    DMASET
  C906 CD0BC6            CALL    READCMD
  C909 E1                POP     HL              ; Get last load address back
  C90A 2006              JR      NZ,MLOAD5       ; Read error or eof?
  C90C 118000            LD      DE,128          ; Increment load address by 128
  C90F 19                ADD     HL,DE
  C910 18D9              JR      MLOAD4          ; Continue loading
  C912           
  C912           ; In case a program would like to find out in what directory the command
  C912           ; processor found the program, temporary DU is stored in bytes 13 (user) and
  C912           ; 14 (drive) in the command FCB.
  C912           
  C912           MLOAD5:
  C912           
  C913 =         TEMPUSR EQU     $+1             ; Pointers for in-the-code modification
  C914 =         TEMPDR  EQU     $+2
  C912 210000            LD      HL,0
  C915 22DDED            LD      (CMDFCB+13),HL
  C918           
  C918           LOGCURRENT:                     ; Return to original logged directory
ZAS Relocating Macro Assembler (v3.05                             page  111
                                                            
                                                            

  C918 2AAEED            LD      HL,(CURUSR)     ; Set L = current user, H = current drive
  C91B 7C                LD      A,H
  C91C CD22C6            CALL    SETDRIVE        ; Login current drive
  C91F 7D                LD      A,L
  C920 C33BC6            JP      SETUSER         ; Log in new user and return from MLOAD
  C923           
  C923           ;----------------------------------------
  C923           
  C923           ; This routine checks to see if building the path or running the ECP should
  C923           ; be skipped.  If there is a colon in the command (an explicit directory
  C923           ; given) but it was not a lone colon (indicating desire to skip resident
  C923           ; commands), then the routine returns with the zero flag reset.
  C923           
  C923                    IF     SKIPPATH
  C923           
  C923           SKIPCHK:
  C923 3AFFC2            LD      A,(COLON)       ; Was there a colon in the command?
  C926 B7                OR      A
  C927 C8                RET     Z               ; Return with zero flag set if not
  C928           
  C928                    IF     FASTECP OR BADDUECP
  C928 3A88C8            LD      A,(FIRSTCHAR)   ; See if the first character was the colon
  C92B                    ELSE
  C92B           FIRSTCHAR EQU   $+1             ; Put data here if other two options are
  C92B                   LD      A,0             ; ..false (in-the-code modification)
  C92B                    ENDIF  ;fastecp or badduecp
  C92B           
  C92B FE3A              CP      ':'
  C92D C9                RET                     ; Return: Z if lone colon, NZ otherwise
  C92E           
  C92E                    ENDIF  ;skippath
  C92E           
  C92E           
  C92E           ; End ZCPR33-6.Z80
  C92E           
ZAS Relocating Macro Assembler (v3.05                             page  112
                                                            
                                                            

  C92E                   PAGE
  C92E           
  C92E           ;-----------------------------------------------------------------------------
  C92E           ;
  C92E           ;               D A T A    A R E A    D E F I N I T I O N S
  C92E           ;
  C92E           ;-----------------------------------------------------------------------------
  C92E           
  C92E           ; ----------   Page line count buffer
  C92E           
  C92E                    IF     LTON            ; Needed only if TYPE command included
  C92E           
  C92E           PAGCNT:
  C92E                   DEFS    1               ; Lines left on page (filled in by code)
  C92E           
  C92E                    ENDIF  ;lton
  C92E           
  C92E           
  C92E           ; ---------- Minpath/Rootpth buffers
  C92E           
  C92E                    IF     EXTMPATH
  C92E           
  EFD0 =         MPATH   EQU     EXTMPATHADR     ; Assign external minpath address
  C92E           
  C92E                    ELSE
  C92E           
  C92E           MPATH:
  C92E                    IF     DRVPREFIX
  C92E                   DEFS    2               ; Two bytes for specified DU
  C92E                    ENDIF
  C92E           
  C92E                    IF     SCANCUR
  C92E                   DEFS    2               ; Two bytes for current DU
  C92E                    ENDIF
  C92E           
  C92E                   DEFS    2 * EXPATHS     ; Space for path from path buffer
  C92E           
  C92E                   DEFS    1               ; One byte for ending null
  C92E           
  C92E                    ENDIF  ; not extmpath
  C92E           
  C92E           
  C92E                    IF     ROOTONLY
  C92E           ROOTPTH:
  C92E 0000              DEFS    2               ; Special path for root dir only
  C930 00                DEFB    0               ; End of path
  C931                    ENDIF  ; rootonly
  C931           
  C931           ;-----------------------------------------------------------------------------
  C931           
  C931           ; The following will cause an error message to appear if
  C931           ; the size of ZCPR33 is over 2K bytes.
  C931           
  C931                    IF     [ $ - ENTRY ] GT 800H
  C931                   *** ZCPR33 IS LARGER THAN 2K BYTES ***
  C931                    ENDIF
ZAS Relocating Macro Assembler (v3.05                             page  113
                                                            
                                                            

  C931           
  C931                    ENDIF  ;errflag
  C931           
  C931                   END     ; ZCPR33

**** Symbol table ****
ACCPTDIR        FFFF ACCPTDU         FFFF ADDAH           C71F
ADDPATH         C854 ADDPATH1        C85C ADDPATH2        C86B
ADUENV          FFFF ALLCHAR         0041 ALTCHAR         002E
ALTCOLON        FFFF ALTONLY         0000 ALTSPACE        FFFF
AMBCHK          C7C5 AMBCHK1         C7D5 ATTCHK          0000
ATTDIR          FFFF ATTSYS          FFFF BADCMD          C400
BADDIRERR       C388 BADDUECP        FFFF BADNUMBER       C7D9
BASE            0000 BDOS            CA06 BDOSB           CA00
BDOSSAVE        C610 BDOSTEST        C630 BELL            0007
BELLFL          FFFF BIAS            8E00 BIOREAS         0A00
BIOS            D800 BIOSTDS         0600 BUFLEN          00D0
BUFSIZ          EF02 CALLPROG        C348 CALLPROGLF      C345
CAPBUF          C29E CCP             C200 CHRCNT          EF03
CMDFCB          EDD0 CMDLIN          EF04 CMDPTR          ED84
CMDSCAN         C794 CMDSEP          003B CMDSIZE         0004
CMDSTATFL       ED83 CMDTBL          C219 COLON           C2FF
COM             C330 COMATT          0000 COMDIR          C317
COMDIR1         C31E COMMAND         F818 COMMENT         003B
COMMSG          C236 COMTYP          FCB5 CONIN           C5D3
CONOUT          C5E9 COUNT           0000 CPRCMD          C30F
CPRMPT          003E CR              000D CRLF            C5E3
CRTTXT0         EC33 CTABLE          FE05 CTRLC           0003
CURDR           EDAF CURIND          0024 CURUSR          EDAE
DECIMAL         C72C DECIMAL1        C72F DEFLTDMA        C61B
DELDAT          C77E DELEND          C788 DIRERR          C57A
DIRON           0000 DIRSCAN         C51A DIRSCAN1        C525
DIRSCAN2        C52F DIRSCAN3        C537 DIRSCAN4        C543
DIRSCAN5        C56C DMASET          C61E DRVPREFIX       FFFF
DU2DIR          C6CD DU2DIR1         C6D6 DU2DIR2         C6DA
DUENV           FFFF DUERR           C57A DUERRFLAG       C3E0
DUFIRST         0000 DUOKFL          EC2E DUSCAN          C57D
DUSCAN1         C58E DUSCAN2         C59F DUSCAN3         C5BC
ECAMBIG         0008 ECBADCMD        0005 ECBADDIR        0002
ECBADNUM        0009 ECBADPASS       0003 ECDISKFULL      000B
ECDUCHG         0001 ECECPERR        0006 ECFLAG          ED80
ECNOCMD         0007 ECNOFILE        000A ECPCHAR         002F
ECPFCB          C22D ECPNAME         FBFD ECPRUN          C891
ECTPAFULL       000C ENTRY           C200 ENVTYPE         C8DB
ERAOK           FFFF ERAON           0000 ERRCMD          ED90
ERRFLAG         0000 ERRINTRNL       C3BF ERROR           C38A
ERROR1          C394 ERRSH           C3B2 EXECADR         C384
EXPATH          EDF4 EXPATHS         0005 EXTFCB          EDD0
EXTMPATH        FFFF EXTMPATHADR     EFD0 EXTRABIAS       1200
EXTSTK          EFD0 FALSE           0000 FASTECP         FFFF
FCP             EA00 FCPCMD          C2DA FCPENV          FFFF
FCPS            0004 FENCE           007C FF              000C
FILL            C675 FIRSTCHAR       C888 FLAG            0064
FULLGET         FFFF GET             C7F4 GETON           FFFF
GETPROGLF       C7ED GETREG          FB20 GETUSER         C639
GO              C7EA GOON            FFFF GOTIT           C461
ZAS Relocating Macro Assembler (v3.05                             page  114
                                                            
                                                            

HASEDS          FFFF HEXNUM          C724 HEXNUM1         C727
HIGHUSER        0000 IDISK1          0024 IDISK2          0024
IDISK3          0001 IDISK4          0001 IFCB            C663
IFPTRFL         ED81 IFSTATFL        ED82 IFTEST          C68B
IFTEST1         C695 INCLDIR         FFFF INCLDU          FFFF
INCLENV         0000 INITFCB         C65D INSPCH          0020
INSPFL          FFFF INTRON          0000 IOP             0000
IOPS            0000 IUSER1          0024 IUSER2          000F
IUSER3          0024 IUSER4          000F JNZERROR        C89C
JPERROR         C7DB JPNEXTCMD       C32D JUMP            C7DE
JUMPON          FFFF LF              000A LOGCURRENT      C918
LOGTEMP         C788 LTON            0000 MAKEPATH2       C83B
MAKEPATH3       C83E MAKEPATH4       C84C MAKEPATH5       C854
MAKEPATH6       C873 MAXDISK         000F MAXDRENV        EC2C
MAXUSR          000F MAXUSRENV       EC2D MLOAD           C818
MLOAD1          C87D MLOAD2          C880 MLOAD2A         C88D
MLOAD3          C8B9 MLOAD3A         C8E8 MLOAD4          C8EB
MLOAD4A         C8FB MLOAD4B         C901 MLOAD5          C912
MP161           C763 MP162           C766 MPATH           EFD0
MPY16           C758 MSIZE           003C NDRENV          FFFF
NEXTCMD         C274 NEXTCMD1        C294 NEXTCMD3        C2A8
NEXTCMD3A       C2B0 NEXTCMD3B       C2B8 NEXTCMD4        C2CD
NEXTCMD5        C2D7 NO              0000 NOINSTALL       C380
NOTE            C61A NOTEON          0000 NUMBASE         0048
NXTCHR          EF00 OFF             0000 ON              FFFF
OPEN            C62E OPENCMD         C627 OPTFLAG         FAAB
OPTIONS         C206 OUTPUT          C5ED PAGECH          0050
PAGEFL          FFFF PARSEPTR        C211 PARSER          C3CF
PARSER1         C3FA PARSER2         C415 PARSETAIL       C420
PASSCK          C4DE PATH            EDF4 PKGOFF          C67A
PRINT           C5F7 PRINTC          C5F4 PRINTHL         C5FD
PROMPT          C697 PROMPT1         C6B0 PROMPT2         C6B5
PROMPT3         C6C2 PUTREG          FB5F PWCHECK         FFFF
PWCK            C50B PWLIN           EFD0 PWNOECHO        FFFF
QCOUNTINC       C4D7 QMCNT           C4A7 QUIETFL         EC28
RADBIN          C732 RADBIN1         C735 RADBIN2         C746
RCP             E200 RCPCMD          C303 RCPENV          FFFF
RCPS            0010 READ            C60E READBUF         C6E7
READBUF3        C71C READCMD         C60B REL             0000
RENON           0000 REPARSE         C210 RESOLVE         F9EA
RESROOM         0400 RESTART         C257 ROOTONLY        FFFF
ROOTPTH         C92E RUNCMD          C2DA RUNCMD1         C2F7
RUNFCP1         C2ED RUNFCP2         C2F5 SAVEON          0000
SCAN            C216 SCAN3           C497 SCAN4           C4A6
SCANBAD         C7BD SCANCMP         C7A0 SCANCUR         0000
SCANEND         C7C2 SCANFIELD       C4B6 SCANFLD1        C4C7
SCANFLD2        C4CE SCANFLD3        C4D0 SCANFLD8        C4AA
SCANNER         C43B SCANNER1        C475 SCANNEXT        C796
SCANSKIP        C7BA SCANTYPE        C47A SCANTYPE2       C48D
SDELM           C772 SECTCH          0020 SEG1            E200
SEG10           EC00 SEG11           EF00 SEG12           EFD0
SEG2            EA00 SEG3            EA00 SEG4            ED00
SEG5            ED80 SEG6            EDD0 SEG7            EDF4
SEG8            EDFF SEG9            EE00 SETDRIVE        C622
SETDU           C5CD SETUSER         C63B SETUSER1        C63C
SHELLIF         0000 SHELLINPUT      C6ED SHSIZE          0020
ZAS Relocating Macro Assembler (v3.05                             page  115
                                                            
                                                            

SHSTK           ED00 SHSTKS          0004 SKIPCHK         C923
SKIPPATH        FFFF SKSP            C651 SLASHFL         FFFF
SPRMPT          005D SRCHFST         C635 STACK           F000
STMPP2          FFFF STMPZS          0000 SUBCLUE         0000
SUBDRV          0041 SUBECHO         0000 SUBFLAG         EDAD
SUBNOISE        0001 SUBON           0000 SUBQUIET        FFFF
SUBTYP          FC4A SUPRES          0000 SWAP            FAE1
SYSCHAR         0053 TAB             0009 TAIL            C353
TAIL1           C367 TAILSV          C349 TBUFF           0080
TEMPDR          C914 TEMPUSR         C913 TFCB            005C
TFCB2           006C TMPCOLON        C40F TPA             0100
TRUE            FFFF TSTEOL          C658 UCASE           C5D8
UDFLAG          0004 USERINPUT       C705 VERS            0016
VERSION         C205 WBOOT           0000 WDIR            0000
WDU             0000 WERA            0000 WGET            0000
WGO             0000 WHEEL           0000 WHLDIR          0000
WHLMASK         0000 WIDE            FFFF WJUMP           0000
WLT             0000 WPASS           FFFF WPREFIX         0000
WREN            0000 WSAVE           0000 XSUBFLAG        EDAC
YES             FFFF Z3CHK           C640 Z3CHK1          C648
Z3CL            EF00 Z3CLS           00D0 Z3ENV           EC00
Z3ENVS          0002 Z3MSG           ED80 Z3NDIR          EE00
Z3NDIRS         001C Z3REV           0021 Z3WHL           EDFF
ZBUFBAS         E200 ZCPR            C239 ZDSSTPR         E838
ZDSSTSZ         01C8 ZEXINPFL        ED87 ZEXRUNFL        ED88
ZFLOPKG         0200 ZIOPKG          0000 ZRESPKG         0800
ZSTDOVR         0400
CLS           00D