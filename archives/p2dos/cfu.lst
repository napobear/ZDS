   1:			
   2:				.Z80
   3:				ASEG
   4:			
   5:			;		      COPYFAST.ASM Version 4.3
   6:			;
   7:			;REVISED	2007/02/25 Piergiorgio Betti <pbetti@lpconsul.net>
   8:			;	EXTENDED DISK RANGE TO A-P (INSTEAD OF A-F)
   9:			;
  10:			;REVISED	11/03/87
  11:			;
  12:			;	IN ADDITION TO MAKING RAPID COPIES OF A DISK, COPYFAST
  13:			;	IS USEFUL FOR MAKING BACKUP COPIES OF A DISK THAT HAS
  14:			;	HAD A FILE DAMAGED IN SOME WAY. YOU CAN THEN USE THE
  15:			;	COPY WHEN TRYING TO RECOVER THE FILE WITH A DISK UTILITY.
  16:			;	(ASSUMING YOUR CONTROLLER CAN STILL READ THE SECTORS)
  17:			;
  18:			;	AS IT IS CURRENTLY CONFIGURED COPYFAST WILL CORRECTLY
  19:			;	COPY SYSTEM TRACKS OTHER THAN TRACK 0 ONLY IF THEY
  20:			;	ARE OF THE SAME FORMAT AND SECTOR COUNT AS THE DATA TRACKS.
  21:			;
  22:			;	Note: to save people time, don't bother to change
  23:			;	the DOC file just to update the change history.
  24:			;
  25:	0100          		ORG	0100H
  26:			;
  27:			;
  28:			;	Equates
  29:			;
  30:	0000          	FALSE	EQU	0		; define false
  31:	FFFF          	TRUE	EQU	NOT FALSE	;  define true
  32:			;
  33:	0000          	EXITCP	EQU	0		; warm start return to CP/M
  34:	005C          	FCB	EQU	5CH		; default FCB address
  35:			;
  36:	000D          	CR	EQU	0DH		; ASCII Carriage return
  37:	000A          	LF	EQU	0AH		; ASCII line feed
  38:	0003          	CTRLC	EQU	3		; ASCII control-C
  39:			;
  40:	0001          	NOLOG	EQU	01		;CALL SELDSK WITH NO LOGON
  41:	0000          	LOGON	EQU	00		;CALL SELDSK WITH LOGON
  42:			;
  43:			;	User-modifiable switches
  44:			;
  45:	0000          	SINGLE	EQU	FALSE		; TRUE for single drive copy program
  46:			;
  47:	0000          	NOCOMP	EQU	FALSE		; TRUE if no read checking at all
  48:			;			;   (DOCOMP MUST BE FALSE)
  49:			;			; FALSE if read checking is done,
  50:			;			;   check DOCOMP
  51:	FFFF          	DOCOMP	EQU	TRUE		; TRUE if byte-by-byte comparison
  52:			;			; desired on read-after-write check
  53:			;			; Must be FALSE if NOCOMP is TRUE
  54:	0000          		IF	NOCOMP AND DOCOMP
  56:				ENDIF
  57:			;
  58:	0002          	NUMERR	EQU	2		; number of error retries done
  59:			;
  60:	0000          	BUFFNU	EQU	0		; the number of full track buffers
  61:			;	that will fit in your system. This figure includes
  62:			;	the space used by the read-back buffers, if used
  63:			;	(minimum 2). If zero, the number of buffers will
  64:			;	be automatically computed at execution.
  65:			;
  66:			;	The next two values specify the copy range, and the program
  67:			;	can be run in other ways by the parameter (first character
  68:			;	of the first filename) given when COPYFAST is first invoked:
  69:			;			(Note: only complete tracks are copied)
  70:			;
  71:			;	All	0-(Lastrk-1)	   ***	Entire disk
  72:			;	Data	Firstrk-(Lastrk-1)	CP/M data area
  73:			;	First	Firstrk			CP/M directory track
  74:			;	Last	(Lastrk-1)		Last track on disk
  75:			;	One	1			Track one, UCSD directory
  76:			;	Pascal	1-(Lastrk-1)		UCSD Pascal data area
  77:			;	System	0-(Firstrk-1)	   ***	CP/M bootstrap
  78:			;	Zero	0		   ***	Track zero, UCSD bootstrap
  79:			;	nn	nn			One track, as specified
  80:			;	n1-n2	n1-n2			A specified range
  81:			;			***	NOTE: this option parameter is
  82:			;				functional only if CPM is TRUE.
  83:			;
  84:			;	The default range, currently Firstrk to Lastrk-1, is given
  85:			;	in the two values at TRKSRT.
  86:			;
  87:	0002          	FIRSTRK EQU	2		; the first data track copied.
  88:			;				; The bootstrap is assumed to be
  89:			;				; on tracks 0 to Firstrk-1
  90:	004D          	LASTRK	EQU	76 + 1		; the last track copied plus one
  91:			;
  92:	0000          	DIFFTRK EQU	0		; difference between first source
  93:			;				; track and the first object track.
  94:			;				; (applies only when default range
  95:			;				; is used)
  96:			;
  97:			; THE NEXT EQUATE MUST BE TRUE. IT WAS LEFT IN TO FACILITATE
  98:			; COMPARISON WITH THE ORIGINAL COPYFAST CODE.
  99:	FFFF          	CPM	EQU	TRUE		; TRUE for CP/M copy (thru BIOS)
 100:			;
 101:	FFFF          	BXTBL	EQU	TRUE		;TRUE TO USE BIOS SECTOR XLATE TABLE
 102:			;
 103:			; IF BXTBL IS TRUE THEN CHANGING THE VALUES FOR 'RSKEW', 'SLOW',
 104:			;AND 'TSKEW' WILL NOT MAKE A SIGNIFICANT DIFFERENCE IN PERFORMANCE
 105:			;BECAUSE THE ENTRIES IN THE SKEW TABLES 'WRITAB' AND 'READTAB'
 106:			;ARE NOT USED. (GIVING A MORE UNIVERSAL PROGRAM).
 107:			; ALSO, THE COPY TIME FOR A STANDARD IBM 3740 DISK MAY BE QUITE A
 108:			;BIT LONGER THAN A SEPARATE CUSTOM VERSION OF THE PROGRAM CONTAINING
 109:			;OPTIMIZED ENTRIES IN 'WRITAB' AND 'READTAB' (WITH BXTBL SET FALSE).
 110:			;
 111:			;
 112:	FFFF          		IF	CPM
 113:			;
 114:	001A          	SDLAST	EQU	26		; the number of sectors per track
 115:			;			; Also determines the lengths of
 116:			;			; WRTAB, READTAB, and WRITAB
 117:			;			; CP/M 2 users: this must be the
 118:			;			; value in the first byte of the
 119:			;			; disk parameter block.
 120:	001A          	SDZERO	EQU	26		; the number of 128-byte sectors on
 121:			;			; track zero. This is usually 26
 122:			;			; even on double-density disks,
 123:			;			; per the IBM standard.
 124:			;			; SHOULD BE NO LARGER THAN SDLAST.
 125:	0000          	WRSWCH	EQU	FALSE		; TRUE if CP/M 2.2 block/deblock
 126:			;			; routines need various values in
 127:			;			; reg. C during writes. See WRTAB
 128:	0002          	WRCODE	EQU	2		; value passed to sector write rtn
 129:			;			; in reg. C if WRSWCH is FALSE
 130:	0080          	SECSIZ	EQU	128		; Note: 128 if CP/M BIOS is used
 131:				ENDIF
 132:			;
 133:	0000          		IF	CPM AND (NOT BXTBL)
 140:				ENDIF
 141:			;
 142:	FFFF          		IF	CPM AND BXTBL
 143:	0000          	RSKEW	EQU	FALSE
 144:	0000          	SLOW	EQU	FALSE
 145:	0000          	TSKEW	EQU	0
 146:				ENDIF
 147:			;
 148:			;
 149:			;	the following shennanigans are because ASM does not
 150:			;	have an EQ operator for comparisons, and neither ASM
 151:			;	nor MAC will perform an IF exactly as described in
 152:			;	the manual. Therefor, a TRUE value is constructed
 153:			;	with AND's and shift's and OR's.
 154:			;
 155:			;
 156:	0000          	XXXSKW	EQU	(0-TSKEW) AND 0FF00H
 157:	0000          	TRSKW	EQU	((XXXSKW) OR (XXXSKW SHR 8)) AND (NOT RSKEW)
 158:			;
 159:			;
 160:			;
 161:	0100  F3      	START:	DI
 162:	0101  C34F09  		JP	VECT1		; go initialize the branches
 163:			;
 164:			;
 165:			;	Useful constants placed here for finding easily
 166:			;	These can be changed using DDT to alter some of
 167:			;	the characteristics of the program to suit your
 168:			;	taste.
 169:			;
 170:	0104          	TRKSRT:	; default first and last+1 track numbers
 171:			;				; Can be changed at run time
 172:	0104  02      		DEFB	FIRSTRK
 173:	0105  4D      		DEFB	LASTRK
 174:	0106          	BUFFNMB:; max. number of buffers
 175:	0106  00      		DEFB	BUFFNU
 176:	0107          	SRCTRAK:; source track - object track
 177:	0107  00      		DEFB	DIFFTRK
 178:			;
 179:	0108  1A      	SPT0:	DEFB	SDZERO		;SECTORS PER TRACK 0
 180:			;
 181:	0109  1A      	SPT:	DEFB	SDLAST		;128 BYTE SECTORS PER DATA TRACK
 182:			;
 183:	010A  02      	OFFSET:	DEFB	2		;NUMBER OF RESERVED (SYSTEM) TRACKS
 184:			;
 185:			;SET THE FOLLOWING NON-ZERO IF YOU DO NOT WANT THE PROGRAM
 186:			;TO OVERWRITE THE BDOS (e.g. USING CACHE22 OR OTHER CP/M MODIFICATION)
 187:			;
 188:	010B  01      	BDOSFG:	DEFB	01
 189:			;
 190:			;	A set of dummy branch points to the CBIOS that are
 191:			;	filled in by the VECTOR routine.
 192:			;
 193:	010C          	WBOOT:
 194:	010C  C30000  		JP	$-$		; not used
 195:	010F          	CONST:
 196:	010F  C30000  		JP	$-$
 197:	0112          	CONIN:
 198:	0112  C30000  		JP	$-$
 199:	0115          	CONOUT:
 200:	0115  C30000  		JP	$-$
 201:	0118          	BLIST:
 202:	0118  C30000  		JP	$-$		; not used
 203:	011B          	PUNCH:
 204:	011B  C30000  		JP	$-$		; not used
 205:	011E          	READER:
 206:	011E  C30000  		JP	$-$		; not used
 207:	0121          	HOME:
 208:	0121  C30000  		JP	$-$
 209:	0124          	SELDIS:
 210:	0124  C30000  		JP	$-$
 211:	0127          	SETRAK:
 212:	0127  C30000  		JP	$-$
 213:	012A          	SETSCT:
 214:	012A  C30000  		JP	$-$
 215:	012D          	SETDMA:
 216:	012D  C30000  		JP	$-$
 217:	0130          	BREAD:
 218:	0130  C30000  		JP	$-$
 219:	0133          	WRITE:
 220:	0133  C30000  		JP	$-$
 221:	0136          	LISTST:
 222:	0136  C30000  		JP	$-$		; not used
 223:	0139          	SECTRAN:
 224:	0139  C30000  		JP	$-$		; only CPM 2.2
 225:			;
 226:			;
 227:			;
 228:			;	This  is the point where the program returns to repeat  the
 229:			;	copy. Everything is re-initialized.
 230:			;
 231:	013C          	REPEAT:
 232:	013C  312B09  		LD	SP,STKTOP	; se-initialize stack
 233:	013F  11A407  		LD	DE,SOURCE
 234:	0142  CDA505  		CALL	PRINT		; ask for source drive
 235:	0145          	SRCELU:
 236:	0145  CD1201  		CALL	CONIN		; read response (upper case)
 237:	0148  FE03    		CP	CTRLC
 238:	014A  CAC601  		JP	Z,EXIT		; CTRL-C means abort
 239:	014D  E65F    		AND	5FH
 240:	014F  FE41    		CP	'A'		;41H
 241:	0151  DA4501  		JP	C,SRCELU	; bad value - less than A
 242:	0154  FE50    		CP	'P'		;50H
 243:	0156  CA5F01  		JP	Z,SETSOU
 244:	0159  DA5F01  		JP	C,SETSOU
 245:	015C  C34501  		JP	SRCELU		; cad value - greater than P
 246:	015F          	SETSOU:
 247:	015F  323307  		LD	(SRCEME),A	; save the source drive
 248:	0000          		IF	SINGLE
 250:				ENDIF
 251:	0162  D641    		SUB	'A'		;41H
 252:	0164  323409  		LD	(SRCEDR),A	; convert value to CP/M number
 253:	0167  3A3307  		LD	A,(SRCEME)
 254:	016A  4F      		LD	C,A
 255:	016B  CD1501  		CALL	CONOUT		; echo value to console
 256:	FFFF          		IF	NOT SINGLE
 257:	016E  11C007  		LD	DE,OBJECT	; prompt for destination disk
 258:	0171  CDA505  		CALL	PRINT
 259:	0174          	OBJLUP:	; read response
 260:	0174  CD1201  		CALL	CONIN
 261:	0177  FE03    		CP	CTRLC		; CTRL-C means abort
 262:	0179  CAC601  		JP	Z,EXIT
 263:	017C  E65F    		AND	5FH		; convert to upper case
 264:	017E  FE41    		CP	'A'		;41H
 265:	0180  DA7401  		JP	C,OBJLUP	; bad value - less than A
 266:	0183  FE50    		CP	'P'		;50H
 267:	0185  CA8E01  		JP	Z,SETOBJ
 268:	0188  DA8E01  		JP	C,SETOBJ
 269:	018B  C37401  		JP	OBJLUP		; bad value - greater than P
 270:	018E          	SETOBJ:
 271:	018E  213307  		LD	HL,SRCEME	; Cannot have a one drive copy
 272:	0191  BE      		CP	(HL)
 273:	0192  CA7401  		JP	Z,OBJLUP
 274:	0195  324307  		LD	(OBJMES),A	; save the destination drive
 275:	0198  D641    		SUB	'A'		;41H
 276:	019A  323509  		LD	(OBJDRI),A	; convert value to CP/M number
 277:	019D  3A4307  		LD	A,(OBJMES)
 278:	01A0  4F      		LD	C,A
 279:	01A1  CD1501  		CALL	CONOUT		; echo object drive
 280:				ENDIF
 281:	0000          		IF	SINGLE
 284:				ENDIF
 285:	01A4  112707  		LD	DE,SIGNON
 286:	01A7  CDA505  		CALL	PRINT		; now give chance to change disks
 287:			;				; or give up
 288:	01AA          	AGIN:
 289:	01AA  CD1201  		CALL	CONIN		; read response from keyboard
 290:	01AD  FE03    		CP	CTRLC
 291:	01AF  CAC601  		JP	Z,EXIT		; ctrl-C means quit
 292:	01B2  FE0D    		CP	CR
 293:	01B4  C2AA01  		JP	NZ,AGIN		; CR means go. Ignore anything else
 294:			;
 295:			;	now go do it !
 296:			;
 297:	01B7  11A107  		LD	DE,CRLF
 298:	01BA  CDA505  		CALL	PRINT		; now start actual copy
 299:	01BD  CD0402  		CALL	COPY
 300:	01C0  11B906  		LD	DE,DONMSG
 301:	01C3  CDA505  		CALL	PRINT		; copy is now done, say so
 302:			;
 303:			;	end of this copy
 304:			;
 305:	01C6  FB      	EXIT:	EI
 306:	01C7  312B09  		LD	SP,STKTOP	; re-initialize stack
 307:	01CA  21FFFF  		LD	HL,0FFFFH	; and maybe flush buffers (MP/M)
 308:	01CD  CD2D01  		CALL	SETDMA
 309:	01D0  3A3409  		LD	A,(SRCEDR)	; first, select source drive
 310:	01D3  4F      		LD	C,A
 311:	01D4  CDD705  		CALL	SELDSK
 312:	01D7  CD2101  		CALL	HOME		; home the disk in case
 313:	FFFF          		IF	NOT SINGLE
 314:	01DA  3A3509  		LD	A,(OBJDRI)
 315:	01DD  4F      		LD	C,A		; now, select destination drive
 316:	01DE  CDD705  		CALL	SELDSK
 317:	01E1  CD2101  		CALL	HOME		; and home that disk, in case
 318:				ENDIF
 319:	01E4  FB      	EXIT1:	EI
 320:	01E5  117A07  		LD	DE,REPMES	; ask if another copy is desired
 321:	01E8  CDA505  		CALL	PRINT
 322:	01EB  CD1201  		CALL	CONIN		; read response, upper case
 323:	01EE  E65F    		AND	5FH
 324:	01F0  FE52    		CP	'R'		; R means repeat
 325:	01F2  CA3C01  		JP	Z,REPEAT
 326:	01F5  FE0D    		CP	CR		; carriage return means back to CP/M
 327:	01F7  C2E401  		JP	NZ,EXIT1
 328:	01FA  0E00    		LD	C,0		; set default disk back to A
 329:	01FC  1E01    		LD	E,NOLOG
 330:	01FE  CDD705  		CALL	SELDSK
 331:	0201  C30000  		JP	EXITCP		; and warmstart back to CP/M
 332:			;
 333:			;	this is the main copy routine
 334:			;
 335:	0204          	COPY:
 336:	0204  3A3409  		LD	A,(SRCEDR)	; first, select source drive
 337:	0207  4F      		LD	C,A
 338:	FFFF          		IF	CPM
 339:	0208  1E00    		LD	E,LOGON		; logon request (2.2 deblocking)
 340:				ENDIF
 341:	020A  CDD705  		CALL	SELDSK
 342:	0000          		IF	NOT BXTBL
 345:				ENDIF
 346:	FFFF          		IF	BXTBL
 347:	020D  5E      		LD	E,(HL)
 348:	020E  23      		INC	HL
 349:	020F  56      		LD	D,(HL)
 350:	0210  EB      		EX	DE,HL
 351:	0211  224109  		LD	(XLT),HL	;SAVE BIOS XLATE TABLE ADDRESS
 352:			;
 353:	0214  EB      		EX	DE,HL
 354:	0215  2B      		DEC	HL		;POINT TO DPH AGAIN
 355:	0216  110A00  		LD	DE,10		;INDEX TO...
 356:	0219  19      		ADD	HL,DE		;...DPB ADDRESS IN DPH
 357:	021A  5E      		LD	E,(HL)		;GET DPB...
 358:	021B  23      		INC	HL
 359:	021C  56      		LD	D,(HL)
 360:	021D  EB      		EX	DE,HL		;...ADDRESS TO HL
 361:	021E  E5      		PUSH	HL		;SAVE FOR LATER
 362:	021F  110200  		LD	DE,2		;INDEX TO BSH
 363:	0222  19      		ADD	HL,DE
 364:	0223  7E      		LD	A,(HL)		;GET BSH
 365:	0224  324309  		LD	(BSH),A		;AND SAVE.
 366:	0227  E1      		POP	HL		;GET DPB ADDRESS
 367:	0228  E5      		PUSH	HL		;SAVE AGAIN
 368:	0229  110500  		LD	DE,5		;INDEX TO DSM
 369:	022C  19      		ADD	HL,DE
 370:	022D  5E      		LD	E,(HL)		;GET LOW BYTE
 371:	022E  23      		INC	HL
 372:	022F  56      		LD	D,(HL)		;NOW GET HIGH BYTE
 373:	0230  EB      		EX	DE,HL		;DSM TO HL
 374:	0231  224409  		LD	(DSM),HL	;AND SAVE.
 375:	0234  E1      		POP	HL		;DPB ADDRESS
 376:	0235  E5      		PUSH	HL
 377:	0236  7E      		LD	A,(HL)		;GET SECTORS PER TRACK
 378:	0237  320901  		LD	(SPT),A		;AND SAVE.
 379:	023A  23      		INC	HL
 380:	023B  7E      		LD	A,(HL)		;CHECK HIGH BYTE
 381:	023C  E1      		POP	HL		;GET BACK DPB ADDRESS
 382:	023D  B7      		OR	A		;MORE THAN 255 SPT?
 383:	023E  113808  		LD	DE,SPTERR
 384:	0241  C27002  		JP	NZ,COPY3	;YES, QUIT
 385:			;
 386:	0244  110D00  		LD	DE,13		;INDEX TO RESERVED
 387:	0247  19      		ADD	HL,DE		;TRACK COUNT IN DPB.
 388:	0248  7E      		LD	A,(HL)		;GET LOW BYTE
 389:	0249  320A01  		LD	(OFFSET),A	;AND SAVE.
 390:	024C  3A4C09  		LD	A,(OPTFLG)	;CHECK COMMAND LINE OPTION
 391:	024F  FE44    		CP	'D'		;COPY ONLY DATA TRACKS?
 392:	0251  7E      		LD	A,(HL)
 393:	0252  C25802  		JP	NZ,COPY1
 394:	0255  320401  		LD	(TRKSRT),A	;YES, UPDATE START TRACK
 395:	0258  FE06    	COPY1:	CP	6		;CHECK LOW BYTE
 396:	025A  D26302  		JP	NC,COPY2	;QUIT IF TOO MANY
 397:	025D  23      		INC	HL
 398:	025E  7E      		LD	A,(HL)		;CHECK HIGH BYTE
 399:	025F  B7      		OR	A		;QUIT IF NON-ZERO
 400:	0260  CA7602  		JP	Z,COPY4
 401:	0263  210A01  	COPY2:	LD	HL,OFFSET	;BUT QUIT ONLY
 402:	0266  3A0401  		LD	A,(TRKSRT)	;IF ATTEMPTING
 403:	0269  BE      		CP	(HL)		;TO COPY
 404:	026A  D27602  		JP	NC,COPY4	;A SYSTEM TRACK.
 405:	026D  115308  		LD	DE,OFFERR
 406:	0270  CDA505  	COPY3:	CALL	PRINT		;NOTIFY USER
 407:	0273  C3E401  		JP	EXIT1		;AND BAIL OUT
 408:			;
 409:			;THE FOLLOWING LIFTED FROM FBAD.ASM V60
 410:			; Convert block number to track
 411:			;
 412:	0276          	COPY4:	;CALCULATE TRACKS/DISK IF 'ALL' OR 'DATA' OPTION
 413:	0276  3A4C09  		LD	A,(OPTFLG)
 414:	0279  FE41    		CP	'A'
 415:	027B  CA8302  		JP	Z,COPY5
 416:	027E  FE44    		CP	'D'
 417:	0280  C2BA02  		JP	NZ,COPY6
 418:	0283  2A4409  	COPY5:	LD	HL,(DSM)	;GET MAXIMUM GROUP
 419:	0286  3A4309  		LD	A,(BSH)		; Dpb value that tells how to
 420:			;
 421:	0289  29      	SHIFTL:	ADD	HL,HL		; Shift group number to get
 422:	028A  3D      		DEC	A		; Disk-data-area relative
 423:	028B  C28902  		JP	NZ,SHIFTL	; Record number
 424:	028E  EB      		EX	DE,HL		; Rel record # into 'DE'
 425:	028F  3A0901  		LD	A,(SPT)		; Records per track from DPB
 426:	0292  6F      		LD	L,A
 427:	0293  2600    		LD	H,0
 428:			;
 429:			; Negate HL
 430:	0295  7D      		LD	A,L
 431:	0296  2F      		CPL
 432:	0297  6F      		LD	L,A
 433:	0298  7C      		LD	A,H
 434:	0299  2F      		CPL
 435:	029A  67      		LD	H,A
 436:	029B  23      		INC	HL
 437:			;
 438:	029C  EB      		EX	DE,HL
 439:	029D  010000  		LD	BC,0		; Initialize quotient
 440:			;
 441:			; Divide by number of records
 442:			;	quotient = track
 443:			;	     mod = record
 444:			;
 445:	02A0  03      	DIVLP:	INC	BC		; Dirty division
 446:	02A1  19      		ADD	HL,DE
 447:	02A2  DAA002  		JP	C,DIVLP
 448:	02A5  0B      		DEC	BC		; Fixup last
 449:	02A6  3A0A01  		LD	A,(OFFSET)	; But before we have track #,
 450:	02A9  6F      		LD	L,A		; We have to add system track offset
 451:	02AA  2600    		LD	H,0
 452:	02AC  09      		ADD	HL,BC
 453:	02AD  7C      		LD	A,H
 454:	02AE  B7      		OR	A		;MORE THAN 255 TRACKS ON DISK?
 455:	02AF  117308  		LD	DE,TRKERR
 456:	02B2  C27002  		JP	NZ,COPY3	;YES, ERROR
 457:	02B5  7D      		LD	A,L
 458:	02B6  3C      		INC	A		;LASTRK+1
 459:	02B7  320501  		LD	(TRKSRT+1),A	;UDATE LAST TRACK
 460:			;
 461:	02BA  CD7F06  	COPY6:	CALL	RANGE		;DISPLAY COPY RANGE
 462:	02BD  CD4406  		CALL	INITBF		;SETUP COPY BUFFERS
 463:				ENDIF			;BXTBL
 464:			;
 465:	02C0  CDB808  		CALL	VECTOR		;INITIALIZE BUFFER COUNT
 466:			;
 467:	02C3  3A0601  		LD	A,(BUFFNMB)	; load desired buffer number
 468:	02C6  B7      		OR	A
 469:	02C7  CAE402  		JP	Z,VECT3		; if no autosize, put in
 470:	FFFF          		IF	DOCOMP
 471:	02CA  3D      		DEC	A		; subtract one for compare buffer
 472:	02CB  320601  		LD	(BUFFNMB),A
 473:				ENDIF
 474:	02CE  21B708  		LD	HL,BUFTMP
 475:	02D1  BE      		CP	(HL)		; compare against number found
 476:	02D2  CAEA02  		JP	Z,VECT2
 477:	02D5  DAEA02  		JP	C,VECT2		; branch if smaller
 478:	02D8  118B08  		LD	DE,BUFERR
 479:	02DB  CDA505  		CALL	PRINT		; print out error msg
 480:	02DE  3AB708  		LD	A,(BUFTMP)
 481:	02E1  CD1206  		CALL	PRTDEC		; print out buffer number
 482:	02E4          	VECT3:
 483:	02E4  3AB708  		LD	A,(BUFTMP)
 484:	02E7  320601  		LD	(BUFFNMB),A	; put in smaller buffer number
 485:	02EA          	VECT2:
 486:	02EA  CD2101  		CALL	HOME		; home the disk first, in case
 487:			;				; the controller requires it.
 488:			;				; (this might be the first time
 489:			;				; the drive has been used)
 490:	02ED  3A0401  		LD	A,(TRKSRT)
 491:	02F0  CDBA03  		CALL	SETTRK		; now start with first track
 492:	FFFF          		IF	NOT SINGLE
 493:	02F3  3A3509  		LD	A,(OBJDRI)
 494:	02F6  4F      		LD	C,A		; now, select destination drive
 495:				ENDIF
 496:	FFFF          		IF	CPM AND (NOT SINGLE)
 497:	02F7  1E00    		LD	E,LOGON		; logon request (2.2 deblocking)
 498:				ENDIF
 499:	FFFF          		IF	NOT SINGLE
 500:	02F9  CDD705  		CALL	SELDSK
 501:	02FC  CD2101  		CALL	HOME		; and home that disk, in case
 502:				ENDIF
 503:			;
 504:			;	return here to continue copy
 505:			;
 506:	02FF          	RDLOOP:
 507:	02FF  3A3309  		LD	A,(TRK)		; note current track
 508:	0302  323009  		LD	(TRKSAV),A
 509:	0305  AF      		XOR	A		; reset error counter
 510:	0306  323209  		LD	(CMPERR),A
 511:	0309  11DC07  		LD	DE,TRKM		; print the current starting track
 512:	030C  CDA505  		CALL	PRINT		; being copied
 513:	030F  3A3009  		LD	A,(TRKSAV)
 514:	0312  CD1206  		CALL	PRTDEC
 515:	0315          	TRYRDA:
 516:	0000          		IF	SINGLE
 518:				ENDIF
 519:	0315  3A3409  		LD	A,(SRCEDR)	; select source drive
 520:			;
 521:			;	read  loop
 522:			;
 523:	0318  CDA003  		CALL	STARTL		; start the copy loop (reading source)
 524:	031B          	LOOP1:
 525:	031B  CD2504  		CALL	READT		; read one track
 526:	031E  CA2803  		JP	Z,LOOP4		; if all tracks read, go check errors
 527:	0321  3A3909  		LD	A,(ERR1)
 528:	0324  B7      		OR	A		; not all done, but see if error already
 529:	0325  C21B03  		JP	NZ,LOOP1	; and go try another track
 530:			;
 531:			;	now see if any errors in the previous operations
 532:			;
 533:	0328          	LOOP4:
 534:	0328  3A3909  		LD	A,(ERR1)	; now check if any errors
 535:	032B  B7      		OR	A
 536:	032C  C25003  		JP	NZ,RDSKIP	; jump if no errors at all
 537:	032F  3E10    		LD	A,10H
 538:	0331  323909  		LD	(ERR1),A	; reset error flag
 539:			;
 540:			;	allow NUMERR errors before giving up
 541:			;
 542:	0334  3A3209  		LD	A,(CMPERR)	; check the retry counter
 543:	0337  3C      		INC	A
 544:	0338  323209  		LD	(CMPERR),A
 545:	033B  FE02    		CP	NUMERR		; normally ten retries max
 546:	033D  C21B03  		JP	NZ,LOOP1	; WAS TRYRDA
 547:	0340  11F706  		LD	DE,MESGC	; if maximum error count,
 548:	0343  CDA505  		CALL	PRINT		;   print message
 549:	0346  AF      		XOR	A
 550:	0347  323209  		LD	(CMPERR),A	; full track error, reset error counter
 551:	034A  CD8105  		CALL	ENDLUP
 552:	034D  C21B03  		JP	NZ,LOOP1	; now bump up track and see if done
 553:			;
 554:			;	write loop
 555:			;
 556:	0350          	RDSKIP:
 557:	0350  AF      		XOR	A		; reset error counter
 558:	0351  323209  		LD	(CMPERR),A
 559:	0354          	TRYAGA:
 560:	0000          		IF	SINGLE
 562:				ENDIF
 563:	0354  3A3509  		LD	A,(OBJDRI)	; now select destination disk
 564:	0357  CDA003  		CALL	STARTL		; start the write loop
 565:	035A          	LOOP2:
 566:	035A  CD7204  		CALL	WRITET		; write one track (and readback check)
 567:	035D  CA6703  		JP	Z,LOOP3		; if all tracks written, go check errors
 568:	0360  3A3909  		LD	A,(ERR1)
 569:	0363  B7      		OR	A		; not all done, but see if error already
 570:	0364  C25A03  		JP	NZ,LOOP2
 571:			;
 572:			;	now see if any errors in the previous operations
 573:			;
 574:	0367          	LOOP3:
 575:	0367  3A3909  		LD	A,(ERR1)	; now check if any errors
 576:	036A  B7      		OR	A
 577:	036B  C28C03  		JP	NZ,SKIP		; jump if no errors at all
 578:			;
 579:			;	allow NUMERR errors before giving up
 580:			;
 581:	036E  3A3209  		LD	A,(CMPERR)	; check the retry counter
 582:	0371  3C      		INC	A
 583:	0372  323209  		LD	(CMPERR),A
 584:	0375  FE02    		CP	NUMERR		; normally ten retries max
 585:	0377  C25403  		JP	NZ,TRYAGA
 586:	037A  11F706  		LD	DE,MESGC	; if maximum error count,
 587:	037D  CDA505  		CALL	PRINT		;   print message
 588:	0380  3A0601  		LD	A,(BUFFNMB)
 589:	0383  67      		LD	H,A
 590:	0384  3A3309  		LD	A,(TRK)		;   and set next track
 591:	0387  3C      		INC	A		;   past track in error
 592:	0388  94      		SUB	H
 593:	0389  323009  		LD	(TRKSAV),A
 594:			;
 595:			;	copied all tracks correctly (or NUMERR errors)
 596:			;
 597:	038C          	SKIP:
 598:	038C  3A0601  		LD	A,(BUFFNMB)	; get number of buffers
 599:	038F  67      		LD	H,A
 600:	0390  3A3009  		LD	A,(TRKSAV)	; bump up track counter
 601:	0393  84      		ADD	A,H
 602:	0394  323309  		LD	(TRK),A
 603:	0397  210501  		LD	HL,TRKSRT+1	; see if copy operation is done
 604:	039A  BE      		CP	(HL)		; TRK < LASTRK+1
 605:	039B  D0      		RET	NC
 606:	039C  C2FF02  		JP	NZ,RDLOOP	; go back and do more
 607:	039F  C9      		RET
 608:			;
 609:			;	This routine selects the disk,  and initializes the  buffer
 610:			;	address,  buffer counter, and track counter,and seeks to the
 611:			;	right track.
 612:			;
 613:	03A0          	STARTL:
 614:	0000          		IF	SINGLE
 629:				ENDIF
 630:	FFFF          		IF	NOT SINGLE
 631:	03A0  4F      		LD	C,A		; select the disk first
 632:				ENDIF
 633:	FFFF          		IF	CPM AND NOT SINGLE
 634:	03A1  1E01    		LD	E,NOLOG		; no logon here (2.2 deblocking)
 635:				ENDIF
 636:	FFFF          		IF	NOT SINGLE
 637:	03A3  CDD705  		CALL	SELDSK
 638:				ENDIF
 639:	0000          		IF	TRSKW
 644:				ENDIF
 645:	03A6  2A3D09  		LD	HL,(BUF0)	; load address of first buffer
 646:	03A9  222E09  		LD	(BUF0SA),HL
 647:	03AC  3E10    		LD	A,10H		; reset error flag
 648:	03AE  323909  		LD	(ERR1),A
 649:	03B1  3A0601  		LD	A,(BUFFNMB)	; load number of buffers
 650:	03B4  323109  		LD	(BUFFCO),A
 651:	03B7  3A3009  		LD	A,(TRKSAV)	; load first track copied
 652:			;
 653:			;	set the track to be used, and add offset if source
 654:			;	drive. Save track number for error routine.
 655:			;
 656:	03BA          	SETTRK:
 657:	03BA  323309  		LD	(TRK),A		; save current track
 658:	FFFF          		IF	(NOT SINGLE)
 659:	03BD  3A3609  		LD	A,(CURRDI)	; check drive
 660:	03C0  4F      		LD	C,A
 661:	03C1  3A3409  		LD	A,(SRCEDR)	; is it source
 662:	03C4  B9      		CP	C
 663:	03C5  3A3309  		LD	A,(TRK)		; if object, skip
 664:	03C8  C2D003  		JP	NZ,SETTR0
 665:	03CB  4F      		LD	C,A		; now get difference
 666:	03CC  3A0701  		LD	A,(SRCTRAK)
 667:	03CF  81      		ADD	A,C		; and do correction
 668:	03D0          	SETTR0:
 669:				ENDIF
 670:	03D0  4F      		LD	C,A		; now go set track
 671:	03D1  C32701  		JP	SETRAK
 672:			;
 673:			;	set the DMA address (in HL)
 674:			;
 675:	03D4          	DMASET:
 676:	03D4  4D      		LD	C,L		; move HL to BC
 677:	03D5  44      		LD	B,H
 678:	03D6  C5      		PUSH	BC		; save result and call CBIOS
 679:	03D7  CD2D01  		CALL	SETDMA
 680:	03DA  C1      		POP	BC
 681:	03DB  C9      		RET
 682:			;
 683:			;	these are the disk error handling routines
 684:			;
 685:	03DC          	FAILR:
 686:	03DC  110607  		LD	DE,MESGD	; read error message
 687:	03DF  C3E503  		JP	DIE
 688:	03E2          	FAILW:
 689:	03E2  111607  		LD	DE,MESGE	; write error message
 690:	03E5          	DIE:
 691:	03E5  CDA505  		CALL	PRINT		; print the main error message
 692:	03E8  11DA06  		LD	DE,ERM
 693:	03EB  CDA505  		CALL	PRINT
 694:	03EE  3A3309  		LD	A,(TRK)		; print the track number
 695:	03F1  CD1206  		CALL	PRTDEC
 696:	03F4  11EE06  		LD	DE,MESGB	; print sector message
 697:	03F7  CDA505  		CALL	PRINT
 698:	03FA  3A3A09  		LD	A,(SECTOR)	; and print sector
 699:	03FD  CD1206  		CALL	PRTDEC
 700:	0400  11D106  		LD	DE,DRIVE	; print drive message
 701:	0403  CDA505  		CALL	PRINT
 702:	0406  3A3609  		LD	A,(CURRDI)
 703:	0409  C641    		ADD	A,'A'		; convert drive number to ASCII
 704:	040B  4F      		LD	C,A
 705:	040C  CD1501  		CALL	CONOUT		; and finally print drive
 706:	040F  AF      		XOR	A
 707:	0410  323909  		LD	(ERR1),A	; note the error so this track is retried
 708:	0413  CD0F01  		CALL	CONST
 709:	0416  B7      		OR	A		; see if any console input present
 710:	0417  CA8105  		JP	Z,ENDLUP
 711:	041A  CD1201  		CALL	CONIN		; yes, see if aborting
 712:	041D  FE03    		CP	CTRLC
 713:	041F  CAC601  		JP	Z,EXIT		; die if CTRL-C was hit
 714:	0422  C38105  		JP	ENDLUP
 715:			;
 716:			;	read the full track now, no interleaving
 717:			;
 718:	0425          	READT:
 719:	0425  CD0F01  		CALL	CONST
 720:	0428  B7      		OR	A		; see if any console input present
 721:	0429  CA3404  		JP	Z,READT0
 722:	042C  CD1201  		CALL	CONIN		; yes, see if aborting
 723:	042F  FE03    		CP	CTRLC
 724:	0431  CAC601  		JP	Z,EXIT		; die if CTRL-C was hit
 725:	0434          	READT0:
 726:	FFFF          		IF	(NOT RSKEW) AND (NOT TRSKW)
 727:	0434  2A2E09  		LD	HL,(BUF0SA)	; first, get beginning of buffer
 728:	0437  223709  		LD	(DMAAD),HL
 729:				ENDIF
 730:	0000          		IF	TRSKW
 738:				ENDIF
 739:	FFFF          		IF	(NOT TRSKW)
 740:	043A  0E00    		LD	C,0		; initialize first sector
 741:				ENDIF
 742:	043C  3A0901  		LD	A,(SPT)		; initialize sector count
 743:	043F  47      		LD	B,A
 744:	0440          	RT3:
 745:	0000          		IF	TRSKW
 755:				ENDIF
 756:	0000          		IF	RSKEW
 770:				ENDIF
 771:	FFFF          		IF	(NOT RSKEW)
 772:	0440  0C      		INC	C		; increment sector counter
 773:	0441  C5      		PUSH	BC
 774:	0442  CDB505  		CALL	SETSEC		; set the sector
 775:	0445  2A3709  		LD	HL,(DMAAD)
 776:	0448  CDD403  		CALL	DMASET		; set the DMA
 777:	044B  218000  		LD	HL,SECSIZ
 778:	044E  09      		ADD	HL,BC		; bump up the DMA for next time
 779:	044F  223709  		LD	(DMAAD),HL
 780:				ENDIF
 781:	FFFF          		IF	CPM
 782:	0452  3A3309  		LD	A,(TRK)		; see if track 0
 783:	0455  B7      		OR	A
 784:	0456  C26304  		JP	NZ,ZER2		; jump if not
 785:	0459  3A0801  		LD	A,(SPT0)
 786:	045C  213A09  		LD	HL,SECTOR
 787:	045F  BE      		CP	(HL)		; see if sector is on track
 788:	0460  DA6A04  		JP	C,ZER28
 789:	0463          	ZER2:
 790:				ENDIF
 791:	0463  CD3001  		CALL	BREAD		; now read one sector
 792:	0466  1F      		RRA
 793:	0467  DCDC03  		CALL	C,FAILR		; if returned 01, read error
 794:	046A  C1      	ZER28:	POP	BC
 795:	046B  05      		DEC	B		; see if all sectors read
 796:	046C  C24004  		JP	NZ,RT3
 797:	0000          		IF	TRSKW
 814:				ENDIF
 815:	046F  C38105  		JP	ENDLUP		; return with complete track read
 816:			;
 817:			;	Write the full track,  with interleaving,  and then check it
 818:			;	by reading it all back in.
 819:			;
 820:	0472          	WRITET:
 821:	0472  CD0F01  		CALL	CONST
 822:	0475  B7      		OR	A		; see if any console input present
 823:	0476  CA8104  		JP	Z,WRITE0
 824:	0479  CD1201  		CALL	CONIN		; yes, see if aborting
 825:	047C  FE03    		CP	CTRLC
 826:	047E  CAC601  		JP	Z,EXIT		; die if CTRL-C was hit
 827:	0481          	WRITE0:
 828:	0481  2A2E09  		LD	HL,(BUF0SA)	; first, get the beginning of buffer
 829:	0484  223709  		LD	(DMAAD),HL
 830:	0487  0E00    		LD	C,0
 831:	0489  3A0901  		LD	A,(SPT)		; initialize sector counter
 832:	048C  47      		LD	B,A
 833:	048D          	WT3:
 834:	048D  C5      		PUSH	BC
 835:	048E  21B808  		LD	HL,WRITAB	; find the interleaved sector number
 836:	0491  CDE605  		CALL	XLATE1		; using the WRITAB
 837:	0494  CDB505  		CALL	SETSEC		; and set the sector
 838:	0497  2600    		LD	H,0
 839:	0499  0D      		DEC	C		; now compute the buffer location
 840:	049A  69      		LD	L,C
 841:	049B  CDDE05  		CALL	SHIFT		; and multiply by sector size
 842:	049E  EB      		EX	DE,HL
 843:	049F  2A3709  		LD	HL,(DMAAD)	; and then adding to the buffer start
 844:	04A2  19      		ADD	HL,DE
 845:	04A3  CDD403  		CALL	DMASET		; set the DMA and do the write
 846:	FFFF          		IF	(NOT WRSWCH) AND CPM
 847:	04A6  0E02    		LD	C,WRCODE	; value for CP/M 2.2 routine
 848:				ENDIF
 849:	0000          		IF	WRSWCH AND CPM
 856:				ENDIF
 857:	FFFF          		IF	CPM
 858:	04A8  3A3309  		LD	A,(TRK)		; see if track 0
 859:	04AB  B7      		OR	A
 860:	04AC  C2B904  		JP	NZ,ZER1		; jump if not
 861:	04AF  3A0801  		LD	A,(SPT0)
 862:	04B2  213A09  		LD	HL,SECTOR
 863:	04B5  BE      		CP	(HL)		; see if sector is on track
 864:	04B6  DAC004  		JP	C,ZER18
 865:	04B9          	ZER1:
 866:				ENDIF
 867:	04B9  CD3301  		CALL	WRITE
 868:	04BC  1F      		RRA			; if 01 returned, write error
 869:	04BD  DCE203  		CALL	C,FAILW
 870:	04C0  C1      	ZER18:	POP	BC
 871:	04C1  0C      		INC	C		; increment sector count
 872:	04C2  05      		DEC	B
 873:	04C3  C28D04  		JP	NZ,WT3		; and loop back if not done
 874:	FFFF          		IF	DOCOMP AND (NOT RSKEW)
 875:	04C6  214F09  		LD	HL,BUF1		; first, get beginning of buffer
 876:	04C9  223709  		LD	(DMAAD),HL
 877:				ENDIF
 878:	04CC  0E00    		LD	C,0
 879:	04CE  3A0901  		LD	A,(SPT)		; reinitialize sector counts for read
 880:	04D1  47      		LD	B,A
 881:	04D2          	WT4:
 882:	04D2  0C      		INC	C		; bump up sector counter
 883:	04D3  C5      		PUSH	BC
 884:	0000          		IF	RSKEW
 888:				ENDIF
 889:	0000          		IF	RSKEW AND DOCOMP
 898:				ENDIF
 899:	FFFF          		IF	(NOT RSKEW) AND DOCOMP
 900:	04D4  CDB505  		CALL	SETSEC		; set the sector
 901:	04D7  2A3709  		LD	HL,(DMAAD)
 902:	04DA  CDD403  		CALL	DMASET		; set the DMA
 903:	04DD  218000  		LD	HL,SECSIZ
 904:	04E0  09      		ADD	HL,BC		; bump up the DMA for next time
 905:	04E1  223709  		LD	(DMAAD),HL
 906:				ENDIF
 907:	0000          		IF	RSKEW AND (NOT DOCOMP)
 910:				ENDIF
 911:	0000          		IF	(NOT RSKEW) AND (NOT DOCOMP)
 915:				ENDIF
 916:	FFFF          		IF	CPM
 917:	04E4  3A3309  		LD	A,(TRK)		; see if track 0
 918:	04E7  B7      		OR	A
 919:	04E8  C2F504  		JP	NZ,ZER3		; jump if not
 920:	04EB  3A0801  		LD	A,(SPT0)
 921:	04EE  213A09  		LD	HL,SECTOR
 922:	04F1  BE      		CP	(HL)		; see if sector is on track
 923:	04F2  DAFC04  		JP	C,ZER4
 924:	04F5          	ZER3:
 925:				ENDIF
 926:	FFFF          		IF	NOT NOCOMP
 927:	04F5  CD3001  		CALL	BREAD
 928:	04F8  1F      		RRA			; was bit 0 set by disk error?
 929:	04F9  DCDC03  		CALL	C,FAILR
 930:				ENDIF
 931:	FFFF          		IF	CPM
 932:	04FC          	ZER4:
 933:				ENDIF
 934:	04FC  C1      		POP	BC		; no error, see if all sectors read
 935:	04FD  05      		DEC	B
 936:	04FE  C2D204  		JP	NZ,WT4		; if not all done, go back
 937:	FFFF          		IF	DOCOMP
 938:	0501  E5      		PUSH	HL
 939:	0502  2A4809  		LD	HL,(TKSIZ)
 940:	0505  44      		LD	B,H
 941:	0506  4D      		LD	C,L		; now, compare the track read in
 942:	0507  E1      		POP	HL
 943:				ENDIF
 944:	FFFF          		IF	CPM AND DOCOMP
 945:	0508  3A3309  		LD	A,(TRK)		; see if track 0
 946:	050B  B7      		OR	A
 947:	050C  C21605  		JP	NZ,ZER5		; jump if not
 948:	050F  E5      		PUSH	HL
 949:	0510  2A4609  		LD	HL,(TK0SIZ)
 950:	0513  44      		LD	B,H
 951:	0514  4D      		LD	C,L
 952:	0515  E1      		POP	HL
 953:	0516          	ZER5:
 954:				ENDIF
 955:	FFFF          		IF	DOCOMP
 956:	0516  2A2E09  		LD	HL,(BUF0SA)
 957:	0519  114F09  		LD	DE,BUF1
 958:	051C  1A      	CMPLP:	LD	A,(DE)		; get read data
 959:	051D  BE      		CP	(HL)
 960:	051E  C22C05  		JP	NZ,CERR		; and if not what was written, error
 961:	0521  23      		INC	HL
 962:	0522  13      		INC	DE		; bump counters
 963:	0523  0B      		DEC	BC
 964:	0524  79      		LD	A,C		; and count BC down to zero
 965:	0525  B0      		OR	B
 966:	0526  C21C05  		JP	NZ,CMPLP	; if all done, return
 967:	0529  C38105  		JP	ENDLUP
 968:			;
 969:			;	print read verify compare error
 970:			;
 971:	052C  E5      	CERR:	PUSH	HL		; save the goodies
 972:	052D  D5      		PUSH	DE
 973:	052E  C5      		PUSH	BC
 974:	052F  11ED07  		LD	DE,MESGA	; start the error message
 975:	0532  CDA505  		CALL	PRINT
 976:	0535  3A3309  		LD	A,(TRK)		; print the track number
 977:	0538  CD1206  		CALL	PRTDEC
 978:	053B  11EE06  		LD	DE,MESGB	; print more
 979:	053E  CDA505  		CALL	PRINT
 980:	0541  E1      		POP	HL		; pop the down counter
 981:	0542  2B      		DEC	HL
 982:				ENDIF
 983:	FFFF          		IF	DOCOMP
 984:	0543  29      		ADD	HL,HL		; multiply by 2 to get sectors left
 985:			;
 986:	0544  3A0901  		LD	A,(SPT)
 987:	0547  94      		SUB	H		; subtract from total number of sectors
 988:	0548  CD1206  		CALL	PRTDEC		; to get sector number, and print it
 989:	054B  111008  		LD	DE,MEM
 990:	054E  CDA505  		CALL	PRINT		; print second line
 991:	0551  E1      		POP	HL
 992:	0552  7E      		LD	A,(HL)		; get byte read
 993:	0553  324D09  		LD	(DATA1),A	; and save it
 994:	0556  CDEA05  		CALL	HLOUT		;PRINT HEX ADDRESS
 995:	0559  0E2C    		LD	C,','
 996:	055B  CD1501  		CALL	CONOUT		; comma
 997:	055E  E1      		POP	HL
 998:	055F  7E      		LD	A,(HL)		; get byte written
 999:	0560  324E09  		LD	(DATA2),A	; and save it
1000:	0563  CDEA05  		CALL	HLOUT		;PRINT HEX ADDRESS
1001:	0566  112408  		LD	DE,DATAM	; print data header
1002:	0569  CDA505  		CALL	PRINT
1003:	056C  3A4D09  		LD	A,(DATA1)	; print byte read
1004:	056F  CDF105  		CALL	PRTHEX
1005:	0572  0E2C    		LD	C,','		; comma
1006:	0574  CD1501  		CALL	CONOUT
1007:	0577  3A4E09  		LD	A,(DATA2)	; print byte written
1008:	057A  CDF105  		CALL	PRTHEX
1009:	057D  AF      		XOR	A
1010:	057E  323909  		LD	(ERR1),A	; note the error so this track is retried
1011:				ENDIF
1012:			;
1013:			;	This  routine  is  used to check if another track is  to  be
1014:			;	read/written:   it   increments  buffer  address  and  track
1015:			;	counter,   and  decrements  the  buffer  counter.  Then,  it
1016:			;	terminates  the  loop if all buffers are full  or  the  last
1017:			;	track has been processed (Z flag set).
1018:			;
1019:	0581          	ENDLUP:
1020:	0581  3A3909  		LD	A,(ERR1)	; now check if any errors
1021:	0584  B7      		OR	A		; and return if so
1022:	0585  C8      		RET	Z
1023:	0586  3A3309  		LD	A,(TRK)		; increment track
1024:	0589  3C      		INC	A
1025:	058A  210501  		LD	HL,TRKSRT+1	; check if last track
1026:	058D  BE      		CP	(HL)
1027:	058E  C8      		RET	Z		; return if last track
1028:	058F  CDBA03  		CALL	SETTRK
1029:	0592  213109  		LD	HL,BUFFCO	; decrement buffer counter
1030:	0595  35      		DEC	(HL)
1031:	0596  C8      		RET	Z		; return if all buffers full/empty
1032:	0597  2A4809  		LD	HL,(TKSIZ)
1033:	059A  EB      		EX	DE,HL
1034:	059B  2A2E09  		LD	HL,(BUF0SA)	; increment buffer address
1035:	059E  19      		ADD	HL,DE
1036:	059F  222E09  		LD	(BUF0SA),HL
1037:	05A2  F6FF    		OR	0FFH		; non-zero to indicate more
1038:	05A4  C9      		RET
1039:			;
1040:			;	this  routine  writes  messages  to  the  console.  Message
1041:			;	address  is in DE,  and terminates on a $.  The BDOS call is
1042:			;	not  used  here because BDOS may be destroyed by  the  track
1043:			;	buffers
1044:			;
1045:	05A5          	PRINT:
1046:	05A5  1A      		LD	A,(DE)		; get the character
1047:	05A6  FE24    		CP	'$'		;24H
1048:	05A8  C8      		RET	Z		; quit if $
1049:	05A9  D5      		PUSH	DE
1050:	05AA  E67F    		AND	$7F		; strip higher bit
1051:	05AC  4F      		LD	C,A		; send it to the console
1052:	05AD  CD1501  		CALL	CONOUT
1053:	05B0  D1      		POP	DE		; go check next character
1054:	05B1  13      		INC	DE
1055:	05B2  C3A505  		JP	PRINT
1056:			;
1057:			;	set the next sector to be used, and save that
1058:			;	number for the error routine, in case.
1059:			;	THE FOLLOWING HIDES ANY BIOS SECTOR TRANSLATION
1060:			;	FROM THE PROGRAM.
1061:			;
1062:	05B5          	SETSEC:
1063:	05B5  79      		LD	A,C		; save the sector number
1064:	05B6  323A09  		LD	(SECTOR),A
1065:	05B9  C5      		PUSH	BC
1066:	05BA  210A01  		LD	HL,OFFSET
1067:	05BD  3A3309  		LD	A,(TRK)
1068:	05C0  BE      		CP	(HL)		;SEE IF SYSTEM TRACK
1069:	05C1  DAD205  		JP	C,SETS1		;SKIP IF SO.
1070:	FFFF          		IF	CPM
1071:	05C4  2A4109  		LD	HL,(XLT)	;GET XLATE TABLE ADDRESS
1072:	05C7  EB      		EX	DE,HL		;IN DE
1073:	05C8  0600    		LD	B,0		;CLEAR B
1074:	05CA  0D      		DEC	C		; 1 TO N ==> 0 TO N-1
1075:	05CB  CD3901  		CALL	SECTRAN
1076:	05CE  C1      		POP	BC		;GET BACK SECTOR NUMBER
1077:	05CF  C5      		PUSH	BC		;AND SAVE IT AGAIN
1078:				ENDIF
1079:	FFFF          		IF	BXTBL
1080:	05D0  44      		LD	B,H		;GET TRANSLATED
1081:	05D1  4D      		LD	C,L		;SECTOR NUMBER
1082:				ENDIF
1083:	05D2  CD2A01  	SETS1:	CALL	SETSCT		; now go set the sector
1084:	05D5  C1      		POP	BC		;RETURN WITH ORIGINAL SECTOR
1085:	05D6  C9      		RET
1086:			;
1087:			;	set the disk to be used, and save that
1088:			;	for the error routine, in case
1089:			;
1090:	05D7          	SELDSK:
1091:	05D7  79      		LD	A,C		; save the disk number
1092:	05D8  323609  		LD	(CURRDI),A
1093:	05DB  C32401  		JP	SELDIS		; now select the disk
1094:			;
1095:			;	Routine to multiple value in HL by SECSIZ
1096:			;
1097:	05DE          	SHIFT:
1098:	05DE  29      		ADD	HL,HL
1099:	05DF  29      		ADD	HL,HL		; The number of DAD H instructions
1100:	05E0  29      		ADD	HL,HL
1101:	05E1  29      		ADD	HL,HL		; MUST correspond to the buffer size
1102:	05E2  29      		ADD	HL,HL
1103:	05E3  29      		ADD	HL,HL		; i.e. 7 DADs means 128 byte (2^7)
1104:	05E4  29      		ADD	HL,HL
1105:	05E5  C9      		RET
1106:			;
1107:			; (XLATE1)  WRITAB USAGE:	0 TO N-1 ==> 1 TO N
1108:			; (XLATE )  READTAB USAGE:	1 TO N   ==> 1 TO N
1109:			;
1110:	05E6          	XLATE1:
1111:	FFFF          		IF	BXTBL
1112:	05E6  0C      		INC	C
1113:				ENDIF
1114:	0000          		IF	NOT BXTBL
1119:				ENDIF
1120:			;
1121:	05E7          	XLATE:
1122:	05E7  0600    		LD	B,0
1123:	0000          		IF	NOT BXTBL	;USE BUILT-IN SKEW TABLE
1130:				ENDIF
1131:	05E9  C9      		RET			;ELSE,USE BIOS SECTRAN ROUTINE
1132:			;
1133:			;CONVERT VALUE IN HL TO ASCII HEX AND PRINT IT
1134:			;
1135:	05EA  7C      	HLOUT:	LD	A,H		;DISPLAY H
1136:	05EB  E5      		PUSH	HL
1137:	05EC  CDF905  		CALL	HEXOUT
1138:	05EF  E1      		POP	HL
1139:	05F0  7D      		LD	A,L		;DISPLAY L
1140:	05F1  CDF905  	PRTHEX:	CALL	HEXOUT
1141:	05F4  0E48    		LD	C,'H'		;DENOTES HEX VALUE
1142:	05F6  C31501  		JP	CONOUT
1143:			;
1144:			;	convert value in A reg. to ASCII hex and print it
1145:			;
1146:	05F9          	HEXOUT:
1147:	05F9  F5      		PUSH	AF		; save for LSN
1148:	05FA  1F      		RRA
1149:	05FB  1F      		RRA			; shift MSN nibble to LSN
1150:	05FC  1F      		RRA
1151:	05FD  1F      		RRA
1152:	05FE  CD0206  		CALL	PRTNBL		; now print it
1153:	0601  F1      		POP	AF		; and then do LSN
1154:	0602          	PRTNBL:
1155:	0602  E60F    		AND	0FH
1156:	0604  C630    		ADD	A,'0'		;convert to ASCII value
1157:	0606  FE3A    		CP	'0'+10		; over 9 ?
1158:	0608  DA0D06  		JP	C,SML
1159:	060B  C607    		ADD	A,7		; convert 10 to A, etc.
1160:	060D          	SML:
1161:	060D  4F      		LD	C,A		; move to C for BIOS call
1162:	060E  CD1501  		CALL	CONOUT
1163:	0611  C9      		RET
1164:			;
1165:			;
1166:			;
1167:			;CONVERT BINARY IN (A) TO ASCII DECIMAL
1168:			;
1169:	0612  113030  	PRTDEC:	LD	DE,3030H	;INITIALIZE TO ASCII ZEROS
1170:	0615  0E30    		LD	C,30H
1171:	0617  D664    	SUB100:	SUB	100
1172:	0619  DA2006  		JP	C,ADD100
1173:	061C  1C      		INC	E		;HUNDREDS DIGIT
1174:	061D  C31706  		JP	SUB100
1175:	0620  C664    	ADD100:	ADD	A,100
1176:	0622  D60A    	SUB10:	SUB	10
1177:	0624  DA2B06  		JP	C,UNITS
1178:	0627  14      		INC	D		;TENS DIGIT
1179:	0628  C32206  		JP	SUB10
1180:	062B  C60A    	UNITS:	ADD	A,10
1181:	062D  81      		ADD	A,C
1182:	062E  4F      		LD	C,A		;UNITS DIGIT
1183:			;
1184:	062F  C5      		PUSH	BC
1185:	0630  D5      		PUSH	DE
1186:	0631  7B      		LD	A,E
1187:	0632  FE30    		CP	'0'		;LEADING ZERO?
1188:	0634  CA3B06  		JP	Z,PD1		;YES, SKIP
1189:	0637  4F      		LD	C,A
1190:	0638  CD1501  		CALL	CONOUT
1191:	063B  D1      	PD1:	POP	DE
1192:	063C  4A      		LD	C,D
1193:	063D  CD1501  		CALL	CONOUT
1194:	0640  C1      		POP	BC
1195:	0641  C31501  		JP	CONOUT
1196:			;
1197:			;INITIALIZE COPY BUFFERS
1198:			;
1199:	FFFF          		IF	BXTBL
1200:	0644  3A0801  	INITBF:	LD	A,(SPT0)
1201:	0647  6F      		LD	L,A
1202:	0648  2600    		LD	H,0
1203:	064A  CDDE05  		CALL	SHIFT		;CALC. SPT0*SECSIZ
1204:	064D  224609  		LD	(TK0SIZ),HL	;AND SAVE
1205:			;
1206:	0650  3A0901  		LD	A,(SPT)
1207:	0653  6F      		LD	L,A
1208:	0654  2600    		LD	H,0
1209:	0656  CDDE05  		CALL	SHIFT		;CALC. SDLAST*SECSIZ
1210:	0659  224809  		LD	(TKSIZ),HL	;AND SAVE
1211:	065C  AF      		XOR	A		;NOW GET -(SDLAST*SECSIZ)
1212:	065D  95      		SUB	L
1213:	065E  6F      		LD	L,A
1214:	065F  3E00    		LD	A,0
1215:	0661  9C      		SBC	A,H
1216:	0662  67      		LD	H,A
1217:	0663  224A09  		LD	(TKSIZC),HL	;AND SAVE
1218:				ENDIF			;BXTBL
1219:			;
1220:	FFFF          		IF	DOCOMP AND BXTBL
1221:	0666  2A4809  		LD	HL,(TKSIZ)
1222:	0669  114F09  		LD	DE,BUF1
1223:	066C  19      		ADD	HL,DE
1224:	066D  223B09  		LD	(BUF1END),HL
1225:				ENDIF
1226:	0000          		IF	(NOT DOCOMP) AND (NOT NOCOMP) AND BXTBL
1231:				ENDIF
1232:	0000          		IF	NOCOMP AND BXTBL
1235:				ENDIF
1236:			;
1237:	FFFF          		IF	BXTBL
1238:	0670  2A3B09  		LD	HL,(BUF1END)
1239:	0673  223D09  		LD	(BUF0),HL
1240:	0676  EB      		EX	DE,HL
1241:	0677  2A4809  		LD	HL,(TKSIZ)
1242:	067A  19      		ADD	HL,DE
1243:	067B  223F09  		LD	(BUFEND),HL
1244:				ENDIF
1245:	067E  C9      		RET
1246:			;
1247:			;
1248:	067F  119806  	RANGE:	LD	DE,BGMES1	; Now print message giving copy range
1249:	0682  CDA505  		CALL	PRINT
1250:	0685  3A0401  		LD	A,(TRKSRT)
1251:	0688  CD1206  		CALL	PRTDEC		; print first track
1252:	068B  11AE06  		LD	DE,BGMES2
1253:	068E  CDA505  		CALL	PRINT
1254:	0691  3A0501  		LD	A,(TRKSRT+1)	; print last track
1255:	0694  3D      		DEC	A
1256:	0695  C31206  		JP	PRTDEC
1257:			;
1258:	0698          	BGMES1:
1259:	0698  0D0A436F		DEFB	CR,LF,'Copying from track $'
	      7079696E
	      67206672
	      6F6D2074
	      7261636B
	      2024
1260:	06AE          	BGMES2:
1261:	06AE  20746F20		DEFB	' to track $'
	      74726163
	      6B2024
1262:			;
1263:			;	all messages here for convenience in disassembling
1264:			;
1265:	06B9          	DONMSG:
1266:	06B9  0D0A2A2A		DEFB	CR,LF,'*** COPY COMPLETE ***$'
	      2A20434F
	      50592043
	      4F4D504C
	      45544520
	      2A2A2A24
1267:	06D1          	DRIVE:
1268:	06D1  2C206472		DEFB	', drive $'
	      69766520
	      24
1269:	06DA          	ERM:
1270:	06DA  0D0A2B20		DEFB	CR,LF,'+ ERROR on track $'
	      4552524F
	      52206F6E
	      20747261
	      636B2024
1271:	06EE          	MESGB:
1272:	06EE  20736563		DEFB	' sector $'
	      746F7220
	      24
1273:	06F7          	MESGC:
1274:	06F7  0D0A2B2B		DEFB	CR,LF,'++PERMANENT $'
	      5045524D
	      414E454E
	      542024
1275:	0706          	MESGD:
1276:	0706  0D0A2B20		DEFB	CR,LF,'+ READ ERROR $'
	      52454144
	      20455252
	      4F522024
1277:	0716          	MESGE:
1278:	0716  0D0A2B20		DEFB	CR,LF,'+ WRITE ERROR $'
	      57524954
	      45204552
	      524F5220
	      24
1279:	0000          		IF	SINGLE
1281:				ENDIF
1282:	0727          	SIGNON:
1283:	0727  0D0A536F		DEFB	CR,LF,'Source on '
	      75726365
	      206F6E20
1284:	0733          	SRCEME:
1285:	0733  00      		DEFB	0		; will be filled in later
1286:	0734  3A202020		DEFB	':   '
1287:	FFFF          		IF	NOT SINGLE
1288:	0738  204F626A		DEFB	' Object on '
	      65637420
	      6F6E20
1289:	0743          	OBJMES:
1290:	0743  00      		DEFB	0		; will be filled in later
1291:	0744  3A      		DEFB	':'
1292:				ENDIF
1293:	0745          	SINOFF:
1294:	FFFF          		IF	NOT SINGLE
1295:	0745  0D0A    		DEFB	CR,LF
1296:				ENDIF
1297:	0747  48697420		DEFB	'Hit <RETURN> to continue, or <CONTROL-C> to exit: $'
	      3C524554
	      55524E3E
	      20746F20
	      636F6E74
	      696E7565
	      2C206F72
	      203C434F
	      4E54524F
	      4C2D433E
	      20746F20
	      65786974
	      3A2024
1298:	0000          		IF	SINGLE
1305:				ENDIF
1306:	077A          	REPMES:
1307:	077A  0D0A3C52		DEFB	CR,LF,'<RETURN> to CP/M, or <R>epeat COPY: $'
	      45545552
	      4E3E2074
	      6F204350
	      2F4D2C20
	      6F72203C
	      523E6570
	      65617420
	      434F5059
	      3A2024
1308:	07A1          	CRLF:
1309:	07A1  0D0A24  		DEFB	CR,LF,'$'
1310:	07A4          	SOURCE:
1311:	07A4  0D0A534F		DEFB	CR,LF,'SOURCE drive (A thru P): $'
	      55524345
	      20647269
	      76652028
	      41207468
	      72752050
	      293A2024
1312:	FFFF          		IF	NOT SINGLE
1313:	07C0          	OBJECT:
1314:	07C0  0D0A4F42		DEFB	CR,LF,'OBJECT drive (A thru P): $'
	      4A454354
	      20647269
	      76652028
	      41207468
	      72752050
	      293A2024
1315:				ENDIF
1316:	07DC          	TRKM:
1317:	07DC  0D0A436F		DEFB	CR,LF,'Copying track $'
	      7079696E
	      67207472
	      61636B20
	      24
1318:			;
1319:	FFFF          		IF	DOCOMP
1320:	07ED          	MESGA:
1321:	07ED  0D0A2B20		DEFB	CR,LF,'+ Memory Compare ERROR on track $'
	      4D656D6F
	      72792043
	      6F6D7061
	      72652045
	      52524F52
	      206F6E20
	      74726163
	      6B2024
1322:	0810          	MEM:
1323:	0810  0D0A2B20		DEFB	CR,LF,'+ Memory Address $'
	      4D656D6F
	      72792041
	      64647265
	      73732024
1324:	0824          	DATAM:
1325:	0824  20286F62		DEFB	' (obj,src)   data: $'
	      6A2C7372
	      63292020
	      20646174
	      613A2024
1326:				ENDIF			;DOCOMP
1327:	FFFF          		IF	BXTBL
1328:	0838          	SPTERR:
1329:	0838  0D0A3E32		DEFB	CR,LF,'>255 SECTORS PER TRACK',CR,LF,'$'
	      35352053
	      4543544F
	      52532050
	      45522054
	      5241434B
	      0D0A24
1330:	0853          	OFFERR:
1331:	0853  0D0A3E35		DEFB	CR,LF,'>5 RESERVED (SYSTEM) TRACKS',CR,LF,'$'
	      20524553
	      45525645
	      44202853
	      59535445
	      4D292054
	      5241434B
	      530D0A24
1332:	0873          	TRKERR:
1333:	0873  0D0A3E32		DEFB	CR,LF,'>255 TRACKS ON DISK',CR,LF,'$'
	      35352054
	      5241434B
	      53204F4E
	      20444953
	      4B0D0A24
1334:				ENDIF			;BXTBL
1335:			;
1336:	088B          	BUFERR:
1337:	088B  0D0A5450		DEFB	CR,LF,'TPA is too small - BUFFER SPACE REDUCED: $'
	      41206973
	      20746F6F
	      20736D61
	      6C6C202D
	      20425546
	      46455220
	      53504143
	      45205245
	      44554345
	      443A2024
1338:			;
1339:	08B7  00      	BUFTMP:	DEFB	0		; temporary storage for buffer counter
1340:			;
1341:			;	 This  is  the  sector interleave table.  If  you  want  the
1342:			;	program to work,  all sector numbers must be here somewhere.
1343:			;
1344:	08B8          	WRITAB:
1345:			;
1346:			;THE FOLLOWING ARE FOR STANDARD IBM 3740 26 SPT FORMAT
1347:	0000          		IF	CPM AND (NOT RSKEW) AND (NOT SLOW) AND (NOT BXTBL)
1352:				ENDIF
1353:	0000          		IF	CPM AND (NOT RSKEW) AND SLOW AND (NOT BXTBL)
1357:				ENDIF
1358:	0000          		IF	CPM AND RSKEW AND (NOT SLOW) AND (NOT BXTBL)
1362:				ENDIF
1363:	0000          		IF	CPM AND RSKEW AND SLOW AND (NOT BXTBL)
1367:				ENDIF
1368:			;
1369:			;
1370:			;	 This  is the read skew table,  if needed.  The same general
1371:			;	considerations as the write skew table apply here also,  but
1372:			;	the table should start with sector 1.  Both the read and the
1373:			;	read-after write use this table.  As you can see,  the write
1374:			;	and read interleaving doesn't have to be the same.
1375:			;
1376:	08B8          	READTAB:
1377:			;
1378:	0000          		IF	RSKEW AND CPM AND (NOT BXTBL)
1382:				ENDIF
1383:			;
1384:			;
1385:			;	This is the write switch table. The values in this table
1386:			;	are passed to the sector write routine of CP/M 2.2 in
1387:			;	reg. C when each write occurs. This table is modified if
1388:			;	and only if some particular pattern is needed for your
1389:			;	blocking routine to work as fast or as well as possible.
1390:			;	Refer to the CP/M 2.2 Alteration Guide for more details.
1391:			;
1392:	0000          		IF	WRSWCH AND CPM
1398:				ENDIF
1399:			;
1400:			;	This is the initialization code, and occupies the lowest area
1401:			;	of the stack.
1402:			;	(The stack is about 40 bytes long)
1403:			;
1404:	08B8          	VECTOR:
1405:	08B8  3E00    		LD	A,BUFFNU
1406:	08BA  320601  		LD	(BUFFNMB),A	;INITIALIZE DEFAULT COUNT
1407:	08BD  AF      		XOR	A
1408:	08BE  32B708  		LD	(BUFTMP),A	;CLEAR BUFTMP
1409:			;
1410:	08C1  2A0100  		LD	HL,(1)		; get bottom of CBIOS
1411:	08C4  3A0B01  		LD	A,(BDOSFG)	;SEE IF
1412:	08C7  B7      		OR	A		;WE DO NOT WANT
1413:	08C8  CACE08  		JP	Z,VECT		;TO OVERWRITE THE BDOS.
1414:	08CB  2A0600  		LD	HL,(6)		;GET BOTTOM OF BDOS
1415:	08CE  44      	VECT:	LD	B,H
1416:	08CF  2A4809  		LD	HL,(TKSIZ)
1417:	08D2  EB      		EX	DE,HL		; get size of buffers
1418:	08D3  2A3D09  		LD	HL,(BUF0)	; start checking where buffer starts
1419:	08D6          	VECT0:
1420:	08D6  19      		ADD	HL,DE		; add buffer size to buffer addr
1421:	08D7  D8      		RET	C		; stop if at end of core
1422:	08D8  7C      		LD	A,H
1423:	08D9  B8      		CP	B		; check hi order byte if high
1424:	08DA  C8      		RET	Z		; or equal
1425:	08DB  D0      		RET	NC
1426:	08DC  7E      		LD	A,(HL)		; gonna see if got memory
1427:	08DD  2F      		CPL
1428:	08DE  77      		LD	(HL),A		; store complement in memory
1429:	08DF  BE      		CP	(HL)		; and see if it is a good spot
1430:	08E0  C0      		RET	NZ
1431:	08E1  3AB708  		LD	A,(BUFTMP)	; buffer fits, add one to count
1432:	08E4  3C      		INC	A
1433:	08E5  32B708  		LD	(BUFTMP),A	; and store
1434:	08E8  C3D608  		JP	VECT0
1435:			;
1436:			;	the stack
1437:			;
1438:	08EB .. 092A 00		DEFS	64
1439:	092B          	STKTOP:
1440:	092B  00      		DEFB	0
1441:	092C .. 092D 00		DEFS	2		;EXTRA SPACE
1442:			;
1443:			;	variables
1444:			;
1445:	092E          	BUF0SA:	; buffer address
1446:	092E  0000    		DEFB	0,0
1447:	0930          	TRKSAV:	; track save area during read and write
1448:	0930  00      		DEFB	0
1449:	0931          	BUFFCO:	; buffer counter
1450:	0931  00      		DEFB	0
1451:	0932          	CMPERR:	; number of disk errors
1452:	0932  00      		DEFB	0
1453:	0933          	TRK:	; current track
1454:	0933  00      		DEFB	0
1455:	0934          	SRCEDR:	; source drive
1456:	FFFF          		IF	NOT SINGLE
1457:	0934  00      		DEFB	0
1458:				ENDIF
1459:	0935          	OBJDRI:	; destination drive
1460:	0935  00      		DEFB	0
1461:	0936          	CURRDI:	; drive for current operation
1462:	0936  00      		DEFB	0
1463:	0937          	DMAAD:	; DMA address for current operation
1464:	0937  0000    		DEFB	0,0
1465:	0939          	ERR1:	; error flag (0 = error)
1466:	0939  00      		DEFB	0
1467:	093A          	SECTOR:	; sector number for current operation
1468:	093A  00      		DEFB	0
1469:			;
1470:	0000          		IF	TRSKW
1475:				ENDIF
1476:			;
1477:	093B  4F16    	BUF1END:DEFW	DSBUF1END
1478:			;
1479:	093D  4F16    	BUF0:	DEFW	DSBUF0
1480:			;
1481:	093F  4F23    	BUFEND:	DEFW	DSBUFEND
1482:			;
1483:	0941  0000    	XLT:	DEFW	00		;ADDRESS OF BIOS SECTOR XLATE TABLE
1484:			;
1485:	0943  00      	BSH:	DEFB	0		;BLOCK SHIFT FROM BIOS DPB
1486:			;
1487:	0944  0000    	DSM:	DEFW	00		;DRIVE SIZE FROM BIOS DPB
1488:			;
1489:	0946  000D    	TK0SIZ:	DEFW	SDZERO*SECSIZ	;TRACK ZERO SIZE
1490:			;
1491:	0948  000D    	TKSIZ:	DEFW	SDLAST*SECSIZ	;DATA TRACK SIZE
1492:			;
1493:	094A  00F3    	TKSIZC:	DEFW	-(SDLAST*SECSIZ); 0 - DATA TRACK SIZE
1494:			;
1495:	094C  00      	OPTFLG:	DEFB	0		;COMMAND LINE OPTION LETTER
1496:			;
1497:			;	the track buffers. BUFEND must not overlay the BIOS !
1498:			;
1499:			;	BUF1 is where the read-after-write is performed
1500:			;
1501:	FFFF          		IF	DOCOMP
1502:	094D          	DATA1:
1503:	094D .. 094D 00		DEFS	1		; used in compare
1504:	094E          	DATA2:
1505:	094E .. 094E 00		DEFS	1
1506:				ENDIF
1507:			;
1508:	094F          	BUF1	EQU	$
1509:			;
1510:	FFFF          		IF	DOCOMP
1511:	164F          	DSBUF1END EQU	BUF1+(SECSIZ*SDLAST); space for a full track read
1512:				ENDIF
1513:			;
1514:	0000          		IF	(NOT DOCOMP) AND (NOT NOCOMP)
1516:				ENDIF
1517:	0000          		IF	NOCOMP
1519:				ENDIF
1520:			;
1521:			;	BUF0 is where all input tracks are read
1522:			;	Tho space for only one track is allocated here,
1523:			;	the program will use BUFFNU track buffers, or
1524:			;	up to the CBIOS, whichever is smaller
1525:			;
1526:	164F          	DSBUF0	EQU	DSBUF1END
1527:	234F          	DSBUFEND EQU	DSBUF0+(SECSIZ*SDLAST)
1528:			;
1529:			;	This is one-time code to initialize the branch table to
1530:			;	the CBIOS vectors. Only those vectors used are initialized.
1531:			;	Placed here so that it wont get clobbered by the stack
1532:			;
1533:	094F          	VECT1:
1534:	094F  2A0100  		LD	HL,(1)		; get warm boot address
1535:	0952  F9      		LD	SP,HL		; and save it in SP for DAD
1536:	0953  210300  		LD	HL,3
1537:	0956  39      		ADD	HL,SP
1538:	0957  221001  		LD	(CONST+1),HL
1539:			;
1540:	095A  210600  		LD	HL,6
1541:	095D  39      		ADD	HL,SP
1542:	095E  221301  		LD	(CONIN+1),HL
1543:			;
1544:	0961  210900  		LD	HL,9
1545:	0964  39      		ADD	HL,SP
1546:	0965  221601  		LD	(CONOUT+1),HL
1547:			;
1548:	FFFF          		IF	CPM
1549:	0968  211500  		LD	HL,15H		; home disk
1550:	096B  39      		ADD	HL,SP
1551:	096C  222201  		LD	(HOME+1),HL
1552:			;
1553:	096F  211800  		LD	HL,18H		; select disk
1554:	0972  39      		ADD	HL,SP
1555:	0973  222501  		LD	(SELDIS+1),HL
1556:			;
1557:	0976  211B00  		LD	HL,1BH		; set track
1558:	0979  39      		ADD	HL,SP
1559:	097A  222801  		LD	(SETRAK+1),HL
1560:			;
1561:	097D  211E00  		LD	HL,1EH		; set sector
1562:	0980  39      		ADD	HL,SP
1563:	0981  222B01  		LD	(SETSCT+1),HL
1564:			;
1565:	0984  212100  		LD	HL,21H		; set dma
1566:	0987  39      		ADD	HL,SP
1567:	0988  222E01  		LD	(SETDMA+1),HL
1568:			;
1569:	098B  212400  		LD	HL,24H		; read disk
1570:	098E  39      		ADD	HL,SP
1571:	098F  223101  		LD	(BREAD+1),HL
1572:			;
1573:	0992  212700  		LD	HL,27H		; write disk
1574:	0995  39      		ADD	HL,SP
1575:	0996  223401  		LD	(WRITE+1),HL
1576:			;
1577:	0999  0E0C    		LD	C,12		; see if got CP/M 2.2
1578:	099B  CD0500  		CALL	5
1579:	099E  7C      		LD	A,H		; check for non-zero
1580:	099F  B5      		OR	L
1581:	09A0  C2AB09  		JP	NZ,GRUNJ1
1582:	09A3  3EC9    		LD	A,$C9		; (RET) no SECTRAN for CP/M 1.4
1583:	09A5  323901  		LD	(SECTRAN),A
1584:	09A8  C3B209  		JP	GRUNJ2
1585:	09AB          	GRUNJ1:
1586:	09AB  212D00  		LD	HL,2DH		; sector translate
1587:	09AE  39      		ADD	HL,SP
1588:	09AF  223A01  		LD	(SECTRAN+1),HL
1589:	09B2          	GRUNJ2:
1590:				ENDIF
1591:			;
1592:			;
1593:			;
1594:			;	Now check what kind of copy is wanted
1595:			;
1596:	09B2  312B09  		LD	SP,STKTOP	; initial stack
1597:	09B5  11DE0A  		LD	DE,INIT
1598:	09B8  CDA505  		CALL	PRINT		; start program
1599:	09BB  2A0401  		LD	HL,(TRKSRT)
1600:			;
1601:	09BE  3A5D00  		LD	A,(FCB+1)	; get character of parameter
1602:	09C1  FE20    		CP	' '		; check for default
1603:	09C3  3E44    		LD	A,'D'		;DEFAULT OPTION- DATA TRACKS
1604:	09C5  324C09  		LD	(OPTFLG),A	;SAVE OPTION
1605:	09C8  CAD40A  		JP	Z,COPYDEF
1606:	09CB  3A5D00  		LD	A,(FCB+1)	;GET CHARACTER AGAIN
1607:	09CE  FE24    		CP	'$'		;OPTION DESIGNATOR
1608:	09D0  C2170A  		JP	NZ,COPYERR	;GIVE HELP
1609:	09D3  3E20    		LD	A,' '		;initl end of FCB
1610:	09D5  326400  		LD	(FCB+8),A
1611:	09D8  215E00  		LD	HL,FCB+2
1612:	09DB  7E      		LD	A,(HL)		;GET CHARACTER OF PARAMETER
1613:	09DC  23      		INC	HL
1614:	09DD  E65F    		AND	5FH		;UPPER CASE
1615:	09DF  324C09  		LD	(OPTFLG),A	;SAVE OPTION
1616:	09E2  47      		LD	B,A
1617:	09E3  AF      		XOR	A		; no track shift
1618:	09E4  320701  		LD	(SRCTRAK),A
1619:	09E7  78      		LD	A,B
1620:	09E8  FE44    		CP	'D'		; check for Data
1621:	09EA  CA8B0A  		JP	Z,COPYDAT
1622:	09ED  FE46    		CP	'F'		; check for First
1623:	09EF  CA920A  		JP	Z,COPYFIR
1624:	09F2  FE4C    		CP	'L'		; check for Last
1625:	09F4  CA990A  		JP	Z,COPYLAS
1626:	09F7  FE4F    		CP	'O'		; check for One
1627:	09F9  CAA00A  		JP	Z,COPYONE
1628:	09FC  FE50    		CP	'P'		; check for Pascal
1629:	09FE  CAA70A  		JP	Z,COPYPAS
1630:	FFFF          		IF	CPM
1631:	0A01  FE41    		CP	'A'		; check for All
1632:	0A03  CAAE0A  		JP	Z,COPYALL
1633:	0A06  FE53    		CP	'S'		; check for System
1634:	0A08  CABF0A  		JP	Z,COPYSYS
1635:	0A0B  FE5A    		CP	'Z'		; check for Zero
1636:	0A0D  CAD00A  		JP	Z,COPYZER
1637:				ENDIF
1638:	0A10  2B      		DEC	HL		;BACK UP POINTER
1639:	0A11  CD4B0A  		CALL	GETNUM		; go check for number
1640:	0A14  D2200A  		JP	NC,COPYNUM
1641:	0A17          	COPYERR:
1642:	0A17  11350B  		LD	DE,CALLERR	; got a bad value
1643:	0A1A  CDA505  		CALL	PRINT
1644:	0A1D  C30000  		JP	EXITCP
1645:			;
1646:			;	routine to decode a numeric value or range
1647:			;
1648:	0A20          	COPYNUM:
1649:	0A20  57      		LD	D,A		; put in lastrk+1
1650:	0A21  3D      		DEC	A
1651:	0A22  5F      		LD	E,A		; put in first track
1652:	0A23  7E      		LD	A,(HL)
1653:	0A24  EB      		EX	DE,HL
1654:	0A25  FE20    		CP	' '		; check if only one parameter
1655:	0A27  CAD40A  		JP	Z,COPYDEF
1656:	0A2A  EB      		EX	DE,HL
1657:	0A2B  FE2C    		CP	','		; ALLOW A COMMA OR DASH
1658:	0A2D  CA350A  		JP	Z,CN1
1659:	0A30  FE2D    		CP	'-'		; check for minus
1660:	0A32  C2170A  		JP	NZ,COPYERR
1661:	0A35  23      	CN1:	INC	HL		; get another number
1662:	0A36  CD4B0A  		CALL	GETNUM
1663:	0A39  DA170A  		JP	C,COPYERR
1664:	0A3C  57      		LD	D,A		; put in last track
1665:	0A3D  BB      		CP	E
1666:	0A3E  DA170A  		JP	C,COPYERR
1667:	0A41  3E20    		LD	A,' '		; check for last character
1668:	0A43  BE      		CP	(HL)
1669:	0A44  C2170A  		JP	NZ,COPYERR
1670:	0A47  EB      		EX	DE,HL		; all OK, go do it
1671:	0A48  C3D40A  		JP	COPYDEF
1672:			;
1673:	0A4B          	GETNUM:
1674:	0A4B  CD580A  		CALL	GETNM
1675:	0A4E  D8      		RET	C		;BAD VALUE
1676:	0A4F          	GETDUN:
1677:	0A4F  04      		INC	B		; add 1 (for last track)
1678:	0A50  3E4D    		LD	A,LASTRK
1679:	0A52  B8      		CP	B		; check for valid range
1680:	0A53  DA870A  		JP	C,GETER
1681:	0A56  78      		LD	A,B		; all done OK
1682:	0A57  C9      		RET
1683:			;
1684:	0A58  7E      	GETNM:	LD	A,(HL)		; valid digit ?
1685:	0A59  FE30    		CP	'0'
1686:	0A5B  D8      		RET	C		; Carry flag if No
1687:	0A5C  FE3A    		CP	'9'+1
1688:	0A5E  3F      		CCF
1689:	0A5F  D8      		RET	C
1690:	0A60  97      		SUB	A		; initial the number
1691:	0A61  47      		LD	B,A
1692:	0A62          	GETLUP:
1693:	0A62  78      		LD	A,B
1694:	0A63  87      		ADD	A,A		; * 2
1695:	0A64  DA870A  		JP	C,GETER
1696:	0A67  87      		ADD	A,A		; * 4
1697:	0A68  DA870A  		JP	C,GETER
1698:	0A6B  80      		ADD	A,B		; * 5
1699:	0A6C  DA870A  		JP	C,GETER
1700:	0A6F  87      		ADD	A,A		; * 10
1701:	0A70  DA870A  		JP	C,GETER
1702:	0A73  47      		LD	B,A
1703:	0A74  7E      		LD	A,(HL)		; get digit
1704:	0A75  D630    		SUB	'0'
1705:	0A77  80      		ADD	A,B		; add to shifted number
1706:	0A78  DA870A  		JP	C,GETER
1707:	0A7B  47      		LD	B,A
1708:	0A7C  23      		INC	HL		; get next character
1709:	0A7D  7E      		LD	A,(HL)
1710:	0A7E  FE30    		CP	'0'		; check if digit
1711:	0A80  3F      		CCF
1712:	0A81  D0      		RET	NC
1713:	0A82  FE3A    		CP	'9'+1
1714:	0A84  DA620A  		JP	C,GETLUP
1715:	0A87          	GETER:
1716:	0A87  E1      		POP	HL		; gonna leave abnormally
1717:	0A88  C3170A  		JP	COPYERR
1718:			;
1719:			;	implement the alphabetic abbreviations for range
1720:			;
1721:	0A8B          	COPYDAT:
1722:	0A8B  264D    		LD	H,LASTRK	; Data
1723:	0A8D  2E02    		LD	L,FIRSTRK
1724:	0A8F  C3D40A  		JP	COPYDEF
1725:	0A92          	COPYFIR:
1726:	0A92  2603    		LD	H,FIRSTRK+1	; First
1727:	0A94  2E02    		LD	L,FIRSTRK
1728:	0A96  C3D40A  		JP	COPYDEF
1729:	0A99          	COPYLAS:
1730:	0A99  264D    		LD	H,LASTRK	; Last
1731:	0A9B  2E4C    		LD	L,LASTRK-1
1732:	0A9D  C3D40A  		JP	COPYDEF
1733:	0AA0          	COPYONE:
1734:	0AA0  2602    		LD	H,2		; One
1735:	0AA2  2E01    		LD	L,1
1736:	0AA4  C3D40A  		JP	COPYDEF
1737:	0AA7          	COPYPAS:
1738:	0AA7  264D    		LD	H,LASTRK	; Pascal
1739:	0AA9  2E01    		LD	L,1
1740:	0AAB  C3D40A  		JP	COPYDEF
1741:	0AAE          	COPYALL:
1742:	FFFF          		IF	BXTBL
1743:	0AAE  CD580A  		CALL	GETNM		;CHECK FOR OPTIONAL TRACK 0 SECTOR COUNT
1744:	0AB1  DAB80A  		JP	C,CPYALL
1745:	0AB4  78      		LD	A,B
1746:	0AB5  320801  		LD	(SPT0),A
1747:				ENDIF
1748:	0AB8  264D    	CPYALL:	LD	H,LASTRK	; All
1749:	0ABA  2E00    		LD	L,0
1750:	0ABC  C3D40A  		JP	COPYDEF
1751:	0ABF          	COPYSYS:
1752:	FFFF          		IF	BXTBL
1753:	0ABF  CD580A  		CALL	GETNM		;CHECK FOR OPTIONAL TRACK 0 SECTOR COUNT
1754:	0AC2  DAC90A  		JP	C,CPYSYS
1755:	0AC5  78      		LD	A,B
1756:	0AC6  320801  		LD	(SPT0),A
1757:				ENDIF
1758:	0AC9  2602    	CPYSYS:	LD	H,FIRSTRK	; System
1759:	0ACB  2E00    		LD	L,0
1760:	0ACD  C3D40A  		JP	COPYDEF
1761:	0AD0          	COPYZER:
1762:	0AD0  2601    		LD	H,1		; Zero
1763:	0AD2  2E00    		LD	L,0
1764:			;
1765:			;	The one time finish - up routine
1766:			;
1767:	0AD4          	COPYDEF:
1768:	0AD4  220401  		LD	(TRKSRT),HL
1769:	0000          		IF	NOT BXTBL	;GIVE COPY RANGE NOW
1771:				ENDIF
1772:			;
1773:	0AD7  213C01  		LD	HL,REPEAT	; go to mainline code now
1774:	0ADA  220101  		LD	(START+1),HL
1775:	0ADD  E9      		JP	(HL)
1776:			;
1777:	0ADE          	INIT:
1778:	0ADE  0D0A434F		DEFB	CR,LF,'COPYFAST '
	      50594641
	      535420
1779:	0AE9  76342E33		DEFB	'v4.3R '
	      5220
1780:	FFFF          		IF	BXTBL
1781:	0AEF  20202020		DEFB	'    (Universal'
	      28556E69
	      76657273
	      616C
1782:				ENDIF
1783:			;
1784:	0000          		IF	NOT BXTBL
1786:				ENDIF
1787:	0000          		IF	SINGLE
1789:				ENDIF
1790:	0AFD  20566572		DEFB	' Version)'
	      73696F6E
	      29
1791:	0B06  0D0A    		DEFB	CR,LF
1792:	0B08  53656374		DEFB	'Sector-for-Sector Disk Duplication Utility'
	      6F722D66
	      6F722D53
	      6563746F
	      72204469
	      736B2044
	      75706C69
	      63617469
	      6F6E2055
	      74696C69
	      7479
1793:	0B32  0D0A24  		DEFB	CR,LF,'$'
1794:			;
1795:	0B35          	CALLERR:
1796:	0B35  0D0A494E		DEFB	CR,LF,'INVALID PARAMETER'
	      56414C49
	      44205041
	      52414D45
	      544552
1797:	0B48  0D0A0D0A		DEFB	CR,LF,CR,LF
1798:	0B4C  20202020		DEFB	'       Usage:   [d:]COPYFAST ['
	      20202055
	      73616765
	      3A202020
	      5B643A5D
	      434F5059
	      46415354
	      205B
1799:	0B6A  A4      		DEFB	'$' OR 80H	;ALLOWS DOLLAR SIGN IN MESSAGE
1800:	0B6B  6F707469		DEFB	'option]',CR,LF,CR,LF
	      6F6E5D0D
	      0A0D0A
1801:	0B76  20202020		DEFB	'       Options are:  (first letter only)',CR,LF
	      2020204F
	      7074696F
	      6E732061
	      72653A20
	      20286669
	      72737420
	      6C657474
	      6572206F
	      6E6C7929
	      0D0A
1802:	0BA0  416C6C20		DEFB	'All     Entire disk',CR,LF
	      20202020
	      456E7469
	      72652064
	      69736B0D
	      0A
1803:	0BB5  44617461		DEFB	'Data    CP/M data area',CR,LF
	      20202020
	      43502F4D
	      20646174
	      61206172
	      65610D0A
1804:			;;	DB	'First   CP/M directory track',CR,LF
1805:			;;	DB	'Last    Last track on disk',CR,LF
1806:			;;	DB	'One     Track one, UCSD directory',CR,LF
1807:			;;	DB	'Pascal  UCSD Pascal data area',CR,LF
1808:	0BCD  53797374		DEFB	'System  CP/M bootstrap',CR,LF
	      656D2020
	      43502F4D
	      20626F6F
	      74737472
	      61700D0A
1809:			;;	DB	'Zero    Track zero, UCSD bootstrap',CR,LF
1810:	0BE5  6E6E2020		DEFB	'nn      One track, as specified',CR,LF
	      20202020
	      4F6E6520
	      74726163
	      6B2C2061
	      73207370
	      65636966
	      6965640D
	      0A
1811:	0C06  6E312D6E		DEFB	'n1-n2   A specified range',CR,LF,CR,LF
	      32202020
	      41207370
	      65636966
	      69656420
	      72616E67
	      650D0A0D
	      0A
1812:	FFFF          		IF	BXTBL
1813:	0C23  416E3120		DEFB	'An1 or Sn1 changes track 0 default SPT to n1',CR,LF
	      6F722053
	      6E312063
	      68616E67
	      65732074
	      7261636B
	      20302064
	      65666175
	      6C742053
	      50542074
	      6F206E31
	      0D0A
1814:				ENDIF
1815:	0C51  24      		DEFB	'$'
1816:			;
1817:			;
1818:	0C52          		END



Statistics:

     4	passes
     0	jr promotions
   216	symbols
     0	bytes



Symbol Table:

add100           620     exit             1c6     setrak           127     
agin             1aa     exit1            1e4     sets1            5d2     
bdosfg           10b     exitcp         =   0+    setsct           12a     
bgmes1           698     failr            3dc     setsec           5b5     
bgmes2           6ae     failw            3e2     setsou           15f     
blist            118+    false          =   0+    settr0           3d0     
bread            130     fcb            =  5c+    settrk           3ba     
bsh              943     firstrk        =   2+    shift            5de     
buf0             93d     getdun           a4f+    shiftl           289     
buf0sa           92e     geter            a87     signon           727     
buf1           = 94f+    getlup           a62     single         =   0+    
buf1end          93b     getnm            a58     sinoff           745+    
bufend           93f     getnum           a4b     skip             38c     
buferr           88b     grunj1           9ab     slow           =   0+    
buffco           931     grunj2           9b2     sml              60d     
buffnmb          106     hexout           5f9     source           7a4     
buffnu         =   0+    hlout            5ea     spt              109     
buftmp           8b7     home             121     spt0             108     
bxtbl          =ffff+    init             ade     spterr           838     
callerr          b35     initbf           644     srcedr           934     
cerr             52c     lastrk         =  4d+    srcelu           145     
cmperr           932     lf             =   a+    srceme           733     
cmplp            51c     listst           136+    srctrak          107     
cn1              a35     logon          =   0+    start            100     
conin            112     loop1            31b     startl           3a0     
conout           115     loop2            35a     stktop           92b     
const            10f     loop3            367     sub10            622     
copy             204     loop4            328     sub100           617     
copy1            258     mem              810     tk0siz           946     
copy2            263     mesga            7ed     tksiz            948     
copy3            270     mesgb            6ee     tksizc           94a     
copy4            276     mesgc            6f7     trk              933     
copy5            283     mesgd            706     trkerr           873     
copy6            2ba     mesge            716     trkm             7dc     
copyall          aae     nocomp         =   0+    trksav           930     
copydat          a8b     nolog          =   1+    trksrt           104     
copydef          ad4     numerr         =   2+    trskw          =   0+    
copyerr          a17     objdri           935     true           =ffff+    
copyfir          a92     object           7c0     tryaga           354     
copylas          a99     objlup           174     tryrda           315+    
copynum          a20     objmes           743     tskew          =   0+    
copyone          aa0     offerr           853     units            62b     
copypas          aa7     offset           10a     vect             8ce     
copysys          abf     optflg           94c     vect0            8d6     
copyzer          ad0     pd1              63b     vect1            94f     
cpm            =ffff+    print            5a5     vect2            2ea     
cpyall           ab8     prtdec           612     vect3            2e4     
cpysys           ac9     prthex           5f1     vector           8b8     
cr             =   d+    prtnbl           602     wboot            10c+    
crlf             7a1     punch            11b+    wrcode         =   2+    
ctrlc          =   3+    range            67f     writab           8b8     
currdi           936     rdloop           2ff     write            133     
data1            94d     rdskip           350     write0           481     
data2            94e     reader           11e+    writet           472     
datam            824     readt            425     wrswch         =   0+    
die              3e5     readt0           434     wt3              48d     
difftrk        =   0+    readtab          8b8+    wt4              4d2     
divlp            2a0     repeat           13c     xlate            5e7+    
dmaad            937     repmes           77a     xlate1           5e6     
dmaset           3d4     rskew          =   0+    xlt              941     
docomp         =ffff+    rt3              440     xxxskw         =   0+    
donmsg           6b9     sdlast         =  1a+    zer1             4b9     
drive            6d1     sdzero         =  1a+    zer18            4c0     
dsbuf0         =164f+    secsiz         =  80+    zer2             463     
dsbuf1end      =164f+    sector           93a     zer28            46a     
dsbufend       =234f+    sectran          139     zer3             4f5     
dsm              944     seldis           124     zer4             4fc     
endlup           581     seldsk           5d7     zer5             516     
erm              6da     setdma           12d     
err1             939     setobj           18e     
