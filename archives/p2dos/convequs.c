/***************************************************************************
*   Copyright (C) 2005 by Piergiorgio Betti   *
*   pbetti@lpconsul.net   *
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
*   This program is distributed in the hope that it will be useful,       *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
*   GNU General Public License for more details.                          *
*                                                                         *
*   You should have received a copy of the GNU General Public License     *
*   along with this program; if not, write to the                         *
*   Free Software Foundation, Inc.,                                       *
*   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
***************************************************************************/


#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <ctype.h>

#define	MAXSYMBOLS	8192

typedef struct {
	char symbol[16];
	int value;
} SYMTAB;

static char ibuf[2048];
static char obuf[2048];
SYMTAB symtab[MAXSYMBOLS];

char * strupper(char * s)
{
	char *r = s;
	while(*s) {
		*s = toupper(*s);
		++s;
	}
	return (r);
}

int main( int argc, char *argv[] )
{
	FILE * lstf, * incf;
	int stage = 0, equn;
	char equbuf[26];
	char * equptr;
	int symcount = 0;

	if (argc < 3) {
		printf("Usage: %s listfile.lst outputfile.inc\n", argv[0]);
		exit(1);
	}

	if ((lstf = fopen(argv[1], "r")) == 0)	{
		printf("Error opening %s\n", argv[1]);
		exit(1);
	}

	if ((incf = fopen(argv[2], "w")) == 0)	{
		printf("Error opening %s\n", argv[2]);
		exit(1);
	}

	while (!feof(lstf)) {
		if (fgets(ibuf, 2048, lstf) == NULL)
			break;
			/* stage 0: search for "Symbol Table:" */
		if (stage == 0) {
			if (!strstr(ibuf, "Symbol Table:"))
				continue;
			/* got it */
			++stage;
			continue;
		}
			/* stage 1: search for next non blank/empty line */
		if (stage == 1) {
			if (!isalnum(ibuf[0]))
				continue;
			/* got it */
			++stage;
		}
			/* stage 2: process line */
		if (stage == 2) {
			/* each line is (16b sym + equal/space + 4b value + 5b filler) * 3 */
			equptr = ibuf;

			for (equn = 0; equn < 3; equn++) {
				if ((equptr - ibuf) > strlen(ibuf) || strlen(equptr) < 20)
					break;		/* EOL */
				/* name */
				strncpy(equbuf, equptr, 25);
				equbuf[20] = '\0';
				if (symcount >= MAXSYMBOLS) {
					printf("Too many symbols !!\n");
					break;
				}
				sscanf(equbuf, "%s%*[ \t=]%x", symtab[symcount].symbol, &symtab[symcount].value);
				++symcount;
				equptr += 25;
			}
		}

	}

	/* generate output */

	fprintf(incf, ";****** Equ's file autogenerated from %s ***\n\n", argv[1]);
	for (equn = 0; equn < symcount; equn++) {
		fprintf(incf, "%-15s\tEQU\t$%04X\n", strupper(symtab[equn].symbol), symtab[equn].value);
	}
	fprintf(incf, ";****** EOF ***\n");

	return EXIT_SUCCESS;
}
