   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.3	Fast directory lookup, ZRL compatible - 11/4/88 Gene Nolan
  13:			;
  14:			;------------------------------------------------------
  15:			;
  16:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  17:			;
  18:			; Main Module
  19:			;
  20:			
  21:			
  22:			; Remove the comments from the following 6 lines if making a ZRL form for NZCOM
  23:			;name	DOSZ82
  24:			;COM	/_ID_/
  25:			;	db	13,10,13,10
  26:			;	db	'You are now loading up the Z80DOS234.ZRL file'
  27:			;	db	13,10,13,10,0
  28:			;	maclib z34cmn
  29:			
  30:			; If you are using Z80MR, change the following to -1 and the -1 to 0
  31:			
  32:	FFFF          	Z80MR	EQU	-1		; We do it this way because of Z80MR
  33:							; ... and for zmac (Z80DarkStar)
  34:	0000          	NOZ80MR	EQU	0
  35:			
  36:	0000          		IF NOZ80MR
  46:				 ENDIF
  47:			
  48:	FFFF          		IF Z80MR
  49:			include z80dhdr.lib	; Operating system addresses, options,
**** z80dhdr.lib ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;--------------------------------------------------------------
  10:			;
  11:			; Z80DOS - Z80 Disk Operating System
  12:			;
  13:			; Version 2.3	Fast directory lookup, ZRL compatiblity
  14:			; Date:		4 Nov 88
  15:			; Update:	Eugene Nolan
  16:			;
  17:			;-------------------------------------------------------------
  18:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  19:			;
  20:			; Support file:	Z80DHDR.LIB
  21:			; Version:	2.0
  22:			; Date:		6 Nov 87
  23:			; Author:	Carson Wilson
  24:			; Changes:	Added RTC equate.  If false, use internal DOS routine
  25:			;		instead of BIOS call for get/set time.  Default address
  26:			;		for buffer is 50 hex.
  27:			;
  28:			; Description:	Options and Standard Equates
  29:			
  30:			; --------------------------------------------------------------------
  31:			
  32:			; Specify where in memory your BDOS begins and where your BIOS ends.
  33:			; The next two equates must be set for the particular system.
  34:			; You can use either kilobyte or page boundaries.
  35:			;
  36:			; The number for "MSize/MPages" is where your BIOS ENDS in memory.  For
  37:			; standard 64k CP/M systems this is 64 kilobytes/256 pages.
  38:			;
  39:			; The number for "base" is where your CCP BEGINS in memory.  This is
  40:			; computed using MSize and a value n which is the size in kilobytes/pages
  41:			; of your entire operating system (CCP+BDOS+BIOS).  You should be able
  42:			; to get these values from the source code of your BIOS.
  43:			;
  44:			; 1 page = 256 bytes, so 4 pages = 1 kilobyte.
  45:			;
  46:			
  47:			include ../common.asm
**** ../common.asm ****
   1:			;
   2:			; Here just some common symbol...
   3:			;
   4:			
   5:	0016          	VERS	EQU     22      	; VERSION 2.2 (CP/M related)
   6:			;
   7:	003C          	MSIZE	EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   8:			;MSIZE	EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   9:	0380          	RESROOM	EQU	896		; RESERVED ROOM SPACE BELOW MONITOR (F000)
  10:				;
  11:				;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  12:				;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  13:				;
  14:	9C80          	BIAS	EQU     ((MSIZE-20)*1024)-RESROOM
  15:	D080          	CCP	EQU     3400H+BIAS      ; BASE OF CCP
  16:	D886          	BDOS	EQU     CCP+806H        ; BASE OF BDOS
  17:	D880          	BDOSB	EQU	CCP+$0800	; BDOS base offset
  18:	E680          	BIOS	EQU     CCP+1600H       ; BASE OF BIOS
  19:				;
  20:				; 	some other equs...
  21:				;
  22:	000D          	CR	EQU     0DH		; CARRIAGE RETURN
  23:	000A          	LF	EQU     0AH		; LINE FEED;
  24:	000C          	FF	EQU	0CH		; FORM FEED (clear screen)
  25:	FFFF          	TRUE	EQU	-1		; ....
  26:	0000          	FALSE	EQU	0
  27:	0000          	INTRON	EQU	FALSE		; Interrupts disabled
**** z80dhdr.lib ****
  48:			
  49:			; Specify addresses using kilobyte boundaries:
  50:			
  51:			; NOTE: Definition of BASE not used if creating a .ZRL file
  52:			
  53:			;MSize	equ	64			; Standard 64k system size
  54:			; base	equ	(MSIZE-(BIOSIZ/1024))*1024	; (MSize-n) where n is size of
  55:								; BIOS+DOS+CCP in kilobytes
  56:			;base	equ	0d400h			; N varies with the length of
  57:								; ..your BIOS.
  58:	D080          	base	EQU	CCP
  59:			;base	EQU	$E400
  60:			; Or, specify addresses using page boundaries:
  61:			
  62:			;MPages equ	256			; 256 page system size
  63:			;base	equ	(MPages-37)*256 	; (mpages-n) where n is size in
  64:								; ..pages of BIOS+DOS+CCP
  65:								; N varies with the length of
  66:								; ..your BIOS.
  67:			
  68:			; Standard addresses and equates - don't change the next five equates:
  69:			
  70:	0000          	RamLow	equ	0000h			; Start address memory
  71:			
  72:			;****** Comment out the following 2 lines if making a .ZRL file
  73:	D880          	DOS	equ	base+800h		; Start address DOS
  74:			;BIOS	equ	DOS+00e00h		; Start address BIOS
  75:			
  76:			
  77:	0000          	false	equ	0
  78:	FFFF          	true	equ	-1
  79:			
  80:			; RTC - Real Time Clock
  81:			;
  82:			; 	Set to true if you are using a Real Time Clock as the
  83:			; source for your time, and fill in the address at BIOStim below.
  84:			;
  85:			;	Set to false to use a 5 byte buffer in protected memory
  86:			; as a substitute for a Real Time Clock, and give the address of
  87:			; the 5 byte buffer at label TimeBuf below.
  88:			;
  89:			; NOTE: If making a ZRL and RTC is TRUE, it may be necessary to
  90:			;	POKE the RTC JMP into NZCOM's psuedo BIOS BEFORE loading the
  91:			;	Z80DOS.ZRL file.
  92:			
  93:	FFFF          	RTC	equ	true		;Real time clock
  94:			
  95:	FFFF          		 if	RTC
  96:							; IF USING Z80MR, then put NO SPACES
  97:							; on the following line between
  98:							; BIOS, the '+', and the address!!!!
  99:	E6A1          	BIOStim	equ	BIOS+33		; Address of BIOS jump or RTC driver
 100:			
 101:				 else
 103:				 endif	; RTC
 104:			
 105:			
 106:			; ResDsk - You can optionally define an alternate disk for disk reset.
 107:			;	   This is useful in floppy systems with a virtual drive feature.
 108:			;	   By defining a non-virtual drive (drive B in Morrow MD3) as the
 109:			;	   reset disk, you avoid having to switch back to disk A every time a
 110:			;	   disk reset is performed.  However, this requires that you always
 111:			;	   have a diskette in drive B:.
 112:			;
 113:			
 114:	0000          	ResDsk	equ	0	; CP/M default is disk A for resets
 115:						; ..0=A, 1=B, 2=C, etc.
 116:			
 117:			
 118:			; Options -	Bit 0: public file enable(1)/disable(0)
 119:			;		Bit 1: delay 256 characters active(1)/disable(0)
 120:			;
 121:	0003          	Options	equ	00000011B		; Enable public file and delay
 122:			
 123:			
 124:			; -------------------------------------------------------------
 125:			;
 126:			; The remaining equates should stay the same for all systems:
 127:			;
 128:			; -------------------------------------------------------------
 129:			
 130:			; Standard BIOS function offsets:
 131:			
 132:	E680          	Boot	equ	BIOS+00000h		; BIOS cold boot
 133:	E683          	WBoot	equ	BIOS+00003h		; BIOS warm boot
 134:	E686          	ConSt	equ	BIOS+00006h		; BIOS console status
 135:	E689          	ConIn	equ	BIOS+00009h		; BIOS console input
 136:	E68C          	ConOut	equ	BIOS+0000ch		; BIOS console output
 137:	E68F          	dlist	equ	BIOS+0000fh		; BIOS list output
 138:	E692          	punch	equ	BIOS+00012h		; BIOS punch output
 139:	E695          	reader	equ	BIOS+00015h		; BIOS reader input
 140:	E698          	home	equ	BIOS+00018h		; BIOS home disk
 141:	E69B          	SelDsk	equ	BIOS+0001bh		; BIOS select disk
 142:	E69E          	SetTrk	equ	BIOS+0001eh		; BIOS select track
 143:	E6A1          	SetSec	equ	BIOS+00021h		; BIOS select sector
 144:	E6A4          	SetDMA	equ	BIOS+00024h		; BIOS set DMA address
 145:	E6A7          	dread	equ	BIOS+00027h		; BIOS read 128 bytes
 146:	E6AA          	write	equ	BIOS+0002ah		; BIOS write 128 bytes
 147:	E6AD          	ListSt	equ	BIOS+0002dh		; BIOS list status
 148:	E6B0          	SecTrn	equ	BIOS+00030h		; BIOS sector translation
 149:			;Time	equ	BIOS+00033h		; BIOS TIME call
 150:	E6B6          	BOTDSK	equ	BIOS+00036h		; BIOS boot drive id
 151:			
 152:			; Internal definitions:
 153:			
 154:	0003          	ContC	equ	003h			; Key to generate warm boot
 155:	0008          	ContH	equ	008h			; Backspace
 156:	0013          	ContS	equ	013h			; Control-S
 157:	0009          	tab	equ	009h			; Tab
 158:	000A          	lf	equ	00ah			; Line feed
 159:	000D          	cr	equ	00dh			; Carriage return
 160:	0010          	ContP	equ	010h			; Set/reset print flag
 161:	0018          	ContX	equ	018h			; Delete line (backspaces)
 162:	003A          	DrvSep	equ	03ah			; Drive seperator (:)
 163:	007F          	rubout	equ	07fh			; Delete last char
 164:			;
 165:	0028          	MaxCmd	equ	40			; Number of valid DOS commands
 166:			
 167:			; END Z80DHDR.LIB
 168:			
**** z80dos24.z80 ****
  50:						; ..and equates
  51:			
  52:			include z80dchar.z80	; Jump table, character I/O routines,error routines
**** z80dchar.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;------------------------------------------------------
  10:			;
  11:			; Version 2.3	Fast file lookup, ZRL compatability
  12:			; Date:		4 Nov 88
  13:			; Update:	Eugene Nolan
  14:			;
  15:			;------------------------------------------------------------
  16:			;
  17:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  18:			;
  19:			; Support file:	Z80DCHAR.Z80
  20:			; Version:	2.0
  21:			; Date:		6 Nov 87
  22:			; Author:	Carson Wilson
  23:			; Changes:	Combined BIOS read and write error messages into one
  24:			;		message - "Data error" so that BDOS error intecepts
  25:			;		work same as standard CP/M.
  26:			;
  27:			;		Added disk changed error routine.
  28:			;
  29:			; Description:	DOS Entry Points, Character I/O, and Error Routines
  30:			;
  31:			; Use ONE only of the following lines:
  32:			;---------------------------------------------
  33:			; Use following line for assembly to .COM file, comment it out for a .ZRL
  34:	D880          		org	DOS
  35:			
  36:	D880  5A383044		db	'Z80D24'
	      3234
  37:			
  38:			;---------------------------------------------
  39:			;
  40:			; Start DOS
  41:			;
  42:			
  43:	D886  C31DD9  	start:	jp	entry			; Jump to entry point DOS
  44:			
  45:			;
  46:			; Error messages DOS - for programs which intercept DOS errors
  47:			;
  48:	D889  9EDB    	StRW:	defw	RWErr			; Read or write error
  49:	D88B  92DB    	StSel:	defw	SelErr			; Select error
  50:	D88D  A3DB    	stro:	defw	rdonly			; Drive read only
  51:	D88F  97DB    	sfilro:	defw	filro			; File read only
  52:			
  53:			;
  54:			; Run-time configurable options:
  55:			;
  56:	D891          	timead:
  57:	FFFF          		 if	RTC
  58:	D891  A1E6    		defw	BIOStim			; Dummy or address of BIOS routine
  59:				 else
  61:				 endif	;RTC
  62:			
  63:	D893          	fixdrvs:
  64:	D893  0000    		dw	0			; This word specifies fixed drives, ie:
  65:								; ones that do not need their ALV's
  66:								; re-built for every non-specific
  67:								; BDOS disk reset command. Set to
  68:								; 1 the bits for drives not to be reset
  69:								; 1=A; 3=A,B, 5=A,C etc
  70:			
  71:			
  72:	D895  03      	flags:	defb	options			; Flag byte for public and ^S interrupt
  73:			
  74:			; ----------------------------------------------------------------------
  75:			
  76:			; RAM area
  77:			
  78:			; -------------
  79:			
  80:	D896  00      	tabcnt:	defb	0			; Tab counter
  81:	D897  00      	tabcx1:	defb	0			; Temporary tab counter (used by rdbuf)
  82:	D898  00      	fcontp:	defb	0			; List enable flag (control p)
  83:	D899  00      	lastch:	defb	0			; Last character
  84:	D89A  FF      	delay:	defb	0ffh			; Delay counter
  85:			;
  86:	D89B  0000    	trans:	defw	0			; Translation vector
  87:	D89D  0000    	temp0:	defw	0			; Number of files on drive
  88:	D89F  0000    	dirbuf:	defw	0			; Directory buffer
  89:	D8A1  0000    	ixp:	defw	0			; Disk parameter block
  90:	D8A3  0000    	csv:	defw	0			; Checksum pointer
  91:	D8A5  0000    	alv:	defw	0			; Allocation vector pointer
  92:			;
  93:	D8A7  0000    	maxsec:	defw	0			; Maximum number of sectors/track
  94:	D8A9  00      	nblock:	defb	0			; Number of blocks
  95:	D8AA  00      	nmask:	defb	0			; Mask number of blocks
  96:	D8AB  00      	nextnd:	defb	0			; Extent mask
  97:	D8AC  0000    	maxlen:	defw	0			; Maximum block number-1
  98:	D8AE  0000    	nfiles:	defw	0			; Maximum number of files-1
  99:	D8B0  00      	ndir0:	defb	0			; First two entries alv buffer
 100:	D8B1  00      	ndir1:	defb	0
 101:	D8B2  0000    	ncheck:	defw	0			; Number of checksum entries
 102:	D8B4  0000    	nftrk:	defw	0			; First track number
 103:			;
 104:	D8B6  0000    	dskro:	defw	0			; Disk R/O vector
 105:	D8B8  0000    	login:	defw	0			; Login vector
 106:	D8BA  0000    	diff:	defw	0			; Disk changed vector <crw>
 107:			;
 108:	D8BC  8000    	DMA:	defw	080h			; DMA address
 109:			;
 110:	D8BE  00      	funct:	defb	0			; Function number
 111:	D8BF  0000    	pexit:	defw	0			; Exit code
 112:	D8C1  00      	fldrv:	defb	0			; Drive select used flag
 113:	D8C2  00      	rdwr:	defb	0			; Read/write flag
 114:			;
 115:	D8C3  00      	FCB0:	defb	0			; FCB byte 0
 116:	D8C4  00      	user:	defb	0			; User number
 117:	D8C5  00      	drive:	defb	0			; Drive number
 118:	D8C6  00      	defdrv:	defb	0			; Default drive number
 119:	D8C7  0000    	recdir:	defw	0			; Record directory (checksum)
 120:	D8C9  0000    	filcnt:	defw	0			; File counter
 121:	D8CB  00      	secpnt:	defb	0			; Sector pointer
 122:	D8CC  00      	subflg:	defb	0			; Submit flag (reset disk command)
 123:			;
 124:	D8CD  0000    	dcopy:	defw	0			; Copy address FCB
 125:	D8CF  00      	searex:	defb	0			; Exit code search
 126:	D8D0  00      	searnb:	defb	0			; Search number of bytes
 127:	D8D1  00      	searqu:	defb	0			; Search question mark used
 128:	D8D2  00      	searpu:	defb	0			; Search public file
 129:			;
 130:	D8D3  00      	retflg:	db	0			; Allow retry on error when non-zero
 131:			;
 132:	D8D4  00      	dtime	db	0			; Flag for UseStp <crw>
 133:	D8D5          	cdate	ds	2			; Create date storage
 134:	D8D7          	udate	ds	4			; Update date/time
 135:	D8DB          	adate	ds	4			; Last access date/time <crw>
 136:			;
 137:	D8DF  0000    	spsave:	defw	0			; Stack pointer location
 138:	D8E1          		defs	60
 139:	D91D          	DOSstk	equ	$			; DOS internal 64 byte stack
 140:	D91D          	DOSstop	equ	$
 141:			;
 142:			
 143:			;
 144:			; Entry point for DOS commands
 145:			;
 146:	D91D  79      	Entry:	ld	a,c			; Get function number
 147:	D91E  32BED8  		ld	(funct),a		; Save it for later use
 148:	D921  210000  		ld	hl,0			; Set hl to zero
 149:	D924  22BFD8  		ld	(pexit),hl		; Clear exit code
 150:	D927  22C1D8  		ld	(fldrv),hl
 151:	D92A  45      		ld	b,l
 152:	D92B  ED73DFD8		ld	(spsave),sp		; Save stack pointer
 153:	D92F  311DD9  		ld	sp,DOSstk			; Get internal stack pointer
 154:	D932  DDE5    		push	ix			; Save index register
 155:	D934  D5      		push	de			; Save parameter register
 156:	D935  DDE1    		pop	ix			; Get it back in ix
 157:	D937  2153E6  		ld	hl,p2exit		; Get exit address DOS
 158:	D93A  E5      		push	hl			; Save it on stack to return from DOS
 159:	D93B  FE29    		cp	maxcmd+1
 160:	D93D  3815    		jr	C,lowcmd
 161:	D93F  FE69    		cp	105			; Test get time <crw>
 162:	D941  CA35E6  		jp	Z,gettim		; Yes then get time
 163:	D944  FE68    		cp	104			; Test set time <crw>
 164:	D946  CA42E6  		jp	Z,settim		; Yes then set time
 165:	D949  FE37    		cp	55			; Test use time stamp <crw>
 166:	D94B  CA4BE6  		jp	Z,UseStp
 167:	D94E  FE36    		cp	54			; Test get time stamp <crw>
 168:	D950  CA01E6  		jp	Z,Getstp
 169:	D953  C9      		ret
 170:	D954  215FD9  	lowcmd:	ld	hl,ctable		; Load table
 171:	D957  81      		add	a,c
 172:	D958  4F      		ld	c,a
 173:	D959  09      		add	hl,bc			; Add
 174:	D95A  7E      		ld	a,(hl)			; Get LSB
 175:	D95B  23      		inc	hl			; Pointer to MSB
 176:	D95C  66      		ld	h,(hl)			; Get MSB
 177:	D95D  6F      		ld	l,a			; Save LSB in l
 178:	D95E  E9      		jp	(hl)			; Jump to routine
 179:			;
 180:			; Command Jump Table
 181:			;
 182:	D95F  83E6    	CTable:	defw	WBoot			; Warm boot
 183:	D961  B7D9    		defw	rdcon			; Console input
 184:	D963  C6D9    		defw	bwrcon			; Console output
 185:	D965  C9D9    		defw	rdrdr			; Reader input
 186:	D967  CED9    		defw	wpunch			; Punch output
 187:	D969  D2D9    		defw	wlist			; List output
 188:	D96B  D6D9    		defw	dcio			; Direct console I/O
 189:	D96D  F0D9    		defw	giost			; Get I/O byte
 190:	D96F  F5D9    		defw	siost			; Set I/O byte
 191:	D971  CEDA    		defw	mess			; Print string
 192:	D973  23DB    		defw	rdbuf			; Read console buffer
 193:	D975  FAD9    		defw	tstcs			; Get console status
 194:	D977  8ADC    		defw	cmnd12			; Return version number
 195:	D979  93DC    		defw	cmnd13			; Reset disk system
 196:	D97B  A5DD    		defw	cmnd14			; Select disk
 197:	D97D  26E2    		defw	cmnd15			; Open file
 198:	D97F  6BE2    		defw	cmnd16			; Close file
 199:	D981  C6DC    		defw	cmnd17			; Search for first
 200:	D983  EDDC    		defw	cmnd18			; Search for next
 201:	D985  F9DC    		defw	cmnd19			; Delete file
 202:	D987  DBE3    		defw	cmnd20			; Read sequential
 203:	D989  26E4    		defw	cmnd21			; Write sequential
 204:	D98B  17E3    		defw	cmnd22			; Make file
 205:	D98D  04DD    		defw	cmnd23			; Rename file
 206:	D98F  0CDD    		defw	cmnd24			; Return login vector
 207:	D991  13DD    		defw	cmnd25			; Return current disk
 208:	D993  AADF    		defw	cmnd26			; Set DMA address
 209:	D995  19DD    		defw	cmnd27			; Get address allocation vector
 210:	D997  0AE0    		defw	cmnd28			; Write protect disk
 211:	D999  1EDD    		defw	cmnd29			; Get R/O vector
 212:	D99B  23DD    		defw	cmnd30			; Set file attributes
 213:	D99D  2BDD    		defw	cmnd31			; Get address disk parameter header(dph)
 214:	D99F  30DD    		defw	cmnd32			; Get/set user code
 215:	D9A1  D1E3    		defw	cmnd33			; Read random
 216:	D9A3  1BE4    		defw	cmnd34			; Write random
 217:	D9A5  3EDD    		defw	cmnd35			; Compute file size
 218:	D9A7  46DD    		defw	cmnd36			; Set random record
 219:	D9A9  56DD    		defw	cmnd37			; Reset multiple drive
 220:	D9AB  C5D9    		defw	dummy			; Access drive - not implemented
 221:	D9AD  B1D9    		defw	gfixed			; Get fixed login vector
 222:	D9AF  1BE4    		defw	cmnd40			; Write random with zero fill
 223:			
 224:			; ---------------------------------
 225:			
 226:			; Return current fixed drive vector
 227:			
 228:	D9B1          	gfixed:
 229:	D9B1  2A93D8  		ld	hl,(fixdrvs)
 230:	D9B4  C30FDD  		jp	cmd24a
 231:			
 232:			; ---------------------------------
 233:			
 234:			;	Character Routines
 235:			
 236:			; ---------------------------------
 237:			
 238:			; DOS console input
 239:			;
 240:			; Read character from console and echo
 241:			;  if char=cr, lf, tab, ContH or >=space
 242:			;
 243:	D9B7  CD72DA  	RdCon:	call	getch			; Get character
 244:	D9BA  CDB2DA  		call	tstch			; Test if cr,lf,tab,ContH or >=space
 245:	D9BD  3803    		jr	C,exit			; No then exit
 246:	D9BF  CD1ADA  		call	wrcon			; Echo character
 247:	D9C2  32BFD8  	exit:	ld	(pexit),a		; Return character
 248:	D9C5  C9      	dummy:	ret				; And exit DOS
 249:			;
 250:			; DOS write console
 251:			;
 252:	D9C6  7B      	bwrcon:	ld	a,e			; Copy character
 253:	D9C7  1851    		jr	wrcon			; And output it
 254:			;
 255:			; read reader
 256:			;
 257:	D9C9  CD95E6  	rdrdr:	call	reader			; Get character from reader
 258:	D9CC  18F4    		jr	exit			; And return it to caller
 259:			;
 260:			; write punch
 261:			;
 262:	D9CE  4B      	wpunch:	ld	c,e			; Copy character
 263:	D9CF  C392E6  		jp	punch			; And output it to punch device
 264:			;
 265:			; Write list
 266:			;
 267:	D9D2  4B      	wlist:	ld	c,e			; Copy character
 268:	D9D3  C38FE6  		jp	dlist			; And output it to list device
 269:			;
 270:			; Direct console input/output
 271:			;
 272:	D9D6  4B      	DCIO:	ld	c,e			; Copy character
 273:	D9D7  1C      		inc	e			; Test if 0ffh
 274:	D9D8  280B    		jr	Z,dcio0			; Yes do input
 275:	D9DA  1C      		inc	e			; Test if 0feh
 276:	D9DB  C28CE6  		jp	NZ,ConOut		; No then output character
 277:	D9DE  CD86E6  		call	ConSt			; Get console status
 278:	D9E1  E601    		and	1			; Test it
 279:	D9E3  18DD    		jr	exit			; And return it to caller
 280:	D9E5  CD86E6  	DCIO0:	call	ConSt			; Get console status
 281:	D9E8  E601    		and	1			; Test it
 282:	D9EA  C8      		ret	Z			; Exit if no character present
 283:	D9EB  CD89E6  		call	ConIn			; Get character
 284:	D9EE  18D2    		jr	exit			; And return it to caller
 285:			;
 286:			; Get I/O status byte
 287:			;
 288:	D9F0  3A0300  	giost:	ld	a,(RamLow+00003h)	; Get I/O byte from ram
 289:	D9F3  18CD    		jr	exit			; And return it to caller
 290:			;
 291:			; Set I/O status byte
 292:			;
 293:	D9F5  7B      	siost:	ld	a,e			; Copy I/O byte
 294:	D9F6  320300  		ld	(RamLow+00003h),a	; And save it in ram
 295:	D9F9  C9      		ret				; Exit to caller
 296:			;
 297:			; Test console status
 298:			;
 299:	D9FA  CD7DDA  	tstcs:	call	gConSt			; Get console status
 300:	D9FD  18C3    		jr	exit			; And return it to caller
 301:			;
 302:			; Output char (control char = ^char)
 303:			;
 304:	D9FF  CDB2DA  	outch:	call	tstch			; Test it cr,lf,tab,ContH or >=space
 305:	DA02  3016    		jr	NC,wrcon		; Yes then jump
 306:	DA04  F5      		push	af			; Save character
 307:	DA05  3E5E    		ld	a,'^'			; Load a with '^'
 308:	DA07  CD1ADA  		call	wrcon			; Output it
 309:	DA0A  F1      		pop	af			; Get character back
 310:	DA0B  F5      		push	af			; Save it again
 311:	DA0C  C640    		add	a,'A'-1			; Add offset
 312:	DA0E  CD1ADA  		call	wrcon			; Output it
 313:	DA11  F1      		pop	af			; Get character
 314:	DA12  C9      		ret				; Return to caller
 315:			;
 316:			; Echo cr,lf
 317:			;
 318:	DA13  3E0D    	CROut:	ld	a,cr			; A=carriage return
 319:	DA15  CD1ADA  		call	wrcon			; Output it
 320:	DA18  3E0A    		ld	a,lf			; A=line feed
 321:								; Fall through to output routine
 322:			;
 323:			; Write character on console
 324:			;
 325:	DA1A  FE09    	wrcon:	cp	tab			; Test if tab
 326:	DA1C  200F    		jr	NZ,wrcon1		; No then jump
 327:	DA1E  3E20    	wrcon0:	ld	a,' '			; Expand tab with spaces
 328:	DA20  CD1ADA  		call	wrcon			; Write space
 329:	DA23  3A96D8  		ld	a,(tabcnt)		; Get tab count
 330:	DA26  E607    		and	7			; Test if done
 331:	DA28  20F4    		jr	NZ,wrcon0		; No then repeat
 332:	DA2A  3E09    		ld	a,tab			; Return tab
 333:	DA2C  C9      		ret				; Return to caller
 334:	DA2D  F5      	wrcon1:	push	af			; Save character
 335:	DA2E  CD7DDA  		call	gConSt			; Test status and ContS/ContC
 336:	DA31  F1      		pop	af			; Get character back
 337:	DA32  F5      		push	af			; Save it again
 338:	DA33  4F      		ld	c,a			; Copy it
 339:	DA34  CD8CE6  		call	ConOut			; Output it
 340:	DA37  F1      		pop	af			; Get character back
 341:	DA38  F5      		push	af			; Save it again
 342:	DA39  4F      		ld	c,a			; Copy it
 343:	DA3A  3A98D8  		ld	a,(fContP)		; Get printer echo flag
 344:	DA3D  B7      		or	a			; Test it
 345:	DA3E  C48FE6  		call	nz,dlist			; Non zero => output char to printer
 346:	DA41  3A95D8  		ld	a,(flags)		; Get flag byte
 347:	DA44  CB4F    		bit	1,a			; Test delay 256 bytes active
 348:	DA46  2808    		jr	Z,wrcon2		; No then exit
 349:	DA48  219AD8  		ld	hl,delay		; Get delay counter
 350:	DA4B  AF      		xor	a			; A=0
 351:	DA4C  B6      		or	(hl)			; Test counter=0
 352:	DA4D  2801    		jr	Z,wrcon2		; Yes then exit
 353:	DA4F  35      		dec	(hl)			; Else decrement counter
 354:	DA50  F1      	wrcon2:	pop	af			; Restore character
 355:								; Fall through to count routine
 356:			;
 357:			; Count characters in line
 358:			;
 359:	DA51  2196D8  	countc:	ld	hl,tabcnt		; Get pointer to tab counter
 360:	DA54  34      		inc	(hl)			; Increment tab counter
 361:	DA55  FE20    		cp	' '			; Test if char >= ' '
 362:	DA57  D0      		ret	NC			; Yes, normal character then exit
 363:	DA58  35      		dec	(hl)			; Control character, decrement tab count
 364:	DA59  FE08    		cp	ContH			; Test backspace
 365:	DA5B  2002    		jr	NZ,count0		; No backspace then jump
 366:	DA5D  35      		dec	(hl)			; Decrement tab counter
 367:	DA5E  C9      		ret				; And exit
 368:	DA5F  FE0D    	count0:	cp	cr			; Test carriage return
 369:	DA61  2003    		jr	NZ,count1		; No then jump
 370:	DA63  3600    		ld	(hl),0			; Reset tab count
 371:	DA65  C9      		ret				; And exit
 372:	DA66  FE09    	count1:	cp	tab			; Test tab character
 373:	DA68  C0      		ret	NZ			; No then exit
 374:	DA69  F5      		push	af			; Save character
 375:	DA6A  7E      		ld	a,(hl)			; Get tab count
 376:	DA6B  C608    		add	a,8			; Advance it 8 position
 377:	DA6D  E6F8    		and	0f8h			; Set it to next tab position
 378:	DA6F  77      		ld	(hl),a			; Save it
 379:	DA70  F1      		pop	af			; Restore character
 380:	DA71  C9      		ret				; And exit
 381:			;
 382:			; Get character from console
 383:			;
 384:	DA72  2199D8  	getch:	ld	hl,lastch		; Get pointer to last input character
 385:	DA75  7E      		ld	a,(hl)			; Get character
 386:	DA76  3600    		ld	(hl),0			; Reset last character
 387:	DA78  B7      		or	a			; Test if character present
 388:	DA79  C0      		ret	NZ			; Return if so
 389:	DA7A  C389E6  		jp	ConIn			; Else get character
 390:			;
 391:			; Get console status
 392:			;
 393:	DA7D  3A9AD8  	gConSt:	ld	a,(delay)		; Get 256 bytes delay
 394:	DA80  B7      		or	a			; Test it
 395:	DA81  2007    		jr	NZ,gcons0		; Non zero, delay stil active or disabled
 396:	DA83  CD86E6  		call	ConSt			; Get console status
 397:	DA86  E601    		and	1			; Test it
 398:	DA88  200C    		jr	NZ,gcons1		; Non zero then get character
 399:	DA8A  3A99D8  	gcons0:	ld	a,(lastch)		; Get last character
 400:	DA8D  B7      		or	a			; Test it
 401:	DA8E  201F    		jr	NZ,gcons3		; Non zero then character present
 402:	DA90  CD86E6  		call	ConSt			; Get console status
 403:	DA93  E601    		and	1			; Test it
 404:	DA95  C8      		ret	Z			; Return if no character present
 405:	DA96  CD89E6  	gcons1:	call	ConIn			; Get character
 406:	DA99  FE13    		cp	ContS			; Test stop character
 407:	DA9B  200A    		jr	NZ,gcons2		; Not then exit character
 408:	DA9D  CD89E6  		call	ConIn			; Get next character
 409:	DAA0  FE03    		cp	ContC			; Test if user wants to exit
 410:	DAA2  CA0000  		jp	Z,RamLow+00000h		; Yes then warm boot
 411:	DAA5  18D6    		jr	gConSt			; Test again
 412:	DAA7  3299D8  	gcons2:	ld	(lastch),a		; Save character
 413:	DAAA  3EFF    		ld	a,0ffh			; Set delay counter
 414:	DAAC  329AD8  		ld	(delay),a		; And save it
 415:	DAAF  3E01    	gcons3:	ld	a,1			; Character present code
 416:	DAB1  C9      		ret				; Return to caller
 417:			;
 418:			; Test character
 419:			;  exit carry=0: cr,lf,tab,ContH or >=space
 420:			;	carry=1: all other characters
 421:			;
 422:	DAB2  FE0D    	tstch:	cp	cr			; Test carriage return
 423:	DAB4  C8      		ret	Z			; Return if so
 424:	DAB5  FE09    		cp	tab			; Test tab
 425:	DAB7  C8      		ret	Z			; Return if so
 426:	DAB8  FE08    		cp	ContH			; Test backspace
 427:	DABA  C8      		ret	Z			; Return if so
 428:	DABB  FE7F    		cp	rubout
 429:	DABD  C8      		ret	Z
 430:	DABE  FE20    		cp	' '			; Test >=space
 431:	DAC0  C9      		ret				; Return to caller
 432:			;
 433:			; Write backspace, space, backspace
 434:			;
 435:	DAC1  CDC9DA  	wContH:	call	wcont0			; Write backspace
 436:	DAC4  0E20    		ld	c,' '			; Load space
 437:	DAC6  CD8CE6  		call	ConOut			; And output it
 438:	DAC9  0E08    	wcont0:	ld	c,ContH			; Load backspace
 439:	DACB  C38CE6  		jp	ConOut			; And output it
 440:			;
 441:			; Output message
 442:			;
 443:	DACE  1A      	mess:	ld	a,(de)			; Get byte from buffer
 444:	DACF  FE24    		cp	'$'			; Test last byte
 445:	DAD1  C8      		ret	Z			; Yes, then return to caller
 446:	DAD2  13      		inc	de			; Point to next byte
 447:	DAD3  D5      		push	de			; Save pointer
 448:	DAD4  CD1ADA  		call	wrcon			; Output character
 449:	DAD7  D1      		pop	de			; Restore pointer
 450:	DAD8  18F4    		jr	mess			; And test again
 451:			;
 452:	DADA  2196D8  	again:	ld	hl,tabcnt		; Get tab count pointer
 453:	DADD  3A97D8  		ld	a,(tabcx1)		; Get position first character line
 454:	DAE0  BE      		cp	(hl)			; Check it
 455:	DAE1  C8      		ret	Z			; Return if on same position
 456:	DAE2  3E20    		ld	a,' '			; Load space
 457:	DAE4  CD1ADA  		call	wrcon			; Output it
 458:	DAE7  18F1    		jr	again			; And test again
 459:			;
 460:			; Delete char
 461:			;  entry : HL = start buffer - 1
 462:			;	   B  = character counter (always > 0)
 463:			;
 464:	DAE9  05      	delch:	dec	b			; Decrement character counter
 465:	DAEA  3A96D8  		ld	a,(tabcnt)		; Get tab counter
 466:	DAED  F5      		push	af			; Save it
 467:	DAEE  C5      		push	bc			; Save character counter
 468:	DAEF  3A97D8  		ld	a,(tabcx1)		; Get position first character line
 469:	DAF2  3296D8  		ld	(tabcnt),a		; Save it in tab counter
 470:	DAF5  78      	delch0:	ld	a,b			; Copy character counter
 471:	DAF6  B7      		or	a			; Test if 0
 472:	DAF7  2813    		jr	Z,delch2		; Yes then jump
 473:	DAF9  05      		dec	b			; Decrement it
 474:	DAFA  23      		inc	hl			; Increment buffer pointer
 475:	DAFB  7E      		ld	a,(hl)			; Get character from buffer
 476:	DAFC  E5      		push	hl			; Save buffer pointer
 477:	DAFD  CDB2DA  		call	tstch			; Test if cr,lf,tab,ContH or >=sp
 478:	DB00  3004    		jr	NC,delch1		; Yes then jump
 479:	DB02  1F      		rra				; Else must be control character
 480:	DB03  CD51DA  		call	countc			; Count control character twice
 481:	DB06  CD51DA  	delch1:	call	countc			; Count character
 482:	DB09  E1      		pop	hl			; Get buffer pointer
 483:	DB0A  18E9    		jr	delch0			; And test again
 484:	DB0C  C1      	delch2:	pop	bc			; Restore character counter
 485:	DB0D  F1      		pop	af			; And tab counter
 486:	DB0E  E5      		push	hl			; Save buffer pointer
 487:	DB0F  C5      		push	bc			; And character counter
 488:	DB10  2196D8  		ld	hl,tabcnt		; Get tab counter pointer
 489:	DB13  96      		sub	(hl)			; Calculate difference
 490:	DB14  3D      	delch3:	dec	a			; Decrement it
 491:	DB15  FE08    		cp	8			; Compare with 8
 492:	DB17  3007    		jr	NC,delch4		; Jump if >=8
 493:	DB19  F5      		push	af			; Save difference
 494:	DB1A  CDC1DA  		call	wContH			; Remove character end line
 495:	DB1D  F1      		pop	af			; Restore counter
 496:	DB1E  18F4    		jr	delch3			; Remove more characters
 497:	DB20  C1      	delch4:	pop	bc			; Restore character counter
 498:	DB21  E1      		pop	hl			; Restore buffer pointer
 499:	DB22  C9      		ret				; And return to caller
 500:			;
 501:			; Read buffer
 502:			;
 503:	DB23  3A96D8  	rdbuf:	ld	a,(tabcnt)		; Get current position cursor
 504:	DB26  3297D8  		ld	(tabcx1),a		; Save it
 505:	DB29  DDE5    	rdbuf0:	push	ix			; Save start address buffer
 506:	DB2B  E1      		pop	hl			; Get it in hl
 507:	DB2C  4E      		ld	c,(hl)			; Get maximum line lenght
 508:	DB2D  23      		inc	hl			; Increment to line lenght position
 509:	DB2E  0600    		ld	b,0			; Clear line lenght counter
 510:	DB30  E5      		push	hl			; Save start line - 1
 511:	DB31  E5      	rdbuf1:	push	hl			; Save registers
 512:	DB32  C5      		push	bc
 513:	DB33  CD72DA  	rdbuf2:	call	getch			; Get character
 514:	DB36  C1      		pop	bc			; Restore registers
 515:	DB37  E1      		pop	hl
 516:	DB38  E67F    		and	07fh			; Mask character
 517:	DB3A  FE08    	rdbuf3:	cp	ContH			; Test backspace
 518:	DB3C  200B    		jr	NZ,rdbuf4		; Not then jump
 519:	DB3E  78      	doback:	ld	a,b			; Test if deleting char from empty line
 520:	DB3F  B7      		or	a
 521:	DB40  28EF    		jr	Z,rdbuf1		; Yes then get next char
 522:	DB42  E1      		pop	hl			; Get start line
 523:	DB43  E5      		push	hl			; And save it again
 524:	DB44  CDE9DA  		call	delch			; Delete character
 525:	DB47  18E8    		jr	rdbuf1			; Get next character
 526:	DB49  FE10    	rdbuf4:	cp	ContP			; Test print enable/disable
 527:	DB4B  2007    		jr	NZ,rdbufC		; Not then jump
 528:	DB4D  3A98D8  		ld	a,(fContP)		; Complement print flag
 529:	DB50  2F      		cpl
 530:	DB51  3298D8  		ld	(fContP),a
 531:	DB54  FE18    	rdbufc:	cp	ContX			; Test delete line
 532:	DB56  200C    		jr	NZ,rdbufe		; Not then jump
 533:	DB58  E1      	rdbufd:	pop	hl			; Get start line
 534:	DB59  78      		ld	a,b			; Test if last character deleted
 535:	DB5A  B7      		or	a
 536:	DB5B  CA23DB  		jp	Z,RDBUF			; Yes start routine again
 537:	DB5E  E5      		push	hl			; Save pointer
 538:	DB5F  CDE9DA  		call	delch			; Delete last character line
 539:	DB62  18F4    		jr	rdbufd			; Test last character deleted
 540:	DB64  FE7F    	rdbufe:	cp	rubout			; Test delete last character
 541:	DB66  2002    		jr	NZ,rdbuff		; Not then jump
 542:	DB68  18D4    		jr	doback			; Part of delete key fix
 543:	DB6A  FE0D    	rdbuff:	cp	cr			; Test carriage return
 544:	DB6C  2818    		jr	Z,rdbufi		; Yes, then exit
 545:	DB6E  23      		inc	hl			; Increment pointer
 546:	DB6F  77      		ld	(hl),a			; And save character
 547:	DB70  04      		inc	b			; Increment line counter
 548:	DB71  E5      	rdbufg:	push	hl			; Save registers
 549:	DB72  C5      		push	bc
 550:	DB73  CDFFD9  		call	outch			; Echo character
 551:	DB76  C1      		pop	bc			; Restore registers
 552:	DB77  E1      		pop	hl
 553:	DB78  FE03    		cp	ContC			; Test warm boot
 554:	DB7A  78      		ld	a,b			; Get line count
 555:	DB7B  2005    		jr	NZ,rdbufh		; No warm boot then jump
 556:	DB7D  FE01    		cp	1			; Test ContC is first character line
 557:	DB7F  CA0000  		jp	Z,RamLow+00000h		; Yes then execute warm boot
 558:	DB82  B9      	rdbufh:	cp	c			; Test line length=maximum line length
 559:	DB83  C231DB  		jp	NZ,rdbuf1		; Not then get next character
 560:	DB86  E1      	rdbufi:	pop	hl			; Get start line - 1
 561:	DB87  70      		ld	(hl),b			; Save line counter
 562:	DB88  3E0D    		ld	a,cr			; Load carriage return
 563:	DB8A  C31ADA  		jp	wrcon			; And echo it
 564:			
 565:			
 566:			;---------------------------
 567:			
 568:			;	Error routines
 569:			
 570:			;---------------------------
 571:			
 572:			;
 573:			; Disk changed error
 574:			;
 575:	DB8D          	ChgErr:
 576:	DB8D  1160DC  		ld	de,mchg 		; Load changed error message
 577:	DB90  1814    		jr	derror			; And display error
 578:			;
 579:			; Select error
 580:			;
 581:	DB92  1166DC  	SelErr:	ld	de,msel			; Load selected error message
 582:	DB95  180F    		jr	derror			; And display error
 583:			;
 584:			; File read only error
 585:			;
 586:	DB97  116CDC  	FilRO:	ld	de,mfilro		; Load file R/O message
 587:	DB9A  3EFF    		ld	a,0ffh			; Set file R/O message flag
 588:	DB9C  1809    		jr	error			; And display error
 589:			;
 590:			; Read/Write error
 591:			;
 592:	DB9E          	RWErr:
 593:	DB9E  1172DC  		ld	de,mrwerr
 594:	DBA1  1803    		jr	derror
 595:			;
 596:			; Drive read only error
 597:			;
 598:	DBA3  116FDC  	rdonly:	ld	de,mro			; Load drive R/O message
 599:	DBA6  AF      	derror:	xor	a			; Set no file R/O message
 600:			;	fall	thru
 601:			
 602:			;
 603:			; Display error message
 604:			;
 605:			; "Error message" error on d:
 606:			; Function	nn
 607:			; File		filename.typ
 608:			;
 609:	DBA7  4F      	error:	ld	c,a			; Save file R/O message flag
 610:	DBA8  C5      		push	bc
 611:	DBA9  D5      		push	de			; Save error message pointer
 612:	DBAA  CD13DA  		call	crout			; Display cr/lf
 613:	DBAD  D1      		pop	de
 614:	DBAE  CDCEDA  		call	mess			; Display error
 615:	DBB1  3AC6D8  		ld	a,(defdrv)		; Get current drive
 616:	DBB4  C641    		add	a,'A'			; Make ASCII
 617:	DBB6  327BDC  		ld	(mdrive),a		; Save it
 618:	DBB9  1175DC  		ld	de,mberr		; Load message " error on d:"
 619:	DBBC  CDCEDA  		call	mess			; Display message
 620:	DBBF  117EDC  		ld	de,mbfunc		; Load message "function "
 621:	DBC2  CDCEDA  		call	mess			; Display message
 622:	DBC5  3ABED8  		ld	a,(funct)		; Get function number
 623:	DBC8  F5      		push	af			; Save it
 624:	DBC9  016400  		ld	bc,100			; Display number / 100
 625:	DBCC  CD3BDC  		call	num
 626:	DBCF  0E0A    		ld	c,10			; Display number / 10
 627:	DBD1  CD3BDC  		call	num
 628:	DBD4  010101  		ld	bc,101h			; Always display number / 1
 629:	DBD7  CD3BDC  		call	num
 630:	DBDA  F1      		pop	af			; Get function number
 631:	DBDB  C1      		pop	bc			; Get file R/O flag
 632:	DBDC  FE0F    		cp	15			; Test if FCB used in command
 633:	DBDE  3839    		jr	C,error3		; Commands <16, don't show filename
 634:	DBE0  FE18    		cp	24
 635:	DBE2  3810    		jr	C,error1		; Commands 16..23 show file
 636:	DBE4  FE1E    		cp	30
 637:	DBE6  280C    		jr	Z,error1		; Command 30 show file
 638:	DBE8  FE21    		cp	33
 639:	DBEA  382D    		jr	C,error3		; Other commands 24..32 no file
 640:	DBEC  FE25    		cp	37
 641:	DBEE  3804    		jr	C,error1		; 33..36 show
 642:	DBF0  FE28    		cp	40
 643:	DBF2  2025    		jr	NZ,error3		; 37 don't show
 644:			
 645:	DBF4  DDE5    	error1:	push	ix			; Display "file ="
 646:	DBF6  D613    		sub	19			; Test delete file function
 647:	DBF8  2007    		jr	NZ,error2		; Not then jump
 648:	DBFA  B1      		or	c			; Test file R/O flag
 649:	DBFB  2804    		jr	Z,error2		; No file R/O then jump
 650:	DBFD  CDFBDE  		call	caldir			; Get FCB from directory buffer
 651:	DC00  E3      		ex	(sp),hl			; Save it
 652:	DC01  1184DC  	error2:	ld	de,mfile		; Get message " file ="
 653:	DC04  CDCEDA  		call	mess			; Display message
 654:	DC07  E1      		pop	hl			; Get pointer FCB
 655:	DC08  0608    		ld	b,8			; Display first 8 characters
 656:	DC0A  CD52DC  		call	filenm
 657:	DC0D  3E2E    		ld	a,'.'			; Load '.'
 658:	DC0F  E5      		push	hl			; Save FCB pointer
 659:	DC10  CD1ADA  		call	wrcon			; Echo it
 660:	DC13  E1      		pop	hl			; Restore FCB pointer
 661:	DC14  0603    		ld	b,3			; Display last 3 characters
 662:	DC16  CD52DC  		call	filenm
 663:			
 664:			; Absorb any pending characters:
 665:			
 666:	DC19  CD7DDA  	error3:	call	gConSt			; Test if character pending
 667:	DC1C  B7      		or	a
 668:	DC1D  2805    		jr	Z,error4		; No then jump
 669:	DC1F  CD72DA  		call	getch			; Get character
 670:	DC22  18F5    		jr	error3			; And test again
 671:			;
 672:			; Allow retry on read/write errors
 673:			;
 674:	DC24          	error4:
 675:	DC24  3AD3D8  		ld	a,(retflg)		; Allow retry?
 676:	DC27  B7      		or	a
 677:	DC28  280A    		jr	Z,error5		; No
 678:	DC2A  AF      		xor	a
 679:	DC2B  32D3D8  		ld	(retflg),a		; Reset flag <crw>
 680:	DC2E  CD72DA  		call	getch
 681:	DC31  FE03    		cp	ContC			; Control-c entered?
 682:	DC33  C0      		ret	NZ			; No, retry
 683:	DC34  AF      	error5:	xor	a			; Make sure no use stamp flag is
 684:								; around when we warmboot
 685:	DC35  32D4D8  		ld	(dtime),a
 686:	DC38  C30000  		jp	RamLow+00000h		; Do warm boot
 687:			;
 688:			; Display number
 689:			;
 690:	DC3B  16FF    	num:	ld	d,0ffh			; Load number -1
 691:	DC3D  14      	num1:	inc	d			; Increment number
 692:	DC3E  91      		sub	c			; Divide by c
 693:	DC3F  30FC    		jr	NC,num1			; Not finished then loop
 694:	DC41  81      		add	a,c			; Restore last value
 695:	DC42  F5      		push	af			; Save it
 696:	DC43  7A      		ld	a,d			; Test if "0"
 697:	DC44  B0      		or	b			; And if leading zero
 698:	DC45  2809    		jr	Z,num2			; Yes, then exit
 699:	DC47  47      		ld	b,a			; Set no leading zero
 700:	DC48  7A      		ld	a,d			; Get number
 701:	DC49  C630    		add	a,'0'			; Make ASCII
 702:	DC4B  C5      		push	bc			; Save registers
 703:	DC4C  CD1ADA  		call	wrcon			; Echo number
 704:	DC4F  C1      		pop	bc			; Restore registers
 705:	DC50  F1      	num2:	pop	af			; Restore number
 706:	DC51  C9      		ret				; And exit
 707:			;
 708:			; Display filename.typ
 709:			;
 710:	DC52  23      	filenm:	inc	hl			; Increment pointer FCB
 711:	DC53  7E      		ld	a,(hl)			; Get character from FCB
 712:	DC54  E67F    		and	07fh			; Mask it
 713:	DC56  E5      		push	hl			; Save registers
 714:	DC57  C5      		push	bc
 715:	DC58  CD1ADA  		call	wrcon			; Echo character
 716:	DC5B  C1      		pop	bc			; Restore registers
 717:	DC5C  E1      		pop	hl
 718:	DC5D  10F3    		djnz	filenm			; Repeat b times
 719:	DC5F  C9      		ret				; And exit
 720:			;
 721:			; Error messages
 722:			; Made more meaningful--b.h.
 723:			;
 724:			
 725:	DC60  446B2063	mchg:	db	'Dk ch$'	;DISK CHANGED
	      6824
 726:			
 727:	DC66  496C2064	msel:	db	'Il dr$'	;ILLEGAL DRIVE
	      7224
 728:			
 729:	DC6C  466C20  	mfilro:	db	'Fl '		;FILE
 730:			
 731:	DC6F  524F24  	mro:	db	'RO$'		;READ ONLY
 732:			
 733:	DC72  447424  	mrwerr:	db	'Dt$'		; DATA  BIOS read/write error
 734:			
 735:	DC75  2065726F	mberr:	defm	' eron '	;ERROR ON
	      6E20
 736:	DC7B  00      	mdrive:	defb	0
 737:	DC7C  3A      		defb	DrvSep
 738:	DC7D  24      		defm	'$'
 739:			
 740:	DC7E  0D0A4674	mbfunc:	defm	cr,lf,'Ft',tab,'$'	;FUNCTION
	      0924
 741:			
 742:	DC84  0D0A4669	mfile:	defm	cr,lf,'Fi',tab,'$'	;FILE
	      0924
 743:			
 744:			; END Z80DCHAR.Z80
**** z80dos24.z80 ****
  53:			
  54:			include z80ddisk.z80	; Return CP/M version, disk routines
**** z80ddisk.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.31	Fast file lookup for random records fix
  13:			; Date		15 Nov 88
  14:			; Update	Eugene Nolan
  15:			;
  16:			; Version 2.3	Fast file lookup
  17:			; Date:		4 Nov 88
  18:			; Update:	Eugene Nolan
  19:			;
  20:			;-------------------------------------------------------------
  21:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  22:			;
  23:			; Support file:	Z80DDISK.Z80
  24:			; Version:	2.0
  25:			; Date:		6 Nov 87
  26:			; Author:	Carson Wilson
  27:			; Description:	DOS Return CP/M Version, Disk Functions
  28:			;
  29:			; Changes:	--------
  30:			;		Changed Readr and Writer to use a common error function,
  31:			;		RWErr, which displays "Data error on d:".
  32:			;
  33:			;		new disk will be overwritten, data from the first file will
  34:			;		probably be lost.
  35:			;
  36:			;		--------
  37:			;		Command 37 (reset individual disk) now resets the disk changed
  38:			;		vector instead of the drive R/O vector.
  39:			;
  40:			;		--------
  41:			;		Removed code which made public files read-only from
  42:			;		other user areas.  The user must now manually set public
  43:			;		files to read-only using the R/O attribute (t1).  This
  44:			;		change was made because some applications must write to
  45:			;		public files.
  46:			;
  47:			;		--------
  48:			;		System files are now R/W unless referenced by wildcards.
  49:			;
  50:			
  51:			
  52:			; -----------------------
  53:			;
  54:			; Return version number
  55:			;
  56:			; -----------------------
  57:			
  58:	DC8A  3E22    	cmnd12:	ld	a,22h			; Set version number
  59:	DC8C  DD210038		ld	ix,3800h		; this will put an '8' into D
  60:								; register upon return, saying
  61:								; Z80DOS operating
  62:	DC90  C316DD  		jp	cmd25a			; And exit
  63:			
  64:			
  65:			; -----------------------------
  66:			;
  67:			;	Disk functions
  68:			;
  69:			; -----------------------------
  70:			;
  71:			; Reset disk system
  72:			;
  73:	DC93          	cmnd13:
  74:			;	ld	hl,0			; Load zero
  75:	DC93  2AB8D8  		ld	hl,(login)		; Get login vector
  76:	DC96  ED5B93D8		ld	de,(fixdrvs)		; get drive mask
  77:	DC9A  7C      		ld	a,h
  78:	DC9B  A2      		and	d
  79:	DC9C  67      		ld	h,a
  80:	DC9D  7D      		ld	a,l
  81:	DC9E  A3      		and	e
  82:	DC9F  6F      		ld	l,a			; HL now has selective drives
  83:								; logged out
  84:	DCA0  22B8D8  		ld	(login),hl
  85:	DCA3  210000  		ld	hl,0
  86:	DCA6  22B6D8  		ld	(dskro),hl		; All drives read/write
  87:	DCA9  22BAD8  		ld	(diff),hl		; No disks changed <crw>
  88:	DCAC  218000  		ld	hl,RamLow+80h		; Set up DMA address
  89:	DCAF  22BCD8  		ld	(DMA),hl		; And save it
  90:	DCB2  CDAEDF  		call	stDMA			; Do BIOS call
  91:			;	ld	a,ResDsk+1		; When selective logout enabled
  92:	DCB5  3AB6E6  		ld	a,(BOTDSK)		; When selective logout enabled
  93:			;	inc	a
  94:								; the call to seldk below requires
  95:								; defdrv and the drive to select in
  96:								; the A reg to be different
  97:	DCB8  32C6D8  		ld	(defdrv),a		; Save it
  98:			;	ld	a,ResDsk		; <crw>
  99:	DCBB  3AB6E6  		ld	a,(BOTDSK)		; When selective logout enabled
 100:	DCBE  CDA6DD  		call	seldk			; Select drive 0=A, 1=B, etc.
 101:	DCC1  3ACCD8  		ld	a,(subflg)		; Get submit flag
 102:	DCC4  1850    		jr	cmd25a			; Exit
 103:			;
 104:			; Search for file
 105:			;
 106:	DCC6  CD76DD  	cmnd17:	call	seldrv			; Select drive from FCB
 107:	DCC9  DD7E00  		ld	a,(ix+0)		; Get drive number from FCB
 108:	DCCC  D63F    		sub	'?'			; Test if '?'
 109:	DCCE  280D    		jr	Z,cmd17b		; If so all entries match
 110:	DCD0  DD7E0E  		ld	a,(ix+14)		; Get system byte
 111:	DCD3  FE3F    		cp	'?'			; Test if '?'
 112:	DCD5  2804    		jr	Z,cmd17a		; Yes, jump
 113:	DCD7  DD360E00		ld	(ix+14),0		; Load system byte with zero
 114:	DCDB  3E0F    	cmd17a:	ld	a,15			; Test first 15 items in FCB
 115:	DCDD  CDACE0  	cmd17b:	call	search			; Do search
 116:	DCE0  2A9FD8  	cmd17c:	ld	hl,(dirbuf)		; Copy directory buffer
 117:	DCE3  ED5BBCD8		ld	de,(DMA)		; To DMA address
 118:	DCE7  018000  		ld	bc,128			; Directory=128 bytes
 119:	DCEA  EDB0    		ldir
 120:	DCEC  C9      		ret				; Exit
 121:			;
 122:			; Search for next occurrence of file
 123:			;
 124:	DCED  DD2ACDD8	cmnd18:	ld	ix,(dcopy)		; Get last FCB used by search
 125:	DCF1  CD76DD  		call	seldrv			; Select drive from FCB
 126:	DCF4  CDBEE0  		call	searcn			; Search next file match
 127:	DCF7  18E7    		jr	cmd17c			; And copy directory to DMA address
 128:			;
 129:			; Delete file
 130:			;
 131:	DCF9  CD76DD  	cmnd19:	call	seldrv			; Select drive from FCB
 132:	DCFC  CD69E1  		call	delete			; Delete file
 133:	DCFF  3ACFD8  	cmd19a:	ld	a,(searex)		; Get exit byte 00=file found,0ffh not
 134:	DD02  1812    		jr	cmd25a			; And exit
 135:			;
 136:			; Rename file
 137:			;
 138:	DD04  CD76DD  	cmnd23:	call	seldrv			; Select drive from FCB
 139:	DD07  CD88E1  		call	renam			; Rename file
 140:	DD0A  18F3    		jr	cmd19a			; And exit
 141:			;
 142:			; Return login vector
 143:			;
 144:	DD0C  2AB8D8  	cmnd24:	ld	hl,(login)		; Get login vector
 145:	DD0F  22BFD8  	cmd24a:	ld	(pexit),hl		; Save it
 146:	DD12  C9      		ret				; And exit
 147:			;
 148:			; Return current drive
 149:			;
 150:	DD13  3AC6D8  	cmnd25:	ld	a,(defdrv)		; Get current drive
 151:	DD16  C3C2D9  	cmd25a:	jp	exit			; And exit
 152:			;
 153:			; Return allocation vector
 154:			;
 155:	DD19  2AA5D8  	cmnd27:	ld	hl,(alv)		; Get allocation vector
 156:	DD1C  18F1    		jr	cmd24a			; And exit
 157:			;
 158:			; Return disk R/O vector
 159:			;
 160:	DD1E  2AB6D8  	cmnd29:	ld	hl,(dskro)		; Get disk R/O vector
 161:	DD21  18EC    		jr	cmd24a			; And exit
 162:			;
 163:			; Set file attributes
 164:			;
 165:	DD23  CD76DD  	cmnd30:	call	seldrv			; Select drive from FCB
 166:	DD26  CDBBE1  		call	cstat			; Change status
 167:	DD29  18D4    		jr	cmd19a			; And exit
 168:			;
 169:			; Get Disk Parameter Block Address
 170:			;
 171:	DD2B  2AA1D8  	cmnd31:	ld	hl,(ixp)		; get drive table
 172:	DD2E  18DF    		jr	cmd24a			; And exit
 173:			;
 174:			; Set/get user code
 175:			;
 176:			
 177:	DD30  7B      	cmnd32:	ld	a,e			; Get user code
 178:	DD31  3C      		inc	a			; Test if 0ffh
 179:	DD32  3AC4D8  		ld	a,(user)		; Get old user code
 180:	DD35  28DF    		jr	Z,cmd25a		; If 0ffh then exit
 181:	DD37  7B      		ld	a,e			; Get new user code
 182:	DD38  E61F    		and	01fh			; Mask it
 183:	DD3A  32C4D8  		ld	(user),a		; Save it
 184:	DD3D  C9      		ret				; And exit
 185:			;
 186:			; Compute file size
 187:			;
 188:	DD3E  CD76DD  	cmnd35:	call	seldrv			; Select drive from FCB
 189:	DD41  CDE2E1  		call	filsz			; Compute file size
 190:	DD44  18B9    		jr	cmd19a			; And exit
 191:			;
 192:			; Set random record count
 193:			;
 194:	DD46  212000  	cmnd36:	ld	hl,32			; Set pointer to next record
 195:	DD49  CDA6E5  		call	calrrc			; Calculate random record count
 196:	DD4C  DD7221  	ldrrc:	ld	(ix+33),d		; And save random record count
 197:	DD4F  DD7122  		ld	(ix+34),c
 198:	DD52  DD7023  		ld	(ix+35),b
 199:	DD55  C9      		ret				; And exit
 200:			;
 201:			; Reset individual disk drives from vector in DE
 202:			;
 203:	DD56  7B      	cmnd37:	ld	a,e			; Get mask LSB
 204:	DD57  2F      		cpl				; Complement it
 205:	DD58  5F      		ld	e,a
 206:	DD59  7A      		ld	a,d			; Get mask MSB
 207:	DD5A  2F      		cpl				; Complement it
 208:	DD5B  57      		ld	d,a
 209:	DD5C  2AB8D8  		ld	hl,(login)		; Get login vector
 210:	DD5F  7B      		ld	a,e			; Mask login vector
 211:	DD60  A5      		and	l			; LSB
 212:	DD61  6F      		ld	l,a
 213:	DD62  7A      		ld	a,d			; Mask login vector
 214:	DD63  A4      		and	h			; MSB
 215:	DD64  67      		ld	h,a
 216:	DD65  22B8D8  		ld	(login),hl		; Save login vector
 217:	DD68  EB      		ex	de,hl			; Use login vector as mask
 218:	DD69  2ABAD8  		ld	hl,(diff)		; Get disk changed vector <crw>
 219:	DD6C  7B      		ld	a,e			; Mask drive R/O vector
 220:	DD6D  A5      		and	l			; LSB
 221:	DD6E  6F      		ld	l,a
 222:	DD6F  7A      		ld	a,d			; Mask drive R/O vector
 223:	DD70  A4      		and	h			; LSB
 224:	DD71  67      		ld	h,a
 225:	DD72  22BAD8  		ld	(diff),hl		; Save disk changed vector <crw>
 226:	DD75  C9      		ret				; And exit
 227:			;
 228:			; Select disk from FCB
 229:			;
 230:	DD76  3EFF    	seldrv:	ld	a,0ffh			; Set disk select done flag
 231:	DD78  32C1D8  		ld	(fldrv),a
 232:	DD7B  3AC6D8  		ld	a,(defdrv)		; Get current drive
 233:	DD7E  32C5D8  		ld	(drive),a		; Save it in memory
 234:	DD81  5F      		ld	e,a			; Save it in register e
 235:	DD82  DD7E00  		ld	a,(ix+0)		; Get drive from FCB
 236:	DD85  32C3D8  		ld	(fcb0),a		; Save it
 237:	DD88  57      		ld	d,a
 238:	DD89  FE3F    		cp	'?'			; Test if '?'
 239:	DD8B  2818    		jr	Z,cmnd14		; Yes, then select drive from register e
 240:	DD8D  E61F    		and	01fh			; Mask drive
 241:	DD8F  7B      		ld	a,e			; Test if zero
 242:	DD90  2802    		jr	Z,seldr0		; Select drive from register e
 243:	DD92  7A      		ld	a,d
 244:	DD93  3D      		dec	a			; Decrement drive
 245:	DD94  CDA6DD  	seldr0:	call	seldk			; Select drive
 246:	DD97  DD7E00  		ld	a,(ix+0)		; Get drive from FCB
 247:	DD9A  E6E0    		and	0e0h			; Remove drive bits
 248:	DD9C  47      		ld	b,a			; Save register
 249:	DD9D  3AC4D8  		ld	a,(user)		; Get user number
 250:	DDA0  B0      		or	b			; Insert user number in FCB
 251:	DDA1  DD7700  		ld	(ix+0),a
 252:	DDA4  C9      		ret				; And exit
 253:			;
 254:			; Select disk
 255:			;
 256:	DDA5  7B      	cmnd14:	ld	a,e			; Copy drive number
 257:			;
 258:	DDA6  E60F    	seldk:	and	0fh			; Mask drive number to 0-15
 259:	DDA8  47      		ld	b,a			; Save counter
 260:	DDA9  ED5BB8D8		ld	de,(login)		; Get login vector
 261:	DDAD  B7      		or	a			; Test drive 'a'
 262:	DDAE  2806    		jr	Z,seldk1		; Yes then jump
 263:	DDB0  CB1A    	seldk0:	rr	d			; Shift login vector
 264:	DDB2  CB1B    		rr	e			; Until bit 0 register e
 265:	DDB4  10FA    		djnz	seldk0			; Is current drive
 266:	DDB6  21C6D8  	seldk1:	ld	hl,defdrv		; Get pointer last drive
 267:	DDB9  CB43    		bit	0,e			; Test if drive logged in
 268:	DDBB  2802    		jr	Z,seldk2		; No, login drive
 269:	DDBD  BE      		cp	(hl)			; Test same drive
 270:	DDBE  C8      		ret	Z			; Yes then exit
 271:	DDBF  77      	seldk2: ld	(hl),a			; Save new current drive
 272:	DDC0  D5      		push	de			; Save drive logged in flag
 273:	DDC1  4F      		ld	c,a
 274:	DDC2  CD9BE6  		call	SelDsk			; Do BIOS select
 275:	DDC5  7C      		ld	a,h			; Test if error
 276:	DDC6  B5      		or	l
 277:	DDC7  282D    		jr	Z,seldk3		; Yes, illegal drive number
 278:	DDC9  5E      		ld	e,(hl)			; Get LSB translation vector
 279:	DDCA  23      		inc	hl			; Increment pointer
 280:	DDCB  56      		ld	d,(hl)			; Get MSB translation vector
 281:	DDCC  23      		inc	hl			; Increment pointer
 282:	DDCD  ED539BD8		ld	(trans),de		; Save translation vector
 283:	DDD1  229DD8  		ld	(temp0),hl		; Save address temp0
 284:	DDD4  110600  		ld	de,6
 285:	DDD7  19      		add	hl,de			; Point to dirbuf pointer <crw>
 286:	DDD8  119FD8  		ld	de,dirbuf		; Load dirbuf pointer
 287:	DDDB  010800  		ld	bc,8			; Copy pointers to dirbuf,
 288:	DDDE  EDB0    		ldir				; ..csv (wacd), alv from BIOS
 289:	DDE0  2AA1D8  		ld	hl,(ixp)		; Get drive parameter address
 290:	DDE3  0E0F    		ld	c,15			; Copy 15 bytes
 291:	DDE5  EDB0    		ldir
 292:	DDE7  D1      		pop	de			; Get drive logged in flag
 293:	DDE8  CB43    		bit	0,e			; Test it
 294:	DDEA  C0      		ret	NZ			; Drive logged in so return
 295:	DDEB  2AB8D8  		ld	hl,(login)		; Get login vector
 296:	DDEE  CD59DE  		call	sdrvb			; Set drive bit in login vector
 297:	DDF1  22B8D8  		ld	(login),hl		; Save login vector
 298:	DDF4  1804    		jr	initdr			; And setup drive tables
 299:	DDF6          	seldk3:
 300:	DDF6  2A8BD8  		ld	hl,(StSel)		; Load error message address
 301:	DDF9  E9      		jp	(hl)			; And display error
 302:			;
 303:			; Init drive
 304:			;  Clear allocation vector bit buffer after drive reset
 305:			;
 306:	DDFA  ED5BACD8	initdr:	ld	de,(maxlen)		; Get length alv buffer-1 (bits)
 307:	DDFE  3E03    		ld	a,3			; Divide by 8
 308:	DE00  CB3A    	initd0:	srl	d			; To get bytes
 309:	DE02  CB1B    		rr	e
 310:	DE04  3D      		dec	a
 311:	DE05  20F9    		jr	NZ,initd0
 312:	DE07  13      		inc	de			; Increment, so all bits are cleared
 313:	DE08  2AA5D8  		ld	hl,(alv)		; Get pointer alv buffer
 314:	DE0B  E5      		push	hl
 315:	DE0C  3600    	initd1:	ld	(hl),0			; Clear 8 bits
 316:	DE0E  23      		inc	hl			; Increment pointer
 317:	DE0F  1B      		dec	de			; Decrement counter
 318:	DE10  7A      		ld	a,d			; Test if counter zero
 319:	DE11  B3      		or	e
 320:	DE12  20F8    		jr	NZ,initd1		; Not then jump
 321:	DE14  E1      		pop	hl			; Get alv pointer
 322:	DE15  ED5BB0D8		ld	de,(ndir0)		; Get first two bytes alv buffer
 323:	DE19  73      		ld	(hl),e			; Save LSB
 324:	DE1A  23      		inc	hl			; Increment pointer
 325:	DE1B  72      		ld	(hl),d			; Save MSB
 326:	DE1C  2A9DD8  		ld	hl,(temp0)		; Clear number of files
 327:	DE1F  AF      		xor	a			; On this drive
 328:	DE20  77      		ld	(hl),a			; Clear LSB
 329:	DE21  23      		inc	hl			; Increment pointer
 330:	DE22  77      		ld	(hl),a			; Clear MSB
 331:	DE23  32CCD8  		ld	(subflg),a		; Clear submit flag (reset disk command)
 332:	DE26  CD06DF  		call	setfct			; Set file count
 333:	DE29  3EFF    	initd2:	ld	a,0ffh			; Update directory checksum
 334:	DE2B  CD2ADF  		call	rddir			; Read FCB's from directory
 335:	DE2E  CD0DDF  		call	tstfct			; Test last FCB
 336:	DE31  C8      		ret	Z			; Yes then exit
 337:	DE32  CDFBDE  		call	caldir			; Calculate entry point FCB
 338:	DE35  7E      		ld	a,(hl)			; Get first byte FCB
 339:	DE36  FEE5    		cp	0e5h			; Test empty directory entry
 340:	DE38  28EF    		jr	Z,initd2		; Yes then get next FCB
 341:	DE3A  FE21    		cp	021h			; Test time stamp
 342:	DE3C  28EB    		jr	Z,initd2		; Yes then get next FCB
 343:	DE3E  3AC4D8  		ld	a,(user)		; Get user number
 344:	DE41  BE      		cp	(hl)			; Test if user is same
 345:	DE42  200B    		jr	NZ,initd3		; No then jump
 346:	DE44  23      		inc	hl			; Point to file name
 347:	DE45  7E      		ld	a,(hl)			; Get first char filename
 348:	DE46  2B      		dec	hl
 349:	DE47  D624    		sub	'$'			; Test if '$'
 350:	DE49  2004    		jr	NZ,initd3		; Not then jump
 351:	DE4B  3D      		dec	a			; Load a with 0ffh
 352:	DE4C  32CCD8  		ld	(subflg),a		; Save it in subflg
 353:	DE4F  0E01    	initd3:	ld	c,1			; Set bit in alv buffer
 354:	DE51  CDE4DF  		call	fillbb			; Set bits from FCB in alv buffer
 355:	DE54  CD14DF  		call	setlf			; Update last file count
 356:	DE57  18D0    		jr	initd2			;
 357:			;
 358:			; Set drive bit from (defdrv) in HL
 359:			;	Exit:	DE = HL before setting bit (if any)
 360:			;
 361:	DE59  EB      	sdrvb:	ex	de,hl			; Copy hl=>de
 362:	DE5A  210100  		ld	hl,1			; Get mask drive "a"
 363:	DE5D  3AC6D8  		ld	a,(defdrv)		; Get current drive
 364:	DE60  B7      		or	a			; Test if drive "a"
 365:	DE61  2804    		jr	Z,sdrvb1		; Yes then done
 366:	DE63  29      	sdrvb0:	add	hl,hl			; Get next mask
 367:	DE64  3D      		dec	a			; Decrement drive counter
 368:	DE65  20FC    		jr	NZ,sdrvb0		; And test if done
 369:	DE67  7A      	sdrvb1:	ld	a,d			; Hl=hl or de
 370:	DE68  B4      		or	h
 371:	DE69  67      		ld	h,a
 372:	DE6A  7B      		ld	a,e
 373:	DE6B  B5      		or	l
 374:	DE6C  6F      		ld	l,a
 375:	DE6D  C9      		ret				; Exit
 376:			
 377:			;
 378:			; Calculate sector/track directory
 379:			;
 380:	DE6E          	stdir:
 381:	DE6E  2AC9D8  		ld	hl,(filcnt)		; Get FCB counter directory
 382:	DE71  CB3C    		srl	h			; Divide by 4
 383:	DE73  CB1D    		rr	l			; (4 FCB's / sector)
 384:	DE75  CB3C    		srl	h
 385:	DE77  CB1D    		rr	l
 386:	DE79  22C7D8  		ld	(recdir),hl		; Save value (used by checksum)
 387:	DE7C  EB      		ex	de,hl			; Copy it to de
 388:	DE7D  210000  		ld	hl,0			; Clear hl
 389:			;
 390:			; Calculate sector/track
 391:			;	Entry:	hl,de = sector number (128 byte sector)
 392:			;	Exit:	set track  = hl,de  /  maxsec
 393:			;		set sector = hl,de mod maxsec
 394:			;
 395:	DE80  ED4BA7D8	calst:	ld	bc,(maxsec)		; Get sectors/track
 396:	DE84  3E11    		ld	a,17			; Set up loop counter
 397:	DE86  B7      	calst0:	or	a			; Test hl>=bc
 398:	DE87  ED42    		sbc	hl,bc
 399:	DE89  3F      		ccf
 400:	DE8A  3802    		jr	C,calst1		; Yes then jump
 401:	DE8C  09      		add	hl,bc			; No then restore hl
 402:	DE8D  B7      		or	a			; And clear carry
 403:	DE8E  CB13    	calst1:	rl	e			; Shift result in de
 404:	DE90  CB12    		rl	d
 405:	DE92  3D      		dec	a			; Test last bit done
 406:	DE93  2806    		jr	Z,calst2		; Yes then exit
 407:	DE95  CB15    		rl	l			; Shift next bit in hl
 408:	DE97  CB14    		rl	h
 409:	DE99  18EB    		jr	calst0			; Continue
 410:	DE9B  E5      	calst2:	push	hl			; Save sector number
 411:	DE9C  2AB4D8  		ld	hl,(nftrk)		; Get first track
 412:	DE9F  19      		add	hl,de			; Add track number
 413:	DEA0  44      		ld	b,h			; Copy it to bc
 414:	DEA1  4D      		ld	c,l
 415:	DEA2  CD9EE6  		call	SetTrk			; BIOS call set track
 416:	DEA5  C1      		pop	bc			; Restore sector number
 417:	DEA6  ED5B9BD8		ld	de,(trans)		; Get translation table address
 418:	DEAA  CDB0E6  		call	SecTrn			; BIOS call sector translation
 419:	DEAD  44      		ld	b,h			; Copy result to bc
 420:	DEAE  4D      		ld	c,l
 421:	DEAF  C3A1E6  		jp	SetSec			; BIOS call set sector
 422:			;
 423:			; Get disk map block number from FCB
 424:			;
 425:			; Exit: HL = address FCB
 426:			;	DE = disk map
 427:			;	BC = offset in disk map
 428:			;
 429:	DEB2  DD4E20  	getdm:	ld	c,(ix+32)		; Get next record
 430:	DEB5  3AA9D8  		ld	a,(nblock)		; Get number of blocks
 431:	DEB8  47      		ld	b,a			; Save it
 432:	DEB9  CB39    	getdm0:	srl	c			; Shift next record
 433:	DEBB  10FC    		djnz	getdm0			; Number of blocks times
 434:	DEBD  2F      	getdm1:	cpl				; Complement number of blocks
 435:	DEBE  C609    		add	a,9			; Add 9
 436:	DEC0  47      		ld	b,a			; B=8-number of blocks
 437:	DEC1  3AABD8  		ld	a,(nextnd)		; Get extend mask
 438:	DEC4  DDA60C  		and	(ix+12)			; Mask with extend
 439:	DEC7  0F      		rrca				; Rotate one right
 440:	DEC8  07      	getdm2:	rlca				; Rotate one left
 441:	DEC9  10FD    		djnz	getdm2			; 8-number of blocks times
 442:	DECB  81      	getdm3:	add	a,c			; Add the two values to get entry FCB
 443:	DECC  DDE5    	getdm4:	push	ix			; Get FCB address
 444:	DECE  E1      		pop	hl
 445:	DECF  0E10    		ld	c,16			; Add offset 16 to point to dm
 446:	DED1  09      		add	hl,bc
 447:	DED2  4F      		ld	c,a			; Add entry FCB
 448:	DED3  09      		add	hl,bc
 449:	DED4  3AADD8  		ld	a,(maxlen+1)		; Test 8 bits/16 bits FCB entry
 450:	DED7  B7      		or	a
 451:	DED8  2003    		jr	NZ,getdm5		; 16 bits => jump
 452:	DEDA  5E      		ld	e,(hl)			; Get 8 bit value
 453:	DEDB  57      		ld	d,a			; Make MSB zero
 454:	DEDC  C9      		ret				; And exit
 455:	DEDD  09      	getdm5:	add	hl,bc			; Add twice (16 bit values)
 456:	DEDE  5E      		ld	e,(hl)			; Get LSB
 457:	DEDF  23      		inc	hl			; Increment pointer
 458:	DEE0  56      		ld	d,(hl)			; Get MSB
 459:	DEE1  2B      		dec	hl			; Decrement pointer
 460:	DEE2  C9      		ret				; And exit
 461:			;
 462:			; Calculate sector number
 463:			;  entry: de=block number from FCB
 464:			;
 465:	DEE3  210000  	calsec:	ld	hl,0			; Clear MSB sector number
 466:	DEE6  3AA9D8  		ld	a,(nblock)		; Get loop counter
 467:	DEE9  47      		ld	b,a			; Save it in b
 468:	DEEA  CB23    	calsc0:	sla	e			; Shift l,d,e
 469:	DEEC  CB12    		rl	d
 470:	DEEE  CB15    		rl	l
 471:	DEF0  10F8    		djnz	calsc0			; B times
 472:	DEF2  3AAAD8  	calsc1:	ld	a,(nmask)		; Get sector mask
 473:	DEF5  DDA620  		and	(ix+32)			; And with next record
 474:	DEF8  B3      		or	e			; Set up LSB sector number
 475:	DEF9  5F      		ld	e,a
 476:	DEFA  C9      		ret				; And exit
 477:			;
 478:			; Calculate dirbuf entry point
 479:			;
 480:	DEFB  2A9FD8  	caldir:	ld	hl,(dirbuf)		; Get start address dirbuf
 481:	DEFE  3ACBD8  		ld	a,(secpnt)		; Get sector pointer
 482:	DF01  85      		add	a,l			; Add l=l+a
 483:	DF02  6F      		ld	l,a
 484:	DF03  D0      		ret	NC			; No carry exit
 485:	DF04  24      		inc	h			; Increment h
 486:	DF05  C9      		ret				; And exit
 487:			;
 488:			; Init file count
 489:			;
 490:	DF06  21FFFF  	setfct:	ld	hl,-1			; Set up file count
 491:	DF09  22C9D8  		ld	(filcnt),hl		; Save it
 492:	DF0C  C9      		ret				; And exit
 493:			;
 494:			; Test file count
 495:			;
 496:			; Exit:	Zero flag set and A = 0 if filcnt = 0ffffh
 497:			;
 498:	DF0D  2AC9D8  	tstfct:	ld	hl,(filcnt)		; Test file count=0ffffh
 499:	DF10  7C      	 	ld	a,h			; Get MSB
 500:	DF11  A5      		and	l			; And LSB
 501:	DF12  3C      		inc	a			; Test if result=0ffh
 502:	DF13  C9      		ret				; And exit
 503:			;
 504:			; Set last file
 505:			;
 506:	DF14  CD1DDF  	setlf:	call	tstlf			; Test last file
 507:	DF17  D8      		ret	C			; No then exit
 508:	DF18  13      		inc	de			; Increment last file
 509:	DF19  72      		ld	(hl),d			; Save it in temp0
 510:	DF1A  2B      		dec	hl
 511:	DF1B  73      		ld	(hl),e
 512:	DF1C  C9      		ret				; And exit
 513:			;
 514:			; Test last file
 515:			;
 516:	DF1D  2A9DD8  	tstlf:	ld	hl,(temp0)		; Get pointer to last file
 517:	DF20  ED5BC9D8		ld	de,(filcnt)		; Get file counter
 518:	DF24  7B      		ld	a,e			; Subtract filcnt-(temp0)
 519:	DF25  96      		sub	(hl)
 520:	DF26  23      		inc	hl
 521:	DF27  7A      		ld	a,d
 522:	DF28  9E      		sbc	a,(hl)			; Carry means (temp0) > filcnt
 523:	DF29  C9      		ret				; Exit
 524:			;
 525:			; Get next FCB from drive
 526:			;	Entry:	A = 0 check checksum
 527:			;		A = 0ffh update checksum
 528:			;
 529:	DF2A  4F      	rddir:	ld	c,a			; Save checksum flag
 530:	DF2B  2AC9D8  		ld	hl,(filcnt)		; Get file counter
 531:	DF2E  23      		inc	hl			; Increment it
 532:	DF2F  22C9D8  		ld	(filcnt),hl		; And save it
 533:	DF32  ED5BAED8		ld	de,(nfiles)		; Get maximum number of files
 534:	DF36  B7      		or	a			; Clear carry
 535:	DF37  ED52    		sbc	hl,de			; Test if last file
 536:	DF39  19      		add	hl,de
 537:	DF3A  2802    		jr	Z,rddir0		; No, jump
 538:	DF3C  30C8    		jr	NC,setfct		; Yes, set file count to 0ffffh
 539:	DF3E  7D      	rddir0:	ld	a,l			; Get file count LSB
 540:	DF3F  87      		add	a,a			; *32
 541:	DF40  87      		add	a,a
 542:	DF41  87      		add	a,a
 543:	DF42  87      		add	a,a
 544:	DF43  87      		add	a,a
 545:	DF44  E660    		and	060h			; Mask it
 546:	DF46  32CBD8  		ld	(secpnt),a		; Save it for later use
 547:	DF49  C0      		ret	NZ			; Return if not first FCB sector
 548:	DF4A  C5      		push	bc			; Save checksum flag
 549:	DF4B  CD6EDE  		call	stdir			; Calculate sector/track directory
 550:	DF4E  CD93DF  		call	readdr			; Read sector directory
 551:	DF51  C1      		pop	bc			; Restore checksum flag
 552:			;
 553:			; Update/check checksum directory
 554:			; Entry C=0 check checksum, C=0ffh update checksum
 555:			;
 556:	DF52  2AB2D8  	chkdir:	ld	hl,(ncheck)		; Get number of checked records
 557:	DF55  7C      		ld	a,h
 558:	DF56  B5      		or	l
 559:	DF57  C8      		ret	Z
 560:	DF58  ED5BC7D8		ld	de,(recdir)		; Get current record
 561:	DF5C  B7      		or	a			; Clear carry
 562:	DF5D  ED52    		sbc	hl,de			; Test current record
 563:	DF5F  C8      		ret	Z			; Exit if zero
 564:	DF60  D8      		ret	C			; Exit if greater then ncheck
 565:	DF61  2A9FD8  		ld	hl,(dirbuf)		; Get dirbuf
 566:	DF64  0680    		ld	b,128			; Set up counter
 567:	DF66  AF      		xor	a			; Clear checksum
 568:	DF67  86      	chkdr0:	add	a,(hl)			; Add checksum
 569:	DF68  23      		inc	hl			; Increment pointer
 570:	DF69  10FC    		djnz	chkdr0			; 128 times
 571:	DF6B  2AA3D8  		ld	hl,(csv)		; Get pointer checksum directory
 572:	DF6E  19      		add	hl,de			; Add current record
 573:	DF6F  0C      		inc	c			; Test checksum flag
 574:	DF70  280E    		jr	Z,chkdr1		; 0ffh=> update checksum
 575:	DF72  BE      		cp	(hl)			; Test checksum
 576:	DF73  C8      		ret	Z			; Exit if ok
 577:	DF74  2ABAD8  		ld	hl,(diff)		; Get disk changed vector
 578:	DF77  CD59DE  		call	sdrvb			; Include drive bit
 579:	DF7A  22BAD8  		ld	(diff),hl		; Save disk changed bit
 580:	DF7D  C313E0  		jp	setfn			; Set # files to maximum
 581:	DF80  77      	chkdr1:	ld	(hl),a			; Update checksum
 582:	DF81  C9      		ret				; And exit
 583:			;
 584:			; Read sector from drive
 585:			;
 586:	DF82  CDA7E6  	readr:	call	dread			; BIOS call read sector
 587:	DF85  1803    		jr	write0			; Test exit code
 588:			;
 589:			; Write sector on drive
 590:			;
 591:	DF87  CDAAE6  	writer:	call	write			; BIOS call write sector
 592:	DF8A  B7      	write0:	or	a			; Test exit code
 593:	DF8B  C8      		ret	Z			; Exit if ok
 594:	DF8C  2A89D8  		ld	hl,(StRW)		; Point to data error routine
 595:	DF8F  32D3D8  		ld	(retflg),a		; Allow retry for read/write errors
 596:	DF92  E9      		jp	(hl)			; Display "Data error on d:"
 597:			;
 598:			; Read directory from drive
 599:			;
 600:	DF93  CDB4DF  	readdr:	call	DMAdir			; Set up DMA directory
 601:	DF96  CD82DF  		call	readr			; Read record
 602:	DF99  1813    		jr	stDMA			; Set up DMA user
 603:			;
 604:			; Write directory on drive
 605:			;
 606:	DF9B  0EFF    	writdr:	ld	c,0ffh			; Update checksum directory
 607:	DF9D  CD52DF  		call	chkdir
 608:	DFA0  CDB4DF  		call	DMAdir			; Set up DMA directory
 609:	DFA3  0E01    		ld	c,1			; Write directory flag
 610:	DFA5  CD87DF  		call	writer			; Write record
 611:	DFA8  1804    		jr	stDMA			; Set up DMA user
 612:			;
 613:			; Set DMA address command
 614:			;
 615:	DFAA  ED53BCD8	cmnd26:	ld	(DMA),de		; Save DMA address
 616:			;
 617:	DFAE  ED4BBCD8	stDMA:	ld	bc,(DMA)		; Get DMA address
 618:	DFB2  1804    		jr	DMAdr0			; And do BIOS call
 619:			;
 620:			; Set DMA address directory
 621:			;
 622:	DFB4  ED4B9FD8	DMAdir:	ld	bc,(dirbuf)		; Get DMA address directory
 623:	DFB8  C3A4E6  	DMAdr0:	jp	setDMA			; BIOS call set DMA
 624:			
 625:			;
 626:			; Get bit from allocation vector buffer
 627:			;
 628:			;	Entry:	DE = block number
 629:			;	Exit:	A  = bit in LSB
 630:			;		B  = bitnumber in a
 631:			;		HL = pointer in alv buffer
 632:			;
 633:	DFBB  7B      	getbit:	ld	a,e			; Get bit number
 634:	DFBC  E607    		and	7			; Mask it
 635:	DFBE  3C      		inc	a			; Add 1
 636:	DFBF  47      		ld	b,a			; Save it
 637:	DFC0  4F      		ld	c,a			; Twice
 638:	DFC1  CB3A    		srl	d			; Get byte number
 639:	DFC3  CB1B    		rr	e			; De=de/8
 640:	DFC5  CB3A    		srl	d
 641:	DFC7  CB1B    		rr	e
 642:	DFC9  CB3A    		srl	d
 643:	DFCB  CB1B    		rr	e
 644:	DFCD  2AA5D8  		ld	hl,(alv)		; Get start address alv buffer
 645:	DFD0  19      		add	hl,de			; Add byte number
 646:	DFD1  7E      		ld	a,(hl)			; Get 8 bits
 647:	DFD2  07      	getbt0:	rlca				; Get correct bit
 648:	DFD3  10FD    		djnz	getbt0
 649:	DFD5  41      		ld	b,c			; Restore bit number
 650:	DFD6  C9      		ret				; And return to caller
 651:			;
 652:			; Set/reset bit in allocation vector buffer
 653:			;	Entry	DE = block number
 654:			;		 C = 0 reset bit, c=1 set bit
 655:			;
 656:	DFD7  C5      	setbit:	push	bc			; Save set/reset bit
 657:	DFD8  CDBBDF  		call	getbit			; Get bit
 658:	DFDB  E6FE    		and	0feh			; Mask it
 659:	DFDD  D1      		pop	de			; Get set/reset bit
 660:	DFDE  B3      		or	e			; Set/reset bit
 661:	DFDF  0F      	setbt0:	rrca				; Rotate bit in correct position
 662:	DFE0  10FD    		djnz	setbt0
 663:	DFE2  77      		ld	(hl),a			; Save 8 bits
 664:	DFE3  C9      		ret				; And return to caller
 665:			;
 666:			; Fill bit buffer from FCB in dirbuf
 667:			;	Entry:	C = 0 reset bit
 668:			;		C = 1 set bit
 669:			;
 670:	DFE4          	fillbb:;	call	caldir			; Get directory entry
 671:	DFE4  111000  		ld	de,16			; Get offset dm block
 672:	DFE7  19      		add	hl,de			; Add offset
 673:	DFE8  43      		ld	b,e			; Get block counter
 674:	DFE9  5E      	fillb0:	ld	e,(hl)			; Get LSB block number
 675:	DFEA  23      		inc	hl			; Increment pointer
 676:	DFEB  1600    		ld	d,0			; Reset MSB block number
 677:	DFED  3AADD8  		ld	a,(maxlen+1)		; Test >256 blocks present
 678:	DFF0  B7      		or	a
 679:	DFF1  2803    		jr	Z,fillb1		; No then jump
 680:	DFF3  05      		dec	b			; Decrement block counter
 681:	DFF4  56      		ld	d,(hl)			; Get correct MSB
 682:	DFF5  23      		inc	hl			; Increment pointer
 683:	DFF6  7A      	fillb1:	ld	a,d			; Test block number
 684:	DFF7  B3      		or	e
 685:	DFF8  280D    		jr	Z,fillb2		; Zero then get next block
 686:	DFFA  E5      		push	hl			; Save pointer
 687:	DFFB  C5      		push	bc			; Save counter and set/reset bit
 688:	DFFC  2AACD8  		ld	hl,(maxlen)		; Get maximum lenght alv buffer
 689:	DFFF  B7      		or	a			; Reset carry
 690:	E000  ED52    		sbc	hl,de			; Test de<=maxlen alv buffer
 691:	E002  D4D7DF  		call	nc,setbit		; Yes then insert bit
 692:	E005  C1      		pop	bc			; Get counter and set/reset bit
 693:	E006  E1      		pop	hl			; Get pointer
 694:	E007  10E0    	fillb2:	djnz	fillb0			; Repeat for all dm entries
 695:	E009  C9      		ret				; And return to caller
 696:			;
 697:			; Set write protect disk
 698:			;
 699:	E00A          	cmnd28:
 700:	E00A  2AB6D8  		ld	hl,(dskro)		; Get disk R/O vector
 701:	E00D  CD59DE  		call	sdrvb			; Include drive bit
 702:	E010  22B6D8  		ld	(dskro),hl		; Save disk R/O bit
 703:	E013  ED5BAED8	setfn:	ld	de,(nfiles)		; Get maximum number of files-1
 704:	E017  13      		inc	de			; Increment it
 705:	E018  2A9DD8  		ld	hl,(temp0)		; Get pointer to disk parameter block
 706:	E01B  73      		ld	(hl),e			; And save number of files
 707:	E01C  23      		inc	hl
 708:	E01D  72      		ld	(hl),d
 709:	E01E  C9      		ret				; And return to caller
 710:			;
 711:			; Check file R/O bit
 712:			;
 713:	E01F  CDFBDE  	chkfro:	call	caldir			; Get directory entry
 714:	E022  110900  		ld	de,9			; Offset to file R/O bit <crw>
 715:	E025  19      		add	hl,de			; Add offset
 716:	E026  CB7E    		bit	7,(hl)			; Test file R/O
 717:	E028  2009    		jr	NZ,chkfr2		; Yes then error
 718:			;
 719:			; System files are R/O if referenced with wildcards:
 720:			;
 721:	E02A  3AD1D8  		ld	a,(searqu)		; Test if question mark used <crw>
 722:	E02D  B7      		or	a			; Test question mark used
 723:	E02E  C8      		ret	Z			; No then don't test system file bit
 724:	E02F  23      		inc	hl			; Increment to system file
 725:	E030  CB7E    		bit	7,(hl)			; Test system file
 726:	E032  C8      		ret	Z			; No system file then ok
 727:	E033          	chkfr2:
 728:	E033  2A8FD8  		ld	hl,(sfilro)		; Get pointer to file R/O message
 729:	E036  E9      		jp	(hl)			; Display message
 730:			
 731:			;
 732:			; Check drive read only
 733:			;
 734:	E037  2AB6D8  	chkro:	ld	hl,(dskro)		; Get drive R/O vector
 735:	E03A  CD59DE  		call	sdrvb			; Set drive bit
 736:	E03D  ED52    		sbc	hl,de			; Test extra bit added
 737:	E03F  C0      		ret	NZ			; Yes then drive not R/O
 738:	E040  2A8DD8  		ld	hl,(stro)		; Get pointer to drive R/O message
 739:	E043  E9      		jp	(hl)			; Display message
 740:			
 741:			;
 742:			; Get free block from allocation vector buffer
 743:			;	Entry:	DE = old block number
 744:			;	Exit:	DE = new block number (0 if no free block)
 745:			; HL counts up
 746:			; DE counts down
 747:			;
 748:	E044  62      	getfre:	ld	h,d			; Copy old block to hl
 749:	E045  6B      		ld	l,e
 750:	E046  7A      	getfr0:	ld	a,d			; Test down counter is zero
 751:	E047  B3      		or	e
 752:	E048  280B    		jr	Z,getfr1		; Yes then jump
 753:	E04A  1B      		dec	de			; Decrememt down counter
 754:	E04B  E5      		push	hl			; Save up/down counter
 755:	E04C  D5      		push	de
 756:	E04D  CDBBDF  		call	getbit			; Get bit from alv buffer
 757:	E050  1F      		rra				; Test if zero
 758:	E051  301F    		jr	NC,getfr3		; Yes then found empty block
 759:	E053  D1      		pop	de			; Get up/down counter
 760:	E054  E1      		pop	hl
 761:	E055  ED4BACD8	getfr1:	ld	bc,(maxlen)		; Get maximum alv lenght-1 in bc
 762:	E059  B7      		or	a			; Clear carry
 763:	E05A  ED42    		sbc	hl,bc			; Test hl>=lenght alv-1
 764:	E05C  09      		add	hl,bc			; Restore hl (flags are not affected)
 765:	E05D  300E    		jr	NC,getfr2		; End buffer then jump
 766:	E05F  23      		inc	hl			; Increment up counter
 767:	E060  D5      		push	de			; Save down/up counter
 768:	E061  E5      		push	hl
 769:	E062  EB      		ex	de,hl			; Save up counter in de
 770:	E063  CDBBDF  		call	getbit			; Get bit from alv buffer
 771:	E066  1F      		rra				; Test if zero
 772:	E067  3009    		jr	NC,getfr3		; Yes then found empty block
 773:	E069  E1      		pop	hl			; Get down/up counter
 774:	E06A  D1      		pop	de
 775:	E06B  18D9    		jr	getfr0			; And test next block
 776:	E06D  7A      	getfr2:	ld	a,d			; Test if last block tested
 777:	E06E  B3      		or	e
 778:	E06F  20D5    		jr	NZ,getfr0		; No then test next block
 779:	E071  C9      		ret				; Exit (de=0)
 780:	E072  37      	getfr3:	scf				; Set block number used
 781:	E073  17      		rla				; Save bit
 782:	E074  CDDFDF  		call	setbt0			; Put bit in alv buffer
 783:	E077  D1      		pop	de			; Get correct counter
 784:	E078  E1      		pop	hl			; Restore stack pointer
 785:	E079  C9      		ret				; Exit (de=block number)
 786:			
 787:			;
 788:			; Entry point to search for a file that is currently open
 789:			;
 790:			
 791:	E07A  3E0F    	sear0:	ld	a,15			; Match first 15 bytes
 792:	E07C  32D0D8  	sear01:	ld	(searnb),a		; Save number of bytes
 793:	E07F  DD7E0D  		ld	a,(ix+13)		; Check if =FF, if was, use normal
 794:	E082  3C      		inc	a			; search routine
 795:	E083  282A    		jr	Z,sr1
 796:	E085  CD98E6  		call	home			; Force BIOS directory read
 797:	E088  DD6E0D  		ld	l,(ix+13)		; Get sector of directory file was on
 798:	E08B  2600    		ld	h,0			; *4 to satisify internal data base
 799:	E08D  CB25    		sla	l
 800:	E08F  CB14    		rl	h
 801:	E091  CB25    		sla	l
 802:	E093  CB14    		rl	h
 803:	E095  22C9D8  		ld	(filcnt),hl		; Place in internal data base
 804:	E098  E5      		push	hl
 805:	E099  CD6EDE  		call	stdir			; Get sec-trk of directory entry
 806:	E09C  CD93DF  		call	readdr			; Read it to memory
 807:	E09F  E1      		pop	hl
 808:	E0A0  2B      		dec	hl			; -1, will be +1 in readdr
 809:	E0A1  22C9D8  		ld	(filcnt),hl
 810:	E0A4  180F    		jr	sear1
 811:			
 812:			;
 813:			; Find file name only
 814:			;
 815:	E0A6  3E0C    	findfn:	ld	a,12
 816:	E0A8  1802    		jr	search
 817:			;
 818:			; Find file
 819:			;
 820:	E0AA  3E0F    	findf:	ld	a,15			; Number of bytes to search for
 821:			
 822:			;
 823:			; Search for file name
 824:			;	Entry:	A = number of bytes to search for
 825:			;
 826:			
 827:	E0AC          	search:
 828:	E0AC  32D0D8  		ld	(searnb),a		; Save number of bytes
 829:	E0AF  CD06DF  	sr1:	call	setfct			; Initiate file counter
 830:	E0B2  CD98E6  		call	home			; Force BIOS directory read
 831:	E0B5  3EFF    	sear1:	ld	a,0ffh			; Set exit code to 0ffh (not found)
 832:	E0B7  32CFD8  		ld	(searex),a
 833:	E0BA  DD22CDD8		ld	(dcopy),ix		; Copy FCB pointer to ram (search next)
 834:			
 835:			;					; ..after disk change
 836:			; Search next file name
 837:			;
 838:	E0BE  AF      	SearcN:	xor	a			; Clear accu, check checksum dir.
 839:	E0BF  32D1D8  		ld	(searqu),a		; Clear question mark detected flag
 840:	E0C2  32D2D8  		ld	(searpu),a		; Clear public file flag
 841:	E0C5  CD2ADF  		call	rddir			; Get FCB from directory
 842:	E0C8  CD0DDF  		call	tstfct			; Test if past last entry
 843:	E0CB  CA46E1  		jp	Z,searc8		; Yes then jump
 844:	E0CE  ED5BCDD8		ld	de,(dcopy)		; Get FCB pointer
 845:	E0D2  1A      		ld	a,(de)			; Get first byte
 846:	E0D3  FEE5    		cp	0e5h			; Test if searching empty directory
 847:	E0D5  2807    		jr	Z,searc1		; Yes then jump
 848:	E0D7  D5      		push	de			; Save FCB pointer
 849:	E0D8  CD1DDF  		call	tstlf			; Test last file on this drive
 850:	E0DB  D1      		pop	de			; Restore FCB pointer
 851:	E0DC  3068    		jr	NC,searc8		; Yes then jump
 852:	E0DE  CDFBDE  	searc1:	call	caldir			; Get entry in directory
 853:	E0E1  7E      		ld	a,(hl)			; Get first byte directory entry
 854:	E0E2  FE21    		cp	021h			; Test time stamp
 855:	E0E4  28D8    		jr	Z,searcn		; Yes then get next directory entry
 856:	E0E6  3AD0D8  		ld	a,(searnb)		; Get number of bytes to search for
 857:	E0E9  47      		ld	b,a			; Save it in counter
 858:	E0EA  AF      		xor	a			; Clear accu
 859:	E0EB  4F      		ld	c,a			; Clear counter
 860:	E0EC  78      	searc2:	ld	a,b			; Test if counter is zero
 861:	E0ED  B7      		or	a
 862:	E0EE  285F    		jr	Z,searc9		; Yes then jump
 863:	E0F0  1A      		ld	a,(de)			; Get byte from FCB
 864:	E0F1  EE3F    		xor	'?'			; Test if question mark
 865:	E0F3  E67F    		and	07fh			; Mask it (remove high bit)
 866:	E0F5  283C    		jr	Z,searc6		; Yes then jump
 867:	E0F7  79      		ld	a,c			; Get FCB counter
 868:	E0F8  B7      		or	a			; Test whether first byte
 869:	E0F9  2023    		jr	NZ,searc3		; No
 870:	E0FB  3A95D8  		ld	a,(flags)		; Yes. get flag byte
 871:	E0FE  CB47    		bit	0,a			; Test public file enable
 872:	E100  281C    		jr	Z,searc3		; No
 873:	E102  23      		inc	hl			; Yes. get pointer to public bit
 874:	E103  23      		inc	hl
 875:	E104  CB7E    		bit	7,(hl)			; Test public bit directory
 876:	E106  2B      		dec	hl			; Restore pointer
 877:	E107  2B      		dec	hl
 878:	E108  2814    		jr	Z,searc3		; No public file then jump
 879:	E10A  1A      		ld	a,(de)			; Get first byte FCB
 880:	E10B  FEE5    		cp	0e5h			; Test if searching empty directory
 881:	E10D  280F    		jr	Z,searc3		; Yes then jump
 882:	E10F  AE      		xor	(hl)			; Test FCB=directory entry
 883:	E110  E67F    		and	07fh			; Mask it
 884:	E112  2819    		jr	Z,searc5		; Yes then jump
 885:	E114  E6E0    		and	0e0h			; Mask user number
 886:	E116  2006    		jr	NZ,searc3		; Not the same then jump
 887:	E118  3D      		dec	a			; A=0ffh
 888:	E119  32D2D8  		ld	(searpu),a		; Set public file found
 889:	E11C  180F    		jr	searc5			; Jump found
 890:	E11E  79      	searc3:	ld	a,c			; Get FCB counter
 891:	E11F  FE0D    		cp	13			; Test if at user code
 892:	E121  280A    		jr	Z,searc5		; Yes then no test
 893:	E123  FE0C    		cp	12			; Test if at extend number
 894:	E125  1A      		ld	a,(de)			; Get byte from FCB
 895:	E126  2811    		jr	Z,searc7		; Jump if extent number
 896:	E128  AE      		xor	(hl)			; Test byte FCB=byte directory entry
 897:	E129  E67F    		and	07fh			; Mask it
 898:	E12B  2091    	searc4:	jr	NZ,searcn		; Not the same then get next entry
 899:	E12D  13      	searc5:	inc	de			; Increment pointer FCB
 900:	E12E  23      		inc	hl			; Increment pointer directory entry
 901:	E12F  0C      		inc	c			; Increment counter
 902:	E130  05      		dec	b			; Decrement counter
 903:	E131  18B9    		jr	searc2			; Test next byte
 904:	E133  3D      	searc6:	dec	a			; Set question mark found flag
 905:	E134  32D1D8  		ld	(searqu),a
 906:	E137  18F4    		jr	searc5			; Jump found
 907:	E139  C5      	searc7:	push	bc			; Save counters
 908:	E13A  AE      		xor	(hl)			; Test extends
 909:	E13B  47      		ld	b,a			; Save it
 910:	E13C  3AABD8  		ld	a,(nextnd)		; Get extent mask
 911:	E13F  2F      		cpl				; Complement it
 912:	E140  E61F    		and	01fh			; Mask it
 913:	E142  A0      		and	b			; Mask extents
 914:	E143  C1      		pop	bc			; Restore counters
 915:	E144  18E5    		jr	searc4			; And test result
 916:	E146  CD06DF  	searc8:	call	setfct			; Error set file counter
 917:	E149  3EFF    		ld	a,0ffh			; And set exit code
 918:	E14B  32BFD8  		ld	(pexit),a
 919:	E14E  C9      		ret				; Return to caller
 920:	E14F  3AD1D8  	searc9:	ld	a,(searqu)		; Get question mark found flag
 921:	E152  47      		ld	b,a			; Save it
 922:	E153  3AD2D8  		ld	a,(searpu)		; Get public file flag
 923:	E156  A0      		and	b			; Test if public file and question mark
 924:	E157  20D2    		jr	NZ,searc4		; Yes then search for next entry
 925:	E159  CD14DF  		call	setlf			; Update last file count (empty FCB)
 926:	E15C  3AC9D8  		ld	a,(filcnt)		; Get file counter
 927:	E15F  E603    		and	3			; Mask it
 928:	E161  32BFD8  		ld	(pexit),a		; And set exit code
 929:	E164  AF      		xor	a			; Clear exit code search
 930:	E165  32CFD8  		ld	(searex),a
 931:	E168  C9      		ret				; And return to caller
 932:			;
 933:			; Delete file
 934:			;
 935:	E169  CD37E0  	delete:	call	chkro			; Check disk R/O
 936:	E16C  CDA6E0  		call	findfn
 937:	E16F  CD0DDF  	del0:	call	tstfct			; Test if file found
 938:	E172  C8      		ret	Z			; Not then exit
 939:	E173  CD1FE0  		call	chkfro			; Check file R/O
 940:	E176  CDFBDE  		call	caldir			; Get entry point directory
 941:	E179  36E5    		ld	(hl),0e5h		; Remove file
 942:	E17B  0E00    		ld	c,0			; Remove bits alv buffer
 943:	E17D  CDE4DF  		call	fillbb
 944:	E180  CD0EE2  		call	wrFCB			; Write directory buffer on disk
 945:	E183  CDBEE0  		call	searcn			; Search next entry
 946:	E186  18E7    		jr	del0			; And test it
 947:			;
 948:			; Rename file
 949:			;
 950:	E188  CD37E0  	renam:	call	chkro			; Check disk R/O
 951:	E18B  CDA6E0  		call	findfn
 952:	E18E  CD0DDF  	renam0:	call	tstfct			; Test if file found
 953:	E191  C8      		ret	Z			; Not then exit
 954:	E192  CD1FE0  		call	chkfro			; Check file R/O
 955:	E195  DDE5    		push	ix			; Save FCB entry
 956:	E197  E1      		pop	hl			; Get it in hl
 957:	E198  111000  		ld	de,16			; Offset to new name
 958:	E19B  19      		add	hl,de			; Add offset
 959:	E19C  EB      		ex	de,hl			; Copy hl=>de
 960:	E19D  CDFBDE  		call	caldir			; Get directory entry
 961:	E1A0  060B    		ld	b,11			; Set up loop counter
 962:	E1A2  23      	renam1:	inc	hl			; Increment directory pointer
 963:	E1A3  13      		inc	de			; Increment FCB pointer
 964:	E1A4  1A      		ld	a,(de)			; Get character from FCB
 965:	E1A5  E67F    		and	07fh			; Mask it
 966:	E1A7  FE3F    		cp	'?'			; Test if question mark
 967:	E1A9  2806    		jr	Z,renam2		; Yes then do not change char. on disk
 968:	E1AB  4F      		ld	c,a			; Save it in c
 969:	E1AC  7E      		ld	a,(hl)			; Get character from directory
 970:	E1AD  E680    		and	080h			; Mask status bit
 971:	E1AF  B1      		or	c			; Or with new character
 972:	E1B0  77      		ld	(hl),a			; Save in directory
 973:	E1B1  10EF    	renam2:	djnz	renam1			; Loop until done
 974:	E1B3  CD0EE2  		call	wrFCB			; And write directory on disk
 975:	E1B6  CDBEE0  		call	searcn			; Search next file
 976:	E1B9  18D3    		jr	renam0			; And test it
 977:			;
 978:			; Change status file
 979:			;
 980:	E1BB  CD37E0  	cstat:	call	chkro			; Check disk R/O
 981:	E1BE  CDA6E0  		call	findfn
 982:	E1C1  CD0DDF  	cstat0:	call	tstfct			; Test if file found
 983:	E1C4  C8      		ret	Z			; Not then exit
 984:	E1C5  DDE5    		push	ix			; Save FCB entry
 985:	E1C7  D1      		pop	de			; Get it in hl
 986:	E1C8  CDFBDE  		call	caldir			; Get directory entry
 987:	E1CB  060B    		ld	b,11			; Set up loop counter
 988:	E1CD  23      	cstat1:	inc	hl			; Increment directory pointer
 989:	E1CE  13      		inc	de			; Increment FCB pointer
 990:	E1CF  1A      		ld	a,(de)			; Get status bit from FCB
 991:	E1D0  E680    		and	080h			; Mask it
 992:	E1D2  4F      		ld	c,a			; Save it in c
 993:	E1D3  7E      		ld	a,(hl)			; Get character from directory
 994:	E1D4  E67F    		and	07fh			; Mask it
 995:	E1D6  B1      		or	c			; Or with new status bit
 996:	E1D7  77      		ld	(hl),a			; Save in directory
 997:	E1D8  10F3    		djnz	cstat1			; Loop until done
 998:	E1DA  CD0EE2  		call	wrFCB			; And write directory to disk
 999:	E1DD  CDBEE0  		call	searcn			; Search next file
1000:	E1E0  18DF    		jr	cstat0			; And test it
1001:			;
1002:			; Compute file size
1003:			;
1004:	E1E2  010000  	filsz:	ld	bc,0			; Reset file size lenght
1005:	E1E5  51      		ld	d,c
1006:	E1E6  CD4CDD  		call	ldrrc			; Save it in FCB+33,34,35
1007:	E1E9  CDA6E0  		call	findfn
1008:	E1EC  CD0DDF  	filsz0:	call	tstfct			; Test if file found
1009:	E1EF  C8      		ret	Z			; Not then exit
1010:	E1F0  CDFBDE  		call	caldir			; Get directory entry
1011:	E1F3  EB      		ex	de,hl			; Copy to de
1012:	E1F4  210F00  		ld	hl,15			; Offset to next record
1013:	E1F7  CDA6E5  		call	calrrc			; Calculate random record count
1014:	E1FA  7A      		ld	a,d			; Test LSB < (ix+33)
1015:	E1FB  DD9621  		sub	(ix+33)
1016:	E1FE  79      		ld	a,c			; Test isb < (ix+34)
1017:	E1FF  DD9E22  		sbc	a,(ix+34)
1018:	E202  78      		ld	a,b			; Test MSB < (ix+35)
1019:	E203  DD9E23  		sbc	a,(ix+35)
1020:	E206  D44CDD  		call	nc,ldrrc		; Write new maximum
1021:	E209  CDBEE0  		call	searcn			; Search next file
1022:	E20C  18DE    		jr	filsz0			; And test it
1023:			;
1024:			; Write FCB on disk
1025:			;
1026:	E20E  CD6EDE  	wrFCB:	call	stdir			; Calculate sector/track directory
1027:	E211  C39BDF  		jp	writdr			; Write directory on disk
1028:			
1029:			;
1030:			; Calculate sector of file opened in FCB
1031:			;
1032:	E214  CD0DDF  	cmd15:	call	tstfct			; Look for ffff
1033:	E217  2809    		jr	Z,cmd151		; yes, save ff, can't do fast lookup
1034:	E219  CB3C    		srl	h			; HL=(filcnt)/4-1
1035:	E21B  CB1D    		rr	l
1036:	E21D  CB3C    		srl	h
1037:	E21F  CB1D    		rr	l
1038:	E221  2D      		dec	l
1039:	E222  DD750D  	cmd151:	ld	(ix+13),l		; Save in FCB+13 for use in SEAR0
1040:	E225  C9      		ret
1041:			;
1042:			; Open file
1043:			;
1044:	E226  CD76DD  	cmnd15:	call	seldrv			; Select drive from FCB
1045:	E229  DD360E00		ld	(ix+14),0		; Clear FCB+14
1046:			
1047:	E22D  CDAAE0  	openf:	call	findf			; Find file
1048:	E230  CD0DDF  		call	tstfct			; Test file found
1049:	E233  C8      		ret	Z			; No then exit
1050:	E234          	openf0:
1051:	E234  DD7E0C  		ld	a,(ix+12)		; Get extent number from FCB
1052:	E237  F5      		push	af			; Save it
1053:	E238  CDFBDE  		call	caldir			; Get directory entry
1054:	E23B  E5      		push	hl			; Save it <crw>
1055:	E23C  1E08    		ld	e,8			; Set access date/time <crw>
1056:	E23E  CDCBE5  		call	stime			; Zero flag set if stamps present <crw>
1057:	E241  E1      		pop	hl			; Get directory entry <crw>
1058:	E242  DDE5    		push	ix			; Save FCB entry
1059:	E244  D1      		pop	de			; Get in in de
1060:	E245  012000  		ld	bc,32			; Number of bytes to move
1061:	E248  EDB0    		ldir				; Move directory to FCB
1062:	E24A  CC0EE2  		call	Z,wrFCB			; Write to disk if stamps present <crw>
1063:	E24D  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1064:	E251  DD460C  		ld	b,(ix+12)		; Get extent number
1065:	E254  DD4E0F  		ld	c,(ix+15)		; Get next record number
1066:	E257  F1      		pop	af			; Get old extent number
1067:	E258  DD770C  		ld	(ix+12),a		; Save it
1068:	E25B  B8      		cp	b			; Compare old and new extent number
1069:	E25C  2806    		jr	Z,openf1		; Same then jump
1070:	E25E  0E00    		ld	c,0			; Set next record count to 0
1071:	E260  3002    		jr	NC,openf1		; Old extent >= new extent then jump
1072:	E262  0E80    		ld	c,80h			; Set next record count to maximum
1073:	E264  DD710F  	openf1:	ld	(ix+15),c		; Save next record count
1074:	E267  CD14E2  		call	cmd15			; Fill in FCB+13,fast lookup
1075:	E26A  C9      		ret				; And return to caller
1076:			
1077:			;
1078:			; Close file command
1079:			;
1080:	E26B  CD76DD  	cmnd16:	call	seldrv			; select drive from FCB
1081:			;
1082:			; Close file
1083:			;
1084:	E26E  DDCB0E7E	close:	bit	7,(ix+14)		; test FCB/file modified
1085:	E272  C0      		ret	NZ			; not then no close required
1086:	E273  CD37E0  		call	chkro			; test disk R/O
1087:			;	ld	a,15			; number of bytes to search for
1088:			;	call	search			; search file
1089:			;	call	findf
1090:	E276  CD7AE0  		call	sear0			; Use fast search
1091:	E279  CD0DDF  		call	tstfct			; test file present
1092:	E27C  C8      		ret	Z			; no then exit
1093:	E27D  CD1FE0  		call	chkfro			; check file R/O
1094:	E280  CDFBDE  		call	caldir			; get directory entry
1095:	E283  011000  		ld	bc,16			; offset to dm block
1096:	E286  09      		add	hl,bc			; add offset
1097:	E287  EB      		ex	de,hl			; save hl in de
1098:	E288  DDE5    		push	ix			; save FCB pointer
1099:	E28A  E1      		pop	hl			; get it in hl
1100:	E28B  09      		add	hl,bc			; add offset
1101:	E28C  3AADD8  		ld	a,(maxlen+1)		; test number of block >= 256
1102:	E28F  B7      		or	a
1103:	E290  2801    		jr	Z,close0		; no then jump
1104:	E292  05      		dec	b			; set flag
1105:	E293  CDDFE2  	close0:	call	copydm			; copy and test blocks
1106:	E296  EB      		ex	de,hl			; exchange copy direction
1107:	E297  CDDFE2  		call	copydm			; copy and test blocks
1108:	E29A  EB      		ex	de,hl			; exchange copy direction
1109:	E29B  203C    		jr	NZ,close4		; block not the same then error
1110:	E29D  23      		inc	hl			; increment pointer FCB
1111:	E29E  13      		inc	de			; increment pointer directory
1112:	E29F  CB40    		bit	0,b			; test number of block >= 256
1113:	E2A1  2803    		jr	Z,close1		; no then jump
1114:	E2A3  23      		inc	hl			; increment pointer FCB
1115:	E2A4  13      		inc	de			; increment pointer directory
1116:	E2A5  0D      		dec	c			; decrement counter
1117:	E2A6  0D      	close1:	dec	c			; decrement counter
1118:	E2A7  20EA    		jr	NZ,close0		; not ready then jump
1119:	E2A9  21ECFF  		ld	hl,-20			; add -20 to get extent number
1120:	E2AC  19      		add	hl,de			; hL contains pointer to extent number
1121:	E2AD  DD7E0C  		ld	a,(ix+12)		; get extent number FCB
1122:	E2B0  BE      		cp	(hl)			; compare with extent number directory
1123:	E2B1  3808    		jr	C,close3		; fCB < directory then jump
1124:	E2B3  77      		ld	(hl),a			; save extent number in directory
1125:	E2B4  23      		inc	hl			; get pointer to next record
1126:	E2B5  23      		inc	hl
1127:	E2B6  23      		inc	hl
1128:	E2B7  DD7E0F  		ld	a,(ix+15)		; get next record FCB
1129:	E2BA  77      	close2:	ld	(hl),a			; save next record in directory
1130:	E2BB  1E04    	close3:	ld	e,4			; Set last update date/time
1131:	E2BD  CDCBE5  		call	stime			; Update time
1132:	E2C0  CDFBDE  		call	caldir			; Get directory entry
1133:	E2C3  010B00  		ld	bc,11			; Point to archive byte
1134:	E2C6  09      		add	hl,bc
1135:	E2C7  CBBE    		res	7,(hl)			; reset archive bit
1136:	E2C9  DDCB0BBE		res	7,(ix+11)		; reset bit in FCB
1137:	E2CD  23      		inc	hl
1138:	E2CE  23      		inc	hl
1139:	E2CF  E5      		push	hl
1140:	E2D0  CD14E2  		call	cmd15			; Fill in FCB+13 for next fast lookup
1141:	E2D3  7D      		ld	a,l
1142:	E2D4  E1      		pop	hl
1143:	E2D5  77      		ld	(hl),a
1144:	E2D6  C30EE2  		jp	wrFCB			; write FCB on disk
1145:			;
1146:	E2D9  3EFF    	close4:	ld	a,0ffh			; flag error
1147:	E2DB  32BFD8  		ld	(pexit),a
1148:	E2DE  C9      		ret				; and return to caller
1149:			;
1150:			; Copy and test disk map
1151:			;
1152:			;	Entry:	HL = pointer to first FCB
1153:			;		DE = pointer to second FCB
1154:			;		 B = 000h if less then 256 blocks
1155:			;		     0ffh if more or equal to 256 blocks
1156:			;	Exit:	Z  blocks are the same
1157:			;		NZ blocks are not the same
1158:			;
1159:	E2DF  7E      	copydm:	ld	a,(hl)			; get byte first FCB
1160:	E2E0  CB40    		bit	0,b			; test number of blocks >=256
1161:	E2E2  2803    		jr	Z,copyd0		; No then jump
1162:	E2E4  23      		inc	hl			; Increment pointer
1163:	E2E5  B6      		or	(hl)			; Test byte =0
1164:	E2E6  2B      		dec	hl			; Decrement pointer
1165:	E2E7  B7      	copyd0:	or	a			; Test block number is zero
1166:	E2E8  200B    		jr	NZ,copyd1		; No then compare blocks
1167:	E2EA  1A      		ld	a,(de)			; Copy block from other FCB in empty location
1168:	E2EB  77      		ld	(hl),a
1169:	E2EC  CB40    		bit	0,b			; Test number of blocks >=256
1170:	E2EE  C8      		ret	Z			; No then exit
1171:	E2EF  23      		inc	hl			; Increment to MSB block numbers
1172:	E2F0  13      		inc	de
1173:	E2F1  1A      		ld	a,(de)			; Copy block from other FCB in empty location
1174:	E2F2  77      		ld	(hl),a
1175:	E2F3  1807    		jr	copyd2			; Jump trick to save space
1176:	E2F5  1A      	copyd1:	ld	a,(de)			; Get block number first FCB
1177:	E2F6  96      		sub	(hl)			; Test if the same
1178:	E2F7  C0      		ret	NZ			; Not then return
1179:	E2F8  B0      		or	b			; Test if >=256 blocks
1180:	E2F9  C8      		ret	Z			; No then return
1181:	E2FA  23      		inc	hl			; Increment to MSB block numbers
1182:	E2FB  13      		inc	de
1183:	E2FC  1A      	copyd2:	ld	a,(de)			; Get block number first FCB
1184:	E2FD  96      		sub	(hl)			; Test if the same
1185:	E2FE  2B      		dec	hl			; Decrement block FCB pointers
1186:	E2FF  1B      		dec	de
1187:	E300  C9      		ret				; And exit to caller
1188:			
1189:			
1190:			;
1191:			; Entry point to use fast lookup to 'MAKE' next FCB entry for open file
1192:			;
1193:			
1194:	E301  CD0CE3  	maker:	call	mak0
1195:	E304  F5      		push	af
1196:	E305  3E01    		ld	a,1
1197:	E307  CD7CE0  		call	sear01
1198:	E30A  181B    		jr	mak1
1199:			
1200:			;
1201:			; Common code for MAKE/MAKER
1202:			;
1203:	E30C  CD37E0  	mak0:	call	chkro			; Check drive R/O
1204:	E30F  DD7E00  		ld	a,(ix+0)		; Get first byte FCB
1205:	E312  DD3600E5		ld	(ix+0),0e5h		; Set first byte to empty file
1206:	E316  C9      		ret
1207:			
1208:			
1209:			;
1210:			; Make file command
1211:			;
1212:			
1213:	E317          	cmnd22:
1214:	E317  CD76DD  		call	seldrv			; Select drive from FCB
1215:	E31A  DD360E00		ld	(ix+14),0		; Clear FCB+14
1216:			;
1217:			; Make file
1218:			;
1219:	E31E          	make:
1220:	E31E  CD0CE3  		call	mak0
1221:	E321  F5      		push	af			; Save it
1222:	E322  3E01    		ld	a,1			; Search for 1 byte
1223:	E324  CDACE0  		call	search			; Search empty file
1224:	E327  F1      	mak1:	pop	af			; Get first byte FCB
1225:	E328  DD7700  		ld	(ix+0),a		; Restore it
1226:	E32B  CD0DDF  		call	tstfct			; Test empty file found
1227:	E32E  C8      		ret	Z			; No then return error
1228:	E32F  AF      		xor	a			; Clear FCB+13
1229:			;	ld	(ix+13),a
1230:	E330  DDE5    		push	ix			; Save FCB pointer
1231:	E332  E1      		pop	hl			; Get it back in hl
1232:	E333  110F00  		ld	de,15			; Prepare offset
1233:	E336  19      		add	hl,de			; Add it
1234:	E337  0611    		ld	b,17			; Set loop counter
1235:	E339  77      	make0:	ld	(hl),a			; Clear FCB+15 up to FCB+31
1236:	E33A  23      		inc	hl			; Increment pointer
1237:	E33B  10FC    		djnz	make0			; And clear all bytes
1238:	E33D  1E02    		ld	e,2			; Set creation date
1239:	E33F  CDCBE5  		call	stime			; Update time in directory
1240:	E342  1E04    		ld	e,4			; Set last update date/time
1241:	E344  CDCBE5  		call	stime			; Update time in directory
1242:	E347  1E08    		ld	e,8			; Set access date/time <crw>
1243:	E349  CDCBE5  		call	stime
1244:	E34C  DDCB0BBE		res	7,(ix+11)		; Reset archive bit if present
1245:			;	call	cmd15			; Fill in FCB for fast lookup
1246:			;	call	caldir			; Get directory entry
1247:			;	push	ix			; Save FCB entry
1248:			;	pop	de			; Get it in de
1249:	E350  CDFBDE  		call	caldir			; get directory entry
1250:	E353  E5      		push	hl			; save directory pointer
1251:	E354  DDE5    		push	ix			; put fcb pointer on stack
1252:	E356  CD14E2  		call	cmd15			; fill in FCB+13
1253:	E359  D1      		pop	de			; fcb pointer to DE
1254:	E35A  E1      		pop	hl			; directory entry pointer
1255:			
1256:	E35B  EB      		ex	de,hl			; Exchange FCB and directory entry
1257:	E35C  012000  		ld	bc,32			; Number of bytes to move
1258:	E35F  EDB0    		ldir				; Move bytes
1259:	E361  CD0EE2  		call	wrFCB			; Write FCB on disk
1260:	E364  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1261:	E368  C9      		ret				; And return to caller
1262:			;
1263:			; Open next extent
1264:			;
1265:	E369  DDCB0E7E	openex:	bit	7,(ix+14)		; Test if FCB/file modified (write)
1266:	E36D  2027    		jr	NZ,openx2		; Not then jump
1267:	E36F  CD6EE2  		call	close			; Close current FCB
1268:	E372  3ABFD8  		ld	a,(pexit)		; Get exit code
1269:	E375  3C      		inc	a			; Test if error
1270:	E376  C8      		ret	Z			; Yes then exit
1271:	E377  CDABE3  		call	calnex			; Calculate next extent
1272:	E37A  381F    		jr	C,openx3		; Error then jump
1273:	E37C  2027    		jr	NZ,openx5		; fCB present from close then jump
1274:	E37E          	openx0:
1275:	E37E  CD7AE0  		call	sear0			; Use fast lookup to find next extent
1276:	E381  CD0DDF  	openx1:	call	tstfct			; Test if file found
1277:	E384  201F    		jr	NZ,openx5		; Yes then jump
1278:	E386  3AC2D8  		ld	a,(rdwr)		; Test read/write flag
1279:	E389  B7      		or	a			; Test if read
1280:	E38A  280F    		jr	Z,openx3		; Yes then error
1281:	E38C  CD01E3  		call	maker			; Make new extent if write
1282:	E38F  CD0DDF  		call	tstfct			; Test if succesfull
1283:	E392  2014    		jr	NZ,openx6		; Yes then exit
1284:	E394  1805    		jr	openx3			; No then error
1285:	E396  CDABE3  	openx2:	call	calnex			; Calculate next extent
1286:	E399  30E3    		jr	NC,openx0
1287:	E39B  DDCB0EFE	openx3:	set	7,(ix+14)		; Set FCB/file not modified
1288:	E39F  3EFF    		ld	a,0ffh			; Set exit code
1289:	E3A1  32BFD8  	openx4:	ld	(pexit),a
1290:	E3A4  C9      		ret				; And return to caller
1291:	E3A5  CD34E2  	openx5:	call	openf0			; Open file
1292:	E3A8  AF      	openx6:	xor	a			; And clear exit code
1293:	E3A9  18F6    		jr	openx4			; Use same routine
1294:			;
1295:			; Calculate next extent
1296:			;
1297:			;	Exit:	C  overflow detected
1298:			;		Z  search next extent
1299:			;		NZ next extent present (close)
1300:			;
1301:	E3AB  DD460C  	calnex:	ld	b,(ix+12)		; Get extent number
1302:	E3AE  DD4E0E  		ld	c,(ix+14)		; Get FCB+14
1303:	E3B1  CB71    		bit	6,c			; Test error bit random record
1304:	E3B3  37      		scf				; Set error flag
1305:	E3B4  C0      		ret	NZ			; Non zero then error exit
1306:	E3B5  04      		inc	b			; Increment extent number
1307:	E3B6  78      		ld	a,b			; Get extent number
1308:	E3B7  E61F    		and	01fh			; Mask it
1309:	E3B9  47      		ld	b,a			; Save it in b
1310:	E3BA  200A    		jr	NZ,calnx0		; Non zero then jump
1311:	E3BC  0C      		inc	c			; Increment FCB+14
1312:	E3BD  79      		ld	a,c			; Get it in a
1313:	E3BE  E63F    		and	03fh			; Mask it
1314:	E3C0  4F      		ld	c,a			; Save it in c
1315:	E3C1  37      		scf				; Set error flag
1316:	E3C2  C8      		ret	Z			; And return if file overflow
1317:	E3C3  AF      		xor	a			; Clear zero flag (not same extent)
1318:	E3C4  1804    		jr	calnx1			; And save extent number and FCB+14
1319:	E3C6  3AABD8  	calnx0:	ld	a,(nextnd)		; Get next extent mask
1320:	E3C9  A0      		and	b			; Test if same extent (close)
1321:	E3CA  DD700C  	calnx1:	ld	(ix+12),b		; Save extent number
1322:	E3CD  DD710E  		ld	(ix+14),c		; Save FCB+14
1323:	E3D0  C9      		ret				; And return to caller
1324:			;
1325:			; Read random record command
1326:			;
1327:	E3D1  CD76DD  	cmnd33:	call	seldrv			; Select drive from FCB
1328:			;
1329:			; Read random sector
1330:			;
1331:	E3D4  AF      	rdran:	xor	a			; Set read/write flag
1332:	E3D5  CD18E5  		call	ldFCB			; Load random record in FCB
1333:	E3D8  2804    		jr	Z,reads			; No error then read sector
1334:	E3DA  C9      		ret				; Return error
1335:			;
1336:			; Read sequential
1337:			;
1338:	E3DB  CD76DD  	cmnd20:	call	seldrv			; Select drive from FCB
1339:			;	ld	c,30h
1340:			;	call	conout
1341:			
1342:			;
1343:			; Read sector
1344:			;
1345:	E3DE  AF      	reads:	xor	a			; Set read/write flag
1346:	E3DF  32C2D8  		ld	(rdwr),a		; Save it
1347:	E3E2  DD7E20  		ld	a,(ix+32)		; Get record counter
1348:	E3E5  FE80    		cp	080h			; Test if last record this extent
1349:	E3E7  300B    		jr	NC,reads1		; Yes then open next extent
1350:	E3E9  DDBE0F  		cp	(ix+15)			; Test if greater then current record
1351:	E3EC  3813    		jr	C,reads2		; No then get record
1352:	E3EE  3E01    	reads0:	ld	a,1			; Set end of file flag
1353:	E3F0  32BFD8  		ld	(pexit),a		; Save it
1354:	E3F3  C9      		ret				; And return to caller
1355:	E3F4          	reads1:
1356:	E3F4  CD69E3  		call	openex			; ..To open next extent
1357:	E3F7  3ABFD8  		ld	a,(pexit)		; Get exit code
1358:	E3FA  B7      		or	a
1359:	E3FB  20F1    		jr	NZ,reads0		; Yes then end of file
1360:	E3FD  DD362000		ld	(ix+32),0		; Clear record counter
1361:	E401  CDB2DE  	reads2:	call	getdm			; Get block number from dm in FCB
1362:	E404  7A      		ld	a,d			; Test block number = 0
1363:	E405  B3      		or	e
1364:	E406  28E6    		jr	Z,reads0		; Yes then end file
1365:	E408  CDE3DE  		call	calsec			; Calculate sector number (128 bytes)
1366:	E40B  CD80DE  		call	calst			; Calculate sector/track number
1367:	E40E  CD82DF  		call	readr			; Read data
1368:	E411  3ABED8  		ld	a,(funct)		; Get function number
1369:	E414  FE14    		cp	20			; Test if read sequential
1370:	E416  C0      		ret	NZ			; No then return
1371:	E417  DD3420  		inc	(ix+32)			; Increment next record counter
1372:	E41A  C9      		ret				; And return to caller
1373:			;
1374:			; Write random record commands
1375:			;
1376:	E41B          	cmnd34:
1377:	E41B          	cmnd40:
1378:	E41B  CD76DD  		call	seldrv			; Select drive from FCB
1379:			;
1380:			; Write random sector
1381:			;
1382:	E41E  3EFF    	wrran:	ld	a,0ffh			; Set read/write flag
1383:	E420  CD18E5  		call	ldFCB			; Load FCB from random record
1384:	E423  2804    		jr	Z,writes		; No error then write record
1385:	E425  C9      		ret				; Return error
1386:			;
1387:			; Write sequential
1388:			;
1389:	E426          	cmnd21:
1390:	E426  CD76DD  		call	seldrv			; Select drive from FCB
1391:			;
1392:			; Write sector
1393:			;
1394:	E429          	writes:
1395:	E429  3EFF    		ld	a,0ffh			; Set read/write flag
1396:	E42B  32C2D8  		ld	(rdwr),a		; And save it
1397:	E42E  CD37E0  		call	chkro			; Check disk R/O
1398:	E431  DDCB097E		bit	7,(ix+9)		; Test if file R/O
1399:	E435  C233E0  		jp	NZ,chkfr2		; Yes then file R/O message
1400:			
1401:			; Check for changed disk.
1402:			; If disk changed:
1403:			; 	If file modified, abort.
1404:			; 	Else reset disk and disk changed bit.
1405:			;
1406:			
1407:			; Test disk changed
1408:			;
1409:	E438  2ABAD8  		ld	hl,(diff)		; Get drive changed vector
1410:	E43B  CD59DE  		call	sdrvb			; Set current drive bit
1411:	E43E  ED52    		sbc	hl,de			; Test extra bit added
1412:	E440  2021    		jr	NZ,writsa		; Bit added, so disk not changed
1413:			
1414:			; Test file modified
1415:			;
1416:	E442  DDCB0E7E		bit	7,(ix+14)		; File modified?
1417:	E446  CA8DDB  		jp	Z,chgerr		; Yes, abort and warm boot
1418:			
1419:			; Reset disk and disk changed bit.
1420:			;	HL = 0 from SBC, DE = (diff) from SDRVB above
1421:			;
1422:	E449  D5      		push	de			; Save (diff)
1423:	E44A  CD59DE  		call	sdrvb			; Set current bit only in HL
1424:	E44D  D1      		pop	de			; Get (diff)
1425:	E44E  E5      		push	hl			; Save current drive bit for reset
1426:	E44F  7A      		ld	a,d
1427:	E450  AC      		xor	h
1428:	E451  57      		ld	d,a			; Mask current bit in DE
1429:	E452  7B      		ld	a,e
1430:	E453  AD      		xor	l
1431:	E454  5F      		ld	e,a
1432:	E455  ED53BAD8		ld	(diff),de		; Reset disk changed bit in (diff)
1433:	E459  D1      		pop	de			; Get current bit for disk reset
1434:	E45A  CD56DD  		call	cmnd37			; No, reset drive:
1435:	E45D  3AC6D8  		ld	a,(defdrv)		; Get drive
1436:	E460  CDA6DD  		call	seldk			; ..and log it in again
1437:	E463          	writsa:
1438:	E463  DD7E20  		ld	a,(ix+32)		; Get record count
1439:	E466  FE80    		cp	080h			; Test if end this extent
1440:	E468  380E    		jr	C,writs0		; Yes then open next extent
1441:	E46A  CD69E3  		call	openex			; Open next extent
1442:	E46D  3ABFD8  		ld	a,(pexit)		; Get error code
1443:	E470  B7      		or	a
1444:	E471  C212E5  		jp	NZ,writs9		; Error then directory full error
1445:	E474  DD362000		ld	(ix+32),0		; Clear record counter
1446:	E478  CDB2DE  	writs0:	call	getdm			; Get block number from FCB
1447:	E47B  7A      		ld	a,d			; Test if block number = 0
1448:	E47C  B3      		or	e
1449:	E47D  2062    		jr	NZ,writs5		; No then write sector
1450:	E47F  E5      		push	hl			; Save pointer to block number
1451:	E480  79      		ld	a,c			; Test first block number in extent
1452:	E481  B7      		or	a
1453:	E482  2804    		jr	Z,writs1		; Yes then jump
1454:	E484  3D      		dec	a			; Decrement pointer to block number
1455:	E485  CDCCDE  		call	getdm4			; Get previous blocknumber
1456:	E488  CD44E0  	writs1:	call	getfre			; Get nearest free block
1457:	E48B  E1      		pop	hl			; Get pointer to block number
1458:	E48C  7A      		ld	a,d			; Test if blocknumber = 0
1459:	E48D  B3      		or	e
1460:	E48E  287C    		jr	Z,writs8		; Yes then disk full error
1461:	E490  DDCB0EBE		res	7,(ix+14)		; Reset FCB/file modified
1462:	E494  73      		ld	(hl),e			; Save blocknumber
1463:	E495  3AADD8  		ld	a,(maxlen+1)		; Get number of blocks
1464:	E498  B7      		or	a			; Test if <256
1465:	E499  2802    		jr	Z,writs2		; Yes then jump
1466:	E49B  23      		inc	hl			; Increment to MSB block number
1467:	E49C  72      		ld	(hl),d			; Save MSB block number
1468:	E49D  0E02    	writs2:	ld	c,2			; Set write new block flag
1469:	E49F  3AAAD8  		ld	a,(nmask)		; Get sector mask
1470:	E4A2  DDA620  		and	(ix+32)			; Mask with record counter
1471:	E4A5  2802    		jr	Z,writsx		; Zero then ok (at start new record)
1472:	E4A7  0E00    		ld	c,0			; Else clear new block flag
1473:	E4A9  3ABED8  	writsx:	ld	a,(funct)		; Get function number
1474:	E4AC  D628    		sub	40			; Test if write rr with zero fill
1475:	E4AE  2033    		jr	NZ,writs6		; No then jump
1476:	E4B0  D5      		push	de			; Save blocknumber
1477:	E4B1  2A9FD8  		ld	hl,(dirbuf)		; Use directory buffer for zero fill
1478:	E4B4  0680    		ld	b,128			; 128 bytes to clear
1479:	E4B6  77      	writs3:	ld	(hl),a			; Clear directory buffer
1480:	E4B7  23      		inc	hl			; Increment pointer
1481:	E4B8  10FC    		djnz	writs3			; Clear all bytes
1482:	E4BA  CDE3DE  		call	calsec			; Calculate sector number (128 bytes)
1483:	E4BD  3AAAD8  		ld	a,(nmask)		; Get sector mask
1484:	E4C0  47      		ld	b,a			; Copy it
1485:	E4C1  04      		inc	b			; Increment it to get number of writes
1486:	E4C2  2F      		cpl				; Complement sector mask
1487:	E4C3  A3      		and	e			; Mask sector number
1488:	E4C4  5F      		ld	e,a			; And save it
1489:	E4C5  0E02    		ld	c,2			; Set write new block flag
1490:	E4C7  E5      	writs4:	push	hl			; Save registers
1491:	E4C8  D5      		push	de
1492:	E4C9  C5      		push	bc
1493:	E4CA  CD80DE  		call	calst			; Calculate sector/track
1494:	E4CD  CDB4DF  		call	DMAdir			; Set DMA directory buffer
1495:	E4D0  C1      		pop	bc			; Get write new block flag
1496:	E4D1  C5      		push	bc			; Save it again
1497:	E4D2  CD87DF  		call	writer			; Write record on disk
1498:	E4D5  C1      		pop	bc			; Restore registers
1499:	E4D6  D1      		pop	de
1500:	E4D7  E1      		pop	hl
1501:	E4D8  0E00    		ld	c,0			; Clear write new block flag
1502:	E4DA  1C      		inc	e			; Increment sector number
1503:	E4DB  10EA    		djnz	writs4			; Write all blocks
1504:	E4DD  CDAEDF  		call	stDMA			; Set user DMA address
1505:	E4E0  D1      		pop	de			; Get block number
1506:	E4E1  0E00    	writs5:	ld	c,0			; Clear write new block flag
1507:	E4E3  DDCB0EBE	writs6:	res	7,(ix+14)		; Reset FCB/file modified flag
1508:	E4E7  C5      		push	bc			; Save it
1509:	E4E8  CDE3DE  		call	calsec			; Calculate sector number (128 bytes)
1510:	E4EB  CD80DE  		call	calst			; Calculate sector/track
1511:	E4EE  C1      		pop	bc			; Get write new block flag
1512:	E4EF  CD87DF  		call	writer			; Write record on disk
1513:	E4F2  DD7E20  		ld	a,(ix+32)		; Get record counter
1514:	E4F5  DDBE0F  		cp	(ix+15)			; Compare with next record
1515:	E4F8  3808    		jr	C,writs7		; If less then jump
1516:	E4FA  3C      		inc	a			; Increment record count
1517:	E4FB  DD770F  		ld	(ix+15),a		; Save it on next record position
1518:	E4FE  DDCB0EBE		res	7,(ix+14)		; Reset FCB/file modified flag
1519:	E502  3ABED8  	writs7:	ld	a,(funct)		; Get function number
1520:	E505  FE15    		cp	21			; Test write sequential
1521:	E507  C0      		ret	NZ			; Not then return
1522:	E508  DD3420  		inc	(ix+32)			; Increment record count
1523:	E50B  C9      		ret				; And return to caller
1524:	E50C  3E02    	writs8:	ld	a,2			; Set disk full error
1525:	E50E  32BFD8  		ld	(pexit),a
1526:	E511  C9      		ret				; And return to caller
1527:	E512  3E01    	writs9:	ld	a,1			; Set directory full flag
1528:	E514  32BFD8  		ld	(pexit),a
1529:	E517  C9      		ret				; And return to caller
1530:			;
1531:			; Load FCB for random read/write
1532:			;
1533:			;	Exit:	Z  no error
1534:			;		NZ error occured
1535:			;
1536:	E518  32C2D8  	ldFCB:	ld	(rdwr),a		; Save read/write flag
1537:	E51B  DD7E21  		ld	a,(ix+33)		; Get first byte random record
1538:	E51E  57      		ld	d,a			; Save it in d
1539:	E51F  CBBA    		res	7,d			; Reset MSB to get next record
1540:	E521  17      		rla				; Shift MSB in carry
1541:	E522  DD7E22  		ld	a,(ix+34)		; Load next byte random record
1542:	E525  17      		rla				; Shift carry
1543:	E526  F5      		push	af			; Save it
1544:	E527  E61F    		and	01fh			; Mask next extent
1545:	E529  4F      		ld	c,a			; Save it in c
1546:	E52A  F1      		pop	af			; Get byte
1547:	E52B  17      		rla				; Shift 4 times
1548:	E52C  17      		rla
1549:	E52D  17      		rla
1550:	E52E  17      		rla
1551:	E52F  E60F    		and	0fh			; Mask it
1552:	E531  47      		ld	b,a			; Save FCB+14
1553:	E532  DD7E23  		ld	a,(ix+35)		; Get next byte random record
1554:	E535  1E06    		ld	e,6			; Set random record to large flag
1555:	E537  FE04    		cp	4			; Test random record to large
1556:	E539  3061    		jr	NC,ldFCB8		; Yes then error
1557:	E53B  07      		rlca				; Shift 4 times
1558:	E53C  07      		rlca
1559:	E53D  07      		rlca
1560:	E53E  07      		rlca
1561:	E53F  80      		add	a,b			; Add byte
1562:	E540  47      		ld	b,a			; Save FCB+14 in b
1563:	E541  DD7220  		ld	(ix+32),d		; Set next record count
1564:	E544  DD560E  		ld	d,(ix+14)		; Get FCB+14
1565:	E547  CB72    		bit	6,d			; Test error random record
1566:	E549  200E    		jr	NZ,ldFCB0		; Yes then jump
1567:	E54B  79      		ld	a,c			; Get new extent number
1568:	E54C  DDBE0C  		cp	(ix+12)			; Compare with FCB
1569:	E54F  2008    		jr	NZ,ldFCB0		; Not equal then open next extent
1570:	E551  78      		ld	a,b			; Get new FCB+14
1571:	E552  DDAE0E  		xor	(ix+14)			; Compare with FCB+14
1572:	E555  E63F    		and	03fh			; Mask it
1573:	E557  283A    		jr	Z,ldFCB6		; Equal then return
1574:	E559  CB7A    	ldFCB0:	bit	7,d			; Test FCB modified (write)
1575:	E55B  200F    		jr	NZ,ldFCB1		; No then jump
1576:	E55D  D5      		push	de			; Save registers
1577:	E55E  C5      		push	bc
1578:	E55F  CD6EE2  		call	close			; Close extent
1579:	E562  C1      		pop	bc			; Restore registers
1580:	E563  D1      		pop	de
1581:	E564  1E03    		ld	e,3			; Set close error
1582:	E566  3ABFD8  		ld	a,(pexit)		; Get exit code
1583:	E569  3C      		inc	a
1584:	E56A  282C    		jr	Z,ldFCB7		; Error then exit
1585:	E56C  DD710C  	ldFCB1:	ld	(ix+12),c		; Save new extent number
1586:	E56F  DD700E  		ld	(ix+14),b		; Save new FCB+14
1587:			;	bit	7,d			; Test FCB modified (previous FCB)
1588:			;	jr	NZ,ldFCB3		; No then jump
1589:			;ldFCB2:
1590:			;	call	sear0			; File was opened for writing, so
1591:								; the close filled in FCB+13 for fast
1592:								; lookup, so do it
1593:			;	jr	ldFCB4			; Jump
1594:			
1595:	E572          	ldFCB3:
1596:	E572  CDAAE0  		call	findf			; Open file old way because may not
1597:								; have valid FCB+13 for fast lookup
1598:			
1599:	E575  3ABFD8  	ldFCB4:	ld	a,(pexit)		; Get error code
1600:	E578  3C      		inc	a
1601:	E579  2015    		jr	NZ,ldFCB5		; No error then exit
1602:	E57B  3AC2D8  		ld	a,(rdwr)		; Get read/write flag
1603:	E57E  1E04    		ld	e,4			; Set read empty record
1604:	E580  3C      		inc	a
1605:	E581  2015    		jr	NZ,ldFCB7		; Read then error
1606:	E583  CD01E3  		call	maker			; Make new FCB using fast lookup
1607:	E586  1E05    		ld	e,5			; Set make error
1608:	E588  3ABFD8  		ld	a,(pexit)		; Get error code
1609:	E58B  3C      		inc	a
1610:	E58C  280A    		jr	Z,ldFCB7		; Error then exit
1611:	E58E  1803    		jr	ldFCB6			; No error exit (zero set)
1612:	E590  CD34E2  	ldFCB5:	call	openf0			; Open file
1613:	E593          	ldFCB6:
1614:	E593  AF      		xor	a			; Set zero flag and clear error code
1615:	E594  32BFD8  		ld	(pexit),a
1616:	E597  C9      		ret				; And return to caller
1617:	E598  DD360EC0	ldFCB7:	ld	(ix+14),0c0h		; Set random record error
1618:	E59C  7B      	ldFCB8:	ld	a,e			; Get error code
1619:	E59D  32BFD8  		ld	(pexit),a		; And save it
1620:	E5A0  DDCB0EFE		set	7,(ix+14)		; Set FCB/file not modified
1621:	E5A4  B7      		or	a			; Clear zero flag
1622:	E5A5  C9      		ret				; And return to caller
1623:			;
1624:			; Calculate random record
1625:			;	Entry:	HL = offset in FCB
1626:			;		DE = FCB pointer
1627:			;	Exit:	D  = LSB random record
1628:			;		C  = ISB random record
1629:			;		B  = MSB random record
1630:			;
1631:	E5A6  19      	calrrc:	add	hl,de			; Pointer to FCB+15 or FCB+32
1632:	E5A7  7E      		ld	a,(hl)			; Get byte
1633:	E5A8  210C00  		ld	hl,12			; Offset to extent number
1634:	E5AB  19      		add	hl,de			; Get pointer to extent byte
1635:	E5AC  57      		ld	d,a			; Save first byte
1636:	E5AD  7E      		ld	a,(hl)			; Get extent byte
1637:	E5AE  E61F    		and	01fh			; Mask it
1638:	E5B0  CB12    		rl	d			; Shift MSB in carry
1639:	E5B2  CE00    		adc	a,0			; Add carry
1640:	E5B4  1F      		rra				; Shift 1 time (16 bits)
1641:	E5B5  CB1A    		rr	d
1642:	E5B7  4F      		ld	c,a			; Save isb
1643:	E5B8  23      		inc	hl			; Increment to FCB+14
1644:	E5B9  23      		inc	hl
1645:	E5BA  7E      		ld	a,(hl)			; Get FCB+14
1646:	E5BB  0F      		rrca				; Shift 4 times
1647:	E5BC  0F      		rrca
1648:	E5BD  0F      		rrca
1649:	E5BE  0F      		rrca
1650:	E5BF  F5      		push	af			; Save it
1651:	E5C0  E603    		and	03h			; Mask MSB
1652:	E5C2  47      		ld	b,a			; Save it
1653:	E5C3  F1      		pop	af			; Get LSB
1654:	E5C4  E6F0    		and	0f0h			; Mask it
1655:	E5C6  81      		add	a,c			; Add with isb
1656:	E5C7  4F      		ld	c,a			; Save isb
1657:	E5C8  D0      		ret	NC			; No carry then return
1658:	E5C9  04      		inc	b			; Increment MSB
1659:	E5CA  C9      		ret				; And return to caller
1660:			
1661:			; END Z80DDISK.Z80
**** z80dos24.z80 ****
  55:			
  56:			include z80dtime.z80	; Time routines, DOS exit routines,
**** z80dtime.z80 ****
   1:			;
   2:			; Z80DOS - Z80 Disk Operating System
   3:			;
   4:			; Version 2.4	Maskable disk reset's using variable fixdrv
   5:			;		Now can assemble with Z80MR if Z80MR equate
   6:			;		set to -1.
   7:			;		Gene Nolan 4/9/89
   8:			;
   9:			;
  10:			;------------------------------------------------------
  11:			;
  12:			; Version 2.3	Fast file lookup
  13:			; Date:		4 Nov 88
  14:			; Update:	Eugene Nolan
  15:			;
  16:			;--------------------------------------------------------------
  17:			;
  18:			; Version 2.0a - BETA TEST VERSION - 6 Nov 87 by Carson Wilson
  19:			;
  20:			; Support file:	Z80DTIME.Z80
  21:			; Version:	2.0
  22:			; Date:		6 Nov 87
  23:			; Author:	Carson Wilson
  24:			; Changes:	Added internal time routine for systems without a
  25:			;		real time clock.  This routine assembles if RTC is false.
  26:			;		Cleaned up and clarified code.
  27:			;
  28:			; Description:	Time Functions, Exit Routine, RAM Area
  29:			;
  30:			
  31:			; ---------------------------------------------------------------------
  32:			
  33:			; Time Routines
  34:			
  35:			; -------------------------
  36:			
  37:			;
  38:			; STime - Set file's time and date at DMA buffer.
  39:			;
  40:			;	Entry:	E = 2 - set creation date or get time stamp
  41:			;		E = 4 - Set last update time/date
  42:			;		E = 8 - Set last access time/date
  43:			;
  44:			;	Exit:	Z  if time stamps present
  45:			;		NZ if no time stamps
  46:			
  47:	E5CB  2A9FD8  	STime:	ld	hl,(dirbuf)		; get directory entry
  48:	E5CE  016000  		ld	bc,060h			; offset entry point time/date stamp
  49:	E5D1  09      		add	hl,bc			; add offset to time stamp
  50:	E5D2  7E      		ld	a,(hl)			; get time stamp byte
  51:	E5D3  D621    		sub	021h			; time stamp present?
  52:	E5D5  C0      		ret	NZ			; no, return
  53:	E5D6  57      		ld	d,a			; yes, clear d
  54:	E5D7  19      		add	hl,de			; add entry (update/create/access)
  55:	E5D8  7B      		ld	a,e			; set access time if E ge 8 <crw>
  56:	E5D9  E608    		and	8			;
  57:	E5DB  2802    		jr	Z,STim1			; E lt 8
  58:	E5DD  CB3B    		srl	e			; E ge 8, set to 4
  59:	E5DF  43      	STim1:	ld	b,e			; save # bytes to write
  60:	E5E0  3ACBD8  		ld	a,(secpnt)		; get sector pointer
  61:	E5E3  0F      		rrca				; shift 2 times
  62:	E5E4  0F      		rrca
  63:	E5E5  5F      		ld	e,a			; save it
  64:	E5E6  0F      		rrca				; shift 2 times
  65:	E5E7  0F      		rrca
  66:	E5E8  83      		add	a,e			; add it (a=0,10,20)
  67:	E5E9  5F      		ld	e,a			; save in e
  68:	E5EA  19      		add	hl,de			; add offset
  69:	E5EB  3ABED8  		ld	a,(funct)
  70:	E5EE  FE36    		cp	54			; if set DOS time
  71:	E5F0  C8      		ret	Z			; ..just point to date stamp
  72:	E5F1  E5      		push	hl			; save result
  73:	E5F2  0E00    		ld	c,0			; time return date/time pointer in hl
  74:	E5F4  C5      		push	bc			; save 2 or 4 byte count <crw>
  75:	E5F5  CD1DE6  		call	time			; return pointer in hl
  76:	E5F8  C1      		pop	bc
  77:	E5F9  D1      		pop	de			; get pointer
  78:	E5FA  48      		ld	c,b			; set write 2 or 4 bytes <crw>
  79:	E5FB  0600    		ld	b,0
  80:	E5FD  EDB0    		ldir				; copy 2 or 4 bytes to directory buff.
  81:	E5FF  AF      		xor	a			; set zero flag - time stamps present
  82:	E600  C9      		ret				; and return to caller
  83:			
  84:			;
  85:			; GetStp - Store time stamp following file find, open, or make.
  86:			;
  87:			;	Exit:	HL points to file's 10-byte time stamp stored in DOS.
  88:			;		This buffer is used by subsequent disk commands if
  89:			;		DOS-time (dtime) has been activated by command 55.
  90:			;
  91:	E601          	GetStp:
  92:	E601  1E02    		ld	e,2			; Point to file's stamp
  93:	E603  CDCBE5  		call	STime			; Point to beginning of
  94:								; ..last file's stamp
  95:	E606  11D5D8  		ld	de,cdate		; Point to DOS stamp buffer
  96:	E609  ED53BFD8		ld	(pexit),de		; Save for return in HL
  97:	E60D  010A00  		ld	bc,10
  98:	E610  2003    		jr	NZ,GtStp1		; STime said no stamp found
  99:	E612  EDB0    		ldir				; Save full stamp
 100:	E614  C9      		ret				; Back to calling program
 101:	E615          	GtStp1:
 102:	E615  41      		ld	b,c			; No stamp found
 103:	E616          	GtStp2:
 104:	E616  3E00    		ld	a,0			; ..so zero out DOS buffer
 105:	E618  12      		ld	(de),a
 106:	E619  13      		inc	de
 107:	E61A  10FA    		djnz	GtStp2
 108:	E61C  C9      		ret				; Return to calling program
 109:			
 110:			; ------------------------------------------------------------------
 111:			
 112:			; Time - get time for stamping from DOS storage or get real time
 113:			
 114:			;
 115:			; Entry:	DTime = 0	Get real time
 116:			;		DTime <> 0	Get time from DOS buffer and reset DTime.
 117:			;
 118:			; Format of time returned to pointer in HL:
 119:			;
 120:			;	HL + 0 = low  byte of date since Dec. 31, 1977
 121:			;	HL + 1 = high byte of date since Dec. 31, 1977
 122:			;	HL + 2 = hours	 (BCD)
 123:			;	HL + 3 = minutes (BCD)
 124:			;	HL + 4 = seconds (BCD) (not used in time stamp)
 125:			;
 126:			
 127:	E61D          	time:
 128:	E61D  3AD4D8  		ld	a,(dtime)		; Get time from buffer?
 129:	E620  B7      		or	a
 130:	E621  2822    		jr	Z,btime			; No, get real time
 131:			
 132:	E623  3ABED8  		ld	a,(funct)		; Yes, check function
 133:	E626  FE16    		cp	22			; Creating file?
 134:	E628  21D5D8  		ld	hl,cdate		; If so, point to
 135:	E62B  2803    		jr	Z,time2			; ..stored create date
 136:	E62D  21D7D8  		ld	hl,udate		; No, point to update date/time
 137:	E630          	time2:
 138:	E630  AF      		xor	a
 139:	E631  32D4D8  		ld	(dtime),a		; Use buffer for this call only
 140:	E634  C9      		ret
 141:			
 142:			; -------------------------------------------------------------------
 143:			
 144:			; GetTim and SetTim - Get or Set Time using memory or Real Time Clock
 145:			
 146:			; -------------------------------------------------------------------
 147:			
 148:			;
 149:			; Get time to address DE
 150:			;
 151:	E635          	gettim:
 152:	E635  D5      		push	de			; Save address to put time
 153:	E636  0E00    		ld	c,0			; Get time address
 154:	E638  CD45E6  		call	btime			; Execute p2bios call
 155:	E63B  D1      		pop	de			; Restore address to put time
 156:	E63C  010500  		ld	bc,5			; 5 bytes to move
 157:	E63F  EDB0    		ldir				; Store the time
 158:	E641  C9      		ret				; Return to caller (or DOS)
 159:			;
 160:			; Set time from address DE
 161:			;
 162:	E642  EB      	settim:	ex	de,hl			; get address time in hl
 163:	E643  0EFF    		ld	c,0ffh			; set time from address
 164:			
 165:			;	fall	thru
 166:			
 167:			;
 168:			; Real Time Clock (RTC) or memory "clock" interface:
 169:			;
 170:			;	Entry:	C =  0: Load 5-byte buffer at HL with time
 171:			;		C <> 0: 5-byte entry pointed to by HL sets system time
 172:			
 173:	FFFF          		if	RTC			; Real time clock available
 174:	E645          	btime:
 175:	E645  E5      		push	hl			; Save value in HL
 176:	E646  2A91D8  		ld	hl,(timead)		; Get address time routine
 177:	E649  E3      		ex	(sp),hl			; Put address on stack and restore hl
 178:	E64A  C9      		ret				; Execute BIOS time routine
 179:			
 180:				 else				; Use memory "clock"
 192:				 endif	; RTC
 193:			
 194:			; ---------------------------------------------------------
 195:			;
 196:			; UseStp - Use stored time stamp for very next DOS call.
 197:			; 	   All other DOS calls cancel DOS time thru p2exit.
 198:			;
 199:	E64B          	UseStp:
 200:	E64B  F6FF    		or	0ffh
 201:	E64D  32D4D8  		ld	(dtime),a		; Use DOS time
 202:	E650  E1      		pop	hl			; clean up stack
 203:	E651  1819    		jr	p2ext0
 204:			
 205:			; -------------------------------------------------------------------------
 206:			
 207:			; DOS exit routines
 208:			
 209:			; -------------------
 210:			
 211:			
 212:	E653  AF      	p2exit:	xor	a
 213:	E654  32D4D8  		ld	(dtime),a		; Turn off DOS time <crw>
 214:	E657  32D3D8  		ld	(retflg),a		; Turn off retries
 215:	E65A  3AC1D8  		ld	a,(fldrv)		; Test drive select used flag
 216:	E65D  B7      		or	a
 217:	E65E  280C    		jr	Z,p2ext0		; No then exit
 218:	E660  3AC3D8  		ld	a,(FCB0)		; Get FCB byte 0
 219:	E663  DD7700  		ld	(ix+0),a		; Save it
 220:	E666  3AC5D8  		ld	a,(drive)		; Get old drive number
 221:	E669  CDA6DD  		call	seldk			; Select disk
 222:	E66C  DDE5    	p2ext0:	push	ix			; Save IX
 223:	E66E  D1      		pop	de			; Restore DE
 224:	E66F  DDE1    		pop	ix			; Restore IX
 225:	E671  ED7BDFD8		ld	sp,(spsave)		; Get old sp
 226:	E675  2ABFD8  		ld	hl,(pexit)		; Get exit code
 227:	E678  3ABED8  		ld	a,(funct)		; Get function code
 228:	E67B  4F      		ld	c,a			; Restore C
 229:	E67C  7D      		ld	a,l			; Copy function code
 230:	E67D  44      		ld	b,h
 231:	E67E  C9      		ret				; And return to caller
 232:	0000          		if	($-dos) gt 3584
 234:				endif
 235:			
 236:			; END Z80DTIME.Z80
 237:			
**** z80dos24.z80 ****
  57:				ENDIF				; ..RAM area
  58:			
  59:			; END Z80DOS.Z80
**** z80dos24.z80 ****



Statistics:

   393	symbols
  3513	bytes



Symbol Table:

adate           d8db+    error3          dc19     rdbufg          db71+    
again           dada     error4          dc24     rdbufh          db82     
alv             d8a5     error5          dc34     rdbufi          db86     
base           =d080     exit            d9c2     rdcon           d9b7     
bdos           =d886+    false          =   0     rddir           df2a     
bdosb          =d880+    fcb0            d8c3     rddir0          df3e     
bias           =9c80     fcontp          d898     rdonly          dba3     
bios           =e680     ff             =   c+    rdran           e3d4+    
biostim        =e6a1     filcnt          d8c9     rdrdr           d9c9     
boot           =e680+    filenm          dc52     rdwr            d8c2     
botdsk         =e6b6     fillb0          dfe9     readdr          df93     
btime           e645     fillb1          dff6     reader         =e695     
bwrcon          d9c6     fillb2          e007     readr           df82     
caldir          defb     fillbb          dfe4     reads           e3de     
calnex          e3ab     filro           db97     reads0          e3ee     
calnx0          e3c6     filsz           e1e2     reads1          e3f4     
calnx1          e3ca     filsz0          e1ec     reads2          e401     
calrrc          e5a6     findf           e0aa     recdir          d8c7     
calsc0          deea     findfn          e0a6     renam           e188     
calsc1          def2+    fixdrvs         d893     renam0          e18e     
calsec          dee3     flags           d895     renam1          e1a2     
calst           de80     fldrv           d8c1     renam2          e1b1     
calst0          de86     funct           d8be     resdsk         =   0+    
calst1          de8e     gcons0          da8a     resroom        = 380     
calst2          de9b     gcons1          da96     retflg          d8d3     
ccp            =d080     gcons2          daa7     rtc            =ffff     
cdate           d8d5     gcons3          daaf     rubout         =  7f     
chgerr          db8d     gconst          da7d     rwerr           db9e     
chkdir          df52     getbit          dfbb     sdrvb           de59     
chkdr0          df67     getbt0          dfd2     sdrvb0          de63     
chkdr1          df80     getch           da72     sdrvb1          de67     
chkfr2          e033     getdm           deb2     sear0           e07a     
chkfro          e01f     getdm0          deb9     sear01          e07c     
chkro           e037     getdm1          debd+    sear1           e0b5     
close           e26e     getdm2          dec8     searc1          e0de     
close0          e293     getdm3          decb+    searc2          e0ec     
close1          e2a6     getdm4          decc     searc3          e11e     
close2          e2ba+    getdm5          dedd     searc4          e12b     
close3          e2bb     getfr0          e046     searc5          e12d     
close4          e2d9     getfr1          e055     searc6          e133     
cmd15           e214     getfr2          e06d     searc7          e139     
cmd151          e222     getfr3          e072     searc8          e146     
cmd17a          dcdb     getfre          e044     searc9          e14f     
cmd17b          dcdd     getstp          e601     search          e0ac     
cmd17c          dce0     gettim          e635     searcn          e0be     
cmd19a          dcff     gfixed          d9b1     searex          d8cf     
cmd24a          dd0f     giost           d9f0     searnb          d8d0     
cmd25a          dd16     gtstp1          e615     searpu          d8d2     
cmnd12          dc8a     gtstp2          e616     searqu          d8d1     
cmnd13          dc93     home           =e698     secpnt          d8cb     
cmnd14          dda5     initd0          de00     sectrn         =e6b0     
cmnd15          e226     initd1          de0c     seldk           dda6     
cmnd16          e26b     initd2          de29     seldk0          ddb0     
cmnd17          dcc6     initd3          de4f     seldk1          ddb6     
cmnd18          dced     initdr          ddfa     seldk2          ddbf     
cmnd19          dcf9     intron         =   0+    seldk3          ddf6     
cmnd20          e3db     ixp             d8a1     seldr0          dd94     
cmnd21          e426     lastch          d899     seldrv          dd76     
cmnd22          e317     ldfcb           e518     seldsk         =e69b     
cmnd23          dd04     ldfcb0          e559     selerr          db92     
cmnd24          dd0c     ldfcb1          e56c     setbit          dfd7     
cmnd25          dd13     ldfcb3          e572+    setbt0          dfdf     
cmnd26          dfaa     ldfcb4          e575+    setdma         =e6a4     
cmnd27          dd19     ldfcb5          e590     setfct          df06     
cmnd28          e00a     ldfcb6          e593     setfn           e013     
cmnd29          dd1e     ldfcb7          e598     setlf           df14     
cmnd30          dd23     ldfcb8          e59c     setsec         =e6a1     
cmnd31          dd2b     ldrrc           dd4c     settim          e642     
cmnd32          dd30     lf             =   a     settrk         =e69e     
cmnd33          e3d1     listst         =e6ad+    sfilro          d88f     
cmnd34          e41b     login           d8b8     siost           d9f5     
cmnd35          dd3e     lowcmd          d954     spsave          d8df     
cmnd36          dd46     mak0            e30c     sr1             e0af     
cmnd37          dd56     mak1            e327     start           d886+    
cmnd40          e41b     make            e31e+    stdir           de6e     
conin          =e689     make0           e339     stdma           dfae     
conout         =e68c     maker           e301     stim1           e5df     
const          =e686     maxcmd         =  28     stime           e5cb     
contc          =   3     maxlen          d8ac     stro            d88d     
conth          =   8     maxsec          d8a7     strw            d889     
contp          =  10     mberr           dc75     stsel           d88b     
conts          =  13     mbfunc          dc7e     subflg          d8cc     
contx          =  18     mchg            dc60     tab            =   9     
copyd0          e2e7     mdrive          dc7b     tabcnt          d896     
copyd1          e2f5     mess            dace     tabcx1          d897     
copyd2          e2fc     mfile           dc84     temp0           d89d     
copydm          e2df     mfilro          dc6c     time            e61d     
count0          da5f     mro             dc6f     time2           e630     
count1          da66     mrwerr          dc72     timead          d891     
countc          da51     msel            dc66     trans           d89b     
cr             =   d     msize          =  3c     true           =ffff     
crout           da13     nblock          d8a9     tstch           dab2     
cstat           e1bb     ncheck          d8b2     tstcs           d9fa     
cstat0          e1c1     ndir0           d8b0     tstfct          df0d     
cstat1          e1cd     ndir1           d8b1+    tstlf           df1d     
csv             d8a3     nextnd          d8ab     udate           d8d7     
ctable          d95f     nfiles          d8ae     user            d8c4     
dcio            d9d6     nftrk           d8b4     usestp          e64b     
dcio0           d9e5     nmask           d8aa     vers           =  16+    
dcopy           d8cd     noz80mr        =   0     wboot          =e683     
defdrv          d8c6     num             dc3b     wcont0          dac9     
del0            e16f     num1            dc3d     wconth          dac1     
delay           d89a     num2            dc50     wlist           d9d2     
delch           dae9     openex          e369     wpunch          d9ce     
delch0          daf5     openf           e22d+    wrcon           da1a     
delch1          db06     openf0          e234     wrcon0          da1e     
delch2          db0c     openf1          e264     wrcon1          da2d     
delch3          db14     openx0          e37e     wrcon2          da50     
delch4          db20     openx1          e381+    wrfcb           e20e     
delete          e169     openx2          e396     writdr          df9b     
derror          dba6     openx3          e39b     write          =e6aa     
diff            d8ba     openx4          e3a1     write0          df8a     
dirbuf          d89f     openx5          e3a5     writer          df87     
dlist          =e68f     openx6          e3a8     writes          e429     
dma             d8bc     options        =   3     writs0          e478     
dmadir          dfb4     outch           d9ff     writs1          e488     
dmadr0          dfb8     p2exit          e653     writs2          e49d     
doback          db3e     p2ext0          e66c     writs3          e4b6     
dos            =d880     pexit           d8bf     writs4          e4c7     
dosstk         =d91d     punch          =e692     writs5          e4e1     
dosstop        =d91d+    ramlow         =   0     writs6          e4e3     
dread          =e6a7     rdbuf           db23     writs7          e502     
drive           d8c5     rdbuf0          db29+    writs8          e50c     
drvsep         =  3a     rdbuf1          db31     writs9          e512     
dskro           d8b6     rdbuf2          db33+    writsa          e463     
dtime           d8d4     rdbuf3          db3a+    writsx          e4a9     
dummy           d9c5     rdbuf4          db49     wrran           e41e+    
entry           d91d     rdbufc          db54     z80mr          =ffff     
error           dba7     rdbufd          db58     
error1          dbf4     rdbufe          db64     
error2          dc01     rdbuff          db6a     
