ZAS Relocating Macro Assembler (v3.05                             page    1
                                                            
                                                            

  0000           ;  PROGRAM:     Z33FCP
  0000           ;  AUTHOR:      Jay Sage
  0000           ;  VERSION:     1.0
  0000           ;  DATE:        May 25, 1987
  0000           ;  DERIVATION:  FCP10 by Jay Sage (ZSIG)
  0000           
  0000           ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000           ; distribution and duplication permitted for non-commercial purposes only.
  0000           ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000           ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000           ; conjunction with any hardware or software product, is expressly prohibited
  0000           ; unless authorized in writing by Echelon.
  0000           
  0000           ;=============================================================================
  0000           ;
  0000           ;                       R E V I S I O N    H I S T O R Y
  0000           ;
  0000           ;=============================================================================
  0000           
  0000           ;  05/25/87     Created ZCPR33 version from the code I released through ZSIG.
  0000           ;    1.0        This code differs only in the more efficient way in which it
  0000           ;               determines if it was invoked with a directory prefix that
  0000           ;               signals that the transient IF.COM should be used to process
  0000           ;               the IF command.  This permits the user to force the use of a
  0000           ;               more powerful option processor in the transient IF.COM than in
  0000           ;               the resident code.  Option bytes were added after the end of
  0000           ;               the resident option dispatch table so that SHOW can report
  0000           ;               configuration options to the user.
  0000           ;
  0000           ;  FCP10 notes
  0000           ;
  0000           ;               The transient processor can now be loaded at an address other
  0000           ;               than 100h so as not to interfere with code loaded in the TPA.
  0000           ;               Then the GO command can normally be used even after IF.COM is
  0000           ;               used to process the flow test.  If the LOADCHK equate
  0000           ;               is true then the FCP will verify that the transient
  0000           ;               processor has been loaded to the page in memory for which
  0000           ;               it was assembled.  If loaded to the wrong page, it will
  0000           ;               be reloaded to the correct one.
  0000           ;
  0000           ;               The test for the form ARG1=ARG2 was tightened up so as not to
  0000           ;               be confused by an equal sign in some later part of the command
  0000           ;               tail (e.g., "IF REG 1 = 2").  Now only the first token
  0000           ;               (contiguous string of characters) is checked.  This extra code
  0000           ;               is under the control of the XEQOPT equate.  The only option
  0000           ;               that is still a problem is the COMIF form '~='.  Since the '='
  0000           ;               is in the first token, this 'not equal' condition cannot be
  0000           ;               distinguished from an equality test against the character '~'.
  0000           ;               The solution is to turn off equality testing in the resident FCP
  0000           ;               or to use the alternative COMIF options 'NE' or '~EQ' for this
  0000           ;               test.
  0000           ;
  0000           ;               Added optional commands AND and OR.  These work like IF except
  0000           ;               that they affect the current IF level rather than going one
  0000           ;               level deeper.
  0000           ;
ZAS Relocating Macro Assembler (v3.05                             page    2
                                                            
                                                            

  0000           ;               Added optional command ZIF to zero out all IF states no matter
  0000           ;               whether current state is true or false (XIF only works if state
  0000           ;               is true.
  0000           ;
  0000           ;               Added new optional command IFQ (if-query) and enhanced the
  0000           ;               IFSTAT code that is invoked when the NOISE equate is true.
  0000           ;               In both cases, the entire tree of IF states is now shown,
  0000           ;               starting with the current level.  For example, IFQ might result
  0000           ;               in the display "IF FTT" (we are at third IF level and it is
  0000           ;               false; the second and first IF levels are true).  If the
  0000           ;               current IF level is 0, then the display is "IF None".
  0000           ;
  0000           ;               Added two new resident options: AMBIGUOUS (AM) returns true if
  0000           ;               the file specification in the second token has a '?' (or '*')
  0000           ;               in it; COMPRESSED (CO) returns true if the file specificaton in
  0000           ;               the second token has a 'Z' or a 'Q' in the second character of
  0000           ;               the file type.
  0000           ;
  0000           ;               Howard Goldstein contributed significantly to the development
  0000           ;               of this code.  Bridger Mitchell also offered helpful
  0000           ;               suggestions.
  0000           ;
  0000           ;                                       Jay Sage
  0000           ;
  0000           ;  Notes from earlier SYSFCP revisions
  0000           ;
  0000           ;  09/12/85     Fixed bug in my code used when IF.COM is found in a specified
  0000           ;               drive/user area.  The values of CDISK and CUSER were not being
  0000           ;               set, and as a result the user was not returned to the correct
  0000           ;               directory.  The EXIST and EMPTY tests did not work correctly
  0000           ;               unless a DIR: or DU: was given explicitly with each file name.
  0000           ;                                       Jay Sage
  0000           
  0000           ;  08/29/85     Reorganized code so that COMIF code handles only those
  0000           ;               options not in the table of local IF functions.  Also changed
  0000           ;               code to allow searching for IF.COM in a specified directory
  0000           ;               instead of using the ROOT of the path.  Also renamed macros
  0000           ;               to make code ZAS compatible.
  0000           ;                                       Jay Sage
  0000           
  0000           ;  07/21/85     Corrected reversed sensing of program error flag in the
  0000           ;               IF ERROR test.
  0000           ;                                       Jay Sage
  0000           
  0000           ;  01/02/85     Revised to correct a bug in the IF EMPTY test.  First, the
  0000           ;               current record byte was not being set to zero before trying
  0000           ;               to read from the file.  Secondly, the test for error was not
  0000           ;               testing for FF but for 00.  My BDOS does not return 0 for
  0000           ;               success.  It seems to return 00, 01, 02, or 03.  This made the
  0000           ;               file appear to be empty.
  0000           ;                                       Jay Sage
  0000           
  0000           ;=============================================================================
  0000           ;
  0000           ;               M A C R O S    A N D    E Q U A T E S
  0000           ;
ZAS Relocating Macro Assembler (v3.05                             page    3
                                                            
                                                            

  0000           ;=============================================================================
  0000           
  0000           ; External macro references
  0000+                  maclib  common.asm
  0000+          ;
  0000+          ; Here just some common symbol...
  0000+          ;
  0000+          
  0016+=         VERS    EQU     22              ; VERSION 2.2 (CP/M related)
  0000+          ;
  0000+          ; MSIZE EQU     63              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  003C+=         MSIZE   EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0000+          ; MSIZE EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  0400+=         RESROOM EQU     1024            ; RESERVED ROOM SPACE BELOW MONITOR (FC00)
  0600+=         BIOSTDS EQU     1536            ; BIOS STANDARD SIZE
  0A00+=         BIOREAS EQU     BIOSTDS+RESROOM ; BIOS REAL SIZE
  0400+=         ZSTDOVR EQU     1024            ; ZCPR STANDARD OVERHEAD SIZE
  0000+=         ZIOPKG  EQU     0               ; ZCPR IO PACKAGE SIZE
  0800+=         ZRESPKG EQU     2048            ; ZCPR RESIDENT CMD PKG SIZE
  0200+=         ZFLOPKG EQU     512             ; ZCPR FLOW CMD PACKAGE SIZE
  01C8+=         ZDSSTSZ EQU     01C8H           ; ZDS Stamper reserved space
  0000+          
  1200+=         EXTRABIAS       EQU     RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG  ; ...
  0000+                  ;
  0000+                  ;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  0000+                  ;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  0000+                  ;
  8E00+=         BIAS    EQU     ((MSIZE-20)*1024)-EXTRABIAS
  C200+=         CCP     EQU     3400H+BIAS      ; BASE OF CCP
  CA06+=         BDOS    EQU     CCP+0806H       ; BASE OF BDOS
  CA00+=         BDOSB   EQU     CCP+0800H       ; BDOS base offset
  D800+=         BIOS    EQU     CCP+1600H       ; BASE OF BIOS
  E200+=         ZBUFBAS EQU     BIOS+BIOREAS    ; BASE OF ZCPR3 BUFFERS
  0000+                  ;
  0000+                  ;       some other equs...
  0000+                  ;
  000D+=         CR      EQU     0DH             ; CARRIAGE RETURN
  000A+=         LF      EQU     0AH             ; LINE FEED;
  000C+=         FF      EQU     0CH             ; FORM FEED (clear screen)
  FFFF+=         TRUE    EQU     -1
  0000+=         FALSE   EQU     0
  0000+          
  0000+=         INTRON  EQU     FALSE           ; Interrupts disabled
  0000+                  ;
  0000+                  ; define which kind of date stamper must be embedded in
  0000+                  ; RCP
  0000+                  ;
  FFFF+=         STMPP2  EQU     TRUE            ; P2DOS date stamper
  0000+=         STMPZS  EQU     FALSE           ; ZSDOS date stamper
  FFFF+=         HASEDS  EQU     (STMPP2+STMPZS) ; set a flag for embedded date stamper
  0000+                  ;
  0000+                  ; path for ZCPR3 used on cold boot
  0000+                  ;
  0024+=         IDISK1  EQU     '$'             ; 1st: current disk, current user
  0024+=         IUSER1  EQU     '$'
  0024+=         IDISK2  EQU     '$'             ; 2nd: current disk, user 15
ZAS Relocating Macro Assembler (v3.05                             page    4
                                                            
                                                            

  000F+=         IUSER2  EQU     15
  0001+=         IDISK3  EQU     'A'-'@'         ; 3rd: disk A, current user
  0024+=         IUSER3  EQU     '$'
  0001+=         IDISK4  EQU     'A'-'@'         ; 4th: disk A, user 15
  000F+=         IUSER4  EQU     15
  0000+          
  0000+          ; COMMON.ASM [EOF]
  0000+                  maclib  z3base.lib      ; Source of system addresses
  0000+          ; Z3BASE - Dynamic Configuration
  0000+          ;
  0000+          ; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
  0000+          ; distribution and duplication permitted for non-commercial purposes only.
  0000+          ; Any commercial use of ZCPR33, defined as any situation where the duplicator
  0000+          ; recieves revenue by duplicating or distributing ZCPR33 by itself or in
  0000+          ; conjunction with any hardware or software product, is expressly prohibited
  0000+          ; unless authorized in writing by Echelon.
  0000+          ;
  0000+          ; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  0000+          ; for Z-Com.  All segment addresses are automatically derived when the
  0000+          ; CCP equate is set.  The benefit of this is that reconfiguration of the
  0000+          ; system after initial installation is greatly eased.
  0000+          ;
  0000+          ; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  0000+          ; previous version of Z3BASE can be used to assemble the Z33 Command
  0000+          ; Processor.  No new symbols are needed.  So, if you have an existing
  0000+          ; Z3BASE, go ahead and use it.
  0000+          ;
  0000+          ; Instructions:
  0000+          ;
  0000+          ; The user should first design the ZCPR3 memory usage using the chart
  0000+          ; below.  (Echelon recommends the chart be filled out, even though it is
  0000+          ; not read by the assembler, so that your system will be self-documenting.)
  0000+          ; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  0000+          ; and change the SEGn equates which follow in the file to ensure that the
  0000+          ; system segments and buffers are placed at the proper addresses.
  0000+          ;
  0000+          ; This file has been customized for use with AMPRO hard disk systems.  The
  0000+          ; target configuration has support for hard disks up to 49 Meg, extended
  0000+          ; IOP support, and 28-entry NDR.
  0000+          ;
  0000+          ;****************************************************************
  0000+          ;*                                                              *
  0000+          ;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System          *
  0000+          ;*                                                              *
  0000+          ;*      Segments:                                               *
  0000+          ;*                                                              *
  0000+          ;*      Segment         Function                                *
  0000+          ;*      -------         --------                                *
  0000+          ;*      ZSDOS           ZSDOS 1.1                               *
  0000+          ;*      CBIOSZ          ZDS BIOS with additional                *
  0000+          ;*                      ZCPR3 initialization routines           *
  0000+          ;*      ZCPR3           Echelon Z80 Command Processor           *
  0000+          ;*                      Replacement, Version 3.3 (ZCPR3)        *
  0000+          ;*      *.ENV           All Environment Descriptors             *
  0000+          ;*      *.FCP           All Flow Command Packages               *
  0000+          ;*      *.NDR           All Named Directory Definition Files    *
ZAS Relocating Macro Assembler (v3.05                             page    5
                                                            
                                                            

  0000+          ;*      *.RCP           All Resident Command Packages           *
  0000+          ;*      *.IOP           All Input/Output Packages               *
  0000+          ;*                                                              *
  0000+          ;*                                                              *
  0000+          ;* Memory Map of System (for CCP EQU 0BC00H):                   *
  0000+          ;*                                                              *
  0000+          ;*      Address Range     Size  Function                        *
  0000+          ;*      -------------   ------- --------                        *
  0000+          ;*          0 -   FF    256 b   Standard CP/M Buffers except    *
  0000+          ;*        100 - C2FF    ~48 K   Transient Program Area          *
  0000+          ;*       C200 - C9FF      2 K   ZCPR 3.3 Command Processor      *
  0000+          ;*       CA00 - D7FF    3.5 K   ZSDOS                           *
  0000+          ;*       D800 - E1FF    2.5 K   BIOS with disk buffers          *
  0000+          ;*       E200 - E9FF      2 K   Resident Command Package        *
  0000+          ;*       0000 - 0000    1.5 K   Input/Output Package            *
  0000+          ;*       EA00 - EBFF     .5 K   Flow Command Package            *
  0000+          ;*       EC00 - ECFF    256 b   Environment Descriptor          *
  0000+          ;*                              Bytes 00H-7FH:  Z3 Parameters   *
  0000+          ;*                              Bytes 80H-FFH:  Z3 TCAP         *
  0000+          ;*       ED00 - ED7F    128 b   ZCPR3 Shell Stack               *
  0000+          ;*       ED80 - EDCF     80 b   ZCPR3 Message Buffers           *
  0000+          ;*       EDD0 - EDF3     36 b   ZCPR3 External FCB              *
  0000+          ;*       EDF4 - EDFE     11 b   ZCPR3 External Path             *
  0000+          ;*       EDFF             1 b   Wheel Byte                      *
  0000+          ;*       EE00 - EEFF    256 B   Memory-Based Named Directory    *
  0000+          ;*       EF00 - EFCF    208 B   Multiple Command Line Buffer    *
  0000+          ;*       EFD0 - EFFF     48 b   ZCPR3 External Stack            *
  0000+          ;****************************************************************
  0000+          
  0000+          ; include       macro   filename
  0000+          ;
  0000+          ;        if     zas
  0000+          ;       .in             filename
  0000+          ;        else   ;slr assembler
  0000+          ;       include filename
  0000+          ;        endif  ;zas
  0000+          ;
  0000+          ;        endm
  0000+          
  0000+          ; FALSE equ     0
  0000+          ; TRUE  equ     NOT FALSE
  0000+          
  0021+=         Z3REV   EQU     33      ; ZCPR3 REV NUMBER
  0000+          ; MSIZE EQU     54      ; SIZE OF CPM SYSTEM
  0000+          
  0000+=         BASE    EQU     0
  0000+          
  0000+          ; CCP   EQU     0BC00H  ; ZCPR3 COMMAND PROCESSOR
  0000+          
  E200+=         SEG1    EQU     ZBUFBAS ; where the things starts
  0000+          
  0000+          ;
  0000+          ; RCP definition.  Set RCPS to 0 to eliminate RCP
  0000+          ;
  0000+          
  0010+=         RCPS    EQU     16              ; 16 128-byte Blocks (2K bytes)
ZAS Relocating Macro Assembler (v3.05                             page    6
                                                            
                                                            

  0000+          
  0000+                   IF     RCPS NE 0
  E200+=         RCP     EQU     SEG1            ; RESIDENT COMMAND PACKAGE
  0000+                   ELSE
  0000+          RCP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG2    EQU     SEG1+(RCPS*128)
  0000+          
  0000+          ;
  0000+          ; IOP definition.  Set IOPS to 0 to eliminate IOP
  0000+          ;
  0000+          ; IOPS  EQU     12              ; 12 128-byte Blocks (1.5K bytes)
  0000+=         IOPS    EQU     0               ; 12 128-byte Blocks (1.5K bytes)
  0000+          
  0000+                   IF     IOPS NE 0
  0000+          IOP     EQU     SEG2            ; REDIRECTABLE I/O PACKAGE
  0000+                   ELSE
  0000+=         IOP     EQU     0
  0000+                   ENDIF
  0000+          
  EA00+=         SEG3    EQU     SEG2+(IOPS*128)
  0000+          
  0000+          ;
  0000+          ; FCP definition.  Set FCPS to 0 to eliminate FCP
  0000+          ;
  0000+          
  0004+=         FCPS    EQU     4       ; 4 128-byte Blocks (0.5K bytes)
  0000+          
  0000+                   IF     FCPS NE 0
  EA00+=         FCP     EQU     SEG3
  0000+                   ELSE
  0000+          FCP     EQU     0
  0000+                   ENDIF
  0000+          
  E838+=         ZDSSTPR EQU     (FCP-ZDSSTSZ)   ; Z80 Darkstar P2DOS Stamper
  0000+          
  EC00+=         SEG10   EQU     SEG3+(FCPS*128)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
  0000+          ; Echelon recommends you work this out so that your ENV begins at address
  0000+          ; FE00h, but this is only a recommendation and not mandatory.
  0000+          ;
  0000+          
  EC00+=         Z3ENV   EQU     SEG10   ; ENVIRONMENT DESCRIPTORS
  0002+=         Z3ENVS  EQU     2       ; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
  0000+          
  ED00+=         SEG4    EQU     SEG10+(Z3ENVS*128)
  0000+          
  0000+          ;
  0000+          ; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
  0000+          ;
  0000+          
  0004+=         SHSTKS  EQU     4       ; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
  0020+=         SHSIZE  EQU     32      ; SIZE OF A SHELL STACK ENTRY
ZAS Relocating Macro Assembler (v3.05                             page    7
                                                            
                                                            

  0000+                                  ;   (STACK SIZE = SHSTKS * SHSIZE)
  0000+                   IF SHSTKS NE 0
  ED00+=         SHSTK   EQU     SEG4
  0000+                   ELSE
  0000+          SHSTK   EQU     0
  0000+                   ENDIF
  0000+          
  ED80+=         SEG5    EQU     SEG4+(SHSTKS*SHSIZE)
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
  0000+          ;
  ED80+=         Z3MSG   EQU     SEG5            ; ZCPR3 MESSAGE BUFFER
  0000+          
  EDD0+=         SEG6    EQU     SEG5+80
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDD0+=         EXTFCB  EQU     SEG6            ; ZCPR3 EXTERNAL FCB
  0000+          
  EDF4+=         SEG7    EQU     SEG6+36
  0000+          
  0000+          ;
  0000+          ; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
  0000+          ; used with this Z3BASE.LIB file.
  0000+          ;
  0000+          
  EDF4+=         EXPATH  EQU     SEG7            ; EXTERNAL PATH
  0005+=         EXPATHS EQU     5               ; 5 2-byte Path Elements
  0000+                                          ;  (PATH SIZE = EXPATHS*2 + 1)
  0000+          
  EDFF+=         SEG8    EQU     SEG7+(EXPATHS*2)+1
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EDFF+=         Z3WHL   EQU     SEG8            ; WHEEL BYTE ADDRESS
  0000+          
  EE00+=         SEG9    EQU     SEG8+1
  0000+          
  0000+          ;
  0000+          ; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
  0000+          ; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
  0000+          ; equate below.
  0000+          ;
  001C+=         Z3NDIRS EQU     28              ; 28 18-byte Named Directory Elements permitted
  0000+                                          ;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
  0000+                   IF     Z3NDIRS NE 0
  EE00+=         Z3NDIR  EQU     SEG9            ; ZCPR3 NAMED DIRECTORY AREA
  0000+                   ELSE
  0000+          Z3NDIR  EQU     0
  0000+                   ENDIF
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page    8
                                                            
                                                            

  EF00+=         SEG11   EQU     SEG9+256        ; add 512 for 28-entry NDR
  0000+                                          ; add 256 for 14-entry NDR ("standard")
  0000+                                          ; add 0 if Z3NDIRS is set to 0
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EF00+=         Z3CL    EQU     SEG11   ; ZCPR3 COMMAND LINE BUFFER
  00D0+=         Z3CLS   EQU     208     ; SIZE OF COMMAND LINE BUFFER
  0000+          
  EFD0+=         SEG12   EQU     SEG11+Z3CLS
  0000+          
  0000+          ;
  0000+          ; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
  0000+          ;
  0000+          
  EFD0+=         EXTSTK  EQU     SEG12   ; ZCPR3 EXTERNAL STACK
  0000+          
  0000+          ; end of Z3BASE.LIB
  0000+          
  0000+                  maclib  z33fcp.lib      ; Source of configuration options
  0000+          
  0000+          ; Z33FCP.LIB
  0000+          
  0000+          ; This module is a set of configuration options for the flow control package
  0000+          ; code in Z33FCP.Z80.  The options are not fully commented here; see
  0000+          ; "ZCPR3, The Manual" for a detailed discussion of most of them.
  0000+          
  0000+          
  0000+          ;             * * * * * *     N O T I C E     * * * * * *
  0000+          ;
  0000+          ; The main code in Z33FCP.Z80 has been written with relative jump instructions
  0000+          ; for minimum code size.  If the options below are changed, then some of the
  0000+          ; jumps may become out-of-range.  You will then have to change the code based
  0000+          ; on the error messages you get from your assembler.  I cannot think of any
  0000+          ; way to handle the jumps automatically (macros fail because the jump distances
  0000+          ; cannot be resolved fully even in two passes of the assembler).  If you want
  0000+          ; to play things really safe, you can do a global search and replace to change
  0000+          ; all occurrences of the JR instruction to JP (but note that this change is
  0000+          ; irreversible).  I prefer to live with this nuisance so that I can get the
  0000+          ; most out of the code.
  0000+          ;
  0000+          ; Another possible way to clear up a problem with a relative jump that is out
  0000+          ; of range is to take the block of code with the labels IFCTRUE and IFCFALSE
  0000+          ; and move it up or down in the code.  It is placed somewhere in the middle of
  0000+          ; the resident options, so that the options can reach those entry points with
  0000+          ; a relative jump.  You should try to place that code near the middle of the
  0000+          ; options which you have enabled.
  0000+          ;
  0000+          ;                       Jay Sage (May 17, 1987)
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Basic Definitions
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page    9
                                                            
                                                            

  0000+=         no              equ     0
  0000+          ; false         equ     0
  FFFF+=         yes             equ     not no
  0000+          ; true          equ     not false
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command inclusion options
  0000+          
  FFFF+=         zifopt          equ     yes             ; Include ZIF command to
  0000+                                                  ; ..unconditionally clear IF states
  0000+          
  FFFF+=         ifqopt          equ     yes             ; Include IFQ command to show current
  0000+                                                  ; ..if status
  0000+          
  FFFF+=         oropt           equ     yes             ; Include OR command
  0000+          
  FFFF+=         andopt          equ     yes             ; Include AND command
  0000+          
  0000+          
  0000+          ; Command names
  0000+          
  0000+          ; The CTABLE macro, which constructs the command dispatch table, includes a
  0000+          ; line for each command, the first parameter of which is the name of the
  0000+          ; command.  These names may be changed if you wish.  But make sure that you
  0000+          ; do not use a name that is longer than the maximum allowed length.  If you
  0000+          ; do, the name will be truncated and a nonfatal error will occur during
  0000+          ; assembly.  DO NOT CHANGE ANY PARAMETER OTHER THAN THE COMMAND NAME.  Lower
  0000+          ; case letters will be converted to upper case.  The macro COMMAND is defined
  0000+          ; in Z33MAC.LIB.
  0000+          
  0004+=         cmdsize equ     4               ; Maximum length of command names
  0000+          
  0000+          ; Command table         name,   enable, wheel,  jump_addr
  0000+                                  ;       [ DO NOT CHANGE THESE PARAMETERS ]
  0000+          ctable  macro
  0000+          ifcmd:  command         if,     yes,    no,     ifstart
  0000+                  command         and,    andopt, no,     andstart
  0000+                  command         or,     oropt,  no,     orstart
  0000+                  command         else,   yes,    no,     ifelse
  0000+                  command         fi,     yes,    no,     ifend
  0000+                  command         ifq,    ifqopt, no,     ifstat0
  0000+                  command         xif,    yes,    no,     ifexit
  0000+                  command         zif,    zifopt, no,     ifzero
  0000+                  endm
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; General configuration options
  0000+          
  0000+=         noise           equ     no              ; Display if-state messages
  0000+          
  0000+          
  FFFF+=         comif           equ     yes             ; Enable transient IF processing if
  0000+                                                  ; ..option not found in resident
  0000+                                                  ; ..code
ZAS Relocating Macro Assembler (v3.05                             page   10
                                                            
                                                            

  8000+=         comifadr        equ     8000h           ; Address to use as scratch buffer
  0000+                                                  ; ..while determining address at which
  0000+                                                  ; ..to load and run IF.COM (type-3)
  FFFF+=         pathroot        equ     yes             ; Find transient IF in root of path
  0000+          
  0041+=         ifdrv           equ     'A'             ; Drive to use if PATHROOT is off or
  0000+                                                  ; ..if the path is empty
  0000+=         ifusr           equ     0               ; User to use if PATHROOT is off or
  0000+                                                  ; ..if the path is empty
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; If Condition Options
  0000+          
  0000+          ;   IF NEGATION
  0000+          
  FFFF+=         ifoneg          equ     yes             ; Allow negation of conditions
  007E+=         negchar         equ     '~'             ; Character to use if negation allowed
  0000+          
  0000+          
  0000+          ;   IF:  T (TRUE) or F (FALSE)
  0000+          
  0000+=         ifotrue         equ     no              ; Allow "IF T" and "IF F" forms
  0000+          
  0000+          
  0000+          ;   IF:  AM (AMBIGUOUS)
  0000+          
  0000+=         ifambig         equ     no              ; Test for '?' in file spec
  0000+          
  0000+          
  0000+          ;   IF:  CO (COMPRESSED)
  0000+          
  0000+=         ifcompr         equ     no              ; Test for 'Z' or 'Q' in 2nd char of
  0000+                                                  ; ..file type
  0000+          
  0000+          
  0000+          ;   IF:  EM (EMPTY)
  0000+          
  0000+=         ifoempty        equ     no              ; Allow testing file for contents
  0000+          
  0000+          
  0000+          ;   IF:  ER (ERROR)
  0000+          
  FFFF+=         ifoerror        equ     yes             ; Allow testing program error flag
  0000+          
  0000+          
  0000+          ;   IF:  EX (EXIST)
  0000+          
  0000+=         ifoexist        equ     no              ; Allow testing file for existence
  0000+          
  0000+          
  0000+          ;   IF:  IN (INPUT)
  0000+          
  0000+=         ifoinput        equ     no              ; Allow getting user input
  0000+          
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   11
                                                            
                                                            

  0000+          ;   IF:  NU (NULL)
  0000+          
  FFFF+=         ifonull         equ     yes             ; Allow testing for no file name
  0000+          
  0000+          
  0000+          ;   IF:  n (Register Value)
  0000+          
  0000+=         iforeg          equ     no              ; Allow testing register values
  0000+          
  0000+          
  0000+          ;   IF:  WH (WHEEL)
  0000+          
  0000+=         ifowheel        equ     no              ; Allow testing if wheel byte set
  0000+          
  0000+          
  0000+          ;  IF:  TC (TCAP)
  0000+          
  0000+=         ifotcap         equ     no              ; Allow testing whether TCAP is loaded
  0000+          
  0000+          
  0000+          ;  IF:  fcb1=fcb2
  0000+          
  0000+=         ifoeq           equ     no              ; Allow testing for equality of two
  0000+                                                  ; ..file names
  FFFF+=         xeqopt          equ     yes             ; Yes to test only first token for
  0000+                                                  ; ..equal sign
  0000+          
  0000+          ; Miscellaneous configuration information
  0000+          
  EDAE+=         curusr          equ     z3msg+2eh       ; Current logged user address
  EDAF+=         curdr           equ     z3msg+2fh       ; Current logged drive address
  0024+=         curint          equ     '$'             ; Path symbol for current drive/user
  0000+          
  0000+          ;  END of Z33FCP.LIB
  0000+          
  0000+                  maclib  z33mac.lib      ; Z33 macros
  0000+          
  0000+          ; Z33MAC.LIB : Macros for use with ZCPR33
  0000+          
  0000+          ; General purpose macros
  0000+          
  0000+          PUTREG   MACRO
  0000+                  PUSH    HL              ; Save registers in order
  0000+                  PUSH    DE
  0000+                  PUSH    BC
  0000+                   ENDM
  0000+          
  0000+          GETREG   MACRO
  0000+                  POP     BC              ; Restore registers in order
  0000+                  POP     DE
  0000+                  POP     HL
  0000+                   ENDM
  0000+          
  0000+          SWAP     MACRO
  0000+                  RRCA                    ; Exchange nibbles
  0000+                  RRCA
ZAS Relocating Macro Assembler (v3.05                             page   12
                                                            
                                                            

  0000+                  RRCA
  0000+                  RRCA
  0000+                   ENDM
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for forming option bytes
  0000+          
  0000+          ; This macro generates a byte with bits corresponding to up to 8 option
  0000+          ; flags.  The bits are filled in the order of the parameters and are right
  0000+          ; justified in the byte.
  0000+          
  0000+          OPTFLAG MACRO   F1,F2,F3,F4,F5,F6,F7,F8
  0000+          
  0000+          FLAG    DEFL    0               ;; initial value
  0000+          
  0000+                  IRP     TEMP,<F1,F2,F3,F4,F5,F6,F7,F8>
  0000+          
  0000+                   IF     NOT NUL TEMP
  0000+          FLAG    DEFL    FLAG SHL 1
  0000+                   IF     TEMP
  0000+          FLAG    DEFL    FLAG OR 1
  0000+                   ENDIF  ;;temp
  0000+                   ENDIF  ;;not nul temp
  0000+          
  0000+                   ENDM                   ;; irp
  0000+          
  0000+                  DEFB    LOW FLAG
  0000+          
  0000+                   ENDM                   ;; optflag
  0000+          
  0000+          ;----------------------------------------
  0000+          
  0000+          ; Macro for directory scanning
  0000+          
  0000+          ; This macro resolves the command token for possible directory references.
  0000+          ; FORM1 and FORM2 can each be either "DU" or "DIR".  FORM2 can also be null.
  0000+          ; The two forms are scanned for in the indicated order.
  0000+          
  0000+          ; This macro preserves the pointer to the FCB in DE and to the next
  0000+          ; character in the line in HL.  On return, the FCB pointer has been restored,
  0000+          ; and the command string pointer is still on the stack.  The routines DUSCAN
  0000+          ; and DIRSCAN are called as needed.
  0000+          
  0000+          RESOLVE MACRO   FORM1,FORM2
  0000+          
  0000+                  LOCAL   RESOLVED
  0000+          
  0000+                  PUSH    HL              ; Save pointer to command string
  0000+                  PUSH    DE              ; Save pointer to FCB
  0000+                  CALL    FORM1&SCAN      ; Scan for the first directory form
  0000+          
  0000+                   IF     NOT NUL FORM2
  0000+          
  0000+                  JR      Z,GOTIT         ; Resolved successfully, so jump ahead
  0000+          
ZAS Relocating Macro Assembler (v3.05                             page   13
                                                            
                                                            

  0000+                  POP     DE              ; Restore pointers for use by second call
  0000+                  POP     HL
  0000+                  PUSH    HL              ; Save them again
  0000+                  PUSH    DE
  0000+                  CALL    FORM2&SCAN      ; Scan for the second directory form
  0000+          
  0000+                   ENDIF  ;not nul form2
  0000+          
  0000+          GOTIT:
  0000+                  POP     DE              ; Restore pointer to FCB
  0000+          
  0000+                   ENDM   ;resolve
  0000+          
  0000+          ;-----------------------------------------------------------------------------
  0000+          
  0000+          ; Command table entry definition macro
  0000+          
  0000+          ; Macro to form an entry for one command in the table.  The first parameter is
  0000+          ; the name to be used for the command (no quotes); the second parameter is the
  0000+          ; flag that indicates whether or not the command is to be enabled; the third
  0000+          ; parameter is the wheel control flag; and the last parameter is the jump
  0000+          ; address to the code that carries out the command.  The command names are
  0000+          ; automatically padded out to the correct length (they will be truncated and
  0000+          ; an error message will result if a command name is too long).  The characters
  0000+          ; in the command name are automatically converted to upper case.
  0000+          
  0000+          COMMAND MACRO CMDNAME,ENABLEFLAG,WHEELFLAG,ADDRESS
  0000+          
  0000+                   IF     ENABLEFLAG      ;; Generate command only if enabled
  0000+          
  0000+          WHLMASK DEFL    WHEELFLAG       ;; Initialize variables
  0000+          COUNT   DEFL    CMDSIZE         ;; Initialize to size of each command name
  0000+          
  0000+                  IRPC    CHAR,CMDNAME    ;; Repeat over letters in command name
  0000+          
  0000+          COUNT   DEFL    COUNT - 1       ;; Count down characters in name
  0000+          
  0000+                   IF     [ COUNT LT CMDSIZE ]
  0000+          
  0000+                          ;; If character is lower case, convert to upper case
  0000+          
  0000+                   IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ] + 80H
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    [ '&CHAR' AND 5FH ]
  0000+                   ENDIF  ;;WHLMASK
  0000+          
  0000+                   ELSE   ;;NOT LOWER CASE
  0000+          
  0000+                   IF     WHLMASK
  0000+                  DEFB    '&CHAR' + 80H   ;; IF CONTROLLED BY WHEEL, SET HIGH BIT
  0000+                   ELSE   ;;NOT WHLMASK
  0000+                  DEFB    '&CHAR'         ;; IF NOT RESTRICTED, LEAVE HIGH BIT CLEAR
  0000+                   ENDIF  ;;WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   14
                                                            
                                                            

  0000+          
  0000+                   ENDIF  ;;LOWER CASE
  0000+          
  0000+                   ENDIF  ;;[ COUNT LT CMDSIZE ]
  0000+          
  0000+          WHLMASK DEFL    FALSE           ;; TURN OFF HIGH-BIT SETTING AFTER FIRST CHAR
  0000+          
  0000+                  ENDM    ;IRPC
  0000+          
  0000+                          ;; PAD COMMAND NAME WITH BLANKS
  0000+          
  0000+                   IF     [ COUNT GT CMDSIZE ]    ;; IF WE UNDERFLOWED
  0000+                  *** COMMAND NAME "&CMDNAME" IS TOO LONG / TRUNCATED ***
  0000+                   ELSE
  0000+                  REPT    COUNT
  0000+                  DEFB    ' '
  0000+                  ENDM
  0000+                   ENDIF  ;[ COUNT GT CMDSIZE ]
  0000+          
  0000+                  DW      ADDRESS         ;; DISPATCH ADDRESS FOR COMMAND
  0000+          
  0000+                   ENDIF  ;ENABLE
  0000+          
  0000+                  ENDM    ;COMMAND
  0000+          
  0000+          ; End Z33MAC.LIB
  0000+          
  0000+          
  0000           
  0000           ; Equates section
  0000           
  000A =         version equ     10
  0000           
  0000           ; lf    equ     0ah
  0000           ; cr    equ     0dh
  0007 =         bell    equ     07h
  0000           
  0000           ; base  equ     0
  0000 =         wboot   equ     base+0000h      ; CP/M warm boot address
  0004 =         udflag  equ     base+0004h      ; User num in high nybble, disk in low
  0005 =         bdose   equ     base+0005h      ; BDOS function call entry point
  005C =         tfcb    equ     base+005ch      ; Default FCB buffer
  005C =         fcb1    equ     tfcb            ; 1st and 2nd FCBs
  006C =         fcb2    equ     tfcb+16
  0080 =         tbuff   equ     base+0080h      ; Default disk I/O buffer
  0100 =         tpa     equ     base+0100h      ; Base of TPA
  0000           
  0000           ;=============================================================================
  0000           
  0000           ; Start of code
  0000           
  EA00                   org     fcp             ; From Z3BASE
  EA00           
  EA00 5A33464350        db      'Z3FCP'         ; Flag for Package Loader
  EA05           
  EA05           ;=============================================================================
ZAS Relocating Macro Assembler (v3.05                             page   15
                                                            
                                                            

  EA05           ;
  EA05           ;                       C O M M A N D    T A B L E
  EA05           ;
  EA05           ;=============================================================================
  EA05           
  EA05           ; The command name table is structured as follows:
  EA05           ;
  EA05           ;       The first byte is the number of characters in each command name.
  EA05           ;       Next come records consisting of command names followed by entry
  EA05           ;       point addresses for the code to process the command.  Finally,
  EA05           ;       there is a null to indicate the end of the dispatch table.
  EA05           
  EA05 04                db      cmdsize         ; Size of text entries
  EA06           ctab:   ctable                  ; Macro defined in Z33FCP.LIB
  EA06           ifcmd:  command         if,     yes,    no,     ifstart
  EA06           
  EA06                    IF     yes
  EA06           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA06           
  EA06                   IRPC    CHAR,if
  EA06           
  EA06           COUNT   DEFL    COUNT - 1
  EA06           
  EA06                    IF     [ COUNT LT CMDSIZE ]
  EA06           
  EA06           
  EA06                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA06           
  EA06                    IF     WHLMASK
  EA06                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA06                    ELSE
  EA06                   DEFB    [ '&CHAR' AND 5FH ]
  EA06                    ENDIF
  EA06           
  EA06                    ELSE
  EA06           
  EA06                    IF     WHLMASK
  EA06                   DEFB    '&CHAR' + 80H
  EA06                    ELSE
  EA06                   DEFB    '&CHAR'
  EA06                    ENDIF
  EA06           
  EA06                    ENDIF
  EA06           
  EA06                    ENDIF
  EA06           
  EA06           WHLMASK DEFL    FALSE
  EA06           
  EA06                   ENDM    ;IRPC
  EA06           
  0003 =         COUNT   DEFL    COUNT - 1
  EA06           
  EA06                    IF     [ COUNT LT CMDSIZE ]
  EA06           
ZAS Relocating Macro Assembler (v3.05                             page   16
                                                            
                                                            

  EA06           
  EA06                    IF     [ 'i' GE 'a' ] AND [ 'i' LE 'z' ]
  EA06           
  EA06                    IF     WHLMASK
  EA06                   DEFB    [ 'i' AND 5FH ] + 80H
  EA06                    ELSE
  EA06 49                DEFB    [ 'i' AND 5FH ]
  EA07                    ENDIF
  EA07           
  EA07                    ELSE
  EA07           
  EA07                    IF     WHLMASK
  EA07                   DEFB    'i' + 80H
  EA07                    ELSE
  EA07                   DEFB    'i'
  EA07                    ENDIF
  EA07           
  EA07                    ENDIF
  EA07           
  EA07                    ENDIF
  EA07           
  0000 =         WHLMASK DEFL    FALSE
  EA07           
  EA07           
  0002 =         COUNT   DEFL    COUNT - 1
  EA07           
  EA07                    IF     [ COUNT LT CMDSIZE ]
  EA07           
  EA07           
  EA07                    IF     [ 'f' GE 'a' ] AND [ 'f' LE 'z' ]
  EA07           
  EA07                    IF     WHLMASK
  EA07                   DEFB    [ 'f' AND 5FH ] + 80H
  EA07                    ELSE
  EA07 46                DEFB    [ 'f' AND 5FH ]
  EA08                    ENDIF
  EA08           
  EA08                    ELSE
  EA08           
  EA08                    IF     WHLMASK
  EA08                   DEFB    'f' + 80H
  EA08                    ELSE
  EA08                   DEFB    'f'
  EA08                    ENDIF
  EA08           
  EA08                    ENDIF
  EA08           
  EA08                    ENDIF
  EA08           
  0000 =         WHLMASK DEFL    FALSE
  EA08           
  EA08                   ENDM    ;IRPC
  EA08           
  EA08           
  EA08                    IF     [ COUNT GT CMDSIZE ]
  EA08                   *** COMMAND NAME "if" IS TOO LONG / TRUNCATED ***
ZAS Relocating Macro Assembler (v3.05                             page   17
                                                            
                                                            

  EA08                    ELSE
  EA08                   REPT    COUNT
  EA08                   DEFB    ' '
  EA08                   ENDM
  EA08 20                DEFB    ' '
  EA09 20                DEFB    ' '
  EA0A                   ENDM
  EA0A                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA0A           
  EA0A BFEA              DW      ifstart
  EA0C           
  EA0C                    ENDIF  ;ENABLE
  EA0C           
  EA0C                   ENDM    ;COMMAND
  EA0C                   command         and,    andopt, no,     andstart
  EA0C           
  EA0C                    IF     andopt
  EA0C           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA0C           
  EA0C                   IRPC    CHAR,and
  EA0C           
  EA0C           COUNT   DEFL    COUNT - 1
  EA0C           
  EA0C                    IF     [ COUNT LT CMDSIZE ]
  EA0C           
  EA0C           
  EA0C                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA0C           
  EA0C                    IF     WHLMASK
  EA0C                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA0C                    ELSE
  EA0C                   DEFB    [ '&CHAR' AND 5FH ]
  EA0C                    ENDIF
  EA0C           
  EA0C                    ELSE
  EA0C           
  EA0C                    IF     WHLMASK
  EA0C                   DEFB    '&CHAR' + 80H
  EA0C                    ELSE
  EA0C                   DEFB    '&CHAR'
  EA0C                    ENDIF
  EA0C           
  EA0C                    ENDIF
  EA0C           
  EA0C                    ENDIF
  EA0C           
  EA0C           WHLMASK DEFL    FALSE
  EA0C           
  EA0C                   ENDM    ;IRPC
  EA0C           
  0003 =         COUNT   DEFL    COUNT - 1
  EA0C           
  EA0C                    IF     [ COUNT LT CMDSIZE ]
  EA0C           
ZAS Relocating Macro Assembler (v3.05                             page   18
                                                            
                                                            

  EA0C           
  EA0C                    IF     [ 'a' GE 'a' ] AND [ 'a' LE 'z' ]
  EA0C           
  EA0C                    IF     WHLMASK
  EA0C                   DEFB    [ 'a' AND 5FH ] + 80H
  EA0C                    ELSE
  EA0C 41                DEFB    [ 'a' AND 5FH ]
  EA0D                    ENDIF
  EA0D           
  EA0D                    ELSE
  EA0D           
  EA0D                    IF     WHLMASK
  EA0D                   DEFB    'a' + 80H
  EA0D                    ELSE
  EA0D                   DEFB    'a'
  EA0D                    ENDIF
  EA0D           
  EA0D                    ENDIF
  EA0D           
  EA0D                    ENDIF
  EA0D           
  0000 =         WHLMASK DEFL    FALSE
  EA0D           
  EA0D           
  0002 =         COUNT   DEFL    COUNT - 1
  EA0D           
  EA0D                    IF     [ COUNT LT CMDSIZE ]
  EA0D           
  EA0D           
  EA0D                    IF     [ 'n' GE 'a' ] AND [ 'n' LE 'z' ]
  EA0D           
  EA0D                    IF     WHLMASK
  EA0D                   DEFB    [ 'n' AND 5FH ] + 80H
  EA0D                    ELSE
  EA0D 4E                DEFB    [ 'n' AND 5FH ]
  EA0E                    ENDIF
  EA0E           
  EA0E                    ELSE
  EA0E           
  EA0E                    IF     WHLMASK
  EA0E                   DEFB    'n' + 80H
  EA0E                    ELSE
  EA0E                   DEFB    'n'
  EA0E                    ENDIF
  EA0E           
  EA0E                    ENDIF
  EA0E           
  EA0E                    ENDIF
  EA0E           
  0000 =         WHLMASK DEFL    FALSE
  EA0E           
  EA0E           
  0001 =         COUNT   DEFL    COUNT - 1
  EA0E           
  EA0E                    IF     [ COUNT LT CMDSIZE ]
  EA0E           
ZAS Relocating Macro Assembler (v3.05                             page   19
                                                            
                                                            

  EA0E           
  EA0E                    IF     [ 'd' GE 'a' ] AND [ 'd' LE 'z' ]
  EA0E           
  EA0E                    IF     WHLMASK
  EA0E                   DEFB    [ 'd' AND 5FH ] + 80H
  EA0E                    ELSE
  EA0E 44                DEFB    [ 'd' AND 5FH ]
  EA0F                    ENDIF
  EA0F           
  EA0F                    ELSE
  EA0F           
  EA0F                    IF     WHLMASK
  EA0F                   DEFB    'd' + 80H
  EA0F                    ELSE
  EA0F                   DEFB    'd'
  EA0F                    ENDIF
  EA0F           
  EA0F                    ENDIF
  EA0F           
  EA0F                    ENDIF
  EA0F           
  0000 =         WHLMASK DEFL    FALSE
  EA0F           
  EA0F                   ENDM    ;IRPC
  EA0F           
  EA0F           
  EA0F                    IF     [ COUNT GT CMDSIZE ]
  EA0F                   *** COMMAND NAME "and" IS TOO LONG / TRUNCATED ***
  EA0F                    ELSE
  EA0F                   REPT    COUNT
  EA0F                   DEFB    ' '
  EA0F                   ENDM
  EA0F 20                DEFB    ' '
  EA10                   ENDM
  EA10                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA10           
  EA10 ADEA              DW      andstart
  EA12           
  EA12                    ENDIF  ;ENABLE
  EA12           
  EA12                   ENDM    ;COMMAND
  EA12                   command         or,     oropt,  no,     orstart
  EA12           
  EA12                    IF     oropt
  EA12           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA12           
  EA12                   IRPC    CHAR,or
  EA12           
  EA12           COUNT   DEFL    COUNT - 1
  EA12           
  EA12                    IF     [ COUNT LT CMDSIZE ]
  EA12           
  EA12           
  EA12                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
ZAS Relocating Macro Assembler (v3.05                             page   20
                                                            
                                                            

  EA12           
  EA12                    IF     WHLMASK
  EA12                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA12                    ELSE
  EA12                   DEFB    [ '&CHAR' AND 5FH ]
  EA12                    ENDIF
  EA12           
  EA12                    ELSE
  EA12           
  EA12                    IF     WHLMASK
  EA12                   DEFB    '&CHAR' + 80H
  EA12                    ELSE
  EA12                   DEFB    '&CHAR'
  EA12                    ENDIF
  EA12           
  EA12                    ENDIF
  EA12           
  EA12                    ENDIF
  EA12           
  EA12           WHLMASK DEFL    FALSE
  EA12           
  EA12                   ENDM    ;IRPC
  EA12           
  0003 =         COUNT   DEFL    COUNT - 1
  EA12           
  EA12                    IF     [ COUNT LT CMDSIZE ]
  EA12           
  EA12           
  EA12                    IF     [ 'o' GE 'a' ] AND [ 'o' LE 'z' ]
  EA12           
  EA12                    IF     WHLMASK
  EA12                   DEFB    [ 'o' AND 5FH ] + 80H
  EA12                    ELSE
  EA12 4F                DEFB    [ 'o' AND 5FH ]
  EA13                    ENDIF
  EA13           
  EA13                    ELSE
  EA13           
  EA13                    IF     WHLMASK
  EA13                   DEFB    'o' + 80H
  EA13                    ELSE
  EA13                   DEFB    'o'
  EA13                    ENDIF
  EA13           
  EA13                    ENDIF
  EA13           
  EA13                    ENDIF
  EA13           
  0000 =         WHLMASK DEFL    FALSE
  EA13           
  EA13           
  0002 =         COUNT   DEFL    COUNT - 1
  EA13           
  EA13                    IF     [ COUNT LT CMDSIZE ]
  EA13           
  EA13           
ZAS Relocating Macro Assembler (v3.05                             page   21
                                                            
                                                            

  EA13                    IF     [ 'r' GE 'a' ] AND [ 'r' LE 'z' ]
  EA13           
  EA13                    IF     WHLMASK
  EA13                   DEFB    [ 'r' AND 5FH ] + 80H
  EA13                    ELSE
  EA13 52                DEFB    [ 'r' AND 5FH ]
  EA14                    ENDIF
  EA14           
  EA14                    ELSE
  EA14           
  EA14                    IF     WHLMASK
  EA14                   DEFB    'r' + 80H
  EA14                    ELSE
  EA14                   DEFB    'r'
  EA14                    ENDIF
  EA14           
  EA14                    ENDIF
  EA14           
  EA14                    ENDIF
  EA14           
  0000 =         WHLMASK DEFL    FALSE
  EA14           
  EA14                   ENDM    ;IRPC
  EA14           
  EA14           
  EA14                    IF     [ COUNT GT CMDSIZE ]
  EA14                   *** COMMAND NAME "or" IS TOO LONG / TRUNCATED ***
  EA14                    ELSE
  EA14                   REPT    COUNT
  EA14                   DEFB    ' '
  EA14                   ENDM
  EA14 20                DEFB    ' '
  EA15 20                DEFB    ' '
  EA16                   ENDM
  EA16                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA16           
  EA16 A4EA              DW      orstart
  EA18           
  EA18                    ENDIF  ;ENABLE
  EA18           
  EA18                   ENDM    ;COMMAND
  EA18                   command         else,   yes,    no,     ifelse
  EA18           
  EA18                    IF     yes
  EA18           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA18           
  EA18                   IRPC    CHAR,else
  EA18           
  EA18           COUNT   DEFL    COUNT - 1
  EA18           
  EA18                    IF     [ COUNT LT CMDSIZE ]
  EA18           
  EA18           
  EA18                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
ZAS Relocating Macro Assembler (v3.05                             page   22
                                                            
                                                            

  EA18           
  EA18                    IF     WHLMASK
  EA18                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA18                    ELSE
  EA18                   DEFB    [ '&CHAR' AND 5FH ]
  EA18                    ENDIF
  EA18           
  EA18                    ELSE
  EA18           
  EA18                    IF     WHLMASK
  EA18                   DEFB    '&CHAR' + 80H
  EA18                    ELSE
  EA18                   DEFB    '&CHAR'
  EA18                    ENDIF
  EA18           
  EA18                    ENDIF
  EA18           
  EA18                    ENDIF
  EA18           
  EA18           WHLMASK DEFL    FALSE
  EA18           
  EA18                   ENDM    ;IRPC
  EA18           
  0003 =         COUNT   DEFL    COUNT - 1
  EA18           
  EA18                    IF     [ COUNT LT CMDSIZE ]
  EA18           
  EA18           
  EA18                    IF     [ 'e' GE 'a' ] AND [ 'e' LE 'z' ]
  EA18           
  EA18                    IF     WHLMASK
  EA18                   DEFB    [ 'e' AND 5FH ] + 80H
  EA18                    ELSE
  EA18 45                DEFB    [ 'e' AND 5FH ]
  EA19                    ENDIF
  EA19           
  EA19                    ELSE
  EA19           
  EA19                    IF     WHLMASK
  EA19                   DEFB    'e' + 80H
  EA19                    ELSE
  EA19                   DEFB    'e'
  EA19                    ENDIF
  EA19           
  EA19                    ENDIF
  EA19           
  EA19                    ENDIF
  EA19           
  0000 =         WHLMASK DEFL    FALSE
  EA19           
  EA19           
  0002 =         COUNT   DEFL    COUNT - 1
  EA19           
  EA19                    IF     [ COUNT LT CMDSIZE ]
  EA19           
  EA19           
ZAS Relocating Macro Assembler (v3.05                             page   23
                                                            
                                                            

  EA19                    IF     [ 'l' GE 'a' ] AND [ 'l' LE 'z' ]
  EA19           
  EA19                    IF     WHLMASK
  EA19                   DEFB    [ 'l' AND 5FH ] + 80H
  EA19                    ELSE
  EA19 4C                DEFB    [ 'l' AND 5FH ]
  EA1A                    ENDIF
  EA1A           
  EA1A                    ELSE
  EA1A           
  EA1A                    IF     WHLMASK
  EA1A                   DEFB    'l' + 80H
  EA1A                    ELSE
  EA1A                   DEFB    'l'
  EA1A                    ENDIF
  EA1A           
  EA1A                    ENDIF
  EA1A           
  EA1A                    ENDIF
  EA1A           
  0000 =         WHLMASK DEFL    FALSE
  EA1A           
  EA1A           
  0001 =         COUNT   DEFL    COUNT - 1
  EA1A           
  EA1A                    IF     [ COUNT LT CMDSIZE ]
  EA1A           
  EA1A           
  EA1A                    IF     [ 's' GE 'a' ] AND [ 's' LE 'z' ]
  EA1A           
  EA1A                    IF     WHLMASK
  EA1A                   DEFB    [ 's' AND 5FH ] + 80H
  EA1A                    ELSE
  EA1A 53                DEFB    [ 's' AND 5FH ]
  EA1B                    ENDIF
  EA1B           
  EA1B                    ELSE
  EA1B           
  EA1B                    IF     WHLMASK
  EA1B                   DEFB    's' + 80H
  EA1B                    ELSE
  EA1B                   DEFB    's'
  EA1B                    ENDIF
  EA1B           
  EA1B                    ENDIF
  EA1B           
  EA1B                    ENDIF
  EA1B           
  0000 =         WHLMASK DEFL    FALSE
  EA1B           
  EA1B           
  0000 =         COUNT   DEFL    COUNT - 1
  EA1B           
  EA1B                    IF     [ COUNT LT CMDSIZE ]
  EA1B           
  EA1B           
ZAS Relocating Macro Assembler (v3.05                             page   24
                                                            
                                                            

  EA1B                    IF     [ 'e' GE 'a' ] AND [ 'e' LE 'z' ]
  EA1B           
  EA1B                    IF     WHLMASK
  EA1B                   DEFB    [ 'e' AND 5FH ] + 80H
  EA1B                    ELSE
  EA1B 45                DEFB    [ 'e' AND 5FH ]
  EA1C                    ENDIF
  EA1C           
  EA1C                    ELSE
  EA1C           
  EA1C                    IF     WHLMASK
  EA1C                   DEFB    'e' + 80H
  EA1C                    ELSE
  EA1C                   DEFB    'e'
  EA1C                    ENDIF
  EA1C           
  EA1C                    ENDIF
  EA1C           
  EA1C                    ENDIF
  EA1C           
  0000 =         WHLMASK DEFL    FALSE
  EA1C           
  EA1C                   ENDM    ;IRPC
  EA1C           
  EA1C           
  EA1C                    IF     [ COUNT GT CMDSIZE ]
  EA1C                   *** COMMAND NAME "else" IS TOO LONG / TRUNCATED ***
  EA1C                    ELSE
  EA1C                   REPT    COUNT
  EA1C                   DEFB    ' '
  EA1C                   ENDM
  EA1C                   ENDM
  EA1C                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA1C           
  EA1C 5AEA              DW      ifelse
  EA1E           
  EA1E                    ENDIF  ;ENABLE
  EA1E           
  EA1E                   ENDM    ;COMMAND
  EA1E                   command         fi,     yes,    no,     ifend
  EA1E           
  EA1E                    IF     yes
  EA1E           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA1E           
  EA1E                   IRPC    CHAR,fi
  EA1E           
  EA1E           COUNT   DEFL    COUNT - 1
  EA1E           
  EA1E                    IF     [ COUNT LT CMDSIZE ]
  EA1E           
  EA1E           
  EA1E                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA1E           
  EA1E                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   25
                                                            
                                                            

  EA1E                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA1E                    ELSE
  EA1E                   DEFB    [ '&CHAR' AND 5FH ]
  EA1E                    ENDIF
  EA1E           
  EA1E                    ELSE
  EA1E           
  EA1E                    IF     WHLMASK
  EA1E                   DEFB    '&CHAR' + 80H
  EA1E                    ELSE
  EA1E                   DEFB    '&CHAR'
  EA1E                    ENDIF
  EA1E           
  EA1E                    ENDIF
  EA1E           
  EA1E                    ENDIF
  EA1E           
  EA1E           WHLMASK DEFL    FALSE
  EA1E           
  EA1E                   ENDM    ;IRPC
  EA1E           
  0003 =         COUNT   DEFL    COUNT - 1
  EA1E           
  EA1E                    IF     [ COUNT LT CMDSIZE ]
  EA1E           
  EA1E           
  EA1E                    IF     [ 'f' GE 'a' ] AND [ 'f' LE 'z' ]
  EA1E           
  EA1E                    IF     WHLMASK
  EA1E                   DEFB    [ 'f' AND 5FH ] + 80H
  EA1E                    ELSE
  EA1E 46                DEFB    [ 'f' AND 5FH ]
  EA1F                    ENDIF
  EA1F           
  EA1F                    ELSE
  EA1F           
  EA1F                    IF     WHLMASK
  EA1F                   DEFB    'f' + 80H
  EA1F                    ELSE
  EA1F                   DEFB    'f'
  EA1F                    ENDIF
  EA1F           
  EA1F                    ENDIF
  EA1F           
  EA1F                    ENDIF
  EA1F           
  0000 =         WHLMASK DEFL    FALSE
  EA1F           
  EA1F           
  0002 =         COUNT   DEFL    COUNT - 1
  EA1F           
  EA1F                    IF     [ COUNT LT CMDSIZE ]
  EA1F           
  EA1F           
  EA1F                    IF     [ 'i' GE 'a' ] AND [ 'i' LE 'z' ]
  EA1F           
ZAS Relocating Macro Assembler (v3.05                             page   26
                                                            
                                                            

  EA1F                    IF     WHLMASK
  EA1F                   DEFB    [ 'i' AND 5FH ] + 80H
  EA1F                    ELSE
  EA1F 49                DEFB    [ 'i' AND 5FH ]
  EA20                    ENDIF
  EA20           
  EA20                    ELSE
  EA20           
  EA20                    IF     WHLMASK
  EA20                   DEFB    'i' + 80H
  EA20                    ELSE
  EA20                   DEFB    'i'
  EA20                    ENDIF
  EA20           
  EA20                    ENDIF
  EA20           
  EA20                    ENDIF
  EA20           
  0000 =         WHLMASK DEFL    FALSE
  EA20           
  EA20                   ENDM    ;IRPC
  EA20           
  EA20           
  EA20                    IF     [ COUNT GT CMDSIZE ]
  EA20                   *** COMMAND NAME "fi" IS TOO LONG / TRUNCATED ***
  EA20                    ELSE
  EA20                   REPT    COUNT
  EA20                   DEFB    ' '
  EA20                   ENDM
  EA20 20                DEFB    ' '
  EA21 20                DEFB    ' '
  EA22                   ENDM
  EA22                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA22           
  EA22 50EA              DW      ifend
  EA24           
  EA24                    ENDIF  ;ENABLE
  EA24           
  EA24                   ENDM    ;COMMAND
  EA24                   command         ifq,    ifqopt, no,     ifstat0
  EA24           
  EA24                    IF     ifqopt
  EA24           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA24           
  EA24                   IRPC    CHAR,ifq
  EA24           
  EA24           COUNT   DEFL    COUNT - 1
  EA24           
  EA24                    IF     [ COUNT LT CMDSIZE ]
  EA24           
  EA24           
  EA24                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA24           
  EA24                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   27
                                                            
                                                            

  EA24                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA24                    ELSE
  EA24                   DEFB    [ '&CHAR' AND 5FH ]
  EA24                    ENDIF
  EA24           
  EA24                    ELSE
  EA24           
  EA24                    IF     WHLMASK
  EA24                   DEFB    '&CHAR' + 80H
  EA24                    ELSE
  EA24                   DEFB    '&CHAR'
  EA24                    ENDIF
  EA24           
  EA24                    ENDIF
  EA24           
  EA24                    ENDIF
  EA24           
  EA24           WHLMASK DEFL    FALSE
  EA24           
  EA24                   ENDM    ;IRPC
  EA24           
  0003 =         COUNT   DEFL    COUNT - 1
  EA24           
  EA24                    IF     [ COUNT LT CMDSIZE ]
  EA24           
  EA24           
  EA24                    IF     [ 'i' GE 'a' ] AND [ 'i' LE 'z' ]
  EA24           
  EA24                    IF     WHLMASK
  EA24                   DEFB    [ 'i' AND 5FH ] + 80H
  EA24                    ELSE
  EA24 49                DEFB    [ 'i' AND 5FH ]
  EA25                    ENDIF
  EA25           
  EA25                    ELSE
  EA25           
  EA25                    IF     WHLMASK
  EA25                   DEFB    'i' + 80H
  EA25                    ELSE
  EA25                   DEFB    'i'
  EA25                    ENDIF
  EA25           
  EA25                    ENDIF
  EA25           
  EA25                    ENDIF
  EA25           
  0000 =         WHLMASK DEFL    FALSE
  EA25           
  EA25           
  0002 =         COUNT   DEFL    COUNT - 1
  EA25           
  EA25                    IF     [ COUNT LT CMDSIZE ]
  EA25           
  EA25           
  EA25                    IF     [ 'f' GE 'a' ] AND [ 'f' LE 'z' ]
  EA25           
ZAS Relocating Macro Assembler (v3.05                             page   28
                                                            
                                                            

  EA25                    IF     WHLMASK
  EA25                   DEFB    [ 'f' AND 5FH ] + 80H
  EA25                    ELSE
  EA25 46                DEFB    [ 'f' AND 5FH ]
  EA26                    ENDIF
  EA26           
  EA26                    ELSE
  EA26           
  EA26                    IF     WHLMASK
  EA26                   DEFB    'f' + 80H
  EA26                    ELSE
  EA26                   DEFB    'f'
  EA26                    ENDIF
  EA26           
  EA26                    ENDIF
  EA26           
  EA26                    ENDIF
  EA26           
  0000 =         WHLMASK DEFL    FALSE
  EA26           
  EA26           
  0001 =         COUNT   DEFL    COUNT - 1
  EA26           
  EA26                    IF     [ COUNT LT CMDSIZE ]
  EA26           
  EA26           
  EA26                    IF     [ 'q' GE 'a' ] AND [ 'q' LE 'z' ]
  EA26           
  EA26                    IF     WHLMASK
  EA26                   DEFB    [ 'q' AND 5FH ] + 80H
  EA26                    ELSE
  EA26 51                DEFB    [ 'q' AND 5FH ]
  EA27                    ENDIF
  EA27           
  EA27                    ELSE
  EA27           
  EA27                    IF     WHLMASK
  EA27                   DEFB    'q' + 80H
  EA27                    ELSE
  EA27                   DEFB    'q'
  EA27                    ENDIF
  EA27           
  EA27                    ENDIF
  EA27           
  EA27                    ENDIF
  EA27           
  0000 =         WHLMASK DEFL    FALSE
  EA27           
  EA27                   ENDM    ;IRPC
  EA27           
  EA27           
  EA27                    IF     [ COUNT GT CMDSIZE ]
  EA27                   *** COMMAND NAME "ifq" IS TOO LONG / TRUNCATED ***
  EA27                    ELSE
  EA27                   REPT    COUNT
  EA27                   DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   29
                                                            
                                                            

  EA27                   ENDM
  EA27 20                DEFB    ' '
  EA28                   ENDM
  EA28                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA28           
  EA28 68EA              DW      ifstat0
  EA2A           
  EA2A                    ENDIF  ;ENABLE
  EA2A           
  EA2A                   ENDM    ;COMMAND
  EA2A                   command         xif,    yes,    no,     ifexit
  EA2A           
  EA2A                    IF     yes
  EA2A           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA2A           
  EA2A                   IRPC    CHAR,xif
  EA2A           
  EA2A           COUNT   DEFL    COUNT - 1
  EA2A           
  EA2A                    IF     [ COUNT LT CMDSIZE ]
  EA2A           
  EA2A           
  EA2A                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA2A           
  EA2A                    IF     WHLMASK
  EA2A                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA2A                    ELSE
  EA2A                   DEFB    [ '&CHAR' AND 5FH ]
  EA2A                    ENDIF
  EA2A           
  EA2A                    ELSE
  EA2A           
  EA2A                    IF     WHLMASK
  EA2A                   DEFB    '&CHAR' + 80H
  EA2A                    ELSE
  EA2A                   DEFB    '&CHAR'
  EA2A                    ENDIF
  EA2A           
  EA2A                    ENDIF
  EA2A           
  EA2A                    ENDIF
  EA2A           
  EA2A           WHLMASK DEFL    FALSE
  EA2A           
  EA2A                   ENDM    ;IRPC
  EA2A           
  0003 =         COUNT   DEFL    COUNT - 1
  EA2A           
  EA2A                    IF     [ COUNT LT CMDSIZE ]
  EA2A           
  EA2A           
  EA2A                    IF     [ 'x' GE 'a' ] AND [ 'x' LE 'z' ]
  EA2A           
  EA2A                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   30
                                                            
                                                            

  EA2A                   DEFB    [ 'x' AND 5FH ] + 80H
  EA2A                    ELSE
  EA2A 58                DEFB    [ 'x' AND 5FH ]
  EA2B                    ENDIF
  EA2B           
  EA2B                    ELSE
  EA2B           
  EA2B                    IF     WHLMASK
  EA2B                   DEFB    'x' + 80H
  EA2B                    ELSE
  EA2B                   DEFB    'x'
  EA2B                    ENDIF
  EA2B           
  EA2B                    ENDIF
  EA2B           
  EA2B                    ENDIF
  EA2B           
  0000 =         WHLMASK DEFL    FALSE
  EA2B           
  EA2B           
  0002 =         COUNT   DEFL    COUNT - 1
  EA2B           
  EA2B                    IF     [ COUNT LT CMDSIZE ]
  EA2B           
  EA2B           
  EA2B                    IF     [ 'i' GE 'a' ] AND [ 'i' LE 'z' ]
  EA2B           
  EA2B                    IF     WHLMASK
  EA2B                   DEFB    [ 'i' AND 5FH ] + 80H
  EA2B                    ELSE
  EA2B 49                DEFB    [ 'i' AND 5FH ]
  EA2C                    ENDIF
  EA2C           
  EA2C                    ELSE
  EA2C           
  EA2C                    IF     WHLMASK
  EA2C                   DEFB    'i' + 80H
  EA2C                    ELSE
  EA2C                   DEFB    'i'
  EA2C                    ENDIF
  EA2C           
  EA2C                    ENDIF
  EA2C           
  EA2C                    ENDIF
  EA2C           
  0000 =         WHLMASK DEFL    FALSE
  EA2C           
  EA2C           
  0001 =         COUNT   DEFL    COUNT - 1
  EA2C           
  EA2C                    IF     [ COUNT LT CMDSIZE ]
  EA2C           
  EA2C           
  EA2C                    IF     [ 'f' GE 'a' ] AND [ 'f' LE 'z' ]
  EA2C           
  EA2C                    IF     WHLMASK
ZAS Relocating Macro Assembler (v3.05                             page   31
                                                            
                                                            

  EA2C                   DEFB    [ 'f' AND 5FH ] + 80H
  EA2C                    ELSE
  EA2C 46                DEFB    [ 'f' AND 5FH ]
  EA2D                    ENDIF
  EA2D           
  EA2D                    ELSE
  EA2D           
  EA2D                    IF     WHLMASK
  EA2D                   DEFB    'f' + 80H
  EA2D                    ELSE
  EA2D                   DEFB    'f'
  EA2D                    ENDIF
  EA2D           
  EA2D                    ENDIF
  EA2D           
  EA2D                    ENDIF
  EA2D           
  0000 =         WHLMASK DEFL    FALSE
  EA2D           
  EA2D                   ENDM    ;IRPC
  EA2D           
  EA2D           
  EA2D                    IF     [ COUNT GT CMDSIZE ]
  EA2D                   *** COMMAND NAME "xif" IS TOO LONG / TRUNCATED ***
  EA2D                    ELSE
  EA2D                   REPT    COUNT
  EA2D                   DEFB    ' '
  EA2D                   ENDM
  EA2D 20                DEFB    ' '
  EA2E                   ENDM
  EA2E                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA2E           
  EA2E 45EA              DW      ifexit
  EA30           
  EA30                    ENDIF  ;ENABLE
  EA30           
  EA30                   ENDM    ;COMMAND
  EA30                   command         zif,    zifopt, no,     ifzero
  EA30           
  EA30                    IF     zifopt
  EA30           
  0000 =         WHLMASK DEFL    no
  0004 =         COUNT   DEFL    CMDSIZE
  EA30           
  EA30                   IRPC    CHAR,zif
  EA30           
  EA30           COUNT   DEFL    COUNT - 1
  EA30           
  EA30                    IF     [ COUNT LT CMDSIZE ]
  EA30           
  EA30           
  EA30                    IF     [ '&CHAR' GE 'a' ] AND [ '&CHAR' LE 'z' ]
  EA30           
  EA30                    IF     WHLMASK
  EA30                   DEFB    [ '&CHAR' AND 5FH ] + 80H
  EA30                    ELSE
ZAS Relocating Macro Assembler (v3.05                             page   32
                                                            
                                                            

  EA30                   DEFB    [ '&CHAR' AND 5FH ]
  EA30                    ENDIF
  EA30           
  EA30                    ELSE
  EA30           
  EA30                    IF     WHLMASK
  EA30                   DEFB    '&CHAR' + 80H
  EA30                    ELSE
  EA30                   DEFB    '&CHAR'
  EA30                    ENDIF
  EA30           
  EA30                    ENDIF
  EA30           
  EA30                    ENDIF
  EA30           
  EA30           WHLMASK DEFL    FALSE
  EA30           
  EA30                   ENDM    ;IRPC
  EA30           
  0003 =         COUNT   DEFL    COUNT - 1
  EA30           
  EA30                    IF     [ COUNT LT CMDSIZE ]
  EA30           
  EA30           
  EA30                    IF     [ 'z' GE 'a' ] AND [ 'z' LE 'z' ]
  EA30           
  EA30                    IF     WHLMASK
  EA30                   DEFB    [ 'z' AND 5FH ] + 80H
  EA30                    ELSE
  EA30 5A                DEFB    [ 'z' AND 5FH ]
  EA31                    ENDIF
  EA31           
  EA31                    ELSE
  EA31           
  EA31                    IF     WHLMASK
  EA31                   DEFB    'z' + 80H
  EA31                    ELSE
  EA31                   DEFB    'z'
  EA31                    ENDIF
  EA31           
  EA31                    ENDIF
  EA31           
  EA31                    ENDIF
  EA31           
  0000 =         WHLMASK DEFL    FALSE
  EA31           
  EA31           
  0002 =         COUNT   DEFL    COUNT - 1
  EA31           
  EA31                    IF     [ COUNT LT CMDSIZE ]
  EA31           
  EA31           
  EA31                    IF     [ 'i' GE 'a' ] AND [ 'i' LE 'z' ]
  EA31           
  EA31                    IF     WHLMASK
  EA31                   DEFB    [ 'i' AND 5FH ] + 80H
ZAS Relocating Macro Assembler (v3.05                             page   33
                                                            
                                                            

  EA31                    ELSE
  EA31 49                DEFB    [ 'i' AND 5FH ]
  EA32                    ENDIF
  EA32           
  EA32                    ELSE
  EA32           
  EA32                    IF     WHLMASK
  EA32                   DEFB    'i' + 80H
  EA32                    ELSE
  EA32                   DEFB    'i'
  EA32                    ENDIF
  EA32           
  EA32                    ENDIF
  EA32           
  EA32                    ENDIF
  EA32           
  0000 =         WHLMASK DEFL    FALSE
  EA32           
  EA32           
  0001 =         COUNT   DEFL    COUNT - 1
  EA32           
  EA32                    IF     [ COUNT LT CMDSIZE ]
  EA32           
  EA32           
  EA32                    IF     [ 'f' GE 'a' ] AND [ 'f' LE 'z' ]
  EA32           
  EA32                    IF     WHLMASK
  EA32                   DEFB    [ 'f' AND 5FH ] + 80H
  EA32                    ELSE
  EA32 46                DEFB    [ 'f' AND 5FH ]
  EA33                    ENDIF
  EA33           
  EA33                    ELSE
  EA33           
  EA33                    IF     WHLMASK
  EA33                   DEFB    'f' + 80H
  EA33                    ELSE
  EA33                   DEFB    'f'
  EA33                    ENDIF
  EA33           
  EA33                    ENDIF
  EA33           
  EA33                    ENDIF
  EA33           
  0000 =         WHLMASK DEFL    FALSE
  EA33           
  EA33                   ENDM    ;IRPC
  EA33           
  EA33           
  EA33                    IF     [ COUNT GT CMDSIZE ]
  EA33                   *** COMMAND NAME "zif" IS TOO LONG / TRUNCATED ***
  EA33                    ELSE
  EA33                   REPT    COUNT
  EA33                   DEFB    ' '
  EA33                   ENDM
  EA33 20                DEFB    ' '
ZAS Relocating Macro Assembler (v3.05                             page   34
                                                            
                                                            

  EA34                   ENDM
  EA34                    ENDIF  ;[ COUNT GT CMDSIZE ]
  EA34           
  EA34 43EA              DW      ifzero
  EA36           
  EA36                    ENDIF  ;ENABLE
  EA36           
  EA36                   ENDM    ;COMMAND
  EA36                   endm
  EA36 00                db      0
  EA37           
  EA37           ;=============================================================================
  EA37           ;
  EA37           ;               I F    C O N D I T I O N    O P T I O N S
  EA37           ;
  EA37           ;=============================================================================
  EA37           
  EA37           condtab:
  EA37           
  EA37                    if     ifotrue
  EA37                   db      'T '            ; TRUE
  EA37                   dw      ifctrue
  EA37                   db      'F '            ; FALSE
  EA37                   dw      ifcfalse
  EA37                    endif  ; ifotrue
  EA37           
  EA37                    if     ifambig         ; Ambiguous file spec
  EA37                   db      'AM'
  EA37                   dw      ifcambig
  EA37                    endif  ; ifambig
  EA37           
  EA37                    if     ifcompr         ; Squeezed or crunched
  EA37                   db      'CO'
  EA37                   dw      ifccompr
  EA37                    endif  ; ifcompr
  EA37           
  EA37                    if     ifoempty
  EA37                   db      'EM'            ; File empty
  EA37                   dw      ifcempty
  EA37                    endif  ; ifoempty
  EA37           
  EA37                    if     ifoerror
  EA37 4552              db      'ER'            ; Error message
  EA39 F8EA              dw      ifcerror
  EA3B                    endif  ; ifoerror
  EA3B           
  EA3B                    if     ifoexist
  EA3B                   db      'EX'            ; File exists
  EA3B                   dw      ifcex
  EA3B                    endif  ; ifoexist
  EA3B           
  EA3B                    if     ifoinput
  EA3B                   db      'IN'            ; User input
  EA3B                   dw      ifcinput
  EA3B                    endif  ; ifoinput
  EA3B           
ZAS Relocating Macro Assembler (v3.05                             page   35
                                                            
                                                            

  EA3B                    if     ifonull
  EA3B 4E55              db      'NU'
  EA3D FEEA              dw      ifcnull
  EA3F                    endif  ; ifonull
  EA3F           
  EA3F                    if     ifotcap         ; Z3 TCAP available
  EA3F                   db      'TC'
  EA3F                   dw      ifctcap
  EA3F                    endif  ; ifotcap
  EA3F           
  EA3F                    if     ifowheel        ; Wheel Byte
  EA3F                   db      'WH'
  EA3F                   dw      ifcwheel
  EA3F                    endif  ; ifowheel
  EA3F           
  EA3F 00                db      0
  EA40           
  EA40           ; Option bytes: these option bytes can be used to convey information to
  EA40           ; programs such as SHOW.  The first one is used to reduce the chance of
  EA40           ; misinterpreting data from an earlier version of the FCP that does not
  EA40           ; have the option bytes.  The next byte tells if COMIF has been activated
  EA40           ; and if the root of the path will be used as the directory in which to look
  EA40           ; for IF.COM.  If PATHROOT is not selected (or if the path is empty), then
  EA40           ; the specified drive/user will be used.  The overflow bit in case the user
  EA40           ; number is greater than 15 is kept in bit 2 of the second option byte.  The
  EA40           ; combined user/drive value is kept in the third option byte.
  EA40           
  0000 =         highuser defl   ifusr gt 15
  EA40           
  EA40 33        opt0:   db      33h             ; ZCPR33 version ID
  EA41           opt1:   optflag highuser,pathroot,comif
  EA41           
  0000 =         FLAG    DEFL    0
  EA41           
  EA41                   IRP     TEMP,<highuser,pathroot,comif,,,,,>
  EA41           
  EA41                    IF     NOT NUL TEMP
  EA41           FLAG    DEFL    FLAG SHL 1
  EA41                    IF     TEMP
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41                    ENDM
  EA41           
  EA41                    IF     NOT NUL highuser
  0000 =         FLAG    DEFL    FLAG SHL 1
  EA41                    IF     highuser
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL pathroot
  0000 =         FLAG    DEFL    FLAG SHL 1
  EA41                    IF     pathroot
ZAS Relocating Macro Assembler (v3.05                             page   36
                                                            
                                                            

  0001 =         FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL comif
  0002 =         FLAG    DEFL    FLAG SHL 1
  EA41                    IF     comif
  0003 =         FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL 
  EA41           FLAG    DEFL    FLAG SHL 1
  EA41                    IF     
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL 
  EA41           FLAG    DEFL    FLAG SHL 1
  EA41                    IF     
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL 
  EA41           FLAG    DEFL    FLAG SHL 1
  EA41                    IF     
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41           
  EA41                    IF     NOT NUL 
  EA41           FLAG    DEFL    FLAG SHL 1
  EA41                    IF     
  EA41           FLAG    DEFL    FLAG OR 1
  EA41                    ENDIF
  EA41                    ENDIF
  EA41           
  EA41                    ENDM
  EA41           
  EA41 03                DEFB    LOW FLAG
  EA42           
  EA42                    ENDM
  EA42 00        opt2:   db [ ifusr and 0fh ] shl 4 + [ ifdrv - 'A' ]    ; user/drive flag
  EA43           
  EA43           ;=============================================================================
  EA43           ;
  EA43           ;               C O M M A N D    P R O C E S S I N G    C O D E
  EA43           ;
  EA43           ;=============================================================================
ZAS Relocating Macro Assembler (v3.05                             page   37
                                                            
                                                            

  EA43           
  EA43           ; Command: ZIF
  EA43           ;
  EA43           ;       This command zeros out the IF system no matter what the current
  EA43           ;       level IF state is.
  EA43           
  EA43                    if     zifopt
  EA43           
  EA43           ifzero:
  EA43                    if     noise
  EA43                   call    nl              ; Print new line
  EA43                    endif  ; noise
  EA43           
  EA43 1804              jr      ifexit1
  EA45           
  EA45                    endif  ; zifopt
  EA45           
  EA45           ;-----------------------------------------------------------------------------
  EA45           
  EA45           ; Command: XIF
  EA45           ;
  EA45           ;       If current IF state is true, XIF terminates all IFs, restoring a basic
  EA45           ;       TRUE state.
  EA45           
  EA45           ifexit:
  EA45                    if     noise
  EA45                   call    nl              ; Print new line
  EA45                    endif  ; noise
  EA45           
  EA45 CD0AEB            call    iftest          ; See if current IF is running and FALSE
  EA48           
  EA48                    if     noise
  EA48                   jr      z,ifstat        ; Abort with status message if so
  EA48                    else   ; not noise
  EA48 C8                ret     z               ; Or just return if false
  EA49                    endif  ; noise
  EA49           
  EA49           ifexit1:
  EA49 2181ED            ld      hl,z3msg+1      ; Pt to IF flag
  EA4C AF                xor     a               ; A=0
  EA4D 77                ld      (hl),a          ; Zero IF flag
  EA4E 1807              jr      ifendmsg        ; Print message
  EA50           
  EA50           ;-----------------------------------------------------------------------------
  EA50           
  EA50           ; Command: FI
  EA50           ;
  EA50           ;       FI decrements to the previous IF level.  It does this by shifting the
  EA50           ;       current-if-bit in the first 'if' message in the Z3MSG buffer right one
  EA50           ;       position.
  EA50           
  EA50           ifend:
  EA50                    if     noise
  EA50                   call    nl              ; Print new line
  EA50                    endif  ; noise
  EA50           
ZAS Relocating Macro Assembler (v3.05                             page   38
                                                            
                                                            

  EA50 2181ED            ld      hl,z3msg+1      ; Point to IF flag
  EA53 7E                ld      a,(hl)          ; Get it
  EA54 B7                or      a               ; No IF active?
  EA55 2802              jr      z,ifnderr
  EA57           
  EA57           ifendmsg:
  EA57                    if     noise
  EA57                   call    print
  EA57                   db      'To',' '+80h    ; Prefix to status display
  EA57                    endif  ; noise
  EA57           
  EA57 CB3E              srl     (hl)            ; Adjust active bit
  EA59           
  EA59                    if     noise
  EA59                   jr      nz,ifstat       ; Print status if IF still active
  EA59                    endif  ; noise
  EA59           
  EA59           ifnderr:
  EA59                    if     noise
  EA59           
  EA59                   call    print           ; Print message
  EA59                   db      'No',' '+80h
  EA59                   jp      prif
  EA59           
  EA59                    else   ; not noise
  EA59           
  EA59 C9                ret
  EA5A           
  EA5A                    endif  ; noise
  EA5A           
  EA5A           ;-----------------------------------------------------------------------------
  EA5A           
  EA5A           ; Command: ELSE
  EA5A           ;
  EA5A           ;       ELSE complements the Active Bit for the Current IF provided the
  EA5A           ;       previous IF state was true.  If the previous state was false, the
  EA5A           ;       command is flushed.
  EA5A           ;
  EA5A           ;       This is accomplished according to the following algorithm.  If the
  EA5A           ;       current IF is 0 (no IF) or 1 (one IF), then take the previous state
  EA5A           ;       to be true and perform the toggle.  Otherwise, test the previous
  EA5A           ;       IF level condition and toggle only if it is true.
  EA5A           
  EA5A           ifelse:
  EA5A                    if     noise and [not ifqopt]
  EA5A                   call    nl              ; Print new line
  EA5A                    endif  ; noise and [not ifqopt]
  EA5A           
  EA5A CD14EB            call    msgbf1          ; Get current if
  EA5D 47                ld      b,a             ; Save in B
  EA5E CB3F              srl     a               ; Back up if pointer bit to previous IF level
  EA60 2802              jr      z,iftog         ; If no previous IF level, go to toggle code
  EA62 A6                and     (hl)            ; Determine state of previous IF level
  EA63           
  EA63                    if     noise
  EA63                   if      ifqopt
ZAS Relocating Macro Assembler (v3.05                             page   39
                                                            
                                                            

  EA63                   jr      z,ifstat0       ; Print status on new line
  EA63                   else
  EA63                   jr      z,ifstat        ; If false, just print status
  EA63                   endif                   ; Ifqopt
  EA63                    else   ; not noise
  EA63 C8                ret     z               ; Or simply return
  EA64                    endif  ; noise
  EA64           
  EA64           iftog:
  EA64 7E                ld      a,(hl)          ; Get if-status message byte
  EA65 A8                xor     b               ; Flip current state
  EA66 77                ld      (hl),a          ; Put result back in message byte
  EA67                                           ; ..and fall thru to print status
  EA67           
  EA67                    if     not noise
  EA67 C9                ret
  EA68                    endif
  EA68           
  EA68           ;-----------------------------------------------------------------------------
  EA68           
  EA68           ; Indicate if current IF is True or False
  EA68           
  EA68                    if     ifqopt or [noise and [andopt or oropt]]
  EA68           
  EA68           ifstat0:
  EA68 CD9EEA            call    nl
  EA6B           
  EA6B                    endif  ; ifqopt or [noise and [andopt or oropt]]
  EA6B           
  EA6B                    if     noise or ifqopt
  EA6B           
  EA6B           ifstat:
  EA6B           
  EA6B CDE9EB            call    prif
  EA6E           
  EA6E CD14EB            call    msgbf1          ; Get current if byte and set flags
  EA71 47                ld      b,a             ; Get it into B
  EA72 2008              jr      nz,ifstat1      ; Nz means if active
  EA74           
  EA74 CDF0EB            call    print
  EA77 4E6F6EE5          db      'Non','e'+80h
  EA7B C9                ret
  EA7C           
  EA7C           ifstat1:
  EA7C 7E                ld      a,(hl)          ; Get if-status message byte
  EA7D A0                and     b               ; Mask in currently active IF level status
  EA7E 0E46              ld      c,'F'           ; Load with false indicator
  EA80 2802              jr      z,ifstat2       ; If current IF is false, jump
  EA82 0E54              ld      c,'T'           ; Else, load with true indicator
  EA84           ifstat2:
  EA84 79                ld      a,c
  EA85 CD8DEA            call    conout
  EA88           
  EA88 CB38              srl     b               ; Drop one IF level
  EA8A 20F0              jr      nz,ifstat1      ; Loop through all IF states
  EA8C C9                ret
ZAS Relocating Macro Assembler (v3.05                             page   40
                                                            
                                                            

  EA8D           
  EA8D                    endif  ; noise or ifqopt
  EA8D           
  EA8D           ;-----------------------------------------------------------------------------
  EA8D           
  EA8D           ;  Console Output Routine
  EA8D           
  EA8D           conout:
  EA8D E5                push    hl              ; Save regs
  EA8E D5                push    de
  EA8F C5                push    bc
  EA90 F5                push    af
  EA91 E67F              and     7fh             ; Clear msb
  EA93 5F                ld      e,a             ; Char in E
  EA94 0E02              ld      c,2             ; Output
  EA96 CD0500            call    bdose
  EA99 F1                pop     af              ; Get regs
  EA9A C1                pop     bc
  EA9B D1                pop     de
  EA9C E1                pop     hl
  EA9D C9                ret
  EA9E           
  EA9E           ;-------------------------
  EA9E           
  EA9E           ;  Output CRLF
  EA9E           
  EA9E           nl:
  EA9E CDF0EB            call    print
  EAA1 0D8A              db      cr,lf+80h
  EAA3 C9                ret
  EAA4           
  EAA4           ;-----------------------------------------------------------------------------
  EAA4           
  EAA4           ; Command:  OR
  EAA4           
  EAA4           ;       This command performs a logical or operation by updating the
  EAA4           ;       if state without going to a new level.  If there are active
  EAA4           ;       IFs and the current state is true, we do nothing.  Else we back
  EAA4           ;       up one level and fall through to normal IF processing.
  EAA4           
  EAA4                   if      oropt
  EAA4           
  EAA4           orstart:
  EAA4 CD14EB            call    msgbf1          ; Get if active byte
  EAA7 2808              jr      z,backup        ; Treat like if if no IFs active
  EAA9 A6                and     (hl)            ; Check current state
  EAAA 2805              jr      z,backup        ; Current STATE false so go proecess
  EAAC           
  EAAC                   if      noise
  EAAC                   jr      ifstat0         ; Else return and show status
  EAAC                   else
  EAAC C9                ret                     ; Or just return
  EAAD           
  EAAD                   endif                   ; Noise
  EAAD                   endif           ; Oropt
  EAAD           
ZAS Relocating Macro Assembler (v3.05                             page   41
                                                            
                                                            

  EAAD           ;-----------------------------------------------------------------------------
  EAAD           
  EAAD           ; Command:  AND
  EAAD           
  EAAD           ;       This command performs a logical and operation by updating the
  EAAD           ;       if state without going to a new level.  If there are active
  EAAD           ;       IFs and the current state is false, we do nothing.  Else we back
  EAAD           ;       up one level and fall through to normal IF processing.
  EAAD           
  EAAD                   if      andopt
  EAAD           
  EAAD           andstart:
  EAAD CD0AEB            call    iftest          ; Test for IF running and false
  EAB0                   if      noise
  EAB0                   jr      z,ifstat0       ; Condition met, show status & return
  EAB0                   else
  EAB0 C8                ret     z               ; Condition met, return
  EAB1                   endif                   ; Noise
  EAB1                   endif           ; Andopt
  EAB1           
  EAB1           ; Common stuff for and and or
  EAB1           
  EAB1                   if andopt or oropt
  EAB1           
  EAB1           backup:
  EAB1 2B                dec     hl              ; Pt to flag byte
  EAB2 CB3E              srl     (hl)            ; Drop back one level
  EAB4           ;
  EAB4           ; Poke "IF" into external fcb for transient
  EAB4           ;
  EAB4                   if      comif
  EAB4           pokefcb:
  EAB4 11D1ED            ld      de,extfcb+1     ; Pt to external fcb
  EAB7 2106EA            ld      hl,ifcmd        ; Pointer to IF command in table
  EABA 010400            ld      bc,cmdsize      ; Length
  EABD EDB0              ldir                    ; Move it in
  EABF           
  EABF                   endif                   ; comif
  EABF           
  EABF           ;       Fall through to IF PROCESSING
  EABF                   endif                   ;Andopt or oropt
  EABF           
  EABF           ;-----------------------------------------------------------------------------
  EABF           
  EABF           ; FCP Command: IF
  EABF           ;
  EABF           ;       If current IF state is false, then advance to next level and set it
  EABF           ;       to false also.  If current IF state is true, then test condition and
  EABF           ;       set the next level accordingly.
  EABF           
  EABF           ifstart:
  EABF                    if     noise
  EABF                   call    nl              ; Print new line
  EABF                    endif  ; noise
  EABF           
  EABF CD0AEB            call    iftest          ; See if current IF is running and FALSE
ZAS Relocating Macro Assembler (v3.05                             page   42
                                                            
                                                            

  EAC2 282F              jr      z,ifcf
  EAC4           
  EAC4           
  EAC4           ; Test for presence of colon in command.  If colon present, then go directly
  EAC4           ; to COMIF processing.
  EAC4           
  EAC4           
  EAC4                    if     comif
  EAC4           
  EAC4 3AD0ED            ld      a,(extfcb)      ; Check drive byte of external FCB
  EAC7 B7                or      a               ; If it is zero, no colon was present
  EAC8 C256EB            jp      nz,runcomif     ; If colon, go to comif processing
  EACB                                           ; Else fall through to resident code
  EACB                    endif  ; comif
  EACB           
  EACB           ;-----------------------------------------------------------------------------
  EACB           ;
  EACB           ;       R E S I D E N T    C O M M A N D    P R O C E S S I N G
  EACB           ;
  EACB           ;-----------------------------------------------------------------------------
  EACB           
  EACB           resident:
  EACB           
  EACB           ; Test for Equality if Equal Sign in Token
  EACB           
  EACB                    if     ifoeq
  EACB           
  EACB                   ld      hl,tbuff+1
  EACB           
  EACB                    if     xeqopt          ; Extended equal testing
  EACB           
  EACB           skipsp:                         ; Skip over any space to first token
  EACB                   ld      a,(hl)
  EACB                   or      a               ; Check for end of tail
  EACB                   jr      z,ifck0         ; If so , go on
  EACB                   cp      ' '+1           ; Test for space or control character
  EACB                   jr      nc,tsteq        ; If not, we are at first token
  EACB                   inc     hl              ; Otherwise advance to next character
  EACB                   jr      skipsp          ; ..and continue testing
  EACB           
  EACB                    endif  ; xeqopt
  EACB           
  EACB           tsteq:
  EACB                   ld      a,(hl)          ; Get character from command tail
  EACB                   inc     hl              ; Point to next one
  EACB                   or      a               ; EOL?
  EACB                   jr      z,ifck0         ; Continue if so
  EACB           
  EACB                    if     xeqopt
  EACB                   cp      ' '+1           ; End of token?
  EACB                   jr      c,ifck0         ; If so, go on
  EACB                    endif  ; xeqopt
  EACB           
  EACB                   cp      '='             ; Found '=' ?
  EACB                   jr      nz,tsteq        ; If not, continue scan
  EACB           
ZAS Relocating Macro Assembler (v3.05                             page   43
                                                            
                                                            

  EACB                   ld      hl,fcb1+1       ; Else, get ready to compare FCBs
  EACB                   ld      de,fcb2+1
  EACB                   ld      b,11            ; 11 bytes
  EACB           eqtest:
  EACB                   ld      a,(de)          ; Compare
  EACB                   cp      (hl)
  EACB                   jr      nz,ifcf
  EACB                   inc     hl              ; Pt to next
  EACB                   inc     de
  EACB                   djnz    eqtest
  EACB                   jr      ifct
  EACB           
  EACB                    endif  ; ifoeq
  EACB           
  EACB           
  EACB           ifck0:
  EACB 115D00            ld      de,fcb1+1       ; Point to first character in FCB1
  EACE           
  EACE                    if     ifoneg
  EACE 1A                ld      a,(de)          ; Get it
  EACF 3206EB            ld      (negflag),a     ; Set negate flag
  EAD2 FE7E              cp      negchar         ; Is it a negate?
  EAD4 2001              jr      nz,ifck1        ; If not, go on
  EAD6 13                inc     de              ; Else point to character after negchar
  EAD7           ifck1:
  EAD7                    endif  ; ifoneg
  EAD7           
  EAD7                    if     iforeg          ; REGISTERS
  EAD7                   call    regtest         ; Test for register value
  EAD7                   jr      nz,runreg
  EAD7                    endif  ; iforeg
  EAD7           
  EAD7 CD1BEB            call    condtest        ; Test of condition match
  EADA 2003              jr      nz,runcond      ; If found, process condition
  EADC           
  EADC                    if     comif
  EADC C356EB            jp      runcomif        ; If function not found in table, use transient
  EADF                   else
  EADF           
  EADF                   call    print           ; Beep to indicate error
  EADF                   db      bell+80h
  EADF           
  EADF                    if     noise
  EADF                   jp      ifstat          ; No condition, display current condition
  EADF                    else   ; no noise
  EADF                   ret
  EADF                    endif  ; noise
  EADF                    endif  ; comif
  EADF           
  EADF           ;-----------------------------------------------------------------------------
  EADF           ;
  EADF           ; Process register - register value is in A
  EADF           ;
  EADF           ;-----------------------------------------------------------------------------
  EADF           
  EADF                    if     iforeg
ZAS Relocating Macro Assembler (v3.05                             page   44
                                                            
                                                            

  EADF           runreg:
  EADF                   push    af              ; Save value
  EADF                   call    getnum          ; Extract value in FCB2 as a number
  EADF                   pop     af              ; Get value
  EADF                   cp      b               ; Compare against extracted value
  EADF                   jr      jrtrue          ; True if match; false if not
  EADF                    endif  ; iforeg
  EADF           
  EADF           ;-----------------------------------------------------------------------------
  EADF           ;
  EADF           ; Process conditional test - address of conditional routine is in HL
  EADF           ;
  EADF           ;-----------------------------------------------------------------------------
  EADF           
  EADF           runcond:
  EADF E9                jp      (hl)            ; "call" routine pted to by HL
  EAE0           
  EAE0           ;=============================================================================
  EAE0           ;
  EAE0           ;               R E S I D E N T    C O N D I T I O N    O P T I O N S
  EAE0           ;
  EAE0           ;=============================================================================
  EAE0           
  EAE0           ; Condition:  AMBIGUOUS
  EAE0           
  EAE0                    if     ifambig
  EAE0           
  EAE0           ifcambig:
  EAE0                   ld      hl,fcb2+1       ; Scan FCB2 for a '?' character
  EAE0                   ld      bc,11           ; Characters to scan
  EAE0                   ld      a,'?'           ; Reference character
  EAE0                   cpir
  EAE0                   jr      jrtrue          ; True if '?' found; false if not
  EAE0           
  EAE0                    endif  ; ifambig
  EAE0           
  EAE0           ;-----------------------------------------------------------------------------
  EAE0           
  EAE0           ; Condition:  COMPRESSED
  EAE0           
  EAE0                    if     ifcompr
  EAE0           
  EAE0           ifccompr:
  EAE0                   ld      a,(fcb2+10)     ; Get middle character of file type
  EAE0                   cp      'Z'             ; Crunched
  EAE0                   jr      z,ifctrue
  EAE0                   cp      'Q'             ; Squeezed
  EAE0                   jr      jrtrue
  EAE0           
  EAE0                    endif  ; ifcompr
  EAE0           
  EAE0           ;-----------------------------------------------------------------------------
  EAE0           
  EAE0           ; Condition:  TRUE
  EAE0           ;       IFCTRUE  enables an active IF
  EAE0           ; Condition:  FALSE
ZAS Relocating Macro Assembler (v3.05                             page   45
                                                            
                                                            

  EAE0           ;       IFCFALSE enables an inactive IF
  EAE0           
  EAE0                    if     ifoempty or ifoerror or ifoexist or ifowheel
  EAE0           jrfalse:
  EAE0 280C              jr      z,ifcfalse
  EAE2                    endif  ; Ifoempty or ifoerror or ifoexist or ifowheel
  EAE2           
  EAE2           ifctrue:
  EAE2           
  EAE2                    if     ifoneg
  EAE2 CD05EB            call    negtest         ; Test for negate
  EAE5 280C              jr      z,ifcf
  EAE7                    endif  ; ifoneg
  EAE7           
  EAE7           ifct:
  EAE7 06FF              ld      b,0ffh          ; Active
  EAE9 C338EB            jp      ifset
  EAEC           
  EAEC                    if     iforeg or ifambig or ifcompr or ifoinput or ifonull
  EAEC           jrtrue:
  EAEC 28F4              jr      z,ifctrue
  EAEE                    endif  ; Iforeg or ifambig or ifcompr or ifoinput or ifonull
  EAEE           
  EAEE           ifcfalse:
  EAEE           
  EAEE                    if     ifoneg
  EAEE CD05EB            call    negtest         ; Test for negate
  EAF1 28F4              jr      z,ifct
  EAF3                    endif  ; ifoneg
  EAF3           
  EAF3           ifcf:
  EAF3 0600              ld      b,0             ; Inactive
  EAF5 C338EB            jp      ifset
  EAF8           
  EAF8           ;-----------------------------------------------------------------------------
  EAF8           
  EAF8           ; Condition: EMPTY filename.typ
  EAF8           
  EAF8                    if     ifoempty
  EAF8           ifcempty:
  EAF8                   call    tlog            ; Log into FCB2's DU
  EAF8                   ld      de,fcb2         ; Pt to fcb2
  EAF8                   ld      c,15            ; Open file
  EAF8                   push    de              ; Save fcb ptr
  EAF8                   call    bdose
  EAF8                   pop     de
  EAF8                   inc     a               ; Not found?
  EAF8                   jr      z,ifctrue
  EAF8                   ld      c,20            ; Try to read a record
  EAF8                   xor     a               ; <JPS> set cr value to zero
  EAF8                   ld      (fcb2+32),a     ; <JPS> to attempt to read first record
  EAF8                   call    bdose
  EAF8                   or      a               ; 0=OK
  EAF8                   jr      jrfalse         ; true if no read
  EAF8                    endif  ; ifoempty
  EAF8           
ZAS Relocating Macro Assembler (v3.05                             page   46
                                                            
                                                            

  EAF8           ;-----------------------------------------------------------------------------
  EAF8           
  EAF8           ; Condition: ERROR
  EAF8           
  EAF8                    if     ifoerror
  EAF8           ifcerror:
  EAF8 3A86ED            ld      a,(z3msg+6)     ; Get error byte
  EAFB B7                or      a               ; 0=FALSE (no error registered)
  EAFC 18E2              jr      jrfalse
  EAFE                    endif  ; ifoerror
  EAFE           
  EAFE           ;-----------------------------------------------------------------------------
  EAFE           
  EAFE           ; Condition: EXIST filename.typ
  EAFE           
  EAFE                    if     ifoexist
  EAFE           ifcex:
  EAFE                   call    tlog            ; Log into DU
  EAFE                   ld      de,fcb2         ; Pt to fcb
  EAFE                   ld      c,17            ; Search for first
  EAFE                   call    bdose
  EAFE                   inc     a               ; Set zero if error
  EAFE                   jr      jrfalse
  EAFE                    endif                  ; Ifoexist
  EAFE           
  EAFE           ;-----------------------------------------------------------------------------
  EAFE           
  EAFE           ; Condition: INPUT (from user)
  EAFE           
  EAFE                    if     ifoinput
  EAFE           ifcinput:
  EAFE                   ld      hl,z3msg+7      ; Pt to ZEX message byte
  EAFE                   ld      (hl),10b        ; Suspend ZEX input
  EAFE                   push    hl              ; Save ptr to ZEX message byte
  EAFE           
  EAFE                    if     not noise
  EAFE                   call    nl
  EAFE                    endif  ; not noise
  EAFE           
  EAFE                   call    prif
  EAFE                   call    print
  EAFE                   db      'True?',' '+80h
  EAFE                   ld      c,1             ; Input from console
  EAFE                   call    bdose
  EAFE                   pop     hl              ; Get ptr to ZEX message byte
  EAFE                   ld      (hl),0          ; Return ZEX to normal processing
  EAFE                   cp      ' '             ; Yes?
  EAFE                   jr      z,ifctrue
  EAFE                   and     5fh             ; Mask and capitalize user input
  EAFE                   cp      'T'             ; True?
  EAFE                   jr      z,ifctrue
  EAFE                   cp      'Y'             ; Yes?
  EAFE                   jr      z,ifctrue
  EAFE                   cp      cr              ; Yes?
  EAFE                   jr      jrtrue
  EAFE           
ZAS Relocating Macro Assembler (v3.05                             page   47
                                                            
                                                            

  EAFE                    endif  ; ifoinput
  EAFE           
  EAFE           ;-----------------------------------------------------------------------------
  EAFE           
  EAFE           ; Condition:  NULL (2nd file name)
  EAFE           
  EAFE                    if     ifonull
  EAFE           ifcnull:
  EAFE 3A6D00            ld      a,(fcb2+1)      ; Get first char of 2nd file name
  EB01 FE20              cp      ' '             ; Space = null
  EB03 18E7              jr      jrtrue
  EB05                    endif  ; ifonull
  EB05           
  EB05           ;-----------------------------------------------------------------------------
  EB05           
  EB05           ; Condition:  TCAP
  EB05           
  EB05                    if     ifotcap
  EB05           ifctcap:
  EB05                   ld      a,(z3env+80h)   ; Get first char of Z3 TCAP Entry
  EB05                   cp      ' '+1           ; Space or less = none
  EB05                   jr      c,ifcfalse
  EB05                   jr      ifctrue
  EB05                    endif  ; ifotcap
  EB05           
  EB05           ;-----------------------------------------------------------------------------
  EB05           
  EB05           ; Condition:  WHEEL
  EB05           
  EB05                    if     ifowheel
  EB05           ifcwheel:
  EB05                   ld      hl,(z3env+29h)  ; Get address of wheel byte
  EB05                   ld      a,(hl)          ; Get byte
  EB05                   or      a               ; Test for true
  EB05                   jr      jrfalse ; False if 0
  EB05                    endif  ; ifowheel
  EB05           
  EB05           ;=============================================================================
  EB05           ;
  EB05           ;               S U P P O R T    R O U T I N E S
  EB05           ;
  EB05           ;=============================================================================
  EB05           
  EB05           ; Convert chars in FCB2 into a number in B
  EB05           
  EB05                    if     iforeg
  EB05           getnum:
  EB05                   ld      b,0             ; Set number
  EB05                   ld      hl,fcb2+1       ; Pt to first char
  EB05           getn1:
  EB05                   ld      a,(hl)          ; Get char
  EB05                   inc     hl              ; Pt to next
  EB05                   sub     '0'             ; Convert to binary
  EB05                   ret     c               ; Done if error
  EB05                   cp      10              ; Range?
  EB05                   ret     nc              ; Done if out of range
ZAS Relocating Macro Assembler (v3.05                             page   48
                                                            
                                                            

  EB05                   ld      c,a             ; Value in C
  EB05                   ld      a,b             ; A=old value
  EB05                   add     a,a             ; *2
  EB05                   add     a,a             ; *4
  EB05                   add     a,b             ; *5
  EB05                   add     a,a             ; *10
  EB05                   add     a,c             ; Add in new digit value
  EB05                   ld      b,a             ; Result in B
  EB05                   jr      getn1           ; Continue processing
  EB05                    endif  ; iforeg
  EB05           
  EB05           ;-----------------------------------------------------------------------------
  EB05           
  EB05           ; Log into DU in FCB2
  EB05           
  EB05                    if     ifoexist or ifoempty
  EB05           
  EB05           tlog:
  EB05                   ld      a,(fcb2)        ; Get disk
  EB05                   or      a               ; Current?
  EB05                   jr      nz,tlog1
  EB05                   ld      c,25            ; Get disk
  EB05                   call    bdose
  EB05                   inc     a               ; Increment for following decrement
  EB05           tlog1:
  EB05                   dec     a               ; A=0
  EB05                   ld      e,a             ; Disk in E
  EB05                   ld      c,14
  EB05                   call    bdose
  EB05                   ld      a,(fcb2+13)     ; Pt to user
  EB05                   ld      e,a
  EB05                   ld      c,32            ; Set user
  EB05                   jp      bdose
  EB05           
  EB05                    endif  ; ifoexist or ifoempty
  EB05           
  EB05           ;-----------------------------------------------------------------------------
  EB05           
  EB05           ; Test of Negate Flag = negchar
  EB05           
  EB05                    if     ifoneg
  EB05           negtest:
  EB06 =         negflag equ     $+1             ; Pointer for in-the-code modification
  EB05 3E00              ld      a,0             ; 2nd byte is filled in
  EB07 FE7E              cp      negchar         ; Test for No
  EB09 C9                ret
  EB0A                    endif  ; ifoneg
  EB0A           
  EB0A           ;-----------------------------------------------------------------------------
  EB0A           
  EB0A           ; Test FCB1 against a single digit (0-9)
  EB0A           ;  Return with register value in A and NZ if so
  EB0A           
  EB0A                    if     iforeg
  EB0A           regtest:
  EB0A                   ld      a,(de)          ; Get digit
ZAS Relocating Macro Assembler (v3.05                             page   49
                                                            
                                                            

  EB0A                   sub     '0'
  EB0A                   jr      c,zret          ; Z flag for no digit
  EB0A                   cp      10              ; Range?
  EB0A                   jr      nc,zret         ; Z flag for no digit
  EB0A                   ld      hl,z3msg+30h    ; Pt to registers
  EB0A                   add     a,l             ; Pt to register
  EB0A                   ld      l,a
  EB0A                   ld      a,h             ; Add in H
  EB0A                   adc     0
  EB0A                   ld      h,a
  EB0A                   xor     a               ; Set NZ
  EB0A                   dec     a
  EB0A                   ld      a,(hl)          ; Get register value
  EB0A                   ret
  EB0A           zret:
  EB0A                   xor     a               ; Set Z
  EB0A                   ret
  EB0A                    endif  ; iforeg
  EB0A           
  EB0A           ;-----------------------------------------------------------------------------
  EB0A           
  EB0A           ; Test to see if a current IF is running and if it is FALSE
  EB0A           ;   If so, return with Zero Flag Set (Z)
  EB0A           ;   If not, return with Zero Flag Clear (NZ)
  EB0A           ; Affect only HL and PSW
  EB0A           
  EB0A           iftest:
  EB0A CD14EB            call    msgbf1          ; Test for active IF
  EB0D 2802              jr      z,ifok          ; No active IF
  EB0F A6                and     (hl)            ; Check active flag
  EB10 C8                ret     z               ; Return Z since IF running and FALSE
  EB11           ifok:
  EB11 AF                xor     a               ; Return NZ for OK
  EB12 3D                dec     a
  EB13 C9                ret
  EB14           
  EB14           msgbf1:
  EB14 2181ED            ld      hl,z3msg+1      ; Get IF active flag
  EB17 7E                ld      a,(hl)
  EB18 23                inc     hl              ; Pt to If status byte
  EB19 B7                or      a               ; Set z if no IF active
  EB1A C9                ret
  EB1B           
  EB1B           ;-----------------------------------------------------------------------------
  EB1B           
  EB1B           ; Test FCB1 against condition table (must have 2-char entries)
  EB1B           ;  Return with routine address in HL if match and NZ flag
  EB1B           
  EB1B           condtest:
  EB1B 2137EA            ld      hl,condtab      ; Pt to table
  EB1E           condt1:
  EB1E 7E                ld      a,(hl)          ; End of table?
  EB1F B7                or      a
  EB20 C8                ret     z
  EB21 1A                ld      a,(de)          ; Get char
  EB22 BE                cp      (hl)            ; Comppare entries
ZAS Relocating Macro Assembler (v3.05                             page   50
                                                            
                                                            

  EB23 23                inc     hl              ; Pt to next
  EB24 13                inc     de
  EB25 200B              jr      nz,condt2
  EB27 1A                ld      a,(de)          ; Get 2nd char
  EB28 BE                cp      (hl)            ; Compare
  EB29 2007              jr      nz,condt2
  EB2B 23                inc     hl              ; Pt to address
  EB2C 7E                ld      a,(hl)          ; Get address in HL
  EB2D 23                inc     hl
  EB2E 66                ld      h,(hl)
  EB2F 6F                ld      l,a             ; HL = address
  EB30 18DF              jr      ifok            ; Set NZ for OK
  EB32           condt2:
  EB32 23                inc     hl              ; Pt to next entry
  EB33 23                inc     hl              ; Skip over addr
  EB34 23                inc     hl
  EB35 1B                dec     de              ; Pt to 1st char of condition
  EB36 18E6              jr      condt1
  EB38           
  EB38           ;-----------------------------------------------------------------------------
  EB38           
  EB38           ; Turn on next IF level
  EB38           ;   B register is 0 if level is inactive, 0FFH if level is active
  EB38           
  EB38           ifset:
  EB38 2181ED            ld      hl,z3msg+1      ; Get IF flag
  EB3B 7E                ld      a,(hl)
  EB3C B7                or      a               ; If no if at all, start 1st one
  EB3D 2806              jr      z,ifset1
  EB3F           ifset0:
  EB3F 87                add     a,a             ; Advance to next level
  EB40 380F              jr      c,iferr         ; Check for overflow (8 IFs max)
  EB42 77                ld      (hl),a          ; Set IF byte
  EB43 1802              jr      ifset2
  EB45           ifset1:
  EB45 3C                inc     a               ; A=1
  EB46 77                ld      (hl),a          ; Set 1st IF
  EB47           ifset2:
  EB47 57                ld      d,a             ; Get IF byte
  EB48 A0                and     b               ; Set interested bit
  EB49 47                ld      b,a
  EB4A 23                inc     hl              ; Pt to active flag
  EB4B 7A                ld      a,d             ; Complement IF byte
  EB4C 2F                cpl
  EB4D A6                and     (hl)            ; Mask in only uninterested bits
  EB4E B0                or      b               ; Mask in interested bit
  EB4F 77                ld      (hl),a          ; Save result
  EB50           
  EB50                    if     noise
  EB50                   jp      ifstat          ; Print status and exit
  EB50                   else
  EB50 C9                ret                     ; Or just exit
  EB51                    endif  ; noise
  EB51           
  EB51           iferr:
  EB51 CDF0EB            call    print           ; Beep to indicate overflow
ZAS Relocating Macro Assembler (v3.05                             page   51
                                                            
                                                            

  EB54 87                db      bell+80h
  EB55 C9                ret
  EB56           
  EB56           ;=============================================================================
  EB56           ;
  EB56           ;               T  R A N S I E N T    I F    P R O C E S S I N G
  EB56           ;
  EB56           ;=============================================================================
  EB56           
  EB56           
  EB56                    if     comif
  EB56           
  EB56           runcomif:
  EB56           
  EB56           ; First we have to find IF.COM
  EB56           
  EB56                    if     pathroot
  EB56           
  EB56 010000            ld      bc,100h*[ifdrv-'A'] + ifusr     ; Values to use if null path
  EB59 21F4ED            ld      hl,expath       ; Point to symbolic path
  EB5C           
  EB5C           fndroot:
  EB5C 7E                ld      a,(hl)          ; Check for end of path
  EB5D B7                or      a
  EB5E 2817              jr      z,froot2        ; If end, branch
  EB60           
  EB60           ; Process Next Path Element
  EB60           
  EB60 FE24              cp      curint          ; Current disk/user symbol?
  EB62 2004              jr      nz,froot0       ; If not, branch
  EB64 3AAFED            ld      a,(curdr)       ; Get current disk
  EB67 3C                inc     a               ; Compensate for following decrement
  EB68           froot0:
  EB68 3D                dec     a               ; Shift to range 0..15
  EB69 47                ld      b,a             ; Set disk
  EB6A 23                inc     hl              ; Point to user in path
  EB6B 7E                ld      a,(hl)          ; Get user
  EB6C FE24              cp      curint          ; Current drive/user symbol?
  EB6E 2003              jr      nz,froot1       ; If not, branch
  EB70 3AAEED            ld      a,(curusr)      ; Get current user
  EB73           froot1:
  EB73 4F                ld      c,a             ; Set user
  EB74 23                inc     hl              ; Point to next element in symbolic path
  EB75 18E5              jr      fndroot
  EB77           
  EB77           ; Done with Search - BC Contains ROOT DU (or specified DU if path is empty)
  EB77           
  EB77                   else    ; not pathroot
  EB77           
  EB77                   ld      bc,100h*[ifdrv-'A'] + ifusr     ; Used specified DU
  EB77           
  EB77                    endif  ; pathroot
  EB77           
  EB77           froot2:
  EB77 CDCCEB            call    logbc           ; Log into IF.COM's directory
  EB7A           
ZAS Relocating Macro Assembler (v3.05                             page   52
                                                            
                                                            

  EB7A           ; Try to Open File IF.COM
  EB7A           
  EB7A 110080            ld      de,comifadr     ; Set DMA to scratch address
  EB7D CDDAEB            call    setdma
  EB80           
  EB80 11D0ED            ld      de,extfcb       ; Point to command FCB
  EB83 AF                xor     a
  EB84 12                ld      (de),a          ; Force current drive
  EB85 0E0F              ld      c,15            ; Open file
  EB87 CD0500            call    bdose
  EB8A 3C                inc     a
  EB8B 2009              jr      nz,ifload       ; Branch if file found
  EB8D           
  EB8D           ; IF.COM not found - process as IF F
  EB8D           
  EB8D           ifnotfnd:
  EB8D CD51EB            call    iferr           ; Ring bell
  EB90 CDC2EB            call    reset           ; Return home
  EB93 C3F3EA            jp      ifcf
  EB96           
  EB96           ; Load File IF.COM
  EB96           
  EB96           ifload:
  EB96 CDDFEB            call    readcmd         ; Read record from file
  EB99 20F2              jr      nz,ifnotfnd     ; If eof, treat as if file not found
  EB9B 3A0880            ld      a,(comifadr+8)  ; Get environment type
  EB9E FE03              cp      3               ; If not type 3
  EBA0 20EB              jr      nz,ifnotfnd     ; ..treat as if file not found
  EBA2 2A0B80            ld      hl,(comifadr+0bh) ; Get type-3 execution address into HL
  EBA5 AF                xor     a               ; Reset current record value to 0
  EBA6 32F0ED            ld      (extfcb+20h),a  ; ..to start reading again from beginning
  EBA9           
  EBA9           ; Read in the file
  EBA9           
  EBA9 E5                push    hl              ; Save execution address on stack
  EBAA           ifload1:
  EBAA E5                push    hl              ; Save loading address
  EBAB EB                ex      de,hl           ; Set DMA address
  EBAC CDDAEB            call    setdma
  EBAF CDDFEB            call    readcmd         ; Read a record from file
  EBB2 E1                pop     hl              ; Get current loading address back
  EBB3 2006              jr      nz,ifload2      ; Branch if done reading
  EBB5 118000            ld      de,80h          ; Advance it by one record
  EBB8 19                add     hl,de
  EBB9 18EF              jr      ifload1         ; Back to read some more
  EBBB           
  EBBB           ; Reset Environment (DMA and DU) and Run IF.COM
  EBBB           
  EBBB           ifload2:
  EBBB CDC2EB            call    reset           ; Reset DMA and directory
  EBBE 2100EC            ld      hl,z3env        ; Call IF.COM with HL pointing to ENV
  EBC1 C9                ret                     ; Run IF.COM (execution address on stack)
  EBC2           
  EBC2           ; Reset DMA and Current DU
  EBC2           
  EBC2           reset:
ZAS Relocating Macro Assembler (v3.05                             page   53
                                                            
                                                            

  EBC2 118000            ld      de,80h          ; Reset DMA address
  EBC5 CDDAEB            call    setdma
  EBC8 ED4BAEED          ld      bc,(curusr)     ; Return home
  EBCC           
  EBCC           ; Log Into DU in BC
  EBCC           
  EBCC           logbc:
  EBCC 58                ld      e,b             ; Set disk
  EBCD C5                push    bc
  EBCE 0E0E              ld      c,14            ; Select disk
  EBD0 CD0500            call    bdose
  EBD3 C1                pop     bc
  EBD4 59                ld      e,c             ; Set user
  EBD5 0E20              ld      c,32            ; Select user
  EBD7 C30500            jp      bdose
  EBDA           
  EBDA           ; Set DMA to address in DE register
  EBDA           
  EBDA           setdma:
  EBDA 0E1A              ld      c,26
  EBDC C30500            jp      bdose
  EBDF           
  EBDF           ; Read a record from file in EXTFCB
  EBDF           
  EBDF           readcmd:
  EBDF 11D0ED            ld      de,extfcb
  EBE2 0E14              ld      c,20
  EBE4 CD0500            call    bdose
  EBE7 B7                or      a               ; Set NZ if error (end of file)
  EBE8 C9                ret
  EBE9           
  EBE9                    endif  ; comif
  EBE9           
  EBE9           ;=============================================================================
  EBE9           ;
  EBE9           ;               U T I L I T Y    S U B R O U T I N E S
  EBE9           ;
  EBE9           ;=============================================================================
  EBE9           
  EBE9           ;  Print " IF"
  EBE9           
  EBE9           prif:
  EBE9 CDF0EB            call    print
  EBEC 4946A0            db      'IF',' '+80h
  EBEF C9                ret
  EBF0           
  EBF0           ;-----------------------------------------------------------------------------
  EBF0           
  EBF0           ;  Print String (terminated in 0 or MSB Set) at Return Address
  EBF0           
  EBF0           print:
  EBF0 E3                ex      (sp),hl         ; Get address
  EBF1 CDF6EB            call    print1
  EBF4 E3                ex      (sp),hl         ; Put address
  EBF5 C9                ret
  EBF6           
ZAS Relocating Macro Assembler (v3.05                             page   54
                                                            
                                                            

  EBF6           ;  Print String (terminated by MSB Set) pted to by HL
  EBF6           
  EBF6           print1:
  EBF6 7E                ld      a,(hl)          ; Done?
  EBF7 23                inc     hl              ; Pt to next
  EBF8 CD8DEA            call    conout          ; Print char
  EBFB B7                or      a               ; Set msb flag (m)
  EBFC F8                ret     m               ; Msb terminator
  EBFD 18F7              jr      print1
  EBFF           
  EBFF           ;=============================================================================
  EBFF           ;
  EBFF           ; Test for Size Error
  EBFF           
  EBFF                    if     [$ gt [fcp + fcps*128]]
  EBFF                   ***  FCP is too large  ***
  EBFF                    endif
  EBFF           
  EBFF                   end

**** Symbol table ****
ANDOPT          FFFF ANDSTART        EAAD BACKUP          EAB1
BASE            0000 BDOS            CA06 BDOSB           CA00
BDOSE           0005 BELL            0007 BIAS            8E00
BIOREAS         0A00 BIOS            D800 BIOSTDS         0600
CCP             C200 CMDSIZE         0004 COMIF           FFFF
COMIFADR        8000 COMMAND         F9AB CONDT1          EB1E
CONDT2          EB32 CONDTAB         EA37 CONDTEST        EB1B
CONOUT          EA8D COUNT           0001 CR              000D
CTAB            EA06 CTABLE          FE05 CURDR           EDAF
CURINT          0024 CURUSR          EDAE EXPATH          EDF4
EXPATHS         0005 EXTFCB          EDD0 EXTRABIAS       1200
EXTSTK          EFD0 FALSE           0000 FCB1            005C
FCB2            006C FCP             EA00 FCPS            0004
FF              000C FLAG            0003 FNDROOT         EB5C
FROOT0          EB68 FROOT1          EB73 FROOT2          EB77
GETREG          FCB3 HASEDS          FFFF HIGHUSER        0000
IDISK1          0024 IDISK2          0024 IDISK3          0001
IDISK4          0001 IFAMBIG         0000 IFCERROR        EAF8
IFCF            EAF3 IFCFALSE        EAEE IFCK0           EACB
IFCK1           EAD7 IFCMD           EA06 IFCNULL         EAFE
IFCOMPR         0000 IFCT            EAE7 IFCTRUE         EAE2
IFDRV           0041 IFELSE          EA5A IFEND           EA50
IFENDMSG        EA57 IFERR           EB51 IFEXIT          EA45
IFEXIT1         EA49 IFLOAD          EB96 IFLOAD1         EBAA
IFLOAD2         EBBB IFNDERR         EA59 IFNOTFND        EB8D
IFOEMPTY        0000 IFOEQ           0000 IFOERROR        FFFF
IFOEXIST        0000 IFOINPUT        0000 IFOK            EB11
IFONEG          FFFF IFONULL         FFFF IFOREG          0000
IFOTCAP         0000 IFOTRUE         0000 IFOWHEEL        0000
IFQOPT          FFFF IFSET           EB38 IFSET0          EB3F
IFSET1          EB45 IFSET2          EB47 IFSTART         EABF
IFSTAT          EA6B IFSTAT0         EA68 IFSTAT1         EA7C
IFSTAT2         EA84 IFTEST          EB0A IFTOG           EA64
IFUSR           0000 IFZERO          EA43 INTRON          0000
IOP             0000 IOPS            0000 IUSER1          0024
ZAS Relocating Macro Assembler (v3.05                             page   55
                                                            
                                                            

IUSER2          000F IUSER3          0024 IUSER4          000F
JRFALSE         EAE0 JRTRUE          EAEC LF              000A
LOGBC           EBCC MSGBF1          EB14 MSIZE           003C
NEGCHAR         007E NEGFLAG         EB06 NEGTEST         EB05
NL              EA9E NO              0000 NOISE           0000
OPT0            EA40 OPT1            EA41 OPT2            EA42
OPTFLAG         FC3E OROPT           FFFF ORSTART         EAA4
PATHROOT        FFFF POKEFCB         EAB4 PRIF            EBE9
PRINT           EBF0 PRINT1          EBF6 PUTREG          FCF2
RCP             E200 RCPS            0010 READCMD         EBDF
RESET           EBC2 RESIDENT        EACB RESOLVE         FB7D
RESROOM         0400 RUNCOMIF        EB56 RUNCOND         EADF
SEG1            E200 SEG10           EC00 SEG11           EF00
SEG12           EFD0 SEG2            EA00 SEG3            EA00
SEG4            ED00 SEG5            ED80 SEG6            EDD0
SEG7            EDF4 SEG8            EDFF SEG9            EE00
SETDMA          EBDA SHSIZE          0020 SHSTK           ED00
SHSTKS          0004 STMPP2          FFFF STMPZS          0000
SWAP            FC74 TBUFF           0080 TFCB            005C
TPA             0100 TRUE            FFFF UDFLAG          0004
VERS            0016 VERSION         000A WBOOT           0000
WHLMASK         0000 XEQOPT          FFFF YES             FFFF
Z3CL            EF00 Z3CLS           00D0 Z3ENV           EC00
Z3ENVS          0002 Z3MSG           ED80 Z3NDIR          EE00
Z3NDIRS         001C Z3REV           0021 Z3WHL           EDFF
ZBUFBAS         E200 ZDSSTPR         E838 ZDSSTSZ         01C8
ZFLOPKG         0200 ZIFOPT          FFFF ZIOPKG          0000
ZRESPKG         0800 ZSTDOVR         0400
S             FFFF
Z3CL            EF00 Z3CLS           00D0 Z3ENV           EC