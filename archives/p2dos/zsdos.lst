   1:			;****************************************************************************
   2:			;				Z S D O S
   3:			;   A CP/M 2.2 compatible replacement Basic Disk Operating System (BDOS)
   4:			;
   5:			;     Copyright (C) 1986,7,8 by:
   6:			;
   7:			;          Harold F. Bower        and       Cameron W. Cotrill
   8:			;
   9:			;         7914 Redglobe Ct.                2160 N.W. 159th Place
  10:			;         Severn, MD 21144-1048            Beaverton, OR  97006
  11:			;         USA.                             USA.
  12:			;
  13:			;       HalBower@worldnet.att.net         ccotrill@symantec.com
  14:			;
  15:			;   This program is free software; you can redistribute it and/or modify
  16:			;   it under the terms of the GNU General Public License as published by
  17:			;   the Free Software Foundation; either version 2 of the License, or
  18:			;   (at your option) any later version.
  19:			;
  20:			;   This program is distributed in the hope that it will be useful,
  21:			;   but WITHOUT ANY WARRANTY; without even the implied warranty of
  22:			;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  23:			;   General Public License (file LICENSE.TXT) for more details.
  24:			;
  25:			;   You should have received a copy of the GNU General Public License
  26:			;   along with this program; if not, write to the Free Software
  27:			;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  28:			;---------------------------------------------------------------------------
  29:			; ZSDOS is a CP/M 2.2 compatable BDOS replacement that contains numerous
  30:			; enhancements.  It is based on P2DOS 2.1 by HAJ Ten Brugge and revisions
  31:			; to P2DOS made by Harold F. Bower, Benjamin Ho, and Cameron W. Cotrill.
  32:			; Several good ideas from both CP/M Plus(tm) and ZRDOS(tm) have been added.
  33:			; The authors wish to thank Bridger Mitchell of Plu*Perfect Systems for
  34:			; suggesting we put our heads together, for reviewing the efforts, and for
  35:			; suggesting better methods for coding some sections.  Thanks also to Joe
  36:			; Wright of Alpha Systems for his review and suggestions, as well as
  37:			; squeezing a few more bytes for us.
  38:			
  39:			; Support for Plu*Perfect'a BackGrounder ii(tm) and ZDS DateStamper(tm) is
  40:			; included, as well as support for ZCPR/BGii WHEEL and PATH.
  41:			; ZSDOS is compatable with NZCOM by Joe Wright of Alpha Systems.
  42:			
  43:			; ZSDOS is designed for Z80 compatible processors ONLY!!!
  44:			; ZSDOS is coded to run in Z280 protected mode and may be ROMmed.
  45:			
  46:			; LEGAL DEPARTMENT:   P2DOS was written by H.A.J. Ten Brugge,  ZSDOS
  47:			; modifications were by Cameron W. Cotrill and Harold F. Bower.
  48:			; ZDDOS modifications were done by Carson Wilson, Cameron W. Cotrill
  49:			; and Harold F. Bower.
  50:			
  51:			; No author assumes responsibility or liability in the use of this
  52:			; program or any of its support utilities.
  53:			
  54:			; P2DOS is Copyright (C) 1985 by H.A.J. Ten Brugge  - All Rights Reserved
  55:			;	H.A.J. Ten Brugge
  56:			;	F. Zernikestraat 207
  57:			;	7553 EC Hengelo
  58:			;	Netherlands
  59:			; Permission to use P2DOS code in ZSDOS granted to Harold F. Bower and
  60:			;   Cameron W. Cotrill in letter 28 March 1988
  61:			
  62:			;   Code sections marked (bm) are revisions suggested by Bridger Mitchell.
  63:			;   Code sections marked (bh) are from SUPRBDOS mods to P2DOS by Benjamin Ho.
  64:			;   Code sections marked (crw) are revisions to support internal datestamper
  65:			;      and are Copyright (C) 1988 by Carson Wilson.
  66:			
  67:			; NOTES: Backgrounder ii and DateStamper are trademarks of Plu*Perfect
  68:			;  Systems.  CP/M is a trademark of Digital Research, Incorporated.
  69:			;  ZRDOS is a trademark of Echelon, Incorporated.
  71:			;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  72:			; Version 1.2a, 11/04/89
  73:			; Assemble with : SLR Z80ASMP or ZMAC
  74:			; Revisions:
  75:			; 11/04/89	Moved home call to rddir so bios hostbuf always
  76:			;		updated before dir read.
  77:			; 07/18/89	Fixed tderr routine in ZDDOS so return codes not
  78:			; CWC		altered from tderr unless called from 102 or 103.
  79:			; 06/20/89	Fixed bug in F10 ^R that output 256 spaces if ^R
  80:			; CWC		entered with tab counter =0.
  81:			;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  82:			;;---------------------------------------------------------------------
  83:			;; Modified on 2006/04/29 to assemble with zmac, linux cross-assembler
  84:			;; not the CP/M ZMAC
  85:			;;---------------------------------------------------------------------
  86:			;; Modified on 2008/02/08 to cope with BIOS clock driver
  87:			;;---------------------------------------------------------------------
  88:			
  89:				include	common.asm	; Common ZDS equs
**** common.asm ****
   1:			;
   2:			; Here just some common symbol...
   3:			;
   4:			
   5:	0016          	VERS	EQU     22      	; VERSION 2.2 (CP/M related)
   6:			;
   7:			; MSIZE	EQU     63              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   8:	003C          	MSIZE	EQU     60              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
   9:			; MSIZE	EQU     56              ; CP/M VERSION MEMORY SIZE IN KILOBYTES
  10:	0400          	RESROOM	EQU	1024		; RESERVED ROOM SPACE BELOW MONITOR (FC00)
  11:	0600          	BIOSTDS	EQU	1536		; BIOS STANDARD SIZE
  12:	0A00          	BIOREAS	EQU	BIOSTDS+RESROOM	; BIOS REAL SIZE
  13:	0400          	ZSTDOVR	EQU	1024		; ZCPR STANDARD OVERHEAD SIZE
  14:	0000          	ZIOPKG	EQU	0		; ZCPR IO PACKAGE SIZE
  15:	0800          	ZRESPKG	EQU	2048		; ZCPR RESIDENT CMD PKG SIZE
  16:	0200          	ZFLOPKG	EQU	512		; ZCPR FLOW CMD PACKAGE SIZE
  17:	01C8          	ZDSSTSZ	EQU	01C8H		; ZDS Stamper reserved space
  18:			
  19:	1200          	EXTRABIAS	EQU	RESROOM+ZSTDOVR+ZIOPKG+ZRESPKG+ZFLOPKG	; ...
  20:				;
  21:				;       "BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
  22:				;       THAN 16K (REFERRED TO AS"B" THROUGHOUT THE TEXT)
  23:				;
  24:	8E00          	BIAS	EQU     ((MSIZE-20)*1024)-EXTRABIAS
  25:	C200          	CCP	EQU     3400H+BIAS      ; BASE OF CCP
  26:	CA06          	BDOS	EQU     CCP+0806H       ; BASE OF BDOS
  27:	CA00          	BDOSB	EQU	CCP+0800H	; BDOS base offset
  28:	D800          	BIOS	EQU     CCP+1600H       ; BASE OF BIOS
  29:	E200          	ZBUFBAS	EQU	BIOS+BIOREAS	; BASE OF ZCPR3 BUFFERS
  30:				;
  31:				; 	some other equs...
  32:				;
  33:	000D          	CR	EQU     0DH		; CARRIAGE RETURN
  34:	000A          	LF	EQU     0AH		; LINE FEED;
  35:	000C          	FF	EQU	0CH		; FORM FEED (clear screen)
  36:	FFFF          	TRUE	EQU	-1
  37:	0000          	FALSE	EQU	0
  38:			
  39:	0000          	INTRON	EQU	FALSE		; Interrupts disabled
  40:				;
  41:				; define which kind of date stamper must be embedded in
  42:				; RCP
  43:				;
  44:	FFFF          	STMPP2	EQU	TRUE		; P2DOS date stamper
  45:	0000          	STMPZS	EQU	FALSE		; ZSDOS date stamper
  46:	FFFF          	HASEDS	EQU	(STMPP2+STMPZS)	; set a flag for embedded date stamper
  47:				;
  48:				; path for ZCPR3 used on cold boot
  49:				;
  50:	0024          	IDISK1	EQU	'$'		; 1st: current disk, current user
  51:	0024          	IUSER1	EQU	'$'
  52:	0024          	IDISK2	EQU	'$'		; 2nd: current disk, user 15
  53:	000F          	IUSER2	EQU	15
  54:	0001          	IDISK3	EQU	'A'-'@'		; 3rd: disk A, current user
  55:	0024          	IUSER3	EQU	'$'
  56:	0001          	IDISK4	EQU	'A'-'@'		; 4th: disk A, user 15
  57:	000F          	IUSER4	EQU	15
  58:			
  59:			; COMMON.ASM [EOF]
**** zsdos.asm ****
  90:			;	MACLIB	ZSDOS.LIB	; Get initialization code
  91:				include z3base.lib	; Get address for WHEEL byte
**** z3base.lib ****
   1:			; Z3BASE - Dynamic Configuration
   2:			;
   3:			; ZCPR33 is copyright 1987 by Echelon, Inc.  All rights reserved.  End-user
   4:			; distribution and duplication permitted for non-commercial purposes only.
   5:			; Any commercial use of ZCPR33, defined as any situation where the duplicator
   6:			; recieves revenue by duplicating or distributing ZCPR33 by itself or in
   7:			; conjunction with any hardware or software product, is expressly prohibited
   8:			; unless authorized in writing by Echelon.
   9:			;
  10:			; This is a special version of Z3BASE, inspired by Joe Wright's Z3BASE
  11:			; for Z-Com.  All segment addresses are automatically derived when the
  12:			; CCP equate is set.  The benefit of this is that reconfiguration of the
  13:			; system after initial installation is greatly eased.
  14:			;
  15:			; Although this version of Z3BASE is being distributed with ZCPR 3.3, any
  16:			; previous version of Z3BASE can be used to assemble the Z33 Command
  17:			; Processor.  No new symbols are needed.  So, if you have an existing
  18:			; Z3BASE, go ahead and use it.
  19:			;
  20:			; Instructions:
  21:			;
  22:			; The user should first design the ZCPR3 memory usage using the chart
  23:			; below.  (Echelon recommends the chart be filled out, even though it is
  24:			; not read by the assembler, so that your system will be self-documenting.)
  25:			; Then set the CCP equate for the beginning address of ZCPR3.  Next, examine
  26:			; and change the SEGn equates which follow in the file to ensure that the
  27:			; system segments and buffers are placed at the proper addresses.
  28:			;
  29:			; This file has been customized for use with AMPRO hard disk systems.  The
  30:			; target configuration has support for hard disks up to 49 Meg, extended
  31:			; IOP support, and 28-entry NDR.
  32:			;
  33:			;****************************************************************
  34:			;*								*
  35:			;*  Z3BASE.LIB -- Base Addresses for ZCPR 3.3/Z-System		*
  36:			;*								*
  37:			;* 	Segments:						*
  38:			;*								*
  39:			;*	Segment		Function				*
  40:			;*	-------		--------				*
  41:			;*	ZSDOS		ZSDOS 1.1				*
  42:			;*	CBIOSZ		ZDS BIOS with additional		*
  43:			;*			ZCPR3 initialization routines		*
  44:			;*	ZCPR3		Echelon Z80 Command Processor		*
  45:			;*			Replacement, Version 3.3 (ZCPR3)	*
  46:			;*	*.ENV		All Environment Descriptors		*
  47:			;*	*.FCP		All Flow Command Packages		*
  48:			;*	*.NDR		All Named Directory Definition Files	*
  49:			;*	*.RCP		All Resident Command Packages		*
  50:			;*	*.IOP		All Input/Output Packages		*
  51:			;*								*
  52:			;*								*
  53:			;* Memory Map of System (for CCP EQU 0BC00H):			*
  54:			;*								*
  55:			;*	Address Range	  Size	Function			*
  56:			;*	-------------	-------	--------			*
  57:			;*	    0 -   FF	256 b	Standard CP/M Buffers except	*
  58:			;*	  100 - C2FF	~48 K	Transient Program Area		*
  59:			;*	 C200 - C9FF	  2 K	ZCPR 3.3 Command Processor	*
  60:			;*	 CA00 - D7FF	3.5 K	ZSDOS				*
  61:			;*	 D800 - E1FF	2.5 K	BIOS with disk buffers		*
  62:			;*	 E200 - E9FF	  2 K	Resident Command Package	*
  63:			;*	 0000 - 0000	1.5 K	Input/Output Package		*
  64:			;*	 EA00 - EBFF	 .5 K	Flow Command Package		*
  65:			;*	 EC00 - ECFF	256 b	Environment Descriptor		*
  66:			;*				Bytes 00H-7FH:  Z3 Parameters	*
  67:			;*				Bytes 80H-FFH:  Z3 TCAP		*
  68:			;*	 ED00 - ED7F	128 b	ZCPR3 Shell Stack		*
  69:			;*	 ED80 - EDCF	 80 b	ZCPR3 Message Buffers		*
  70:			;*	 EDD0 - EDF3	 36 b	ZCPR3 External FCB		*
  71:			;*	 EDF4 - EDFE	 11 b	ZCPR3 External Path	        *
  72:			;*       EDFF  		  1 b	Wheel Byte			*
  73:			;*	 EE00 - EEFF    256 B	Memory-Based Named Directory	*
  74:			;*	 EF00 - EFCF	208 B	Multiple Command Line Buffer	*
  75:			;*	 EFD0 - EFFF	 48 b	ZCPR3 External Stack		*
  76:			;****************************************************************
  77:			
  78:			; include	macro	filename
  79:			;
  80:			; 	 if	zas
  81:			; 	.in		filename
  82:			; 	 else	;slr assembler
  83:			; 	include	filename
  84:			; 	 endif	;zas
  85:			;
  86:			; 	 endm
  87:			
  88:			; FALSE	equ	0
  89:			; TRUE	equ	NOT FALSE
  90:			
  91:	0021          	Z3REV	EQU	33	; ZCPR3 REV NUMBER
  92:			; MSIZE	EQU	54	; SIZE OF CPM SYSTEM
  93:			
  94:	0000          	BASE	EQU	0
  95:			
  96:			; CCP	EQU	0BC00H 	; ZCPR3 COMMAND PROCESSOR
  97:			
  98:	E200          	SEG1	EQU	ZBUFBAS	; where the things starts
  99:			
 100:			;
 101:			; RCP definition.  Set RCPS to 0 to eliminate RCP
 102:			;
 103:			
 104:	0010          	RCPS	EQU	16		; 16 128-byte Blocks (2K bytes)
 105:			
 106:	0001          		 IF	RCPS NE 0
 107:	E200          	RCP	EQU	SEG1		; RESIDENT COMMAND PACKAGE
 108:				 ELSE
 110:				 ENDIF
 111:			
 112:	EA00          	SEG2	EQU	SEG1+(RCPS*128)
 113:			
 114:			;
 115:			; IOP definition.  Set IOPS to 0 to eliminate IOP
 116:			;
 117:			; IOPS	EQU	12		; 12 128-byte Blocks (1.5K bytes)
 118:	0000          	IOPS	EQU	0		; 12 128-byte Blocks (1.5K bytes)
 119:			
 120:	0000          		 IF	IOPS NE 0
 122:				 ELSE
 123:	0000          	IOP	EQU	0
 124:				 ENDIF
 125:			
 126:	EA00          	SEG3	EQU	SEG2+(IOPS*128)
 127:			
 128:			;
 129:			; FCP definition.  Set FCPS to 0 to eliminate FCP
 130:			;
 131:			
 132:	0004          	FCPS	EQU	4	; 4 128-byte Blocks (0.5K bytes)
 133:			
 134:	0001          		 IF	FCPS NE 0
 135:	EA00          	FCP	EQU	SEG3
 136:				 ELSE
 138:				 ENDIF
 139:			
 140:	E838          	ZDSSTPR	EQU	(FCP-ZDSSTSZ)	; Z80 Darkstar P2DOS Stamper
 141:			
 142:	EC00          	SEG10	EQU	SEG3+(FCPS*128)
 143:			
 144:			;
 145:			; The ZCPR3 External Environment Descriptor is mandatory for ZCPR 3.3.
 146:			; Echelon recommends you work this out so that your ENV begins at address
 147:			; FE00h, but this is only a recommendation and not mandatory.
 148:			;
 149:			
 150:	EC00          	Z3ENV	EQU	SEG10	; ENVIRONMENT DESCRIPTORS
 151:	0002          	Z3ENVS	EQU	2	; SIZE OF ENVIRONMENT DESCRIPTOR IN 128-BYTE BLOCKS
 152:			
 153:	ED00          	SEG4	EQU	SEG10+(Z3ENVS*128)
 154:			
 155:			;
 156:			; Shell Stack definition.  Set SHSTKS to 0 to eliminate Shell Stack
 157:			;
 158:			
 159:	0004          	SHSTKS	EQU	4	; NUMBER OF SHSIZE-BYTE SHELL STACK ENTRIES
 160:	0020          	SHSIZE	EQU	32	; SIZE OF A SHELL STACK ENTRY
 161:						;   (STACK SIZE = SHSTKS * SHSIZE)
 162:	0001          		 IF SHSTKS NE 0
 163:	ED00          	SHSTK	EQU	SEG4
 164:				 ELSE
 166:				 ENDIF
 167:			
 168:	ED80          	SEG5	EQU	SEG4+(SHSTKS*SHSIZE)
 169:			
 170:			;
 171:			; The ZCPR3 Message Buffers are mandatory for ZCPR 3.3.
 172:			;
 173:	ED80          	Z3MSG	EQU	SEG5		; ZCPR3 MESSAGE BUFFER
 174:			
 175:	EDD0          	SEG6	EQU	SEG5+80
 176:			
 177:			;
 178:			; The ZCPR3 External FCB is mandatory for ZCPR 3.3.
 179:			;
 180:			
 181:	EDD0          	EXTFCB	EQU	SEG6		; ZCPR3 EXTERNAL FCB
 182:			
 183:	EDF4          	SEG7	EQU	SEG6+36
 184:			
 185:			;
 186:			; The Path is mandatory for ZCPR 3.3.  No more than 5 path elements can be
 187:			; used with this Z3BASE.LIB file.
 188:			;
 189:			
 190:	EDF4          	EXPATH	EQU	SEG7		; EXTERNAL PATH
 191:	0005          	EXPATHS	EQU	5		; 5 2-byte Path Elements
 192:							;  (PATH SIZE = EXPATHS*2 + 1)
 193:			
 194:	EDFF          	SEG8	EQU	SEG7+(EXPATHS*2)+1
 195:			
 196:			;
 197:			; The ZCPR3 Wheel Byte is mandatory for ZCPR 3.3.
 198:			;
 199:			
 200:	EDFF          	Z3WHL	EQU	SEG8		; WHEEL BYTE ADDRESS
 201:			
 202:	EE00          	SEG9	EQU	SEG8+1
 203:			
 204:			;
 205:			; ZCPR3 Named Directory Buffer definition.  Set Z3NDIRS to 0 to eliminate
 206:			; the named directory buffer.  If Z3NDIRS is changed, also change the seg11
 207:			; equate below.
 208:			;
 209:	001C          	Z3NDIRS	EQU	28		; 28 18-byte Named Directory Elements permitted
 210:							;   (NDIR SIZE = Z3NDIRS*18 + 1 for trailing 0)
 211:	0001          		 IF	Z3NDIRS NE 0
 212:	EE00          	Z3NDIR	EQU	SEG9		; ZCPR3 NAMED DIRECTORY AREA
 213:				 ELSE
 215:				 ENDIF
 216:			
 217:	EF00          	SEG11	EQU	SEG9+256	; add 512 for 28-entry NDR
 218:							; add 256 for 14-entry NDR ("standard")
 219:							; add 0 if Z3NDIRS is set to 0
 220:			
 221:			;
 222:			; The ZCPR3 External Command Line Buffer is mandatory for ZCPR 3.3.
 223:			;
 224:			
 225:	EF00          	Z3CL	EQU	SEG11	; ZCPR3 COMMAND LINE BUFFER
 226:	00D0          	Z3CLS	EQU	208	; SIZE OF COMMAND LINE BUFFER
 227:			
 228:	EFD0          	SEG12	EQU	SEG11+Z3CLS
 229:			
 230:			;
 231:			; The ZCPR3 External Stack is mandatory for ZCPR 3.3.
 232:			;
 233:			
 234:	EFD0          	EXTSTK	EQU	SEG12	; ZCPR3 EXTERNAL STACK
 235:			
 236:			; end of Z3BASE.LIB
 237:			
**** zsdos.asm ****
  92:				include	zsdos.lib		; Get initialization code
**** zsdos.lib ****
   1:			;.....
   2:			; ZSDOS Customization.  		-HFB,  18 Sept 1987
   3:			;					revised 07/17/88 CWC
   4:			
   5:	0000          	FALSE	EQU	0
   6:	FFFF          	TRUE	EQU	NOT FALSE
   7:			
   8:			; Set these conditionals before assembly
   9:			
  10:			;****************************************************************************
  11:			; In the General Public Release version, we have included an equate which
  12:			; controls an additional unreleased fix (which only Howard Goldstein found).
  13:			; If the following equate is set TRUE, a version 1.1 BDOS will be produced
  14:			; which will require no changes to any released utilities.  If set to FALSE,
  15:			; a version 1.2 BDOS will result, and many support utility libraries and
  16:			; overlays will need to be revised to make them function properly.    HFB
  17:			
  18:	FFFF          	ZSDOS11	EQU	TRUE			; Set True for Ver 1.1, False for 1.2
  19:			
  20:			;****************************************************************************
  21:			
  22:	FFFF          	ZS	EQU	TRUE      		; Set True for ZSDOS, False for ZDDOS
  23:			
  24:			;----------
  25:			;   Select assembler for ZSDOS.  Any modifications to source code must
  26:			; support these assemblers at minimum.
  27:			
  28:	FFFF          	SLR	EQU	TRUE		; SLR Z80ASM or SLR180 Assembler, OR ZMAC
  29:							; ... and Linux Z80 cross asm. zmac too !!
  30:	0000          	ZAS	EQU	FALSE 		; MITEK/ECHELON ZAS Assembler (3.0 or later)
  31:			
  32:	0000          		  IF ZAS
  34:				  ENDIF
  35:			
  36:	FFFF          		  IF  SLR
  37:				.Z80
  38:			;	NAME	('DOS')
  39:				  ENDIF
  40:			
  41:	0000          		  IF ZAS AND ZS
  47:				  ENDIF
  48:	0000          		  IF ZAS AND (NOT ZS)
  54:				  ENDIF
  55:			
  56:	FFFF          		  IF SLR AND ZS
  57:	FFFF          		   IF  ZSDOS11
  58:				TITLE	'ZSDOS 1.1 - Enhanced CP/M BDOS Replacement'
  59:				   ELSE		;~Zsdos11
  61:				   ENDIF	;Zsdos11
  62:				  ENDIF
  63:	0000          		  IF SLR AND (NOT ZS)
  69:				  ENDIF
  70:			
  71:			;----------
  72:			;   P2DOS introduced a search path feature compatible with that used in
  73:			; Richard Conn's ZCPR2 and ZCPR3.  If a requested file is not located in
  74:			; the currently logged Drive/User, the SEARCH routine will sequentially
  75:			; scan along the path until either the file is found or the end of the
  76:			; path is reached.
  77:			
  78:	FFFF          		  IF	ZS
  79:	D7F1          	PATHAD	EQU	IPATH		; Set to the desired ZCPR2/3 search path.
  80:				  ELSE			; use 0000H to disable path.  A short
  82:				  ENDIF			; in ZSDOS.  ZDDOS does not use path.
  83:			
  84:			;----------
  85:			;   The WHEEL byte may be sensed from within ZSDOS by setting the following
  86:			; address to that of the ZCPR3 WHEEL byte.  A value of 0 disables the WHEEL
  87:			; byte sensing.
  88:			
  89:	EDFF          	WHLADR	EQU	Z3WHL		; Set WHEEL byte address (0FDFFH for SB180)
  90:			
  91:			;----------
  92:			;   Some systems, like the Kaypro 4, only recognize changes between single
  93:			; and double-sided disks when the system is warm booted; BDOS Function 13
  94:			; (reset disk) will not work.  By adding a "hook" to the BIOS of these mach-
  95:			; ines and setting RESDSK to TRUE, BDOS functions 13 and 37 will allow changes
  96:			; between single and double-sided disks; very handy for disk housekeeping
  97:			; utilities such as NSWP, NULU, and cataloging programs.
  98:			
  99:			;   The "hook" is added as follows: Obtain the source to your computer's BIOS.
 100:			; Examine the code for WARM BOOT.  Somewhere, there should be a call to a rou-
 101:			; tine which initializes the disk system after a warm boot, or which detects
 102:			; changes between single and double-sided disks.  Call this routine DISKINT
 103:			; for purposes of discussion.  Modify your BIOS's cold boot routine to ini-
 104:			; tialize 3 bytes at address SETDSK as "JP DISKINT".  The location of SETDSK
 105:			; is arbitrary, it may be in your BIOS, or in a reserved spot in CP/M's page 0.
 106:			
 107:	0000          	RESDSK	EQU	FALSE
 108:			
 109:	0000          	   IF	   RESDSK
 111:			   ENDIF		; resdsk (bh)
 112:			
 113:			;----------
 114:			;   The following equate is used to produce separate code and data segments
 115:			; for blowing ZSDOS into ROM.  Calling BDOS Function 0 will initialize the
 116:			; Data Segment to default values.
 117:			
 118:	0000          	ROM	EQU	FALSE		; Separate data and code?
 119:			
 120:			;----------
 121:			;   Many ZSDOS features can be controlled while ZSDOS is running by altering
 122:			; the FLAG byte.  Set the following equate to your desired configuration based
 123:			; on your requirements.  The individual bit assignments in the FLAG byte are:
 124:			;
 125:			; Bit -	7 6 5 4 3 2 1 0
 126:			;	 \ \ \ \ \ \ \ \__Public File Enable (1) / Disable (0)
 127:			;	  \ \ \ \ \ \ \___Public/Path Write Enable (1) / Disable (0)
 128:			;	   \ \ \ \ \ \____Read-Only Enable (1) / Disable (0)
 129:			;	    \ \ \ \ \_____Fast Fixed Disk Relog Enable (1) / Disable (0)
 130:			;	     \ \ \ \______Disk Change Warning Enable (1) / Disable (0)
 131:			;	      \ \ \_______ZCPR2/3 Path Enable (1) / Disable (0)
 132:			;	       \ \________Path without System Enable (1) / Disable (0)
 133:			;		\_________(Reserved)
 134:			
 135:	006D          	FLGBITS	EQU	01101101B	; PUBLIC On, P/P Write Off, R/O On,
 136:							; Fast Relog On,Disk Change warning Off,
 137:							; Path On, No System path On
 138:			
 139:			; The operation of Bit 6 represents a deviation from the description of PUBLIC
 140:			; Files as given in DDJ Article by Bridger Mitchell and Derek McKay of Plu*
 141:			; Perfect Systems.  The PUBLIC Specification states that Public Files will NOT
 142:			; be found by any wildcard reference except when a "?" is in the FCB+0 byte.
 143:			; The code here relaxes that requirement as follows:  If we are in the same
 144:			; user area as the public file, then don't report the file as PUBLIC, but find
 145:			; it.  This has a nasty side effect - it allows erasing of PUBLIC files if we
 146:			; are in the same area.  However, these files also show up on the directory
 147:			; (they wouldn't otherwise), so at least we should know we're blasting them.
 148:			
 149:			;----------
 150:			; Equates for selecting ZSDOS or ZDDOS configurations
 151:			
 152:			; Since much ZSDOS code must be deleted to embed DateStamper in ZDDOS, the
 153:			; following flags do the stripping:
 154:			;	PICKEY	- True = Don't save users' DE register
 155:			;	CTLREN	- True = Add ^R Retype line to cons read, False = No ^R
 156:			;	UNROLL	- True = Inline code for shifts, False = collapse into loops
 157:			;	UPATH	- True = Add User path from OS, False = No OS path search
 158:			
 159:	FFFF          		  IF ZS
 160:	FFFF          	CTLREN	EQU	TRUE
 161:	FFFF          	UNROLL	EQU	TRUE
 162:	FFFF          	UPATH	EQU	TRUE
 163:	0000          	PICKEY	EQU	FALSE
 164:				  ELSE
 169:				  ENDIF
 170:			
 171:			;----------
 172:			; To Use the Named-COMMON aspect of NZCOM and JETLOADER (tm), the BIOS must
 173:			; be referenced from the _BIOS_ name.  If operating under this scheme, set
 174:			; the ZRL equate to TRUE.  With the ZRL equate set to FALSE, a standalone
 175:			; .REL file will be produced with no external requirements.
 176:			
 177:	0000          	ZRL	EQU	FALSE		; Set True .ZRL file with COMMON for NZCOM,
 178:							;     False to produce straight .REL file
 179:			
 180:			
**** zsdos.asm ****
  93:			
  94:	0000          	RAMLOW	EQU	0000H		; Start address memory
  95:	CA00          		ORG	BDOSB
  96:			
  97:			; 	CSEG
  98:	CA00          	ZSDOS	EQU	$		; Start address ZSDOS
  99:			
 100:	0000          		  IF  	ZRL
 104:				  ELSE
 105:			;BIOS	EQU	ZSDOS+0E00H	; already in common.asm
 106:				  ENDIF
 107:			
 108:	D800          	BOOT	EQU	BIOS+0000H	; Cold Boot
 109:	D803          	WBOOT	EQU	BIOS+0003H	; Warm Boot
 110:	D806          	CONST	EQU	BIOS+0006H	; Console Status
 111:	D809          	CONIN	EQU	BIOS+0009H	; Console Input
 112:	D80C          	CONOUT	EQU	BIOS+000CH	; Console Output
 113:	D80F          	BDLIST	EQU	BIOS+000FH	; List Output
 114:	D812          	PUNCH	EQU	BIOS+0012H	; Punch Output
 115:	D815          	READER	EQU	BIOS+0015H	; Reader Input
 116:	D818          	HOME	EQU	BIOS+0018H	; Home Disk
 117:	D81B          	SELDSK	EQU	BIOS+001BH	; Select Disk
 118:	D81E          	SETTRK	EQU	BIOS+001EH	; Select Track
 119:	D821          	SETSEC	EQU	BIOS+0021H	; Select Sector
 120:	D824          	SETDMA	EQU	BIOS+0024H	; Set DMA Address
 121:	D827          	BDREAD	EQU	BIOS+0027H	; Read 128 Bytes
 122:	D82A          	WRITE	EQU	BIOS+002AH	; Write 128 Bytes
 123:	D82D          	LISTST	EQU	BIOS+002DH	; List Status
 124:	D830          	SECTRN	EQU	BIOS+0030H	; Sector Translation
 125:	D833          	BTIME	EQU	BIOS+0033H	; BIOS clock driver
 126:	D836          	BOTDSK	EQU	BIOS+0036H	; BIOS boot drive id
 127:			
 128:			; Internal Definitions
 129:	FFFF          		  IF  ZSDOS11
 130:	0001          	VERMAJ	EQU	1		; Major version number
 131:	0001          	VERMIN	EQU	1		; Minor version number
 132:				  ELSE
 135:				  ENDIF		;Zs
 136:	0011          	BDVERS	EQU	VERMAJ*10H+VERMIN
 137:			
 138:	0003          	CONTC	EQU	03H		; Key to generate warm boot
 139:	0008          	CONTH	EQU	08H		; Backspace
 140:	0009          	TAB	EQU	09H		; Tab
 141:	000A          	LF	EQU	0AH		; Line feed
 142:	000D          	CR	EQU	0DH		; Carriage return
 143:	0010          	CONTP	EQU	10H		; Set/reset print flag
 144:	0012          	CONTR	EQU	12H		; Retype line
 145:	0013          	CONTS	EQU	13H		; Stop console output
 146:	0018          	CONTX	EQU	18H		; Delete line (backspaces)
 147:	0015          	CONTU	EQU	15H		; Same as Control-X
 148:	007F          	RUBOUT	EQU	7FH		; Delete last char
 149:			
 150:	001F          	MAXEXT	EQU	1FH		; Maximum extent number
 151:	003F          	MAXMOD	EQU	3FH		; Maximum data module number
 152:			
 153:	0091          	TDCKSM	EQU	91H		; CHECKSUM OF !!!TIME&.DAT
 154:			
 155:			; Attribute Bit Definitions
 156:			
 157:	0002          	PUBATT	EQU	2		; Public attribute offset
 158:	0007          	PSFATT	EQU	7		; Public/system file (internal only)
 159:	0008          	WHLATT	EQU	8		; Wheel protect attribute offset
 160:	0009          	ROATT	EQU	9		; Read only attribute offset
 161:	000A          	SYSATT	EQU	10		; System attribute offset
 162:	000B          	ARCATT	EQU	11		; Archive attribute offset
 163:			
 164:			; FCB POSITION EQUATES
 165:			
 166:	000C          	FCBEXT	EQU	12		; Extent number
 167:	000D          	FCBUSR	EQU	13		; User valid at offset 13 if set (internal)
 168:	000E          	FCBMOD	EQU	14		; Data module number - D7 used as unmod flag
 169:	000F          	FCBREC	EQU	15		; Record number
 170:	0020          	NXTREC	EQU	32		; Next record number
 172:			;**************************************************************
 173:			;*	 Z S D O S	P r o g r a m	  S t a r t	      *
 174:			;**************************************************************
 175:			
 176:			; WARNING!!  Do NOT change labels or sequences of ZSDOS through ZSDOS+25H
 177:			;   ID string added for easy identification in running system (hfb)
 178:			
 179:	FFFF          		  IF  ZS
 180:	CA00  5A53444F		DEFB	'ZSDOS '	; Used in CP/M for serial number. these bytes
	      5320
 181:				  ELSE			; are patched by INSTALOS to contain the serial
 183:				  ENDIF			; still be used without problems.
 184:			
 185:			; ZSDOS Entry Point
 186:			
 187:	CA06  C39BCA  	START:	JP	ZENTRY		; Jump to start of program code
 188:			
 189:			; CP/M 2.2 Compatable Error Vector Table
 190:			
 191:	CA09  4CCD    	STBDSC:	DEFW	ERROR		; Bad sector message
 192:	CA0B  4CCD    	STSEL:	DEFW	ERROR		; Select error
 193:	CA0D  4CCD    	STRO:	DEFW	ERROR		; Drive read only
 194:	CA0F  4CCD    	SFILRO:	DEFW	ERROR		; File read only
 195:			
 196:			; External Path Name
 197:			
 198:	CA11  F1D7    	PATH:	DEFW	PATHAD		; Path address for file open, 0 if no path
 199:			
 200:			; Wheel Byte Pointer
 201:			
 202:	CA13  FFED    	WHEEL:	DEFW	WHLADR		; Address of wheel byte, 0 if none
 203:			
 204:			; User configuration byte
 205:			
 206:	CA15  6D      	FLAGS:	DEFB	FLGBITS		; Flag byte set in zsdos.lib
 207:			
 208:			; Dispatch table for time/date stamp routines
 209:			
 210:			; ZSDOS uses all vectors in this table as indicated.  ZDDOS uses all but
 211:			; STUPDV, GETSTV, and PUTSTV.  STCRV is used to store the address of the
 212:			; stamp for ZDDOS, thus allowing ZSCONFIG to enable and disable stamping
 213:			; of Last Access and Modify.
 214:			
 215:			; GSTIME:	DEFW	DOTDER		; Address of get/set time/date routine (hfb)
 216:			
 217:	CA16  33D8    	GSTIME:	DEFW	BTIME		; Address of get/set time/date routine (hfb)
 218:	FFFF          		  IF	ZS
 219:	0000          		   IF	STMPZS
 222:				   ELSE
 223:	CA18  DDD7    	STLAV:	DEFW	DOTDER		; Address of stamp last access routine
 224:				   ENDIF
 225:	CA1A  38E8    	STCRV:	DEFW	ZDSSTPR+0	; Address of stamp create routine
 226:	CA1C  3BE8    	STUPDV:	DEFW	ZDSSTPR+3	; Address of stamp modify routine
 227:				  ELSE
 231:				  ENDIF
 232:	CA1E  3EE8    	GETSTV:	DEFW	ZDSSTPR+6	; Address of get stamp routine
 233:	CA20  41E8    	PUTSTV:	DEFW	ZDSSTPR+9	; Address of set stamp routine
 234:	CA22  DDD7    		DEFW	DOTDER		; Dummy vector to disable with ZSCONFIG
 235:	CA24  0000    	UNLOAD:	DEFW	0		; Pointer to remove Time Stamp routine
 236:			
 238:			;********************************************************
 239:			;*	 Z S D O S	L o w	 R A M	 D a t a	*
 240:			;********************************************************
 241:			
 242:			; RAM has been moved down here to an area that is compatable with ZRDOS per
 243:			; suggestion by Hal Bower.  The actual addresses used are NOT compatable with
 244:			; ZRDOS.
 245:			
 246:			; Due to ZSDOS's smaller RAM area, any program that saves RAM in accordance
 247:			; with ZRDOS's specifications for re-entry into BDOS should work under ZSDOS
 248:			; without problems.  Some code will be saved also, as well as the Flag Byte,
 249:			; but this should be no problem for IOP'S.
 250:			
 251:			; The Write Protect, Login, and Hard Disk Login Vectors are kept at the top of
 252:			; ZSDOS, as they must reflect the current status of the Disk System and hence
 253:			; should NOT be saved with other system variables Under ANY Circumstance!
 254:			
 255:	0000          		  IF  ROM
 257:				  ENDIF
 258:	CA26          	BGLORAM:
 259:			;--------------------------------------------------------------------
 260:			; The following locations MUST remain in EXACTLY this order
 261:			
 262:	CA26  00      	TABCNT:	DEFB	0		; Tab counter
 263:	CA27  00      	TABCX1:	DEFB	0		; Temporary Tab counter (used by RDBUF)
 264:			;--------------------------------------------------------------------
 265:			
 266:	CA28  00      	FCONTP:	DEFB	0		; List enable flag (Control-P) - used by BGii
 267:	CA29  00      	LASTCH:	DEFB	0		; Last character - used by BGii
 268:			
 269:			;--------------------------------------------------------------------
 270:			; The following locations MUST remain in EXACTLY this order
 271:			
 272:	CA2A  00      	USER:	DEFB	0		; User number - used by BGii
 273:	CA2B  00      	DEFDRV:	DEFB	0		; Default drive number - used by BGii and DS
 274:	CA2C  00      	DRIVE:	DEFB	0		; Drive number
 275:			;--------------------------------------------------------------------
 276:			
 277:	CA2D  00      	FCB0:	DEFB	0		; FCB byte 0
 278:			
 279:	CA2E          	BGHIRAM:
 280:	CA2E  8000    	DMA:	DEFW	0080H		; DMA address
 281:			
 282:	CA30  0000    	TRANS:	DEFW	0		; Translation vector
 283:	CA32  0000    	TEMP0:	DEFW	0		; Number of files on drive
 284:			
 285:			
 286:	CA34  0000    	DIRBUF:	DEFW	0		; Directory buffer pointer - used by bgii
 287:	CA36  0000    	IXP:	DEFW	0		; Disk parameter block
 288:	CA38  0000    	CSV:	DEFW	0		; Check sum pointer
 289:	CA3A  0000    	ALV:	DEFW	0		; Allocation vector pointer
 290:			
 291:			;--------------------------------------------------------------------
 292:			; The following locations MUST remain in EXACTLY this order
 293:			; Copy of DPB for Current Drive
 294:			
 295:	003C          	DPBOF	EQU	$-ZSDOS		; Value needed by ZSDOS
 296:			
 297:	CA3C  0000    	MAXSEC:	DEFW	0		; Number of sectors/track
 298:	CA3E  00      	NBLOCK:	DEFB	0		; Block shift
 299:	CA3F  00      	NMASK:	DEFB	0		; Mask number of blocks
 300:	CA40  00      	NEXTND:	DEFB	0		; Extent mask
 301:	CA41  0000    	MAXLEN:	DEFW	0		; Maximum block number-1
 302:	CA43  0000    	NFILES:	DEFW	0		; Maximum number of files-1
 303:	CA45  00      	NDIR0:	DEFB	0		; First two entries ALV buffer
 304:	CA46  00      		DEFB	0		; ..(NDIR1)
 305:	CA47  0000    	NCHECK:	DEFW	0		; Number of checksum entries
 306:	CA49  0000    	NFTRK:	DEFW	0		; First track number
 307:			;--------------------------------------------------------------------
 308:	CA4B  00      	FUNCT:	DEFB	0		; Function number
 309:	CA4C  0000    	PEXIT:	DEFW	0		; Exit code
 310:			;--------------------------------------------------------------------
 311:			; The following locations MUST remain in EXACTLY this order
 312:			
 313:	CA4E  00      	FLDRV:	DEFB	0		; Drive select used flag
 314:	CA4F  00      	RDWR:	DEFB	0		; Read/write flag
 315:	CA50  00      	SEARQU:	DEFB	0		; Search question mark used
 316:	CA51  00      	SEARPU:	DEFB	0		; Search public file
 317:			;--------------------------------------------------------------------
 318:	CA52  0000    	RECDIR:	DEFW	0		; Record directory (checksum)
 319:	CA54  0000    	FILCNT:	DEFW	0		; File counter
 320:	CA56  00      	SECPNT:	DEFB	0		; Sector pointer
 321:	CA57  00      	SUBFLG:	DEFB	0		; Submit flag (reset disk command)
 322:			
 323:	CA58  0000    	DCOPY:	DEFW	0		; Copy address FCB
 324:	CA5A  00      	SEAREX:	DEFB	0		; Exit code search
 325:	CA5B  00      	SEARNB:	DEFB	0		; Search number of bytes
 326:	CA5C  00      	ERMODE:	DEFB	0		; BDOS error mode
 327:			
 328:	CA5D  0000    	ARWORD:	DEFW	0		; De argument on entry - used for BGii
 329:	CA5F  0000    	DEVAL:	DEFW	0		; Return value for DE reg
 330:	CA61  0000    	SPSAVE:	DEFW	0		; Stack pointer location
 331:	FFFF          		  IF  ZS
 332:	CA63  5A53444F		DEFB	'ZSDOS 1.1 Copyri'
	      5320312E
	      3120436F
	      70797269
 333:				  ELSE
 335:				  ENDIF
 336:	CA73  67687420		DEFB	'ght (c) 1987,88 '
	      28632920
	      31393837
	      2C383820
 337:	CA83  20432E57		DEFB	' C.W.Cotrill & H'
	      2E436F74
	      72696C6C
	      20262048
 338:	CA93  2E462E42		DEFB	'.F.Bow'
	      6F77
 339:	CA99  6572    	IXSAVE:	DEFB	'er'		; User's IX register
 340:	CA9B          	ZSDOSS:				; ZSDOS stack
 341:			
 342:	CA9B          	BGRAMTOP EQU	ZSDOSS
 344:			; 	CSEG
 345:			;**********************************************************************
 346:			;*		 Z S D O S   e n t r y	 p o i n t		      *
 347:			;**********************************************************************
 348:			
 349:	CA9B  AF      	ZENTRY:	XOR	A		; Clear A
 350:	CA9C  47      		LD	B,A		; For later 16 bit adds
 351:	CA9D  6F      		LD	L,A
 352:	CA9E  67      		LD	H,A		; Set HL to zero
 353:	CA9F  224CCA  		LD	(PEXIT),HL	; Clear exit code
 354:	CAA2  224ECA  		LD	(FLDRV),HL	; Reset drive select and R/W flags
 355:	CAA5  ED7361CA		LD	(SPSAVE),SP	; Save stack pointer
 356:	CAA9  319BCA  		LD	SP,ZSDOSS	; Get internal stack pointer
 357:	CAAC  DDE5    		PUSH	IX		; Save index register on our stack
 358:	CAAE  D5      		PUSH	DE		; Save parameter register
 359:	CAAF  DDE1    		POP	IX		; Get it back in IX
 360:	CAB1  DD225DCA		LD	(ARWORD),IX	; Save in memory for BGii
 361:	FFFF          		  IF  NOT PICKEY
 362:	CAB5  DD225FCA		LD	(DEVAL),IX	; ..and for non-file access returns
 363:				  ENDIF
 364:	CAB9  21E6CD  		LD	HL,DOSEXIT	; Get exit address ZSDOS
 365:	CABC  E5      		PUSH	HL		; Save it on stack to return from ZSDOS
 366:	CABD  79      		LD	A,C		; Get function code - B reg = 0
 367:	CABE  324BCA  		LD	(FUNCT),A	; Save it for later use
 368:	CAC1  FE0C    		CP	12		; Is it a non-disk function?
 369:	CAC3  380D    		JR	C,ZENTRY0	; ..jump if so
 370:	CAC5  FE31    		CP	MAXCMD		; Cmnd < Maximum Command Number (48)?
 371:	CAC7  380D    		JR	C,ZENTRY1	; ..jump if disk function
 372:			
 373:			; Extended function scanner for added functions
 374:			
 375:	CAC9  FE62    		CP	98		; Is it less than Cmd98?
 376:	CACB  D8      		RET	C		; ..return if so
 377:	CACC  FE68    		CP	103+1		; Is it greater than Cmd103?
 378:	CACE  D0      		RET	NC		; ..quit if so
 379:	CACF  D631    		SUB	98-MAXCMD	; Rework so 98-->49..103-->54
 380:	CAD1  4F      		LD	C,A		; Save reworked function #
 381:						; ..fall thru to entry0..
 382:			
 383:			; If Non-disk Function (ie Function # less than 12), push the address of
 384:			;  the SAVEA routine on the Stack (save A reg as return code).	Saves
 385:			;  code in Console Routines, as simple RET can be used in most cases.
 386:			
 387:	CAD2  21BBCE  	ZENTRY0:	LD	HL,SAVEA
 388:	CAD5  E5      		PUSH	HL		; Vector return thru A reg save
 389:	CAD6  21E2CA  	ZENTRY1:	LD	HL,CTABLE	; Load table
 390:	CAD9  09      		ADD	HL,BC		; Add
 391:	CADA  09      		ADD	HL,BC		; Add twice to get word value
 392:	CADB  7E      		LD	A,(HL)		; Get LSB
 393:	CADC  23      		INC	HL		; Pointer to MSB
 394:	CADD  66      		LD	H,(HL)		; Get MSB
 395:	CADE  6F      		LD	L,A		; Save LSB in L
 396:			
 397:			; Copy byte argument into A and C to simplify Function calls.  This allows
 398:			;  direct BIOS jumps for several functions with resulting code savings.
 399:			
 400:	CADF  4B      		LD	C,E		; Place arg in C for BIOS
 401:	CAE0  7B      		LD	A,E		; And in A for others
 402:	CAE1  E9      		JP	(HL)		; Jump to routine
 403:			
 405:			;******************************************************
 406:			;*	 C O M M A N D	    T A B L E		      *
 407:			;******************************************************
 408:	CAE2          	CTABLE:
 409:	0000          		  IF  ROM
 411:				  ELSE
 412:	CAE2  CACD    		DEFW	ERROR5		; Warm boot (BIOS) with ERMODE clear
 413:				  ENDIF
 414:	CAE4  50CB    		DEFW	CMND01		; Console input
 415:	CAE6  64CC    		DEFW	WRCON		; Console output
 416:	CAE8  15D8    		DEFW	READER		; Reader input (BIOS)
 417:	CAEA  12D8    		DEFW	PUNCH		; Punch output (BIOS)
 418:	CAEC  0FD8    		DEFW	BDLIST		; List output (BIOS)
 419:	CAEE  5ACB    		DEFW	CMND06		; Direct console I/O
 420:	CAF0  91CB    		DEFW	CMND07		; Get I/O byte
 421:	CAF2  8ECB    		DEFW	CMND08		; Set I/O byte
 422:	CAF4  D5CC    		DEFW	CMND09		; Print string
 423:	CAF6  95CB    		DEFW	CMND10		; Read console buffer
 424:	CAF8  B7CC    		DEFW	CMND11		; Get console status
 425:	CAFA  CFCE    		DEFW	CMND12		; Return version number
 426:	CAFC  0ACE    		DEFW	CMND13		; Reset disk system
 427:	CAFE  7ACF    		DEFW	CMND14		; Select disk
 428:	CB00  B4D4    		DEFW	CMND15		; Open file
 429:	CB02  A8D1    		DEFW	CMND16		; Close file
 430:	CB04  6ECE    		DEFW	CMND17		; Search for first
 431:	CB06  95CE    		DEFW	CMND18		; Search for next
 432:	CB08  A5CE    		DEFW	CMND19		; Delete file
 433:	CB0A  BED5    		DEFW	CMND20		; Read sequential
 434:	CB0C  FFD5    		DEFW	CMND21		; Write sequential
 435:	CB0E  02D5    		DEFW	CMND22		; Make file
 436:	CB10  B0CE    		DEFW	CMND23		; Rename file
 437:	CB12  E8CE    		DEFW	CMND24		; Return login vector
 438:	CB14  B8CE    		DEFW	CMND25		; Return current disk
 439:	CB16  33D2    		DEFW	CMND26		; Set DMA address
 440:	CB18  E4CE    		DEFW	CMND27		; Get address allocation vector
 441:	CB1A  03D1    		DEFW	CMND28		; Write protect disk
 442:	CB1C  DCCE    		DEFW	CMND29		; Get R/O vector
 443:	CB1E  C7CE    		DEFW	CMND30		; Set file attributes
 444:	CB20  ECCE    		DEFW	CMND31		; Get address disk parameter header (DPH)
 445:	CB22  FBCE    		DEFW	CMND32		; Get/set user code
 446:	CB24  B4D5    		DEFW	CMND33		; Read random
 447:	CB26  F4D5    		DEFW	CMND34		; Write random
 448:	CB28  07CF    		DEFW	CMND35		; Compute file size
 449:	CB2A  0FCF    		DEFW	CMND36		; Set random record
 450:	CB2C  1CCE    		DEFW	CMND37		; Reset multiple drive
 451:	CB2E  BECE    		DEFW	DUMMY		; Function 38 (unused)
 452:	CB30  E0CE    		DEFW	CMND39		; Return fixed disk login vector
 453:	CB32  F4D5    		DEFW	CMND40		; Write random with zero fill
 454:	CB34  BECE    		DEFW	DUMMY		; Function 41 (unused)
 455:	CB36  BECE    		DEFW	DUMMY		; Function 42 (unused)
 456:	CB38  BECE    		DEFW	DUMMY		; Function 43 (unused)
 457:	CB3A  BECE    		DEFW	DUMMY		; Function 44 (unused)
 458:	CB3C  F7CE    		DEFW	CMND45		; Set Error Mode
 459:	CB3E  BECE    		DEFW	DUMMY		; Function 46 (unused)
 460:	CB40  F0CE    		DEFW	CMND47		; Return DMA
 461:	CB42  D8CE    		DEFW	CMND48		; Return DOS version
 462:			
 463:	0031          	MAXCMD	EQU	($-CTABLE)/2	; Jww
 464:			
 465:	CB44  D7D7    		DEFW	CMD98		; Get Time	; 49
 466:	CB46  D4D7    		DEFW	CMD99		; Set Time	; 50
 467:	CB48  C2CE    		DEFW	CMD100		; Get Flags	; 51
 468:	CB4A  BFCE    		DEFW	CMD101		; Set Flags	; 52
 469:	CB4C  A4D7    		DEFW	CMD102		; Get Stamp	; 53
 470:	CB4E  A4D7    		DEFW	CMD103		; Put Stamp	; 54
 471:			
 473:			;******************************************************
 474:			;*	 N o n - D i s k     F u n c t i o n s	      *
 475:			;******************************************************
 476:			
 477:	0000          		  IF  ROM
 502:				  ENDIF		; Rom
 503:			
 504:			;.....
 505:			; I/O Routines
 506:			
 507:			; ZSDOS Console Input.	Read character from Console and Echo
 508:			;  If Char=CR,LF,TAB,CONTH or >=Space
 509:			
 510:	CB50  CD75CB  	CMND01:	CALL	GETCH		; Get character (and test it  jww)
 511:	CB53  D8      		RET	C		; Less than space, exit
 512:	CB54  E5      	PUTCH:	PUSH	HL		; Save regs for other calls
 513:	CB55  CD64CC  		CALL	WRCON		; Echo character
 514:	CB58  E1      		POP	HL
 515:	CB59  C9      		RET
 516:			
 517:			; Direct Console Input/Output
 518:			;  Call with Char in C and E - Enhanced to CP/M-3 Spec
 519:			;  Checks ZSDOS typeahead for reliable console I/O under all conditions
 520:			;  as per a suggestion by Bridger Mitchell.
 521:			
 522:	CB5A  1C      	CMND06:	INC	E		; Test if get char if avail
 523:	CB5B  2814    		JR	Z,DCIO1		; Yes do input
 524:	CB5D  1C      		INC	E		; Test for 0FEH
 525:	CB5E  2806    		JR	Z,DCIO2		; Yes, get status
 526:	CB60  1C      		INC	E		; Test for 0FDH
 527:	CB61  2812    		JR	Z,GETCH		; Yes, wait for input char
 528:	CB63  C30CD8  		JP	CONOUT		; Else print char
 529:			
 530:	CB66  3A29CA  	DCIO2:	LD	A,(LASTCH)	; Check for buffered char
 531:	CB69  B7      		OR	A
 532:	CB6A  3E01    		LD	A,0001B		; ..preset ready
 533:	CB6C  CC06D8  		CALL	Z,CONST		; Get console status
 534:	CB6F  A7      		AND	A		; Test it
 535:	CB70  C9      		RET			; And return it to caller
 536:			
 537:	CB71  CD66CB  	DCIO1:	CALL	DCIO2		; Get console status
 538:	CB74  C8      		RET	Z		; Exit if no character present
 539:							; Else fall thru
 540:			; Get Character from Console
 541:			
 542:	CB75  2129CA  	GETCH:	LD	HL,LASTCH	; Check ZSDOS type ahead for char
 543:	CB78  7E      		LD	A,(HL)
 544:	CB79  3600    		LD	(HL),0		; Reset last character
 545:	CB7B  B7      		OR	A		; ..set flags
 546:	CB7C  CC09D8  		CALL	Z,CONIN		; Get character (and test it  jww)
 547:			
 548:			; Test Character
 549:			;  Exit Carry=0: CR,LF,TAB,CONTH or >= Space
 550:			;	Carry=1: All other Characters
 551:			
 552:	CB7F  FE0D    		CP	CR		; Is it a carriage return?
 553:	CB81  C8      		RET	Z		; ..return if so
 554:	CB82  FE0A    		CP	LF		; Is it a line feed?
 555:	CB84  C8      		RET	Z		; ..return if so
 556:	CB85  FE09    		CP	TAB		; Is it a tab?
 557:	CB87  C8      		RET	Z		; ..return if so
 558:	CB88  FE08    		CP	CONTH		; Is it a backspace?
 559:	CB8A  C8      		RET	Z		; ..return if so
 560:	CB8B  FE20    		CP	' '		; Test >=space
 561:	CB8D  C9      		RET			; ..and return to caller
 562:			
 563:			; Set I/O Status Byte
 564:			
 565:	CB8E  320300  	CMND08:	LD	(RAMLOW+0003H),A ; And save it in RAM and fall through
 566:			
 567:			; Get I/O Status Byte
 568:			
 569:	CB91  3A0300  	CMND07:	LD	A,(RAMLOW+0003H) ; Get I/O byte from RAM
 570:	CB94  C9      		RET
 571:			
 572:			; Buffered Console Read
 573:	CB95  3A26CA  	CMND10:	LD	A,(TABCNT)
 574:	CB98  3227CA  		LD	(TABCX1),A	; Save start tab position
 575:	CB9B  13      		INC	DE
 576:	CB9C  AF      		XOR	A
 577:	CB9D  12      		LD	(DE),A		; Set char count to zero
 578:	CB9E  13      		INC	DE		; Point to actual buffer start
 579:			
 580:	CB9F  D5      	RDBUF1:	PUSH	DE		; Save buffer pointer
 581:	CBA0  CD75CB  		CALL	GETCH		; Get next byte from user
 582:	CBA3  D1      		POP	DE
 583:	CBA4  219FCB  		LD	HL,RDBUF1
 584:	CBA7  E5      		PUSH	HL		; Return address to stack
 585:	CBA8  2A5DCA  		LD	HL,(ARWORD)
 586:	CBAB  4E      		LD	C,(HL)		; Put buffer length in C
 587:	CBAC  23      		INC	HL		; And point to current length
 588:			
 589:	CBAD  FE0D    		CP	CR
 590:	FFFF          		  IF  CTLREN
 591:	CBAF  2802    		JR	Z,JZRBX		; Exit if CR
 592:				  ELSE
 594:				  ENDIF		;Ctlren
 595:			
 596:	CBB1  FE0A    		CP	LF
 597:	FFFF          		  IF  CTLREN
 598:	CBB3  CA4ECC  	JZRBX:	JP	Z,RDBUFX	; ..or LF
 599:				  ELSE
 601:				  ENDIF		;Ctlren
 602:						;..Not CR or LF, so fall thru to next test
 603:			
 604:			; Delete Character from Buffer
 605:			;  RUB, Backspace, CR, LF are NEVER in the Buffer
 606:			
 607:	CBB6  FE7F    	RDBUF2:	CP	RUBOUT		; Delete char?
 608:	CBB8  2804    		JR	Z,DOBACK	; ..jump if so
 609:	CBBA  FE08    		CP	CONTH		; Control-H also deletes
 610:	CBBC  2036    		JR	NZ,RDBUF3	; Skip to next test if no delete
 611:			
 612:	CBBE  7E      	DOBACK:	LD	A,(HL)
 613:	CBBF  A7      		AND	A		; Test if attempting del from empty line
 614:	CBC0  C8      		RET	Z		; ..Exit if so
 615:	CBC1  1B      	DOBAK0:	DEC	DE		; Back up to last character
 616:	CBC2  35      		DEC	(HL)		; Erase from buffer
 617:	CBC3  D5      		PUSH	DE		; Save buffer pointer
 618:	CBC4  46      		LD	B,(HL)		; Get new char count
 619:	CBC5  23      		INC	HL		; Point to first char
 620:	CBC6  EB      		EX	DE,HL
 621:	CBC7  2126CA  		LD	HL,TABCNT
 622:	CBCA  4E      		LD	C,(HL)		; Save current Tab count
 623:	CBCB  23      		INC	HL
 624:	CBCC  7E      		LD	A,(HL)		; Get starting Tab position
 625:	CBCD  2B      		DEC	HL
 626:	CBCE  77      		LD	(HL),A		; Init the counter
 627:	CBCF  04      		INC	B		; Insure non-zero
 628:	CBD0  1805    		JR	DOBAK2		; Jump to done test
 629:			
 630:	CBD2  1A      	DOBAK1:	LD	A,(DE)		; Get char from buffer
 631:	CBD3  CD93CC  		CALL	WRCON2		; Counts chars
 632:	CBD6  13      		INC	DE
 633:	CBD7  10F9    	DOBAK2:	DJNZ	DOBAK1		; Continue count until done
 634:	CBD9  79      		LD	A,C		; Get prior tab count
 635:	CBDA  96      		SUB	(HL)		; Get diff between new and old
 636:	CBDB  47      		LD	B,A		; Set up as count
 637:	CBDC  71      		LD	(HL),C		; Restore prior count
 638:	CBDD  D1      		POP	DE		; Restore buffer pointer
 639:			
 640:			; Delete B Characters from Console
 641:			
 642:	CBDE  D5      		PUSH	DE		; Save pointer
 643:	CBDF  0E08    	DOBAK5:	LD	C,CONTH
 644:	CBE1  C5      		PUSH	BC		; Save counter from destruction
 645:	CBE2  CD0CD8  		CALL	CONOUT
 646:	CBE5  0E20    		LD	C,' '
 647:	CBE7  CD0CD8  		CALL	CONOUT		; Output backspace,space to CON: only
 648:	CBEA  3E08    		LD	A,CONTH
 649:	CBEC  CD64CC  		CALL	WRCON		; Now backspace CON:, counter, and printer
 650:	CBEF  C1      		POP	BC		; Restore counter
 651:	CBF0  10ED    		DJNZ	DOBAK5		; Loop until all done
 652:	CBF2  D1      		POP	DE		; Restore pointer
 653:	CBF3  C9      		RET
 654:			
 655:			; Erase Buffer
 656:			
 657:	CBF4  FE15    	RDBUF3:	CP	CONTU		; Test erase line
 658:	CBF6  2804    		JR	Z,ERALIN	; Do it if so
 659:	CBF8  FE18    		CP	CONTX
 660:	CBFA  200A    		JR	NZ,RDBUF4	; Skip to next test if no erase line
 661:			
 662:	CBFC  AF      	ERALIN:	XOR	A
 663:	CBFD  B6      		OR	(HL)		; Line empty?
 664:	CBFE  C8      		RET	Z		; Exit if so
 665:	CBFF  E5      		PUSH	HL
 666:	CC00  CDC1CB  		CALL	DOBAK0		; Else delete another (skip empty check)
 667:	CC03  E1      		POP	HL
 668:	CC04  18F6    		JR	ERALIN
 669:			
 670:	CC06          	RDBUF4:			; If CTL-R=True, do following code, else bypass
 671:	FFFF          		  IF  CTLREN
 672:	CC06  FE12    		CP	CONTR		; If ^R, type clean buffer version on console
 673:	CC08  2024    		JR	NZ,RDBUF5
 674:	CC0A  E5      		PUSH	HL		; Save pointer to buffer length
 675:	CC0B  CDD2CC  		CALL	CROUT		; Do CR/LF
 676:	CC0E  2126CA  		LD	HL,TABCNT
 677:	CC11  3600    		LD	(HL),0		; Init Tab count
 678:	CC13  23      		INC	HL
 679:	CC14  46      		LD	B,(HL)		; And get Tab offset count
 680:	CC15  3E20    		LD	A,' '
 681:	CC17  04      		inc	b		; [1.1] insure nz value
 682:	CC18  1803    		jr	rety1a		; [1.1] so case of lh side of screen ok
 683:	CC1A  CD64CC  	RETYP1:	CALL	WRCON		; Space off start of line
 684:	CC1D  10FB    	rety1a:	DJNZ	RETYP1
 685:	CC1F  E1      		POP	HL		; Point to buffer length
 686:	CC20  46      		LD	B,(HL)		; Get how many chars to print
 687:	CC21  23      		INC	HL		; Restore buffer pointer
 688:	CC22  EB      		EX	DE,HL		; Put buffer pointer in DE
 689:	CC23  04      		INC	B		; Comp for first DJNZ
 690:	CC24  1805    		JR	RETYP3		; Skip to done test
 691:	CC26  1A      	RETYP2:	LD	A,(DE)		; Get char from buffer
 692:	CC27  CD53CC  		CALL	WRCTL		; Output it
 693:	CC2A  13      		INC	DE		; Bump pointer
 694:	CC2B  10F9    	RETYP3:	DJNZ	RETYP2		; Loop until done
 695:	CC2D  C9      		RET
 696:				  ENDIF		; Ctlren
 697:			
 698:			; Toggle Line Printer Echo
 699:			
 700:	CC2E  FE10    	RDBUF5:	CP	CONTP		; Toggle printer?
 701:	CC30  2007    		JR	NZ,RDBUF6	; Next test if not
 702:	CC32  2128CA  		LD	HL,FCONTP
 703:	CC35  7E      		LD	A,(HL)		; Get printer echo flag
 704:	CC36  2F      		CPL			; Toggle it
 705:	CC37  77      		LD	(HL),A		; Put back
 706:	CC38  C9      		RET
 707:			
 708:			; Check if Control-C is First char in BUFF and Exit if so
 709:			
 710:	CC39  12      	RDBUF6:	LD	(DE),A		; Put character in buffer
 711:	CC3A  E5      		PUSH	HL
 712:	CC3B  CD53CC  		CALL	WRCTL		; Echo the character
 713:	CC3E  E1      		POP	HL
 714:	CC3F  34      		INC	(HL)		; Increment the character count
 715:			
 716:	CC40  7E      		LD	A,(HL)		; Get current length
 717:	CC41  B9      		CP	C		; Test against buffer size
 718:	CC42  280A    		JR	Z,RDBUFX
 719:	CC44  3D      		DEC	A		; Set Z flag for first character
 720:	CC45  1A      		LD	A,(DE)		; Get the character back
 721:	CC46  13      		INC	DE		; ..and bump the pointer
 722:	CC47  C0      		RET	NZ		; Return if not the first character
 723:	CC48  FE03    		CP	CONTC		; Possible user abort?
 724:	CC4A  C0      		RET	NZ		; ..return if not
 725:	CC4B  C3CACD  		JP	ERROR5		; Else jump to error reset exit
 726:			
 727:			; Done with Read Console Buffer Function
 728:			
 729:	CC4E  E1      	RDBUFX:	POP	HL		; Clear RDBUF1 return address
 730:	CC4F  3E0D    		LD	A,CR
 731:	CC51  1811    		JR	WRCON		; ..and echo a CR
 732:			
 733:			; Print Control Character as '^X'
 734:			
 735:	CC53  FE20    	WRCTL:	CP	' '		; Test if control char
 736:	CC55  300D    		JR	NC,WRCON	; Not, send it out
 737:	CC57  FE09    		CP	TAB		; Test if Tab
 738:	CC59  280D    		JR	Z,WRCON0	; It is, so expand with spaces
 739:	CC5B  F5      		PUSH	AF		; Save char
 740:	CC5C  3E5E    		LD	A,'^'		; Output a karet
 741:	CC5E  CD77CC  		CALL	WRCON1		; No need for Tab test here
 742:	CC61  F1      		POP	AF
 743:	CC62  C640    		ADD	A,40H		; Convert to printable
 744:							; And fall thru to WRCON
 745:			
 746:			; Output char with List Echo, Tab Expansion (Function 2)
 747:			
 748:	CC64  FE09    	WRCON:	CP	TAB		; Is it a Tab?
 749:	CC66  200F    		JR	NZ,WRCON1	; ..jump if not
 750:	CC68  3E20    	WRCON0:	LD	A,' '		; Expand Tab with spaces
 751:	CC6A  CD77CC  		CALL	WRCON1		; Write space
 752:	CC6D  3A26CA  		LD	A,(TABCNT)	; Get Tab count
 753:	CC70  E607    		AND	7		; Test if done
 754:	CC72  20F4    		JR	NZ,WRCON0	; No then repeat
 755:	CC74  3E09    		LD	A,TAB		; Return Tab
 756:	CC76  C9      		RET			; Return to caller
 757:			
 758:	CC77  C5      	WRCON1:	PUSH	BC
 759:	CC78  D5      		PUSH	DE		; Save pointers
 760:	CC79  4F      		LD	C,A
 761:	CC7A  C5      		PUSH	BC		; Save character
 762:			
 763:	CC7C          	BGPTCH0	EQU	$+1		;<-- BGii patches this address
 764:			
 765:	CC7B  CDB7CC  		CALL	CMND11		; Test status and CONTS/CONTC
 766:	CC7E  C1      		POP	BC		; Get character back
 767:	CC7F  C5      		PUSH	BC		; Save it again
 768:	CC80  CD0CD8  		CALL	CONOUT		; Output it
 769:	CC83  C1      		POP	BC		; Get character back
 770:	CC84  C5      		PUSH	BC		; Save it again
 771:	CC85  3A28CA  		LD	A,(FCONTP)	; Get printer echo flag
 772:	CC88  B7      		OR	A		; Test it
 773:	CC89  C40FD8  		CALL	NZ,BDLIST	; Non zero => output char to printer
 774:	CC8C  C1      		POP	BC		; Restore character
 775:	CC8D  79      		LD	A,C		; Fall through to count routine
 776:	CC8E  D1      		POP	DE
 777:	CC8F  C1      		POP	BC		; Restore pointers
 778:			
 779:			; Count Characters in line as shown by f10
 780:			
 781:	CC90  2126CA  		LD	HL,TABCNT	; Get pointer to Tab counter
 782:	CC93  34      	WRCON2:	INC	(HL)		; Increment Tab counter
 783:	CC94  FE7F    		CP	RUBOUT		; Test if character = Rubout
 784:	CC96  2815    		JR	Z,WRCON3	; Treat like Backspace
 785:	CC98  FE20    		CP	' '
 786:	CC9A  D0      		RET	NC		; Ok if not Control
 787:	CC9B  FE09    		CP	TAB		; Only DOBACK ever gets Tabs through here
 788:	CC9D  2811    		JR	Z,WRCON4	; Handle differently if Tab
 789:	CC9F  FE08    		CP	CONTH
 790:	CCA1  280A    		JR	Z,WRCON3	; Or Backspace
 791:	CCA3  34      		INC	(HL)		; Must have been echoed as two chars
 792:	CCA4  FE0A    		CP	LF
 793:	CCA6  2805    		JR	Z,WRCON3	; ..unless it's LF
 794:	CCA8  FE0D    		CP	CR		; ..or CR
 795:	CCAA  C0      		RET	NZ
 796:	CCAB  3602    		LD	(HL),2		; Reset Tab count
 797:	CCAD  35      	WRCON3:	DEC	(HL)		; Decrement Tab counter
 798:	CCAE  35      		DEC	(HL)
 799:	CCAF  C9      		RET			; And exit
 800:			
 801:	CCB0  3E07    	WRCON4:	LD	A,7		; Bumped by one already
 802:	CCB2  86      		ADD	A,(HL)		; Tabs are every 8 spaces
 803:	CCB3  E6F8    		AND	0F8H		; ...mod 8
 804:	CCB5  77      		LD	(HL),A		; Save updated Tab count
 805:	CCB6  C9      		RET			; ..and continue
 806:			
 807:			; Get Console Status - BGII uses this routine
 808:			
 809:	CCB7          	BGCONST:
 810:	CCB7  CD66CB  	CMND11:	CALL	DCIO2		; Get character present status
 811:	CCBA  C8      		RET	Z		; ..exit if none
 812:	CCBB  CD75CB  		CALL	GETCH		; Get next console char
 813:	CCBE  FE13    		CP	CONTS		; Is it stop char?
 814:	CCC0  200A    		JR	NZ,GCONS2	; ..jump if Not
 815:	CCC2  CD09D8  		CALL	CONIN		; Get next character
 816:	CCC5  FE03    		CP	CONTC		; Does the user want to exit (^C)?
 817:	CCC7  20EE    		JR	NZ,CMND11	; ..check for another character if not
 818:	CCC9  C3CACD  		JP	ERROR5		; Else jump to warm boot & clear ERMODE
 819:			
 820:	CCCC  3229CA  	GCONS2:	LD	(LASTCH),A	; Save character
 821:	CCCF  3E01    		LD	A,1		; Character present code
 822:	CCD1  C9      		RET			; Return to caller
 823:			
 824:			; Echo CR,LF
 825:			
 826:	CCD2  1149CD  	CROUT:	LD	DE,MCRLF	; Fall through to output routine
 827:			
 828:			; Output Message
 829:			
 830:	CCD5  1A      	CMND09:	LD	A,(DE)		; Get byte from buffer
 831:	CCD6  FE24    		CP	'$'		; Test last byte
 832:	CCD8  C8      		RET	Z		; Yes, then return to caller
 833:	CCD9  13      		INC	DE		; Point to next byte
 834:	CCDA  CD64CC  		CALL	WRCON		; Output character
 835:	CCDD  18F6    		JR	CMND09		; And test again
 836:			
 838:			;**********************************************
 839:			;*	 E r r o r	R o u t i n e s       *
 840:			;**********************************************
 841:			
 842:	CCDF  016400  	PRDEC:	LD	BC,100
 843:	CCE2  CDEDCC  		CALL	NUM
 844:	CCE5  0E0A    		LD	C,10
 845:	CCE7  CDEDCC  		CALL	NUM
 846:	CCEA  010101  		LD	BC,101H
 847:			
 848:			; Display Number
 849:			
 850:	CCED  16FF    	NUM:	LD	D,-1		; Load number -1
 851:	CCEF  14      	NUM1:	INC	D		; Increment number
 852:	CCF0  91      		SUB	C		; Divide by C
 853:	CCF1  30FC    		JR	NC,NUM1		; Not finished then loop
 854:	CCF3  81      		ADD	A,C		; Restore last value
 855:	CCF4  F5      		PUSH	AF		; Save it
 856:	CCF5  7A      		LD	A,D		; Test if "0"
 857:	CCF6  B0      		OR	B		; And if leading zero
 858:	CCF7  2807    		JR	Z,NUM2		; Yes, then exit
 859:	CCF9  47      		LD	B,A		; Set no leading zero
 860:	CCFA  7A      		LD	A,D		; Get number
 861:	CCFB  C630    		ADD	A,'0'		; Make ASCII
 862:	CCFD  CD54CB  		CALL	PUTCH		; Echo number preserving BC
 863:	CD00  F1      	NUM2:	POP	AF		; Restore number
 864:	CD01  C9      		RET			; And exit
 865:			
 866:			; Error Messages
 867:			
 868:	CD02  4368616E	MDSKCH:	DEFB	'Changed$'
	      67656424
 869:			
 870:	CD0A  42616420	MBADSC:	DEFB	'Bad Sector$'
	      53656374
	      6F7224
 871:			
 872:	CD15  4E6F2044	MSEL:	DEFB	'No Drive$'
	      72697665
	      24
 873:			
 874:	CD1E  46696C65	MFILRO:	DEFB	'File '
	      20
 875:			
 876:	CD23  572F5024	MRO:	DEFB	'W/P$'
 877:	FFFF          		 IF ZS
 878:	CD27  5A53444F	MBERR:	DEFB	'ZSDOS'
	      53
 879:				 ELSE
 881:				 ENDIF
 882:	CD2C  20657272		DEFB	' error on $'
	      6F72206F
	      6E2024
 883:			
 884:	CD37  0D0A4361	MBFUNC:	DEFB	CR,LF,'Call'
	      6C6C
 885:	CD3D  3A2024  	MDRIVE:	DEFB	': $'
 886:			
 887:	CD40  20204669	MFILE:	DEFB	'  File: $'
	      6C653A20
	      24
 888:			
 889:	CD49  0D0A24  	MCRLF:	DEFB	CR,LF,'$'
 890:			
 891:			; New ZSDOS error handler - enter w/ error code in B and message pointer
 892:			; in DE
 893:			
 894:	CD4C  3A5CCA  	ERROR:	LD	A,(ERMODE)
 895:	CD4F  4F      		LD	C,A		; Save error mode
 896:	CD50  0F      		RRCA			; Test supress print
 897:	CD51  385C    		JR	C,ERROR3	; Suppressed, so skip dsp
 898:			
 899:			; Print ZSDOS Error on X: Explanation
 900:			
 901:	CD53  C5      		PUSH	BC
 902:	CD54  D5      		PUSH	DE		; Save params
 903:	CD55  CDD2CC  		CALL	CROUT		; Output CR/LF
 904:	CD58  1127CD  		LD	DE,MBERR
 905:	CD5B  CDD5CC  		CALL	CMND09		; Output ZSDOS error on
 906:	CD5E  3A2BCA  		LD	A,(DEFDRV)	; Get current default drive
 907:	CD61  C641    		ADD	A,'A'		; Convert to ascii
 908:	CD63  CD64CC  		CALL	WRCON		; Output it to console
 909:	CD66  113DCD  		LD	DE,MDRIVE	; Point to drive tag
 910:	CD69  CDD5CC  		CALL	CMND09		; Put it also
 911:	CD6C  D1      		POP	DE		; Restore error message pointer
 912:	CD6D  CDD5CC  		CALL	CMND09		; Send message
 913:			
 914:			; Now print CALL: XXX [FILE: XXXXXXXX.XXX]
 915:			
 916:	CD70  1137CD  		LD	DE,MBFUNC
 917:	CD73  CDD5CC  		CALL	CMND09		; Display 'call: '
 918:	CD76  3A4BCA  		LD	A,(FUNCT)	; Get function number
 919:	CD79  CDDFCC  		CALL	PRDEC		; Output it
 920:	CD7C  3A4ECA  		LD	A,(FLDRV)
 921:	CD7F  A7      		AND	A		; Was FCB used?
 922:	CD80  2829    		JR	Z,ERROR2	; ..Skip file name display if not
 923:	CD82  C1      		POP	BC
 924:	CD83  C5      		PUSH	BC		; Get error type
 925:	CD84  DDE5    		PUSH	IX		; Save FCB pointer
 926:	CD86  3A4BCA  		LD	A,(FUNCT)	; ARE WE ERASING A FILE?
 927:	CD89  FE13    		CP	19		; IF SO, GET NAME FROM DIRBUF AS
 928:	CD8B  2004    		JR	NZ,ERROR0	; AMBIG NAME MAY HAVE BEEN USED
 929:	CD8D  CDF1D0  		CALL	CALDIR		; Get DIR buffer pointer
 930:	CD90  E3      		EX	(SP),HL		; To show what we really gagged on
 931:	CD91  1140CD  	ERROR0:	LD	DE,MFILE
 932:	CD94  CDD5CC  		CALL	CMND09		; Output 'file: '
 933:	CD97  E1      		POP	HL		; Point to FCB
 934:	CD98  060B    		LD	B,11		; Output this many chars
 935:	CD9A  23      	ERROR1:	INC	HL
 936:	CD9B  3E03    		LD	A,3
 937:	CD9D  B8      		CP	B		; Time to send '.'?
 938:	CD9E  3E2E    		LD	A,'.'		; Get ready for it
 939:	CDA0  CC54CB  		CALL	Z,PUTCH		; Send it if time
 940:	CDA3  7E      		LD	A,(HL)		; Get char
 941:	CDA4  E67F    		AND	7FH		; Mask attributes
 942:	CDA6  CD54CB  		CALL	PUTCH		; Output it
 943:	CDA9  10EF    		DJNZ	ERROR1
 944:	CDAB  CDD2CC  	ERROR2:	CALL	CROUT		; Send CR,LF
 945:	CDAE  C1      		POP	BC		; Get error mode back
 946:	CDAF  3E04    	ERROR3:	LD	A,4
 947:	CDB1  90      		SUB	B		; Test if select error
 948:	CDB2  200D    		JR	NZ,ERROR4	; Skip if not
 949:	CDB4  212CCA  		ld	hl,drive	; point to old default
 950:	CDB7  7E      		ld	a,(hl)		; get it
 951:	CDB8  2B      		dec	hl		; point to bad drive
 952:	CDB9  BE      		cp	(hl)		; same?
 953:	CDBA  2805    		jr	z,error4	; if so, skip relog
 954:	CDBC  C5      		PUSH	BC
 955:	CDBD  CD81CF  		CALL	SELDK		; Get BIOS back in step
 956:	CDC0  C1      		POP	BC
 957:	CDC1  CB49    	ERROR4:	BIT	1,C		; Test if return error mode
 958:	CDC3  2018    		JR	NZ,ERROR7	; Go if return error
 959:	CDC5  3E01    		LD	A,1
 960:	CDC7  90      		SUB	B		; Test if fatal error
 961:	CDC8  3005    		JR	NC,ERROR6	; If not a fatal error
 962:	CDCA  AF      	ERROR5:	XOR	A
 963:	CDCB  325CCA  		LD	(ERMODE),A	; Set DOS error mode to default CP/M
 964:	CDCE  C7      		RST	0		; ..and leave
 965:			
 966:	CDCF  CD71CB  	ERROR6:	CALL	DCIO1		; Get console char if present
 967:	CDD2  A7      		AND	A		; Test if any
 968:	CDD3  20FA    		JR	NZ,ERROR6	; Keep getting them until typeahead eaten
 969:	CDD5  CD75CB  		CALL	GETCH		; Now get operator's response
 970:	CDD8  FE03    		CP	CONTC		; Test if abort
 971:	CDDA  C0      		RET	NZ		; If operator said ignore error
 972:	CDDB  18ED    		JR	ERROR5		; Else boot
 973:			
 974:	CDDD  78      	ERROR7:	LD	A,B		; Get error
 975:	CDDE  67      		LD	H,A		; Save code in H reg for return
 976:	CDDF  A7      		AND	A		; Test if disk changed warning
 977:	CDE0  C8      		RET	Z		; Continue relog if so
 978:	CDE1  2EFF    		LD	L,0FFH		; Set extended error code
 979:	CDE3  224CCA  		LD	(PEXIT),HL	; Save as return code
 980:						; ..and fall thru to DOS exit
 982:			;******************************************************
 983:			;*	 D O S	   E x i t    R o u t i n e	      *
 984:			;******************************************************
 985:			
 986:	CDE6  3A4ECA  	DOSEXIT: LD	A,(FLDRV)	; Test drive select used flag
 987:	CDE9  B7      		OR	A
 988:	CDEA  280C    		JR	Z,DOSEXT0	; No then exit
 989:	CDEC  3A2DCA  		LD	A,(FCB0)	; Get FCB byte 0
 990:	CDEF  DD7700  		LD	(IX+0),A	; Save it
 991:	CDF2  3A2CCA  		LD	A,(DRIVE)	; Get old drive number
 992:	CDF5  CD81CF  		CALL	SELDK		; Select disk
 993:	0000          		  IF  PICKEY
 995:				  ENDIF
 996:			
 997:			; If the error handler was invoked, the stack is in an undefined
 998:			;  condition at this point.  We therefore have to restore the user's
 999:			;  IX register independent of stack position.  Thanks to Joe Wright's
1000:			;  eagle eye for catching this one!
1001:			
1002:	CDF8  ED7B61CA	DOSEXT0: LD	SP,(SPSAVE)	; Restore user stack
1003:	CDFC  DD2A99CA		LD	IX,(IXSAVE)	; Restore IX (stack is don't care)
1004:	CE00  2A4CCA  		LD	HL,(PEXIT)	; Get exit code
1005:	FFFF          		  IF  NOT PICKEY
1006:	CE03  ED5B5FCA		LD	DE,(DEVAL)	; And DE reg for DateStamper
1007:				  ENDIF
1008:	CE07  7D      		LD	A,L		; Copy function code
1009:	CE08  44      		LD	B,H
1010:	CE09  C9      		RET			; And return to caller
1012:			;******************************************************
1013:			;*	 D i s k     F u n c t i o n s		      *
1014:			;******************************************************
1015:			
1016:			; Reset Disk System
1017:			
1018:	CE0A  218000  	CMND13:	LD	HL,RAMLOW+0080H	; Set up DMA address
1019:	CE0D  222ECA  		LD	(DMA),HL	; And save it
1020:	CE10  CD37D2  		CALL	STDMA		; Do BIOS call
1021:			; 	XOR	A		; Set default drive = 'A'
1022:	CE13  3A36D8  		LD	A,(BOTDSK)	; default drive is boot drive
1023:	CE16  322BCA  		LD	(DEFDRV),A	; Save it
1024:	CE19  11FFFF  		LD	DE,0FFFFH	; Reset all drives
1025:			
1026:			; Reset Multiple Login Drive - DE = Reset mask
1027:			; Fixed Disk Login vector is also altered by this call
1028:			
1029:	CE1C  CD5DCE  	CMND37:	CALL	UNLOG		; Clear selected drives in DE from login
1030:	CE1F  3A15CA  		LD	A,(FLAGS)
1031:	CE22  CB57    		BIT	2,A		; Test hard R/O enabled
1032:	CE24  2006    		JR	NZ,UNWPT1	; If enabled
1033:	CE26  21FCD7  		LD	HL,DSKWP	; Get drive W/P vector
1034:	CE29  CD66CE  		CALL	ANDDEM		; Reset W/P stat only of requested drvs
1035:	CE2C  3A4BCA  	UNWPT1:	LD	A,(FUNCT)
1036:	CE2F  FE0D    		CP	13		; Skip hard disk login change?
1037:	CE31  21FED7  		LD	HL,HDLOG
1038:	CE34  C466CE  		CALL	NZ,ANDDEM	; Clear HD Login Vector if Fcn 37
1039:	CE37          	RELOG1:
1040:	FFFF          		  IF  ZS
1041:	CE37  2AFED7  		LD	HL,(HDLOG)
1042:	CE3A  CD58D0  		CALL	HLORDE		; Don't clear fixed disks from T/D
1043:	CE3D  EB      		EX	DE,HL		; Place modified logout in DE
1044:	CE3E  21F8D7  		LD	HL,TDFVCT
1045:	CE41  CD66CE  		CALL	ANDDEM		; Clear T/D vector as needed
1046:				  ENDIF
1047:			
1048:	CE44  3A2BCA  		LD	A,(DEFDRV)	; Get default drive
1049:	CE47  F5      		PUSH	AF
1050:	CE48          	RELOG2:
1051:	0000          		  IF  RESDSK		; (bh)
1053:				  ELSE
1054:			; 	DEFB	0,0,0		; Make 3 NOP's to keep constant code (hfb)
1055:	CE48  00      		DEFB	0		; two bytes stolen to keep in sync with
1056:							; BIOS BOTDSK
1057:				  ENDIF			; (bh)
1058:	CE49  F1      		POP	AF
1059:	CE4A  CD81CF  		CALL	SELDK		; Select default drive
1060:			
1061:			; ZSDOS watches for any $*.* in any user on any drive during re-log,
1062:			; make, and delete.  In this manner, SUBFLG will always be valid -
1063:			; even under fast relog and NZCOM!  Thanks to Joe Wright for suggesting
1064:			; the need for this, and suggesting ways to do it.
1065:			
1066:	CE4D  3A57CA  	SUBEXT:	LD	A,(SUBFLG)	; Get submit flag
1067:	CE50  1869    		JR	SAVEA		; Exit
1068:			
1069:			; Check for possible existance of submit file by checking first
1070:			; byte of dir entry or FCB for '$'.  Pointer to dir or FCB passed
1071:			; to routine in HL.
1072:			
1073:	CE52  23      	CKSUB:	INC	HL		; Point to file name
1074:	CE53  7E      		LD	A,(HL)		; Get first char filename
1075:	CE54  2B      		DEC	HL
1076:	CE55  D624    		SUB	'$'		; Test if '$'
1077:	CE57  C0      		RET	NZ		; Not then exit
1078:	CE58  3D      		DEC	A		; Load a with 0FFH
1079:	CE59  3257CA  		LD	(SUBFLG),A	; Save it in subflg
1080:	CE5C  C9      		RET
1081:			
1082:			; Unlog Drive mask in DE
1083:			
1084:	CE5D  7B      	UNLOG:	LD	A,E		; Get LSB
1085:	CE5E  2F      		CPL			; Complement it
1086:	CE5F  5F      		LD	E,A
1087:	CE60  7A      		LD	A,D		; Get MSB
1088:	CE61  2F      		CPL			; Complement it
1089:	CE62  57      		LD	D,A		; DE = not reset
1090:	CE63  21FAD7  		LD	HL,LOGIN	; Get addr of login vector
1091:	CE66  7B      	ANDDEM:	LD	A,E		; Clear login bits of reset drives
1092:	CE67  A6      		AND	(HL)		; ..a byte at a time
1093:	CE68  77      		LD	(HL),A		; Put to memory
1094:	CE69  23      		INC	HL
1095:	CE6A  7A      		LD	A,D
1096:	CE6B  A6      		AND	(HL)
1097:	CE6C  77      		LD	(HL),A
1098:	CE6D  C9      		RET
1099:			
1100:			; Search for File
1101:			
1102:	CE6E  CD1FCF  	CMND17:	CALL	SELDRV		; Select drive from FCB
1103:	CE71  DD7E00  		LD	A,(IX+0)
1104:	CE74  D63F    		SUB	'?'		; Test if '?'
1105:	CE76  280D    		JR	Z,CMD17B	; If so all entries match
1106:	CE78  DD7E0E  		LD	A,(IX+FCBMOD)	; Get system byte
1107:	CE7B  FE3F    		CP	'?'		; Test if '?'
1108:	CE7D  2804    		JR	Z,CMD17A	; Yes, jump
1109:	CE7F  DD360E00		LD	(IX+FCBMOD),0	; Load system byte with Zero
1110:	CE83  3E0F    	CMD17A:	LD	A,15		; Test first 15 items in FCB
1111:	CE85  CDF3D2  	CMD17B:	CALL	SEARCH		; Do search
1112:	CE88  2A34CA  	CMD17C:	LD	HL,(DIRBUF)	; Copy directory buffer
1113:	CE8B  018000  		LD	BC,128		; Directory=128 bytes
1114:	CE8E  ED5B2ECA	MV2DMA:	LD	DE,(DMA)	; To DMA address
1115:	CE92  EDB0    		LDIR
1116:	CE94  C9      		RET			; Exit
1117:			
1118:			; Search for Next Occurence of File
1119:			
1120:	CE95  DD2A58CA	CMND18:	LD	IX,(DCOPY)	; Get last FCB used by search
1121:	CE99  DD225DCA		LD	(ARWORD),IX	; Save FCB pointer for BGii
1122:	CE9D  CD1FCF  		CALL	SELDRV		; Select drive from FCB
1123:	CEA0  CD0AD3  		CALL	SEARCN		; Search next file match
1124:	CEA3  18E3    		JR	CMD17C		; And copy directory to DMA address
1125:			
1126:			; Delete File
1127:			
1128:	CEA5  CD1FCF  	CMND19:	CALL	SELDRV		; Select drive from FCB
1129:	CEA8  CD6DD2  		CALL	DELETE		; Delete file
1130:	CEAB  3A5ACA  	CMD19A:	LD	A,(SEAREX)	; Get exit byte 00=file found, 0FFH=Not
1131:	CEAE  180B    		JR	SAVEA		; And exit
1132:			
1133:			; Rename File
1134:			
1135:	CEB0  CD1FCF  	CMND23:	CALL	SELDRV		; Select drive from FCB
1136:	CEB3  CDD7D3  		CALL	RENAM		; Rename file
1137:	CEB6  18F3    		JR	CMD19A		; And exit
1138:			
1139:			; Return Current Drive
1140:			
1141:	CEB8  3A2BCA  	CMND25:	LD	A,(DEFDRV)	; Get current drive
1142:	CEBB  324CCA  	SAVEA:	LD	(PEXIT),A	; Return character
1143:	CEBE  C9      	DUMMY:	RET			; ..and exit ZSDOS
1144:			
1145:			; Set flags
1146:			
1147:	CEBF  3215CA  	CMD101:	LD	(FLAGS),A	; Set ZSDOS flags
1148:							; ..and fall thru
1149:			; Get flags
1150:			
1151:	CEC2  3A15CA  	CMD100:	LD	A,(FLAGS)	; Get ZSDOS flags
1152:	CEC5  18F4    		JR	SAVEA		; ..and exit
1153:			
1154:			; Change Status
1155:			
1156:	CEC7  CD1FCF  	CMND30:	CALL	SELDRV		; Select drive from FCB
1157:	CECA  CD02D4  		CALL	CSTAT		; Change status
1158:	CECD  18DC    		JR	CMD19A		; And exit
1159:			
1160:			; Return CP/M Version Number
1161:			
1162:	CECF          	ZDPCH1:
1163:	CECF  212200  	CMND12:	LD	HL,22H		; Set CP/M compatable version number
1164:	0000          		  IF  NOT ZS		; (crw)
1173:				  ENDIF
1174:	FFFF          		  IF  NOT PICKEY
1175:	CED2  ED535FCA		LD	(DEVAL),DE	; In case DS gave us a clock addr
1176:				  ENDIF
1177:	CED6  181B    		JR	SAVHL		; For speed
1178:			
1179:			; Following commands return status in like manner and are consolidated here
1180:			; in selected order with least-accessed commands taking longest to traverse
1181:			; string, and frequently accessed/time critical exitting quickest.
1182:			
1183:			; The code in this section is a bit obscure, as it depends on burying
1184:			; instructions within other instructions.  6502 users have long used the
1185:			; 'BIT' trick to skip instructions - this inspired me to see if similar
1186:			; things could be done with the Z80.  Indeed they can, as this demonstrates.
1187:			; When the Z80 jumps in at a label, it executes the LD HL instruction.	The
1188:			; DEFB 0DDH turns the LD HL instructions that follow into LD IX.  In effect,
1189:			; this turns the DEFB 0DDH into a one byte relative jump to SAVHL.  As IX
1190:			; is never used by these calls, its loss is of no consequence.
1191:			; A similar trick is used in SEAR15, resulting in a useless LD HL but
1192:			; saving a byte.
1193:			
1194:			; New Universal Return Version FUNCTION 48
1195:			
1196:	CED8          	CMND48:
1197:	FFFF          		  IF  ZS
1198:	CED8  211153  		LD	HL,('S' SHL 8) + BDVERS ;"S" indicates ZSDOS - ZRDOS returns 0
1199:				  ELSE
1201:				  ENDIF
1202:	CEDB  DD      		DEFB	0DDH		; Trash IX and fall through
1203:			
1204:			; Return Disk W/P Vector
1205:			
1206:	CEDC  2AFCD7  	CMND29:	LD	HL,(DSKWP)	; Get disk W/P vector
1207:	CEDF  DD      		DEFB	0DDH		; Trash IX and fall through
1208:			
1209:			; Return Fixed Disk Login Vector
1210:			
1211:	CEE0  2AFED7  	CMND39:	LD	HL,(HDLOG)	; Return fixed disk login vector
1212:	CEE3  DD      		DEFB	0DDH		; Trash IX and fall through
1213:			
1214:			; Return ALV Vector
1215:			
1216:	CEE4  2A3ACA  	CMND27:	LD	HL,(ALV)	; Get allocation vector
1217:	CEE7  DD      		DEFB	0DDH		; Trash IX and fall through
1218:			
1219:			; Return Login Vector
1220:			
1221:	CEE8  2AFAD7  	CMND24:	LD	HL,(LOGIN)	; Get login vector
1222:	CEEB  DD      		DEFB	0DDH		; Trash IX and fall through
1223:			
1224:			; Return Drive Table
1225:			
1226:	CEEC  2A36CA  	CMND31:	LD	HL,(IXP)	; Get drive table
1227:	CEEF  DD      		DEFB	0DDH		; Trash IX and fall through
1228:			
1229:			; Return Current DMA
1230:			
1231:	CEF0  2A2ECA  	CMND47:	LD	HL,(DMA)	; Return current DMA addr
1232:	CEF3  224CCA  	SAVHL:	LD	(PEXIT),HL	; Save it
1233:	CEF6  C9      		RET			; And exit
1234:			
1235:			; Set BDOS Error Mode
1236:			
1237:	CEF7  325CCA  	CMND45:	LD	(ERMODE),A	; Save error mode
1238:	CEFA  C9      		RET			; And exit
1239:			
1240:			; Set/Get User Code
1241:			
1242:	CEFB  212ACA  	CMND32:	LD	HL,USER		; Point to user byte location
1243:	CEFE  3C      		INC	A		; Test if 0FFH
1244:	CEFF  7E      		LD	A,(HL)		; Get old user code
1245:	CF00  28B9    		JR	Z,SAVEA		; If 0FFH then exit
1246:	CF02  7B      		LD	A,E		; Get new user code
1247:	CF03  E61F    		AND	01FH		; Mask it
1248:	CF05  77      		LD	(HL),A		; Save it
1249:	CF06  C9      		RET			; And exit
1250:			
1251:			; Compute File Size Command
1252:			
1253:	CF07  CD2DCF  	CMND35:	CALL	SELDR1		; Select drive from FCB
1254:	CF0A  CD2BD4  		CALL	FILSZ		; Compute file size
1255:	CF0D  189C    		JR	CMD19A		; And exit
1256:			
1257:			; Set Random Record Count
1258:			
1259:	CF0F  212000  	CMND36:	LD	HL,32		; Set pointer to next record
1260:	CF12  CD7FD7  		CALL	CALRRC		; Calculate random record count
1261:	CF15  DD7221  	LDRRC:	LD	(IX+33),D	; And save random record count
1262:	CF18  DD7122  		LD	(IX+34),C
1263:	CF1B  DD7023  		LD	(IX+35),B
1264:	CF1E  C9      		RET			; And exit
1265:			
1266:			; Select Disk From FCB
1267:			
1268:	CF1F          	BGSELDRV:
1269:	CF1F  3A5CCA  	SELDRV:	LD	A,(ERMODE)	; Are we in modified user mode?
1270:	CF22  A7      		AND	A
1271:	CF23  2008    		JR	NZ,SELDR1	; Jump if so, else..
1272:	CF25  2A5DCA  		LD	HL,(ARWORD)	;
1273:	CF28  010D00  		LD	BC,FCBUSR	; Point to user number
1274:	CF2B  09      		ADD	HL,BC		;
1275:	CF2C  77      		LD	(HL),A		; Clear user flag
1276:	CF2D  3EFF    	SELDR1:	LD	A,0FFH		; Set disk select done flag
1277:	CF2F  324ECA  		LD	(FLDRV),A
1278:	CF32  3A2BCA  		LD	A,(DEFDRV)	; Get current drive
1279:	CF35  5F      		LD	E,A		; Save it in register E
1280:	CF36  2A5DCA  		LD	HL,(ARWORD)
1281:	CF39  7E      		LD	A,(HL)		; Get drive from FCB
1282:	CF3A  322DCA  		LD	(FCB0),A	; Save it
1283:	CF3D  FE3F    		CP	'?'		; Test if '?'
1284:	CF3F  2839    		JR	Z,CMND14	; Yes, then select drive from register E
1285:	CF41  DDE5    		PUSH	IX		; Save BGii's IX register
1286:							; IX won't be altered on cmnd14
1287:	CF43  DD2A5DCA		LD	IX,(ARWORD)	; Get FCB pointer
1288:			;1.1a Changed to allow proper access to Drive P:
1289:			;1.2a	AND	0FH		; Mask drive
1290:	CF47  E61F    		AND	1FH		;1.2a Mask Drive
1291:	CF49  E5      		PUSH	HL
1292:	CF4A  2802    		JR	Z,SELDR0	; Select drive from register E
1293:	CF4C  5E      		LD	E,(HL)		; Get drive from FCB
1294:	CF4D  1D      		DEC	E		; Decrement drive number so A=0
1295:	CF4E  CD7ACF  	SELDR0:	CALL	CMND14		; - do select of drive
1296:	CF51  E1      		POP	HL		; Restore FCB pointer
1297:			
1298:			; Resolve User for FCB - FCBPTR in IX, Returns User in A
1299:			
1300:	CF52  DD7E0D  		LD	A,(IX+FCBUSR)	; ..get potential user in case
1301:	CF55  CB7F    		BIT	7,A		; Is this a valid user?
1302:	CF57  2007    		JR	NZ,RESUS1	; Skip if there is
1303:	CF59  3A2ACA  		LD	A,(USER)	; Get user number
1304:	CF5C  1802    		JR	RESUS1		; ..and bypass push IX
1305:			
1306:			; Set User in FCB to Value passed in A
1307:			
1308:	CF5E  DDE5    	RESUSR:	PUSH	IX		; Preserve IX
1309:	CF60  DD2A5DCA	RESUS1:	LD	IX,(ARWORD)
1310:	CF64  E61F    		AND	1FH		; User number in A
1311:	CF66  DD7700  		LD	(IX+0),A	; Save in FCB 0 byte
1312:	CF69  F680    		OR	80H		; Set valid DOS user flag
1313:	CF6B  DD770D  		LD	(IX+FCBUSR),A	; ..and in FCB 13 byte
1314:	CF6E  DDE1    		POP	IX		; Restore caller's IX
1315:	CF70  C9      		RET
1316:			
1317:			; Select Disk Error Exit - The stack is off by one level here, but
1318:			;  this is a one way trip anyway.
1319:			
1320:	CF71  2A0BCA  	SELDK3:	LD	HL,(STSEL)	; Load error message address
1321:	CF74  0604    		LD	B,4		; Select error
1322:	CF76  1115CD  		LD	DE,MSEL		; Load select error message
1323:	CF79  E9      		JP	(HL)		; And display error
1324:			
1325:			; Select Disk from E register
1326:			
1327:	CF7A  3A2BCA  	CMND14:	LD	A,(DEFDRV)	; Get current drive
1328:	CF7D  322CCA  		LD	(DRIVE),A	; Save it in memory
1329:	CF80  7B      		LD	A,E		; Copy drive number
1330:			
1331:			; Select Disk
1332:			;  Call w/ A = Drive Number (0..15 = A..P)
1333:			
1334:	CF81          	SELDK:
1335:	CF81  2AFAD7  		LD	HL,(LOGIN)	; Get login vector
1336:	CF84  E60F    		AND	0FH		; Mask drive number
1337:	CF86  47      		LD	B,A		; Save counter
1338:	CF87  C461D0  		CALL	NZ,SHRHLB	; ..and rotate into position
1339:	CF8A  EB      	SELDK0:	EX	DE,HL		; Put drive bit mask in DE
1340:	CF8B  212BCA  		LD	HL,DEFDRV	; Get pointer last drive
1341:	CF8E  CB43    		BIT	0,E		; Test if drive logged in
1342:	CF90  2802    		JR	Z,SELDK2	; No, login drive
1343:	CF92  BE      		CP	(HL)		; Test same drive
1344:	CF93  C8      		RET	Z		; Yes then exit
1345:			
1346:			; NOTE: A long standing DOS bug concerns the SELECT function.  If a
1347:			;  function 14 call is made and the drive doesn't exist, the default
1348:			;  will still point to the bad drive unless we fix it in the error
1349:			;  routine.  It is for this reason that drive is saved above.  We must
1350:			;  allow default to assume the illegal drive value long enough for the
1351:			;  error handler to print it, then re-select the old default.
1352:			
1353:	CF94          	SELDK2:
1354:	CF94  77      		LD	(HL),A		; Save new current drive
1355:	CF95  D5      		PUSH	DE		; Save drive logged in flag
1356:	CF96  4F      		LD	C,A		; Copy drive number
1357:	CF97  CD1BD8  		CALL	SELDSK		; Do BIOS select
1358:	CF9A  7C      		LD	A,H		; Test if error
1359:	CF9B  B5      		OR	L
1360:	CF9C  28D3    		JR	Z,SELDK3	; Yes, illegal drive number
1361:	CF9E  1130CA  		LD	DE,TRANS	; Point to local translation store
1362:	CFA1  010200  		LD	BC,2		; ..and move 2-byte ptr in
1363:	CFA4  EDB0    		LDIR
1364:	CFA6  2232CA  		LD	(TEMP0),HL	; Save address temp0
1365:	CFA9  0E06    		LD	C,6		; Advance to dirbuf part of DPH
1366:	CFAB  09      		ADD	HL,BC		; As TEMP1 and TEMP2 unused in P?DOS
1367:	CFAC  1134CA  		LD	DE,DIRBUF	; Load DIRBUF pointer
1368:	CFAF  0E08    		LD	C,8		; Copy 8 bytes
1369:	CFB1  EDB0    		LDIR
1370:	CFB3  2A36CA  		LD	HL,(IXP)	; Get drive parameter address
1371:	CFB6  0E0F    		LD	C,15		; Copy 15 bytes
1372:	CFB8  EDB0    		LDIR
1373:	CFBA  D1      		POP	DE		; Get drive logged in flag
1374:	CFBB  CB43    		BIT	0,E		; Test it
1375:	CFBD  C0      		RET	NZ		; Drive logged in so return
1376:	CFBE  CD47D0  		CALL	GETCDM
1377:	CFC1  EB      		EX	DE,HL		; Drive mask in DE
1378:	CFC2  2AFAD7  		LD	HL,(LOGIN)	; Get login vector
1379:	CFC5  CD58D0  		CALL	HLORDE		; Set drive bit in login vector
1380:	CFC8  22FAD7  		LD	(LOGIN),HL	; Save login vector
1381:	CFCB  3A15CA  		LD	A,(FLAGS)	; Get flags
1382:	CFCE  CB5F    		BIT	3,A		; Fast relog enabled?
1383:	CFD0  282A    		JR	Z,INITDR	; Skip if disabled
1384:			
1385:			; The following code checks the WACD size to determine if the drive
1386:			;  being selected is a fixed disk.  If the WACD size is 0, the disk
1387:			;  is Non-Removable.  However, several BIOSes support remapping of
1388:			;  logical drives.  This complicates matters because BDOS must catch
1389:			;  the swap and clear the Hard Disk Allocation Vector and allow the
1390:			;  allocation bitmaps to be rebuilt.  Thus, every disk that is being
1391:			;  selected for the first time traverses this code.  If a disk was
1392:			;  logged as a fixed disk and all of the sudden has a WACD buffer,
1393:			;  the Fixed Disk Login Vector is cleared.  Thus, for Bug-free
1394:			;  operation of Fast Fixed Disk Logging, if drives are swapped
1395:			;  NEVER SWAP TWO FIXED DRIVES!
1396:			
1397:	CFD2  2A47CA  		LD	HL,(NCHECK)	; Is this a fixed drive?
1398:	CFD5  7C      		LD	A,H
1399:	CFD6  B5      		OR	L
1400:	CFD7  4F      		LD	C,A		; Save fixed disk flag (Z=true)
1401:	CFD8  2AFED7  		LD	HL,(HDLOG)
1402:	CFDB  7B      		LD	A,E		; See if logged as fixed disk
1403:	CFDC  A5      		AND	L
1404:	CFDD  6F      		LD	L,A
1405:	CFDE  7A      		LD	A,D
1406:	CFDF  A4      		AND	H		; MSB
1407:	CFE0  B5      		OR	L		; Z flag set if HL and DE = 0
1408:	CFE1  3EFF    		LD	A,0FFH		; Don't alter flags
1409:	CFE3  2801    		JR	Z,SELDK4	; If not logged as fixed disk
1410:	CFE5  3C      		INC	A		; Else flag as logged
1411:	CFE6  47      	SELDK4:	LD	B,A		; Save logged as fixed disk flag (Z=true)
1412:	CFE7  B1      		OR	C		; Test if still fixed disk
1413:	CFE8  C8      		RET	Z		; Skip re-map if logged and not swapped
1414:	CFE9  AF      		XOR	A
1415:	CFEA  67      		LD	H,A
1416:	CFEB  6F      		LD	L,A		; Null vector
1417:	CFEC  B0      		OR	B		; Was it logged as a fixed disk?
1418:	CFED  280A    		JR	Z,SELDK5	; Invalidate HDLOG vector - drive no longer
1419:							; Fixed disk
1420:	CFEF  79      		LD	A,C
1421:	CFF0  B7      		OR	A		; Wasn't fixed disk before - is it now?
1422:	CFF1  2009    		JR	NZ,INITDR	; Skip vector update if it isn't
1423:	CFF3  2AFED7  		LD	HL,(HDLOG)
1424:	CFF6  CD58D0  		CALL	HLORDE		; Else add this drive to fixed disk vector
1425:	CFF9  22FED7  	SELDK5:	LD	(HDLOG),HL	; Update fixed disk vector
1426:						;..fall thru to INITDR
1427:			
1428:			; Init Drive
1429:			;  Clear ALV Bit Buffer after Drive reset
1430:			
1431:	CFFC  2A41CA  	INITDR:	LD	HL,(MAXLEN)	; Get length ALV buffer-1 (bits)
1432:	CFFF  CD5FD0  		CALL	SHRHL3		; Divide by 8 to get bytes
1433:	D002  44      		LD	B,H
1434:	D003  4D      		LD	C,L		; Counter to BC (will be count+1 cleared)
1435:	D004  2A3ACA  		LD	HL,(ALV)	; Get pointer ALV buffer
1436:	D007  E5      		PUSH	HL
1437:	D008  54      		LD	D,H
1438:	D009  5D      		LD	E,L
1439:	D00A  13      		INC	DE		; ALV buffer +1 in DE
1440:	D00B  AF      		XOR	A
1441:	D00C  77      		LD	(HL),A		; Clear first 8 bits
1442:	D00D  EDB0    		LDIR			; And remainder of buffer
1443:	D00F  E1      		POP	HL		; Get ALV pointer
1444:	D010  ED5B45CA		LD	DE,(NDIR0)	; Get first two bytes ALV buffer
1445:	D014  73      		LD	(HL),E		; Save LSB
1446:	D015  23      		INC	HL		; Increment pointer
1447:	D016  72      		LD	(HL),D		; Save MSB
1448:	D017  2A32CA  		LD	HL,(TEMP0)	; Clear number of files on this drive
1449:	D01A  77      		LD	(HL),A		; Clear LSB (A still has 0)
1450:	D01B  23      		INC	HL		; Increment pointer
1451:	D01C  77      		LD	(HL),A		; Clear MSB
1452:			
1453:	D01D          	ZDPCH2	EQU	$		;<-- Intercept first scan (ZDS Patch)
1454:	D01D  CDFCD0  		CALL	SETFCT		; Set file count
1455:	D020  3EFF    	INITD2:	LD	A,0FFH		; Update directory checksum
1456:	D022  CD30D1  		CALL	RDDIR		; Read FCB's from directory
1457:	D025  CD1CD1  		CALL	TSTFCT		; Test last FCB
1458:	D028  CA4DCE  		JP	Z,SUBEXT	; Return subflg for strict CP/M compat (hfb)
1459:	D02B  CDF1D0  		CALL	CALDIR		; Calculate entry point FCB
1460:	D02E  7E      		LD	A,(HL)		; Get first byte FCB
1461:	D02F  FEE5    		CP	0E5H		; Test empty directory entry
1462:	D031  28ED    		JR	Z,INITD2	; Yes then get next FCB
1463:	D033  FE21    		CP	021H		; Test time stamp
1464:	D035  28E9    		JR	Z,INITD2	; Yes then get next FCB
1465:			
1466:	D037          	ZDPCH3	EQU	$		;<-- Test for T&D if first time (ZDS Patch)
1467:	D037  CD52CE  		CALL	CKSUB		; Test for submit file
1468:	D03A  0E01    		LD	C,1		; Set bit in ALV buffer
1469:	D03C  CD83D2  		CALL	FILLBB		; Set bits from FCB in ALV buffer
1470:	D03F  CD23D1  		CALL	TSTLF		; Test for last file
1471:	D042  D414D1  		CALL	NC,SETLF0	; ..and update the last file count if so
1472:	D045  18D9    		JR	INITD2		; And get next FCB
1473:			
1474:			; Return Mask for Current Drive in HL
1475:			
1476:	D047  210000  	GETCDM:	LD	HL,0		; No drives to Or
1477:			
1478:			; Set Drive bit in HL
1479:			
1480:	D04A  EB      	SDRVB:	EX	DE,HL		; Copy HL=>DE
1481:	D04B  210100  		LD	HL,1		; Get mask drive "A"
1482:	D04E  3A2BCA  		LD	A,(DEFDRV)	; Get current drive
1483:	D051  B7      		OR	A		; Test if drive "A"
1484:	D052  2804    		JR	Z,HLORDE	; Yes then done
1485:	D054  29      	SDRVB0:	ADD	HL,HL		; Get next mask
1486:	D055  3D      		DEC	A		; Decrement drive counter
1487:	D056  20FC    		JR	NZ,SDRVB0	; And test if done
1488:	D058  7A      	HLORDE:	LD	A,D		; HL=HL or DE
1489:	D059  B4      		OR	H
1490:	D05A  67      		LD	H,A
1491:	D05B  7B      		LD	A,E
1492:	D05C  B5      		OR	L
1493:	D05D  6F      		LD	L,A
1494:	D05E  C9      		RET			; Exit
1495:			
1496:	D05F  0603    	SHRHL3:	LD	B,3		; Used in a few places
1497:			
1498:			; Shift HL right logical B bits
1499:			
1500:	D061  CB3C    	SHRHLB:	SRL	H
1501:	D063  CB1D    		RR	L		; Shift HL right one bit (divide by 2)
1502:	D065  10FA    		DJNZ	SHRHLB
1503:	D067  C9      		RET
1504:			
1505:			; Calculate Sector/Track Directory
1506:			
1507:	D068  2A54CA  	STDIR:	LD	HL,(FILCNT)	; Get FCB counter directory
1508:	FFFF          		  IF  UNROLL
1509:	D06B  CB3C    		SRL	H
1510:	D06D  CB1D    		RR	L
1511:	D06F  CB3C    		SRL	H		; (net cost: 3)
1512:	D071  CB1D    		RR	L		; Divide by 4 (inline for speed)
1513:				  ELSE
1516:				  ENDIF
1517:	D073  2252CA  		LD	(RECDIR),HL	; Save value (used by checksum)
1518:	D076  EB      	STDIR2:	EX	DE,HL		; Copy it to DE
1519:	D077  210000  	STDIR1:	LD	HL,0		; Clear HL
1520:			
1521:			; Calculate Sector/Track
1522:			;  Entry: HL,DE=Sector Number (128 byte sector)
1523:			;  Result Set Track  =HL,DE  /	MAXSEC
1524:			;	  Set Sector =HL,DE MOD MAXSEC
1525:			
1526:	D07A  ED4B3CCA	CALST:	LD	BC,(MAXSEC)	; Get sectors/track
1527:	D07E  3E11    		LD	A,17		; Set up loop counter
1528:	D080  B7      	CALST0:	OR	A
1529:	D081  ED42    		SBC	HL,BC		; HL > BC?
1530:	D083  3F      		CCF
1531:	D084  3802    		JR	C,CALST1	; Yes then jump
1532:	D086  09      		ADD	HL,BC		; No then restore HL
1533:	D087  B7      		OR	A		; Clear Carry
1534:	D088  CB13    	CALST1:	RL	E		; Shift result in DE
1535:	D08A  CB12    		RL	D
1536:	D08C  3D      		DEC	A		; Test last bit done
1537:	D08D  2804    		JR	Z,CALST2	; Yes then exit
1538:	D08F  ED6A    		ADC	HL,HL		; Shift next bit in HL
1539:	D091  18ED    		JR	CALST0		; Continue
1540:			
1541:	D093  E5      	CALST2:	PUSH	HL		; Save sector number
1542:	D094  2A49CA  		LD	HL,(NFTRK)	; Get first track
1543:	D097  19      		ADD	HL,DE		; Add track number
1544:	D098  44      		LD	B,H		; Copy it to BC
1545:	D099  4D      		LD	C,L
1546:	D09A  CD1ED8  		CALL	SETTRK		; CBIOS call Set Track
1547:	D09D  C1      		POP	BC		; Restore sector number
1548:	D09E  ED5B30CA		LD	DE,(TRANS)	; Get translation table address
1549:	D0A2  CD30D8  		CALL	SECTRN		; CBIOS call sector translation
1550:	D0A5  44      		LD	B,H		; Copy result to BC
1551:	D0A6  4D      		LD	C,L
1552:	D0A7  C321D8  		JP	SETSEC		; BIOS call Set Sector
1553:			
1554:			; Get Disk Map Block Number from FCB   (Squeezed by Joe Wright)
1555:			;  Exit HL=Address FCB
1556:			;	DE=DM
1557:			;	BC=Offset in DM
1558:			;	Zero Flag Set (Z) if DM=0, Else reset (NZ)
1559:			
1560:	D0AA  DD6E20  	GETDM:	LD	L,(IX+NXTREC)	; Get record number in L
1561:	D0AD  CB15    		RL	L		; Shift it left once
1562:	D0AF  3A40CA  		LD	A,(NEXTND)	; Get EXM
1563:	D0B2  DDA60C  		AND	(IX+FCBEXT)	; And the extent number
1564:	D0B5  67      		LD	H,A		; To H
1565:	D0B6  3A3ECA  		LD	A,(NBLOCK)	; Get BSH
1566:	D0B9  47      		LD	B,A		; To B
1567:	D0BA  04      		INC	B		; +1
1568:	D0BB  CD61D0  		CALL	SHRHLB		; Shift HL right B times
1569:	D0BE  50      		LD	D,B		; Zero to D
1570:	D0BF  7D      		LD	A,L		; Result to A
1571:			
1572:	D0C0  2A5DCA  	GETDM4:	LD	HL,(ARWORD)
1573:	D0C3  0E10    		LD	C,16		; Add offset 16 to point to DM
1574:	D0C5  09      		ADD	HL,BC
1575:	D0C6  4F      		LD	C,A		; Add entry FCB
1576:	D0C7  09      		ADD	HL,BC
1577:	D0C8  3A42CA  		LD	A,(MAXLEN+1)	; Test 8 bits/16 bits FCB entry
1578:	D0CB  B7      		OR	A
1579:	D0CC  5E      		LD	E,(HL)		; Get 8 bit value
1580:	D0CD  2805    		JR	Z,GETDMX	; ..and exit if 8-bit entries
1581:			
1582:	D0CF  09      		ADD	HL,BC		; Add twice (16 bit values)
1583:	D0D0  5E      		LD	E,(HL)		; Get LSB
1584:	D0D1  23      		INC	HL		; Increment pointer
1585:	D0D2  56      		LD	D,(HL)		; Get MSB
1586:	D0D3  2B      		DEC	HL		; Decrement pointer
1587:	D0D4  7A      	GETDMX:	LD	A,D		; Check for zero DM value
1588:	D0D5  B3      		OR	E
1589:	D0D6  C9      		RET			; And exit
1590:			
1591:			; Calculate Sector Number
1592:			;  Entry: DE=Block Number from FCB
1593:			
1594:	D0D7  210000  	CALSEC:	LD	HL,0		; Clear MSB sector number
1595:	D0DA  3A3ECA  		LD	A,(NBLOCK)	; Get loop counter
1596:	D0DD  47      		LD	B,A		; Save it in B
1597:	D0DE  EB      		EX	DE,HL
1598:	D0DF  29      	CALSC0:	ADD	HL,HL		; Shift L,D,E
1599:	D0E0  CB13    		RL	E
1600:	D0E2  10FB    		DJNZ	CALSC0		; B times
1601:	D0E4  EB      		EX	DE,HL
1602:	D0E5  3A3FCA  		LD	A,(NMASK)	; Get sector mask
1603:	D0E8  DDA620  		AND	(IX+NXTREC)	; And with next record
1604:	D0EB  B3      		OR	E		; Set up LSB sector number
1605:	D0EC  5F      		LD	E,A
1606:	D0ED  C9      		RET			; And exit
1607:			
1608:			; Check for File Read-Only status, then fall thru to CALDIR
1609:			
1610:	D0EE  CDACD2  	CKRODI:	CALL	CHKFRO		; Abort if the file is R/O
1611:							; ..fall thru..
1612:			
1613:			; Calculate DIRBUF Entry Point
1614:			
1615:	D0F1  3A56CA  	CALDIR:	LD	A,(SECPNT)	; Get sector pointer
1616:	D0F4          	CALDIR1:			; New label for DS (crw)
1617:	D0F4  2A34CA  		LD	HL,(DIRBUF)	; Get start address dirbuf
1618:	D0F7  85      	CALDI0:	ADD	A,L		; Add L=L+A
1619:	D0F8  6F      		LD	L,A
1620:	D0F9  D0      		RET	NC		; No carry exit
1621:	D0FA  24      		INC	H		; Increment H
1622:	D0FB  C9      		RET			; And exit
1623:			
1624:			; Init File Count
1625:			
1626:	D0FC  21FFFF  	SETFCT:	LD	HL,-1		; Set up file count
1627:	D0FF  2254CA  		LD	(FILCNT),HL	; Save it
1628:	D102  C9      		RET			; And exit
1629:			
1630:			; Set Write Protect Disk Command  (relocated & compressed hfb)
1631:			
1632:	D103          	CMND28:				; Set read only disk
1633:	D103  2AFCD7  		LD	HL,(DSKWP)	; Get disk W/P vector
1634:	D106  CD4AD0  		CALL	SDRVB		; Include drive bit
1635:	D109  22FCD7  		LD	(DSKWP),HL	; Save disk W/P vector
1636:	D10C  ED5B43CA		LD	DE,(NFILES)	; Get max number of files-1 (bumped below)
1637:	D110  2A32CA  		LD	HL,(TEMP0)	; Get pointer to disk parameter block
1638:	D113  23      		INC	HL		; Correct pointer..
1639:							; Setlf0 relocated in-line here (hfb)
1640:	D114  13      	SETLF0:	INC	DE		; Increment last file
1641:	D115  72      		LD	(HL),D		; Save it in TEMP0
1642:	D116  2B      		DEC	HL
1643:	D117  73      		LD	(HL),E
1644:	D118  C9      		RET			; And exit
1645:			
1646:			; Search using first 15 bytes of FCB, test if found
1647:			
1648:	D119  CDF1D2  	SRCT15:	CALL	SEAR15		; Search on 15-bytes..(consolidated-hfb)
1649:							; ..fall thru to test presence..
1650:			; Test File Count
1651:			
1652:	D11C  2A54CA  	TSTFCT:	LD	HL,(FILCNT)	; Test file count=0FFFFH
1653:	D11F  7C      		LD	A,H		; Get MSB
1654:	D120  A5      		AND	L		; And LSB
1655:	D121  3C      		INC	A		; Test if result=0FFH
1656:	D122  C9      		RET			; And exit
1657:			
1658:			; Test Last File
1659:			
1660:	D123  2A32CA  	TSTLF:	LD	HL,(TEMP0)	; Get pointer to last file
1661:	D126  ED5B54CA		LD	DE,(FILCNT)	; Get file counter
1662:	D12A  7B      		LD	A,E		; Subtract DE-(HL)
1663:	D12B  96      		SUB	(HL)
1664:	D12C  23      		INC	HL
1665:	D12D  7A      		LD	A,D
1666:	D12E  9E      		SBC	A,(HL)
1667:	D12F  C9      		RET			; Exit
1668:			
1669:			; Get Next FCB from Drive
1670:			; Entry A=0 Check Checksum, A=0FFH Update Checksum
1671:			
1672:	D130  4F      	RDDIR:	LD	C,A		; Save checksum flag
1673:	D131  2A54CA  		LD	HL,(FILCNT)	; Get file counter
1674:	D134  23      		INC	HL		; Increment it
1675:	D135  2254CA  		LD	(FILCNT),HL	; And save it
1676:	D138  ED5B43CA		LD	DE,(NFILES)	; Get maximum number of files
1677:	D13C  7B      		LD	A,E		; Is this the last file?
1678:	D13D  95      		SUB	L
1679:	D13E  7A      		LD	A,D
1680:	D13F  9C      		SBC	A,H
1681:	D140  38BA    		JR	C,SETFCT	; ..set file count to 0FFFFH if so
1682:	D142  7D      		LD	A,L		; Get file count LSB
1683:	D143  0F      		RRCA			; *32 (bm/hfb-to save a byte)
1684:	D144  0F      		RRCA
1685:	D145  0F      		RRCA
1686:	D146  E660    		AND	060H		; Mask it
1687:	D148  3256CA  		LD	(SECPNT),A	; Save it for later use
1688:	D14B  C0      		RET	NZ		; Return if not first FCB sector
1689:	D14C  C5      		PUSH	BC		; Save checksum flag
1690:	0000          		  IF  NOT ZSDOS11	;  (* This was NOT in released package *)
1702:				  ENDIF		;~Zsdos11
1703:	D14D  CD68D0  	RdDir0:	CALL	STDIR		; Calculate sector/track directory
1704:	0000          		  IF  NOT ZS
1723:				  ELSE
1724:							; READDR subroutine moved in-line here
1725:	D150  CD3DD2  		CALL	DMADIR		; Set up DMA directory
1726:	D153  CD95D1  		CALL	READR		; Read a record
1727:	D156  CD37D2  		CALL	STDMA		; ..and set up user's DMA
1728:				  ENDIF
1729:	D159  C1      		POP	BC		; Restore checksum flag
1730:			
1731:			; Update/Check Checksum Directory
1732:			; Entry C=0 Check Checksum, C=0FFH update Checksum
1733:			
1734:	D15A  2A47CA  	CHKDIR:	LD	HL,(NCHECK)	; Get number of checked records
1735:	D15D  ED5B52CA		LD	DE,(RECDIR)	; Get current record
1736:	D161  AF      		XOR	A		; Clear carry (bm)
1737:	D162  ED52    		SBC	HL,DE		; Test current record
1738:	D164  C8      		RET	Z		; Exit if zero
1739:	D165  D8      		RET	C		; Exit if greater than ncheck
1740:	D166  2A34CA  		LD	HL,(DIRBUF)	; Get dirbuf
1741:	D169  CDE0D7  		CALL	CKS127		; ..and checksum first 127 bytes..
1742:	D16C  86      		ADD	A,(HL)		; ...then 128th byte (hfb)
1743:	D16D  2A38CA  		LD	HL,(CSV)	; Get pointer checksum directory
1744:	D170  19      		ADD	HL,DE		; Add current record
1745:	D171  0C      		INC	C		; Test checksum flag
1746:	D172  2002    		JR	NZ,CHKDR1	; 0FFH=> update checksum
1747:	D174  77      		LD	(HL),A		; Update checksum
1748:	D175  C9      		RET			; And exit
1749:			
1750:	D176  BE      	CHKDR1:	CP	(HL)		; Test checksum
1751:	D177  C8      		RET	Z		; Exit if ok
1752:			
1753:			; Checksum differs, So Disk has changed.  Relog it and continue
1754:			
1755:	D178  3A15CA  		LD	A,(FLAGS)
1756:	D17B  CB67    		BIT	4,A		; Inform user?
1757:	D17D  0600    		LD	B,0		; Disk change error code
1758:	D17F  1102CD  		LD	DE,MDSKCH	; Disk changed message
1759:	D182  C44CCD  		CALL	NZ,ERROR	; Inform user
1760:			
1761:			; Relog Current Drive after media change detected
1762:			
1763:	D185  CD47D0  		CALL	GETCDM		; Get current drive mask in HL
1764:	D188  EB      		EX	DE,HL		; Xfer mask to DE
1765:	D189  CD5DCE  		CALL	UNLOG		; Reset login vector for logged drive
1766:	D18C  CD37CE  		CALL	RELOG1		; Do the meat of relogging
1767:							; Caveat emptor: this call is recursive...
1768:	D18F  CDFCD0  		CALL	SETFCT		; Re-initialize search file count
1769:	D192  AF      		XOR	A		; We only get here by checking.. (bm)
1770:	D193  189B    		JR	RDDIR		; And all checking is done from rddir
1771:			
1772:			; Read Sector from Drive
1773:			
1774:	D195  CD27D8  	READR:	CALL	BDREAD		; CBIOS call read sector
1775:	D198  1803    		JR	WRITE0
1776:			
1777:			; Write Sector on Drive
1778:			
1779:	D19A  CD2AD8  	WRITER:	CALL	WRITE		; CBIOS call write sector
1780:	D19D  B7      	WRITE0:	OR	A		; Test exit code
1781:	D19E  C8      		RET	Z		; Exit if ok
1782:	D19F  0601    		LD	B,1		; Disk I/O error code
1783:	D1A1  110ACD  		LD	DE,MBADSC	; Load bad sector message
1784:	D1A4  2A09CA  		LD	HL,(STBDSC)	; Load bad sector vector
1785:	D1A7  E9      		JP	(HL)		; ZSDOS error on D: Bad Sector
1786:			
1787:			; Close File Command (relocated hfb)
1788:			
1789:	D1A9          	BGPTCH2	EQU	$+1		;<-- BGii patch point
1790:			
1791:	D1A8  CD2DCF  	CMND16:	CALL	SELDR1		; Select drive from FCB
1792:			
1793:			; Close File
1794:			
1795:	D1AB  DDCB0E7E	CLOSE:	BIT	7,(IX+FCBMOD)	; Test FCB/file modified
1796:	D1AF  C0      		RET	NZ		; Not then no close required
1797:	D1B0  CDD8D2  		CALL	CHKRO		; Test disk W/P
1798:	D1B3  CD19D1  		CALL	SRCT15		; Search file and test present
1799:	D1B6  C8      		RET	Z		; No then exit with error
1800:	D1B7  CDEED0  		CALL	CKRODI		; Check file W/P, get directory entry
1801:	D1BA  011000  		LD	BC,16		; Offset to DM block
1802:	D1BD  09      		ADD	HL,BC		; Add offset
1803:	D1BE  EB      		EX	DE,HL		; Save DIR PTR in DE
1804:	D1BF  2A5DCA  		LD	HL,(ARWORD)	; Get FCB ptr
1805:	D1C2  09      		ADD	HL,BC		; Add offset
1806:	D1C3  EB      		EX	DE,HL
1807:	D1C4  41      		LD	B,C		; Xfer counter
1808:			
1809:			; Copy FCB (DE) to DIR (HL) if and only if DIR=0 or DIR=FCB
1810:			
1811:	D1C5  34      	CLOSE0:	INC	(HL)
1812:	D1C6  35      		DEC	(HL)		; Test DIR for 0
1813:	D1C7  1A      		LD	A,(DE)		; Get byte from FCB
1814:	D1C8  2804    		JR	Z,CLOSE1	; OK to Copy if 0
1815:	D1CA  BE      		CP	(HL)		; Test if same as DIR
1816:	D1CB  C27AD5  		JP	NZ,RETCFF	; ..if Not, abort Close and return error
1817:	D1CE  77      	CLOSE1:	LD	(HL),A		; Else save in DIR
1818:	D1CF  13      		INC	DE
1819:	D1D0  23      		INC	HL
1820:	D1D1  10F2    		DJNZ	CLOSE0		; Bump pointers and loop until done
1821:	D1D3  11ECFF  		LD	DE,-20		; Add -20 to get Extent Number from DIR
1822:	D1D6  19      		ADD	HL,DE		; HL contains pointer to extent number
1823:	D1D7  DD7E0C  		LD	A,(IX+FCBEXT)	; Get extent number FCB
1824:	D1DA  BE      		CP	(HL)		; Compare with extent number directory
1825:	D1DB  3808    		JR	C,CLOSE3	; FCB < directory then jump
1826:	D1DD  77      		LD	(HL),A		; Save extent number in directory
1827:	D1DE  23      		INC	HL		; Get pointer to next record
1828:	D1DF  23      		INC	HL
1829:	D1E0  23      		INC	HL
1830:	D1E1  DD7E0F  		LD	A,(IX+FCBREC)	; Get next record FCB
1831:	D1E4  77      		LD	(HL),A		; Save next record in directory
1832:	D1E5  CD08D2  	CLOSE3:	CALL	CLOSE6		; Clear Archive Bit and Write FCB
1833:	D1E8  CDA6D5  		CALL	GETDME		; Get Data Module and Extent
1834:	0000          		  IF  NOT ZSDOS11	;  (* NOT in Release version *)
1837:				  ELSE		;Zsdos11   (* This was Release version *)
1838:	D1EB  280D    		JR	Z,CLOSE4	; ..jump to Stamp if they are both 0
1839:	D1ED  C5      		PUSH	BC		; Save prior module and Extent
1840:				  ENDIF		;~Zsdos11
1841:	D1EE  010000  		LD	BC,0
1842:	D1F1  CD9ED5  		CALL	SETDME		; Set FCB Data Module and Extent to 0
1843:	D1F4  CD19D1  		CALL	SRCT15		; Find proper DIR Entry
1844:	0000          		  IF  NOT ZSDOS11
1847:				  ELSE		;Zsdos11
1848:	D1F7  C1      		POP	BC
1849:	D1F8  280B    		JR	Z,JSETDME	; ..Exit if Extent 0 Not Found
1850:	D1FA  C5      	CLOSE4:	PUSH	BC
1851:				  ENDIF		;~Zsdos11
1852:	D1FB  CD08D2  		CALL	CLOSE6		; Clear Archive Bit and Write FCB
1853:	D1FE  2A1CCA  		LD	HL,(STUPDV)	; Get the update routine address
1854:	FFFF          		  IF  ZS
1855:	D201  CDB9D7  		CALL	STAMPT		; ..and stamp it
1856:				  ELSE		;If not Zs (crw)
1859:				  ENDIF		;ZS
1860:	0000          		  IF  NOT  ZSDOS11
1863:				  ELSE		;Zsdos11
1864:	D204  C1      		POP	BC		; Get Original Module and Extent Back
1865:	D205          	JSETDME:
1866:				  ENDIF		;~Zsdos11
1867:	D205  C39ED5  		JP	SETDME		; Restore to FCB and Exit
1868:			
1869:	D208  CDF1D0  	CLOSE6:	CALL	CALDIR		; Get directory entry
1870:	D20B  010B00  		LD	BC,11		; Point to archive byte
1871:	D20E  09      		ADD	HL,BC
1872:	D20F  CBBE    		RES	7,(HL)		; Reset archive bit
1873:	D211  DDCB0BBE		RES	7,(IX+ARCATT)	; Reset bit in FCB
1874:	FFFF          		  IF  ZSDOS11
1875:	D215  1800    		JR	WRFCB		; Write FCB to Disk
1876:			
1877:	0000          		   IF  NOT ZS
1881:				   ENDIF	;NOT Zs
1882:				  ENDIF		;Zsdos11
1883:			
1884:	D217  CDF1D0  	WRFCB:	CALL	CALDIR		; Point to dir entry to write
1885:	D21A  3E0D    		LD	A,FCBUSR	; Offset to user byte in FCB
1886:	D21C  CDF7D0  		CALL	CALDI0		; ..do the add here
1887:	D21F  3600    		LD	(HL),0		; Prevent writing it to disk
1888:	D221  CD68D0  		CALL	STDIR		; Calculate sector/track directory
1889:	D224  0EFF    		LD	C,0FFH		; Update checksum directory
1890:	D226  CD5AD1  		CALL	CHKDIR
1891:	D229  CD3DD2  	WRITD1:	CALL	DMADIR		; Set up dma directory (label for DS - crw)
1892:	D22C  0E01    		LD	C,1		; Write directory flag
1893:	D22E  CD9AD1  		CALL	WRITER		; Write record
1894:	D231  1804    		JR	STDMA		; Set up DMA user
1895:			
1896:	0000          		  IF  NOT ZSDOS11
1902:				  ENDIF		;~Zsdos11
1903:			
1904:			; Set DMA Address Command
1905:			
1906:	D233  ED532ECA	CMND26:	LD	(DMA),DE	; Save DMA address
1907:			
1908:			; Set DMA Address
1909:			
1910:	D237  ED4B2ECA	STDMA:	LD	BC,(DMA)	; Get DMA address
1911:	D23B  1804    		JR	DMADR0		; And do BIOS call
1912:			
1913:			; Set DMA Address Directory
1914:			
1915:	D23D  ED4B34CA	DMADIR:	LD	BC,(DIRBUF)	; Get DMA address directory
1916:	D241  C324D8  	DMADR0:	JP	SETDMA		; Cbios call set DMA
1917:			
1918:			; Get Bit from ALV Buffer
1919:			;  Entry DE=Block Number
1920:			;  Exit  A =Bit in LSB
1921:			;	 B =Bit Number in A
1922:			;	 HL=Pointer in ALV Buffer
1923:			
1924:	D244  7B      	GETBIT:	LD	A,E		; Get bit number
1925:	D245  E607    		AND	7		; Mask it
1926:	D247  3C      		INC	A		; Add 1
1927:	D248  4F      		LD	C,A		; Save it
1928:	FFFF          		  IF  UNROLL
1929:	D249  CB3A    		SRL	D		; Get byte number
1930:	D24B  CB1B    		RR	E		; DE=DE/8
1931:	D24D  CB3A    		SRL	D
1932:	D24F  CB1B    		RR	E
1933:	D251  CB3A    		SRL	D
1934:	D253  CB1B    		RR	E		; ..inline for speed (net cost: 4)
1935:	D255  47      		LD	B,A		; Re-save bit number for next shift
1936:	D256  2A3ACA  		LD	HL,(ALV)	; Get start address ALV buffer
1937:				  ELSE
1942:				  ENDIF		;Unroll
1943:	D259  19      		ADD	HL,DE		; Add byte number
1944:	D25A  7E      		LD	A,(HL)		; Get 8 bits
1945:	D25B  07      	GETBT0:	RLCA			; Get correct bit
1946:	D25C  10FD    		DJNZ	GETBT0
1947:	D25E  41      		LD	B,C		; Restore bit number
1948:	D25F  C9      		RET			; And return to caller
1949:			
1950:			; Set/Reset bit in ALV Buffer
1951:			;  Entry DE=Block Number
1952:			;	 C =0 Reset Bit, C=1 Set Bit
1953:			
1954:	D260  C5      	SETBIT:	PUSH	BC		; Save set/reset bit
1955:	D261  CD44D2  		CALL	GETBIT		; Get bit
1956:	D264  E6FE    		AND	0FEH		; Mask it
1957:	D266  D1      		POP	DE		; Get set/reset bit
1958:	D267  B3      		OR	E		; Set/reset bit
1959:	D268  0F      	SETBT0:	RRCA			; Rotate bit in correct position
1960:	D269  10FD    		DJNZ	SETBT0
1961:	D26B  77      		LD	(HL),A		; Save 8 bits
1962:	D26C  C9      		RET			; And return to caller
1963:			
1964:			; Delete File
1965:			
1966:	D26D  CDBDD3  	DELETE:	CALL	COMCOD		; Call common code w/VDEL on stack
1967:			
1968:			; Delete Routine Core (relocated to save space) (hfb)
1969:			
1970:	D270  CDEED0  	VDEL:	CALL	CKRODI		; Check file W/P, get directory entry
1971:	D273  36E5    		LD	(HL),0E5H	; Remove file
1972:	D275  23      		INC	HL
1973:	D276  7E      		LD	A,(HL)		; Get first char
1974:	D277  D624    		SUB	'$'		; See if submit file
1975:	D279  2003    		JR	NZ,VDEL1	; If not
1976:	D27B  3257CA  		LD	(SUBFLG),A	; Clear subflg if $*.* erased
1977:	D27E  23      	VDEL1:	INC	HL
1978:	D27F  CBBE    		RES	7,(HL)		; Insure erased files are not public
1979:	D281  0E00    		LD	C,0		; Remove bits ALV buffer
1980:							; ..fall thru and return to caller..
1981:			
1982:			; Fill bit buffer from FCB in DIRBUF
1983:			;  Entry C=0 Reset Bit, C=1 Set Bit
1984:			
1985:	D283  CDF1D0  	FILLBB:	CALL	CALDIR		; Get directory entry
1986:	D286  111000  		LD	DE,16		; Get offset DM block
1987:	D289  19      		ADD	HL,DE		; Add offset
1988:	D28A  43      		LD	B,E		; Get block counter
1989:	D28B  5E      	FILLB0:	LD	E,(HL)		; Get LSB block number
1990:	D28C  23      		INC	HL		; Increment pointer
1991:	D28D  1600    		LD	D,0		; Reset MSB block number
1992:	D28F  3A42CA  		LD	A,(MAXLEN+1)	; Test >256 blocks present
1993:	D292  B7      		OR	A
1994:	D293  2803    		JR	Z,FILLB1	; No then jump
1995:	D295  05      		DEC	B		; Decrement block counter
1996:	D296  56      		LD	D,(HL)		; Get correct MSB
1997:	D297  23      		INC	HL		; Increment pointer
1998:	D298  7A      	FILLB1:	LD	A,D		; Test block number
1999:	D299  B3      		OR	E
2000:	D29A  280D    		JR	Z,FILLB2	; Zero then get next block
2001:	D29C  E5      		PUSH	HL		; Save pointer
2002:	D29D  C5      		PUSH	BC		; Save counter and set/reset bit
2003:	D29E  2A41CA  		LD	HL,(MAXLEN)	; Get maximum length ALV buffer
2004:	D2A1  B7      		OR	A		; Reset carry
2005:	D2A2  ED52    		SBC	HL,DE		; Test DE<=maxlen ALV buffer
2006:	D2A4  D460D2  		CALL	NC,SETBIT	; Yes then insert bit
2007:	D2A7  C1      		POP	BC		; Get counter and set/reset bit
2008:	D2A8  E1      		POP	HL		; Get pointer
2009:	D2A9  10E0    	FILLB2:	DJNZ	FILLB0		; Repeat for all DM entries
2010:	D2AB  C9      		RET			; And return to caller
2011:			
2012:			; Check File W/P Bit - SEARCH called first
2013:			
2014:	D2AC  CDF1D0  	CHKFRO:	CALL	CALDIR		; Get directory entry
2015:	D2AF  110800  		LD	DE,WHLATT	; Offset to R/O bit
2016:	D2B2  19      		ADD	HL,DE		; Add offset
2017:	D2B3  ED5B13CA		LD	DE,(WHEEL)	; Get wheel byte address from header
2018:	D2B7  1A      		LD	A,(DE)		; ..and retrieve the actual byte
2019:	D2B8  A7      		AND	A		; ..and check the Wheel byte
2020:	D2B9  2004    		JR	NZ,CHKFR4	; We have wheel, so allow writes anyway
2021:	D2BB  CB7E    		BIT	7,(HL)		; Else check Wheel attribute
2022:	D2BD  2010    		JR	NZ,CHKFR2	; Yes then error
2023:	D2BF  23      	CHKFR4:	INC	HL		; Check W/P bit (hfb)
2024:	D2C0  CB7E    		BIT	7,(HL)		; Test file W/P
2025:	D2C2  200B    		JR	NZ,CHKFR2	; If W/P
2026:	D2C4  DDCB077E	CHKFR3:	BIT	7,(IX+PSFATT)	; Was file accessed as Public or Path?
2027:	D2C8  C8      		RET	Z		; If normal access
2028:	D2C9  3A15CA  		LD	A,(FLAGS)	; Else test for writes allowed
2029:	D2CC  E602    		AND	0010B
2030:	D2CE  C0      		RET	NZ		; Go ahead, writes are allowed
2031:	D2CF  2A0FCA  	CHKFR2:	LD	HL,(SFILRO)	; Get pointer to file W/P message
2032:	D2D2  0603    		LD	B,3		; File W/P error code
2033:	D2D4  111ECD  		LD	DE,MFILRO	; Load file W/P message
2034:	D2D7  E9      		JP	(HL)		; Display message
2035:			
2036:			
2037:			; Check Drive Write Protect
2038:			
2039:	D2D8          	BGCKDRO:
2040:	D2D8  CDE5D2  	CHKRO:	CALL	CHKRO1		; Is the disk W/P?
2041:	D2DB  C0      		RET	NZ		; ..return if disk R/W
2042:	D2DC  0602    		LD	B,2		; Else set disk W/P error code
2043:	D2DE  1123CD  		LD	DE,MRO		; Load drive W/P message
2044:	D2E1  2A0DCA  		LD	HL,(STRO)	; Get pointer to drive W/P message
2045:	D2E4  E9      		JP	(HL)		; Display message
2046:			
2047:	D2E5  2AFCD7  	CHKRO1:	LD	HL,(DSKWP)	; Get the W/P drive vector
2048:	D2E8  CD4AD0  		CALL	SDRVB		; Set the bit for this drive
2049:	D2EB  ED52    		SBC	HL,DE		; See if extra bit added (Cy is clear)
2050:	D2ED  C9      		RET
2051:			
2052:			; Search using first 12 bytes of FCB (hfb)
2053:			
2054:	D2EE  3E0C    	SEAR12:	LD	A,12
2055:	D2F0  21      		DEFB	21H		; Trash HL and fall through
2056:			
2057:			; Search using first 15 bytes of FCB
2058:			
2059:	D2F1  3E0F    	SEAR15:	LD	A,15
2060:			
2061:			; Search for File Name
2062:			;  Entry: A = Number of bytes for which to search
2063:			
2064:	D2F3  325BCA  	SEARCH:	LD	(SEARNB),A	; Save number of bytes
2065:	D2F6  3EFF    		LD	A,0FFH		; Set exit code to 0FFH (not found)
2066:	D2F8  325ACA  		LD	(SEAREX),A
2067:	D2FB  DD2258CA		LD	(DCOPY),IX	; Copy FCB pointer to RAM (search next)
2068:	D2FF  CDFCD0  		CALL	SETFCT		; Initiate file counter
2069:			
2070:			; Force directory read with a Call HOME (bh)   (Only if Floppys-hfb)
2071:	FFFF          		  IF  ZSDOS11		; (* Logic moved to RDDIR if NOT Zsdos11 *)
2072:	D302  2A47CA  		LD	HL,(NCHECK)	; Is this a fixed media?
2073:	D305  7C      		LD	A,H
2074:	D306  B5      		OR	L
2075:	D307  C418D8  		CALL	NZ,HOME		; Invoke CBIOS Home routine if removeable
2076:				  ENDIF		;~Zsdos11
2077:			
2078:			; Search Next File Name
2079:			
2080:	D30A  AF      	SEARCN:	XOR	A		; Check checksum directory
2081:	D30B  67      		LD	H,A
2082:	D30C  6F      		LD	L,A
2083:	D30D  2250CA  		LD	(SEARQU),HL	; Clear question mark & public detected flags
2084:	D310  DDCB07BE		RES	7,(IX+PSFATT)	; Reset public/system file flag
2085:	D314  CD30D1  		CALL	RDDIR		; Get FCB from directory
2086:	D317  CD1CD1  		CALL	TSTFCT		; Test if past last entry
2087:	D31A  280E    		JR	Z,JSEAR8	; Yes then jump (note carry always clear)
2088:	D31C  ED5B58CA		LD	DE,(DCOPY)	; Get FCB pointer
2089:	D320  1A      		LD	A,(DE)		; Get first byte
2090:	D321  FEE5    		CP	0E5H		; Test if searching empty directory
2091:	D323  2807    		JR	Z,SEARC1	; Yes then jump
2092:	D325  D5      		PUSH	DE		; Save FCB pointer
2093:	D326  CD23D1  		CALL	TSTLF		; Test last file on this drive
2094:	D329  D1      		POP	DE		; Restore FCB pointer
2095:	D32A  306B    	JSEAR8:	JR	NC,SEARC8	; Yes then jump
2096:	D32C  CDF1D0  	SEARC1:	CALL	CALDIR		; Get entry in directory
2097:	D32F  7E      		LD	A,(HL)		; Get first byte directory entry
2098:	D330  FE21    		CP	21H		; Test time stamp
2099:	D332  28D6    		JR	Z,SEARCN	; Yes then get next directory entry
2100:	D334  0E00    		LD	C,0		; Clear counter
2101:	D336  3A5BCA  		LD	A,(SEARNB)	; Get number of bytes to search for
2102:	D339  47      		LD	B,A		; Save it in counter
2103:	D33A  78      	SEARC2:	LD	A,B		; Test if counter is zero
2104:	D33B  B7      		OR	A
2105:	D33C  285F    		JR	Z,SEARC9	; Yes then jump
2106:	D33E  1A      		LD	A,(DE)		; Get byte from FCB
2107:	D33F  EE3F    		XOR	'?'		; Test if question mark
2108:	D341  E67F    		AND	7FH		; Mask it
2109:	D343  283B    		JR	Z,SEARC6	; Yes then jump
2110:	D345  79      		LD	A,C		; Get FCB counter
2111:	D346  B7      		OR	A		; Test first byte
2112:	D347  2022    		JR	NZ,SEARC3	; No then jump
2113:	D349  3A15CA  		LD	A,(FLAGS)	; Get flag byte
2114:	D34C  1F      		RRA			; Test public file enable
2115:	D34D  301C    		JR	NC,SEARC3	; ..jump if not
2116:	D34F  23      		INC	HL		; Get pointer to Public Bit
2117:	D350  23      		INC	HL
2118:	D351  CB7E    		BIT	7,(HL)		; Test Public Bit directory
2119:	D353  2B      		DEC	HL		; Restore pointer
2120:	D354  2B      		DEC	HL
2121:	D355  2814    		JR	Z,SEARC3	; No public file then jump
2122:	D357  1A      		LD	A,(DE)		; Get first byte FCB
2123:	D358  FEE5    		CP	0E5H		; Test if searching empty directory
2124:	D35A  280F    		JR	Z,SEARC3	; Yes then jump
2125:			
2126:			; The following 3 lines of code represent a deviation from the description of
2127:			; PUBLIC Files as given in DDJ Article by Bridger Mitchell and Derek McKay of
2128:			; Plu*Perfect Systems.	The PUBLIC Specification states that Public Files will
2129:			; NOT be found by any wildcard reference except when a "?" is in the FCB+0
2130:			; byte.  The code here relaxes that requirement as follows:  If we are in the
2131:			; same user area as the public file, then don't report the file as PUBLIC, but
2132:			; find it.  This has a nasty side effect - it allows erasing of PUBLIC files
2133:			; if we are in the same area.  However, these files also show up on the direc-
2134:			; tory (they wouldn't otherwise), so at least we should know we're blasting
2135:			; them.
2136:			
2137:	D35C  AE      		XOR	(HL)		; Test FCB = Directory Entry
2138:	D35D  E67F    		AND	7FH		; Mask it (setting Zero Flag)
2139:	D35F  2819    		JR	Z,SEARC5	; Jump if user is same
2140:	D361  3EFF    		LD	A,0FFH
2141:	D363  3251CA  		LD	(SEARPU),A	; Set Public file found
2142:	FFFF          		  IF  UPATH
2143:	D366  CDAFD4  		CALL	SETPSF		; Set Public/System file flag
2144:				  ELSE
2146:				  ENDIF
2147:	D369  180F    		JR	SEARC5		; Jump found
2148:			
2149:	D36B  79      	SEARC3:	LD	A,C		; Get FCB counter
2150:	D36C  FE0D    		CP	13		; Is it User Code?
2151:	D36E  280A    		JR	Z,SEARC5	; ..jump if so..don't test
2152:	D370  FE0C    		CP	12		; Is it an Extent Number?
2153:	D372  1A      		LD	A,(DE)		; ..Get byte from FCB
2154:	D373  2811    		JR	Z,SEARC7	; ..Jump if Extent Number
2155:	D375  AE      		XOR	(HL)		; Is FCB byte = Directory Entry byte?
2156:	D376  E67F    		AND	07FH		; ..Mask it
2157:	D378  2090    	SEARC4:	JR	NZ,SEARCN	; ..jump if not same and get next entry
2158:	D37A  13      	SEARC5:	INC	DE		; Increment FCB pointer
2159:	D37B  23      		INC	HL		; Increment Directory Entry pointer
2160:	D37C  0C      		INC	C		; Increment counter
2161:	D37D  05      		DEC	B		; Decrement counter
2162:	D37E  18BA    		JR	SEARC2		; Test next byte
2163:			
2164:	D380  3D      	SEARC6:	DEC	A		; Set question mark found flag
2165:	D381  3250CA  		LD	(SEARQU),A
2166:	D384  18F4    		JR	SEARC5		; Jump found
2167:			
2168:	D386          	SEARC7:
2169:	D386  AE      		XOR	(HL)		; Test extent
2170:	D387  CD8CD3  		CALL	SEARC7A		; Mask Extent
2171:	D38A  18EC    		JR	SEARC4		; ..and test Result
2172:			
2173:			
2174:	D38C  C5      	SEARC7A: PUSH	BC
2175:	D38D  47      		LD	B,A		; Save Extent
2176:	D38E  3A40CA  		LD	A,(NEXTND)	; Get extent mask
2177:	D391  2F      		CPL			; Complement it
2178:	D392  E61F    		AND	MAXEXT		; Mask it
2179:	D394  A0      		AND	B		; Mask extent
2180:	D395  C1      		POP	BC		; Restore counters
2181:	D396  C9      		RET
2182:			
2183:	D397  CDFCD0  	SEARC8:	CALL	SETFCT		; Error set file counter
2184:	D39A  C37AD5  		JP	RETCFF		; Set return code to FF and exit
2185:			
2186:	D39D  2A50CA  	SEARC9:	LD	HL,(SEARQU)	; Get question mark and public found flags
2187:	D3A0  7C      		LD	A,H
2188:	D3A1  A5      		AND	L
2189:	D3A2  20D4    		JR	NZ,SEARC4	; Yes then search for next entry
2190:	D3A4  CD23D1  		CALL	TSTLF		; Test for last file
2191:	D3A7  D414D1  		CALL	NC,SETLF0	; And update if so
2192:	D3AA  2A52CA  		LD	HL,(RECDIR)	; Set DE return to directory record
2193:	D3AD  225FCA  		LD	(DEVAL),HL	; .. for DateStamper simulation
2194:	D3B0  3A54CA  		LD	A,(FILCNT)	; Get file counter
2195:	D3B3  E603    		AND	3		; Mask it
2196:	D3B5  324CCA  		LD	(PEXIT),A	; And set exit code
2197:	D3B8  AF      		XOR	A		; Clear exit code search
2198:	D3B9  325ACA  		LD	(SEAREX),A
2199:	D3BC  C9      		RET			; And return to caller
2200:			
2201:			; The following code is common to DELETE, RENAME, and CSTAT.
2202:			; It is coded in a manner that is compatable with the Z280
2203:			; in protected Mode.
2204:			
2205:	D3BD  CDD8D2  	COMCOD:	CALL	CHKRO		; Check disk W/P
2206:	D3C0  CDEED2  		CALL	SEAR12		; Search file
2207:	D3C3  CD1CD1  	COMCO1:	CALL	TSTFCT		; Test if file found
2208:	D3C6  E1      		POP	HL		; Routine addr to HL (in case not found)
2209:	D3C7  C8      		RET	Z		; Not then exit
2210:	D3C8  E5      		PUSH	HL		; ..found, so routine back to stack
2211:	D3C9  E5      		PUSH	HL		; Twice, as RET pops first push
2212:	D3CA  21CFD3  		LD	HL,COMCO2
2213:	D3CD  E3      		EX	(SP),HL		; COMCO2 to stack, routine addr to HL
2214:	D3CE  E9      		JP	(HL)		; ..branch to routine
2215:			
2216:	D3CF  CD17D2  	COMCO2:	CALL	WRFCB		; Write directory buffer on disk
2217:	D3D2  CD0AD3  		CALL	SEARCN		; Search next entry
2218:	D3D5  18EC    		JR	COMCO1		; And test it
2219:			
2220:			
2221:			; Rename File - Note Wildcard Support
2222:			
2223:	D3D7  CDBDD3  	RENAM:	CALL	COMCOD		; Go to common code w/VRENAM on stack
2224:			
2225:	D3DA  CDACD2  	VRENAM:	CALL	CHKFRO		; Check file W/P
2226:	D3DD  2A5DCA  		LD	HL,(ARWORD)
2227:	D3E0  111000  		LD	DE,16		; Offset to new name
2228:	D3E3  19      		ADD	HL,DE		; Add offset
2229:	D3E4  EB      		EX	DE,HL		; Copy HL=>DE
2230:	D3E5  CDF1D0  		CALL	CALDIR		; Get directory entry
2231:	D3E8  23      		INC	HL
2232:	D3E9  23      		INC	HL
2233:	D3EA  CBBE    		RES	7,(HL)		; Make any renamed file private
2234:	D3EC  2B      		DEC	HL
2235:	D3ED  2B      		DEC	HL
2236:	D3EE  060B    		LD	B,11		; Set up loop counter
2237:	D3F0  23      	RENAM1:	INC	HL		; Increment directory pointer
2238:	D3F1  13      		INC	DE		; Increment FCB pointer
2239:	D3F2  1A      		LD	A,(DE)		; Get character from FCB
2240:	D3F3  E67F    		AND	7FH		; Mask it
2241:	D3F5  FE3F    		CP	'?'		; Test if question mark
2242:	D3F7  2001    		JR	NZ,RENAM2	; no, then change character on disk
2243:	D3F9  7E      		LD	A,(HL)		; Else get what's there as there is no change
2244:	D3FA  17      	RENAM2:	RLA			; Clear MSB
2245:	D3FB  CB16    		RL	(HL)		; Get MSB from directory
2246:	D3FD  1F      		RRA			; And move to FCB
2247:	D3FE  77      		LD	(HL),A		; Save in directory
2248:	D3FF  10EF    		DJNZ	RENAM1		; Loop until done
2249:	D401  C9      		RET
2250:			
2251:			; Change Status Bits for File
2252:			
2253:	D402  CDBDD3  	CSTAT:	CALL	COMCOD		; Go to common code w/VCSTAT on stack
2254:			
2255:	D405  DDE5    	VCSTAT:	PUSH	IX
2256:	D407  D1      		POP	DE		; FCB pointer in DE
2257:	D408  CDF1D0  		CALL	CALDIR		; Get directory entry
2258:	D40B  060B    		LD	B,11		; Set up loop counter
2259:	D40D  23      	CSTAT1:	INC	HL		; Increment directory pointer
2260:	D40E  13      		INC	DE		; Increment FCB pointer
2261:	D40F  3E04    		LD	A,4		; Are we pointing to Wheel Attribute?
2262:	D411  B8      		CP	B
2263:	D412  200E    		JR	NZ,CSTAT2	; ..jump if not
2264:	D414  E5      		PUSH	HL
2265:	D415  2A13CA  		LD	HL,(WHEEL)	; Else do we have Wheel privileges?
2266:	D418  7E      		LD	A,(HL)
2267:	D419  E1      		POP	HL
2268:	D41A  A7      		AND	A		; ..set flags to show
2269:	D41B  2005    		JR	NZ,CSTAT2	; Jump if we have Wheel
2270:	D41D  CB7E    		BIT	7,(HL)		; Is file Wheel protected?
2271:	D41F  C2CFD2  		JP	NZ,CHKFR2	; ..jump if so
2272:	D422  1A      	CSTAT2:	LD	A,(DE)		; Get status bit from FCB
2273:	D423  CB16    		RL	(HL)		; Remove MSB of directory
2274:	D425  17      		RLA			; Get msb from FCB
2275:	D426  CB1E    		RR	(HL)		; And move into directory char
2276:	D428  10E3    		DJNZ	CSTAT1		; Loop until done
2277:	D42A  C9      		RET
2278:			
2279:			; Compute File Size
2280:			
2281:	D42B  010000  	FILSZ:	LD	BC,0		; Reset file size length
2282:	D42E  51      		LD	D,C
2283:	D42F  CD15CF  		CALL	LDRRC		; Save it in FCB+33,34,35
2284:	D432  CDEED2  		CALL	SEAR12		; Search file (hfb)
2285:	D435  CD1CD1  	FILSZ0:	CALL	TSTFCT		; Test if file found
2286:	D438  C8      		RET	Z		; Not then exit
2287:	D439  CDF1D0  		CALL	CALDIR		; Get directory entry
2288:	D43C  EB      		EX	DE,HL		; Copy to DE
2289:	D43D  210F00  		LD	HL,15		; Offset to next record
2290:	D440  CD7FD7  		CALL	CALRRC		; Calculate random record count
2291:	D443  7A      		LD	A,D		; Test LSB < (ix+33)
2292:	D444  DD9621  		SUB	(IX+33)
2293:	D447  79      		LD	A,C		; Test ISB < (ix+34)
2294:	D448  DD9E22  		SBC	A,(IX+34)
2295:	D44B  78      		LD	A,B		; Test MSB < (ix+35)
2296:	D44C  DD9E23  		SBC	A,(IX+35)
2297:	D44F  D415CF  		CALL	NC,LDRRC	; Write new maximum
2298:	D452  CD0AD3  		CALL	SEARCN		; Search next file
2299:	D455  18DE    		JR	FILSZ0		; And test it
2300:			
2301:			; Find File
2302:	FFFF          		  IF  UPATH
2303:	D457          	FINDF:
2304:	D457  CD19D1  		CALL	SRCT15		; Search file
2305:	D45A  C0      		RET	NZ		; Yes then exit
2306:	D45B  3A15CA  		LD	A,(FLAGS)
2307:	D45E  CB6F    		BIT	5,A		; Test if Path enabled
2308:	D460  C8      		RET	Z		; Exit if not
2309:	D461  2A11CA  		LD	HL,(PATH)	; Get Path address
2310:	D464  7C      		LD	A,H		; Test if zero (no path)
2311:	D465  B5      		OR	L
2312:	D466  C8      		RET	Z		; Yes then exit
2313:	D467  7E      	FINDF0:	LD	A,(HL)		; Get first entry path name
2314:	D468  23      		INC	HL		; Increment pointer
2315:	D469  B7      		OR	A		; Test if last entry
2316:	D46A  CA97D3  		JP	Z,SEARC8	; Yes then error exit
2317:	D46D  E67F    		AND	7FH		; Mask drive number
2318:	D46F  FE24    		CP	'$'		; Test if current drive
2319:	D471  2004    		JR	NZ,FINDF1	; No then jump
2320:	D473  3A2CCA  		LD	A,(DRIVE)	; Get current drive
2321:	D476  3C      		INC	A		; Increment drive number
2322:	D477  3D      	FINDF1:	DEC	A		; Decrement drive number
2323:	D478  E5      		PUSH	HL		; Save path pointer
2324:	D479  CD81CF  		CALL	SELDK		; Select drive
2325:	D47C  E1      		POP	HL		; Restore path pointer
2326:	D47D  7E      		LD	A,(HL)		; Get user number
2327:	D47E  23      		INC	HL		; Advance pointer
2328:	D47F  E67F    		AND	7FH		; Mask user number
2329:	D481  FE24    		CP	'$'		; Test if current user
2330:	D483  2003    		JR	NZ,FINDF2	; No then jump
2331:	D485  3A2ACA  		LD	A,(USER)	; Get current user
2332:	D488  E61F    	FINDF2:	AND	1FH		; Mask user number
2333:	D48A  E5      		PUSH	HL		; Save path pointer
2334:	D48B  CD5ECF  		CALL	RESUSR		; Add new user number in FCB+0 and FCB+13
2335:	D48E  CD19D1  		CALL	SRCT15		; Search file and test if present
2336:	D491  E1      		POP	HL		; Restore path pointer
2337:	D492  28D3    		JR	Z,FINDF0	; No then test next path entry
2338:	D494  E5      		PUSH	HL		; Save path pointer
2339:	D495  CDF1D0  		CALL	CALDIR		; Get directory entry
2340:	D498  110A00  		LD	DE,10		; Add offset system bit
2341:	D49B  19      		ADD	HL,DE
2342:	D49C  CB7E    		BIT	7,(HL)		; Test system file
2343:	D49E  3A15CA  		LD	A,(FLAGS)	; Test for relaxed path definition
2344:	D4A1  17      		RLA			; ..by rotating bit..
2345:	D4A2  17      		RLA			; ..into carry flag
2346:	D4A3  E1      		POP	HL		; Restore path pointer
2347:	D4A4  3802    		JR	C,FINDF3	; If carry, system attrib not required
2348:	D4A6  28BF    		JR	Z,FINDF0	; No system file then test next path entry
2349:	D4A8  3A2BCA  	FINDF3:	LD	A,(DEFDRV)	; Get current drive
2350:	D4AB  3C      		INC	A		; Increment drive number
2351:	D4AC  322DCA  		LD	(FCB0),A	; Save it in exit FCB0
2352:	D4AF  DDCB07FE	SETPSF:	SET	7,(IX+PSFATT)	; set Public/System file flag
2353:	D4B3  C9      		RET			; And return to caller
2354:				  ENDIF		;Upath
2355:			
2356:			; Open File Command
2357:			
2358:	D4B4  CD1FCF  	CMND15:	CALL	SELDRV		; Select drive from FCB
2359:	D4B7  DD360E00		LD	(IX+FCBMOD),0	; Clear data module number
2360:			; Open File
2361:	FFFF          		  IF  UPATH
2362:	D4BB  CD57D4  		CALL	FINDF		; Find file (use path name)
2363:	D4BE  CD1CD1  		CALL	TSTFCT		; Test file found
2364:				  ELSE
2366:				  ENDIF		;Upath
2367:	D4C1  C8      		RET	Z		; No then exit
2368:	D4C2  DD7E07  	OPENF0:	LD	A,(IX+PSFATT)	; Get Public/System file bit
2369:	D4C5  F5      		PUSH	AF		; Save it
2370:	D4C6  DD7E0C  		LD	A,(IX+FCBEXT)	; Get extent number from FCB
2371:	D4C9  F5      		PUSH	AF		; Save it
2372:	D4CA  CDF1D0  		CALL	CALDIR		; Get directory entry
2373:	D4CD  7E      		LD	A,(HL)		; Find real user number file is in
2374:	D4CE  F680    		OR	80H		; Set user valid flag
2375:	D4D0  DDE5    		PUSH	IX		; Save FCB entry
2376:	D4D2  D1      		POP	DE		; Get in in DE
2377:	D4D3  012000  		LD	BC,32		; Number of bytes to move
2378:	D4D6  EDB0    		LDIR			; Move directory to FCB
2379:	D4D8  DD770D  		LD	(IX+FCBUSR),A	; And put user byte back
2380:	D4DB  CD7AD7  		CALL	SETB14		; Set FCB/File Not Modified
2381:	D4DE  DD460C  		LD	B,(IX+FCBEXT)	; Get extent number
2382:	D4E1  DD4E0F  		LD	C,(IX+FCBREC)	; Get next record number
2383:	D4E4  F1      		POP	AF		; Get old extent number
2384:	D4E5  DD770C  		LD	(IX+FCBEXT),A	; Save it
2385:	D4E8  B8      		CP	B		; Compare old and new extent number
2386:	D4E9  2804    		JR	Z,OPENF1	; Same then jump
2387:	D4EB  0E00    		LD	C,0		; Set next record count to 0
2388:	D4ED  CB19    		RR	C		; Record count to Max (80H) if need new extent
2389:	D4EF  DD710F  	OPENF1:	LD	(IX+FCBREC),C	; Save next record count
2390:	D4F2  F1      		POP	AF		; Get Public/System file bit
2391:	D4F3  DDCB0716		RL	(IX+PSFATT)	; Remove MSB from IX+8
2392:	D4F7  17      		RLA			; Set new MSB in carry
2393:	D4F8  DDCB071E		RR	(IX+PSFATT)	; Save Carry in IX+8
2394:	FFFF          		  IF  ZS
2395:	D4FC  2A18CA  		LD	HL,(STLAV)	; Get address of last accessed routine
2396:	D4FF  C3B9D7  		JP	STAMPT
2397:				  ELSE
2401:				  ENDIF		;Zs
2402:			
2403:			; Make File Command
2404:			
2405:	D502  CD1FCF  	CMND22:	CALL	SELDRV		; Select drive from FCB
2406:	D505  DD360E00		LD	(IX+FCBMOD),0	; Clear data module number
2407:			
2408:			; Make File
2409:			
2410:	D509  CDD8D2  	MAKES:	CALL	CHKRO		; Check drive W/P
2411:	D50C  2A5DCA  		LD	HL,(ARWORD)
2412:	D50F  7E      		LD	A,(HL)		; Get first byte FCB
2413:	D510  F5      		PUSH	AF		; Save it
2414:	D511  36E5    		LD	(HL),0E5H	; Set first byte to empty file
2415:	D513  3E01    		LD	A,1		; Search for 1 byte
2416:	D515  CDF3D2  		CALL	SEARCH		; Search empty file
2417:	D518  F1      		POP	AF		; Get first byte FCB
2418:	D519  DD7700  		LD	(IX+0),A	; Restore it
2419:	D51C  CD1CD1  		CALL	TSTFCT		; Test empty file found
2420:	D51F  C8      		RET	Z		; No then return error
2421:	D520  2A5DCA  		LD	HL,(ARWORD)	; Get FCB pointer
2422:	D523  CD52CE  		CALL	CKSUB		; Check if this is a submit file
2423:	D526  110F00  		LD	DE,15		; Prepare offset
2424:	D529  19      		ADD	HL,DE		; Add it
2425:	D52A  0611    		LD	B,17		; Set loop counter
2426:	D52C  AF      		XOR	A
2427:	D52D  77      	MAKE0:	LD	(HL),A		; Clear FCB+15 up to FCB+31
2428:	D52E  23      		INC	HL		; Increment pointer
2429:	D52F  10FC    		DJNZ	MAKE0		; And clear all bytes
2430:	D531  DDCB07BE		RES	7,(IX+PSFATT)	; Reset Public/System file bit
2431:	D535  DDCB0BBE		RES	7,(IX+ARCATT)	; Reset archive bit if present
2432:	D539  CDF1D0  		CALL	CALDIR		; Get directory entry
2433:	D53C  DDE5    		PUSH	IX		; Save FCB entry
2434:	D53E  D1      		POP	DE		; Get it in DE
2435:	D53F  EB      		EX	DE,HL		; Exchange FCB and directory entry
2436:	D540  012000  		LD	BC,32		; Number of bytes to move
2437:	D543  EDB0    		LDIR			; Move bytes
2438:	D545  CD17D2  		CALL	WRFCB		; Write FCB on disk
2439:	D548  CD7AD7  		CALL	SETB14		; Set file not modified
2440:	FFFF          		  IF  ZS
2441:	D54B  2A1ACA  		LD	HL,(STCRV)	; Get address of Stamp Create routine
2442:	D54E  C3B9D7  		JP	STAMPT		; ..and stamp it
2443:				  ELSE
2446:				  ENDIF		;Zs
2447:			
2448:			; Open Next Extent
2449:			
2450:	D551  DDCB0E7E	OPENEX:	BIT	7,(IX+FCBMOD)	; Test if FCB/File Modified (write)
2451:	D555  2008    		JR	NZ,OPENX2	; Not then jump
2452:	D557  CDABD1  		CALL	CLOSE		; Close current FCB
2453:	D55A  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2454:	D55D  3C      		INC	A		; Test if error
2455:	D55E  C8      		RET	Z		; Yes then exit
2456:	D55F  CD85D5  	OPENX2:	CALL	CALNEX		; Calculate next extent (LABEL MOVED)
2457:	D562  3813    		JR	C,OPENX3	; Error then jump
2458:			
2459:	D564  CD19D1  	OPENX0:	CALL	SRCT15		; Search for 15-char match & test presence
2460:	D567  2016    		JR	NZ,OPENX5	; Yes then jump
2461:	D569  3A4FCA  		LD	A,(RDWR)	; Test Read/Write flag
2462:	D56C  B7      		OR	A		; Test if read
2463:	D56D  2808    		JR	Z,OPENX3	; Yes then error
2464:	D56F  CD09D5  		CALL	MAKES		; Make new extent if write
2465:	D572  CD1CD1  		CALL	TSTFCT		; Test if succesfull
2466:	D575  200B    		JR	NZ,OPENX6	; Yes then exit
2467:	D577  CD7AD7  	OPENX3:	CALL	SETB14		; Set FCB/File Not Modified
2468:	D57A  3EFF    	RETCFF:	LD	A,0FFH		; (hfb/cwc) set exit code
2469:	D57C  C3BBCE  	OPENX4:	JP	SAVEA		; And return to caller
2470:			
2471:	D57F  CDC2D4  	OPENX5:	CALL	OPENF0		; Open file
2472:	D582  AF      	OPENX6:	XOR	A		; And clear exit code
2473:	D583  18F7    		JR	OPENX4		; Use same routine
2474:			
2475:			;==OPENX2:	CALL	CALNEX		; Calculate next extent
2476:			;==	JR	C,OPENX3	; Error then jump
2477:			;==	JR	OPENX0		; Open next extent, FCB contains DU:
2478:			
2479:			; Calculate Next Extent
2480:			;  Exit: Carry=1 => Overflow Detected
2481:			
2482:	D585  CDA6D5  	CALNEX:	CALL	GETDME		; Get extent number, data module number
2483:	D588  CB70    		BIT	6,B		; Test error bit random record
2484:	D58A  37      		SCF			; Set error flag
2485:	D58B  C0      		RET	NZ		; ..Error exit if Non-zero
2486:	D58C  0C      		INC	C		; Increment extent number
2487:	D58D  79      		LD	A,C		; Get extent number
2488:	D58E  E61F    		AND	MAXEXT		; Mask it for max extent
2489:	D590  4F      		LD	C,A		; Save it in C
2490:			;==	JR	NZ,SETDME	; If new data module not required
2491:	D591  2007    		JR	NZ,CALNE1	;== IF NEW DATA MODULE NOT REQUIRED
2492:	D593  04      		INC	B		; Set next data module
2493:	D594  78      		LD	A,B		; Get it in A
2494:	D595  E63F    		AND	MAXMOD		; Mask it for max module
2495:	D597  47      		LD	B,A		; Save it in B
2496:	D598  37      		SCF			; Set error flag
2497:	D599  C8      		RET	Z		; And return if file overflow
2498:	D59A  DD362000	CALNE1:	LD	(IX+NXTREC),0	;== ZERO NEXT RECORD COUNT
2499:	D59E  DD710C  	SETDME:	LD	(IX+FCBEXT),C	; Save Extent number
2500:	D5A1  DD700E  		LD	(IX+FCBMOD),B	; Save Data Module number
2501:	FFFF          		  IF  ZS
2502:	D5A4  A7      		AND	A		; Clear flag here if ZS
2503:	D5A5  C9      		RET
2504:				  ENDIF			; ..else fall thru on ZD to do same thing
2505:			
2506:	D5A6  DD4E0C  	GETDME:	LD	C,(IX+FCBEXT)	; Get Extent number
2507:	D5A9  DD460E  		LD	B,(IX+FCBMOD)	; Get Data Module number
2508:	D5AC  79      		LD	A,C
2509:	D5AD  CD8CD3  		CALL	SEARC7A		; Mask Extent
2510:	D5B0  CBB8    		RES	7,B		; Clear Unmodified Flag
2511:	D5B2  B0      		OR	B		; Test for Module and Extent = 0
2512:	D5B3  C9      		RET			; ..and return to caller
2513:			
2514:			; Read Random Record Command
2515:			
2516:	D5B4  CD2DCF  	CMND33:	CALL	SELDR1		; Select drive from FCB
2517:			
2518:			; Read Random Sector
2519:			
2520:	D5B7  AF      		XOR	A		; Set read/write flag
2521:	D5B8  CDF6D6  		CALL	LDFCB		; Load random record in FCB
2522:	D5BB  2804    		JR	Z,READS		; No error then read sector
2523:	D5BD  C9      		RET			; Return error
2524:			
2525:			; Read Sequential
2526:			
2527:	D5BE  CD2DCF  	CMND20:	CALL	SELDR1		; Select drive from FCB
2528:			
2529:			; Read Sector
2530:			
2531:	D5C1  AF      	READS:	XOR	A		; Set Read/Write flag
2532:	D5C2  324FCA  		LD	(RDWR),A	; Save it
2533:	D5C5  DD7E20  		LD	A,(IX+NXTREC)	; Get record counter
2534:	D5C8  FE80    		CP	80H		; Test if last record this extent
2535:			;=	JR	NC,READS1	; Yes then open next extent
2536:	D5CA  2809    		JR	Z,READS1	;= Yes then open next extent
2537:	D5CC  DDBE0F  		CP	(IX+FCBREC)	; Test if greater then current record
2538:	D5CF  3807    		JR	C,READS2	; No then get record
2539:	D5D1  3E01    	READS0:	LD	A,1		; Set end of file flag
2540:	D5D3  18A7    		JR	OPENX4		; And exit
2541:			
2542:	D5D5  CDE9D5  	READS1:	CALL	OPNXCK		; Open next extent
2543:	D5D8  CDAAD0  	READS2:	CALL	GETDM		; Get block number from DM in FCB
2544:	D5DB  28F4    		JR	Z,READS0	; Jump if block number=0 to end file
2545:	D5DD  CDD7D0  		CALL	CALSEC		; Calculate Sector Number (128 bytes)
2546:	D5E0  CD7AD0  		CALL	CALST		; Calculate Sector/Track number
2547:	D5E3  CD95D1  		CALL	READR		; Read data
2548:	D5E6  C3E4D6  		JP	WRITS7		; Increment elsewhere if necessary
2549:			
2550:			; Consolidated Routine to Open Extent and check status
2551:			
2552:	D5E9  CD51D5  	OPNXCK:	CALL	OPENEX		; Open next extent
2553:	D5EC  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2554:	D5EF  B7      		OR	A
2555:	D5F0  C8      		RET	Z		;== IF OPEN OK
2556:	D5F1  E1      		POP	HL		;== ELSE POP RETURN ADDRESS TO ABORT R/W
2557:	D5F2  18DD    		JR	READS0		;== AND SET ERROR CODE TO EOF
2558:			;==	JR	NZ,READS0	; Yes then end of file
2559:			;==	LD	(IX+NXTREC),A	; Clear record counter (jww)
2560:			;==	RET
2561:			
2562:			; Write Random Record Command (with and without Zero Fill)
2563:			
2564:	D5F4          	CMND40:				; (hfb/cwc)
2565:	D5F4  CD2DCF  	CMND34:	CALL	SELDR1		; Select drive from FCB
2566:			
2567:			; Write Random Sector and Write Random with Zero Fill
2568:			
2569:	D5F7  3EFF    		LD	A,0FFH		; Set Read/Write flag
2570:	D5F9  CDF6D6  		CALL	LDFCB		; Load FCB from random record
2571:	D5FC  2804    		JR	Z,WRITES	; No error then write record
2572:	D5FE  C9      		RET			; Return error
2573:			
2574:			; Write Sequential
2575:			
2576:	D5FF  CD2DCF  	CMND21:	CALL	SELDR1		; Select drive from FCB
2577:			
2578:			; Write Sector.  Permitted to PUBlic files and those found along Path
2579:			
2580:	D602  3EFF    	WRITES:	LD	A,0FFH		; Set read/write flag
2581:	D604  324FCA  		LD	(RDWR),A	; And save it
2582:			
2583:	D608          	BGPTCH1	EQU	$+1		;<-- Patched location for BGii
2584:			
2585:	D607  CDD8D2  		CALL	CHKRO		; Check disk W/P
2586:	D60A  DDCB097E		BIT	7,(IX+ROATT)	; Test if file W/P
2587:	D60E  200E    		JR	NZ,WRITSA	; Yes then file W/P message
2588:	D610  CDC4D2  		CALL	CHKFR3		; Test W/P if path or Public used
2589:	D613  2A13CA  		LD	HL,(WHEEL)	; Get address of Wheel byte
2590:	D616  7E      		LD	A,(HL)		; Do we have it?
2591:	D617  A7      		AND	A
2592:	D618  2007    		JR	NZ,WRITSB	; Yes - allow write
2593:	D61A  DDCB087E		BIT	7,(IX+WHLATT)	; Else test if Wheel Prot file
2594:	D61E  C2CFD2  	WRITSA:	JP	NZ,CHKFR2	; Yes then file W/P message
2595:	D621  DDCB207E	WRITSB:	BIT	7,(IX+NXTREC)	; End of this extent?
2596:	D625  C4E9D5  		CALL	NZ,OPNXCK	; Open next extent and check status (hfb)
2597:	D628  CDAAD0  		CALL	GETDM		; Get block number from FCB
2598:	D62B  C2C3D6  		JP	NZ,WRITS5	; Jump to write sector if Block Number <> 0
2599:	D62E  E5      		PUSH	HL		; Save pointer to Block Number
2600:	D62F  79      		LD	A,C		; Test first Block Number in extent
2601:	D630  B7      		OR	A
2602:	D631  2804    		JR	Z,WRITS1	; Yes then jump
2603:	D633  3D      		DEC	A		; Decrement pointer to Block Number
2604:	D634  CDC0D0  		CALL	GETDM4		; Get previous Block Number
2605:			
2606:			; Get Free Block from ALV Buffer
2607:			;  Entry DE=Old Block Number
2608:			;  Exit  DE=New Block Number (0 if No Free Block)
2609:			;   HL counts Up,DE counts Down
2610:							; GETFRE routine relocated here inline
2611:	D637  62      	WRITS1:	LD	H,D		; Copy old block to HL
2612:	D638  6B      		LD	L,E
2613:	D639  7A      	GETFR0:	LD	A,D		; Test down counter is zero
2614:	D63A  B3      		OR	E
2615:	D63B  280B    		JR	Z,GETFR1	; Yes then jump
2616:	D63D  1B      		DEC	DE		; Decrememt down counter
2617:	D63E  E5      		PUSH	HL		; Save up/down counter
2618:	D63F  D5      		PUSH	DE
2619:	D640  CD44D2  		CALL	GETBIT		; Get bit from ALV buffer
2620:	D643  1F      		RRA			; Test if zero
2621:	D644  3020    		JR	NC,GETFR3	; Yes then found empty block
2622:	D646  D1      		POP	DE		; Get up/down counter
2623:	D647  E1      		POP	HL
2624:	D648  ED4B41CA	GETFR1:	LD	BC,(MAXLEN)	; Get maximum ALV length-1 in BC
2625:	D64C  7D      		LD	A,L		; Is HL >= length ALV-1?
2626:	D64D  91      		SUB	C		; ..do while preserving HL
2627:	D64E  7C      		LD	A,H
2628:	D64F  98      		SBC	A,B
2629:	D650  300E    		JR	NC,GETFR2	; End buffer then jump
2630:	D652  23      		INC	HL		; Increment up counter
2631:	D653  D5      		PUSH	DE		; Save down/up counter
2632:	D654  E5      		PUSH	HL
2633:	D655  EB      		EX	DE,HL		; Save up counter in DE
2634:	D656  CD44D2  		CALL	GETBIT		; Get bit from ALV buffer
2635:	D659  1F      		RRA			; Test if zero
2636:	D65A  300A    		JR	NC,GETFR3	; Yes then found empty block
2637:	D65C  E1      		POP	HL		; Get down/up counter
2638:	D65D  D1      		POP	DE
2639:	D65E  18D9    		JR	GETFR0		; And test next block
2640:			
2641:	D660  7A      	GETFR2:	LD	A,D		; Test if last block tested
2642:	D661  B3      		OR	E
2643:	D662  20D5    		JR	NZ,GETFR0	; No then test next block
2644:	D664  1807    		JR	WRITSG		; Continue with DE=0
2645:			
2646:	D666  37      	GETFR3:	SCF			; Set block number used
2647:	D667  17      		RLA			; Save bit
2648:	D668  CD68D2  		CALL	SETBT0		; Put bit in ALV buffer
2649:	D66B  D1      		POP	DE		; Get correct counter
2650:	D66C  E1      		POP	HL		; Restore stack pointer
2651:							; ..continue with (DE=block number)
2652:			
2653:	D66D  E1      	WRITSG:	POP	HL		; Get pointer to Block Number
2654:	D66E  7A      		LD	A,D		; Test if blocknumber = 0
2655:	D66F  B3      		OR	E
2656:	D670  287F    		JR	Z,WRITS8	; Yes then disk full error
2657:	D672  DDCB0EBE		RES	7,(IX+FCBMOD)	; Reset FCB/File Modified
2658:	D676  73      		LD	(HL),E		; Save blocknumber
2659:	D677  3A42CA  		LD	A,(MAXLEN+1)	; Get number of blocks
2660:	D67A  B7      		OR	A		; Is it < 256?
2661:	D67B  2802    		JR	Z,WRITS2	; ..Jump if so
2662:	D67D  23      		INC	HL		; Increment to MSB Block Number
2663:	D67E  72      		LD	(HL),D		; ..and save MSB block number
2664:	D67F  0E02    	WRITS2:	LD	C,2		; Set write new block flag
2665:	D681  3A3FCA  		LD	A,(NMASK)	; Get sector mask
2666:	D684  DDA620  		AND	(IX+NXTREC)	; Mask with record counter
2667:	D687  2802    		JR	Z,WRITSX	; Zero then Ok (at start new record)
2668:	D689  0E00    		LD	C,0		; Else clear new block flag
2669:	D68B  3A4BCA  	WRITSX:	LD	A,(FUNCT)	; Get function number
2670:	D68E  D628    		SUB	40		; Test if Write RR with zero fill
2671:	D690  2033    		JR	NZ,WRITS6	; No then jump
2672:	D692  D5      		PUSH	DE		; Save blocknumber
2673:	D693  2A34CA  		LD	HL,(DIRBUF)	; Use directory buffer for zero fill
2674:	D696  0680    		LD	B,128		; 128 bytes to clear
2675:	D698  77      	WRITS3:	LD	(HL),A		; Clear directory buffer
2676:	D699  23      		INC	HL		; Increment pointer
2677:	D69A  10FC    		DJNZ	WRITS3		; Clear all bytes
2678:	D69C  CDD7D0  		CALL	CALSEC		; Calculate sector number (128 bytes)
2679:	D69F  3A3FCA  		LD	A,(NMASK)	; Get sector mask
2680:	D6A2  47      		LD	B,A		; Copy it
2681:	D6A3  04      		INC	B		; Increment it to get number of writes
2682:	D6A4  2F      		CPL			; Complement sector mask
2683:	D6A5  A3      		AND	E		; Mask sector number
2684:	D6A6  5F      		LD	E,A		; And save it
2685:	D6A7  0E02    		LD	C,2		; Set write new block flag
2686:	D6A9  E5      	WRITS4:	PUSH	HL		; Save registers
2687:	D6AA  D5      		PUSH	DE
2688:	D6AB  C5      		PUSH	BC
2689:	D6AC  CD7AD0  		CALL	CALST		; Calculate sector/track
2690:	D6AF  CD3DD2  		CALL	DMADIR		; Set DMA directory buffer
2691:	D6B2  C1      		POP	BC		; Get write new block flag
2692:	D6B3  C5      		PUSH	BC		; Save it again
2693:	D6B4  CD9AD1  		CALL	WRITER		; Write record on disk
2694:	D6B7  C1      		POP	BC		; Restore registers
2695:	D6B8  D1      		POP	DE
2696:	D6B9  E1      		POP	HL
2697:	D6BA  0E00    		LD	C,0		; Clear write new block flag
2698:	D6BC  1C      		INC	E		; Increment sector number
2699:	D6BD  10EA    		DJNZ	WRITS4		; Write all blocks
2700:	D6BF  CD37D2  		CALL	STDMA		; Set user DMA address
2701:	D6C2  D1      		POP	DE		; Get Block Number
2702:	D6C3  0E00    	WRITS5:	LD	C,0		; Clear write new block flag
2703:	D6C5  DDCB0EBE	WRITS6:	RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
2704:	D6C9  C5      		PUSH	BC		; Save it
2705:	D6CA  CDD7D0  		CALL	CALSEC		; Calculate sector number (128 bytes)
2706:	D6CD  CD7AD0  		CALL	CALST		; Calculate Sector/Track
2707:	D6D0  C1      		POP	BC		; Get write new block flag
2708:	D6D1  CD9AD1  		CALL	WRITER		; Write record on disk
2709:	D6D4  DD7E20  		LD	A,(IX+NXTREC)	; Get record counter
2710:	D6D7  DDBE0F  		CP	(IX+FCBREC)	; Compare with next record
2711:	D6DA  3808    		JR	C,WRITS7	; If less then jump
2712:	D6DC  3C      		INC	A		; Increment record count
2713:	D6DD  DD770F  		LD	(IX+FCBREC),A	; Save it on next record position
2714:	D6E0  DDCB0EBE		RES	7,(IX+FCBMOD)	; Reset FCB/File Modified flag
2715:	D6E4  3A4BCA  	WRITS7:	LD	A,(FUNCT)	; Get function number
2716:	D6E7  FE14    		CP	20		; (hfb)
2717:	D6E9  D8      		RET	C		; Return if < 20 (hfb)
2718:	D6EA  FE16    		CP	21+1		; (hfb)
2719:	D6EC  D0      		RET	NC		; Return if > 21 (hfb)
2720:	D6ED  DD3420  		INC	(IX+NXTREC)	; Increment record count
2721:	D6F0  C9      		RET			; And return to caller
2722:			
2723:	D6F1  3E02    	WRITS8:	LD	A,2		; Set disk full error
2724:	D6F3  C3BBCE  		JP	SAVEA		; And return to caller
2725:			
2726:			
2727:			; Load FCB for Random Read/Write
2728:			;  Exit : Zero Flag = 1 No Error
2729:			;		      0 Error Occured
2730:			
2731:	D6F6  324FCA  	LDFCB:	LD	(RDWR),A	; Save Read/Write flag
2732:	D6F9  DD7E21  		LD	A,(IX+33)	; Get first byte random record
2733:	D6FC  57      		LD	D,A		; Save it in D
2734:	D6FD  CBBA    		RES	7,D		; Reset MSB to get next record
2735:	D6FF  17      		RLA			; Shift MSB in carry
2736:	D700  DD7E22  		LD	A,(IX+34)	; Load next byte random record
2737:	D703  17      		RLA			; Shift Carry
2738:	D704  F5      		PUSH	AF		; Save it
2739:	D705  E61F    		AND	MAXEXT		; Mask next extent
2740:	D707  4F      		LD	C,A		; Save it in C
2741:	D708  F1      		POP	AF		; Get byte
2742:	D709  17      		RLA			; Shift 4 times
2743:	D70A  17      		RLA
2744:	D70B  17      		RLA
2745:	D70C  17      		RLA
2746:	D70D  E60F    		AND	0FH		; Mask it
2747:	D70F  47      		LD	B,A		; Save data module number
2748:	D710  DD7E23  		LD	A,(IX+35)	; Get next byte random record
2749:	D713  1E06    		LD	E,6		; Set random record to large flag
2750:	D715  FE04    		CP	4		; Test random record to large
2751:	D717  305C    		JR	NC,LDFCB8	; Yes then error
2752:	D719  07      		RLCA			; Shift 4 times
2753:	D71A  07      		RLCA
2754:	D71B  07      		RLCA
2755:	D71C  07      		RLCA
2756:	D71D  80      		ADD	A,B		; Add byte
2757:	D71E  47      		LD	B,A		; Save data module number in B
2758:	D71F  DD7220  		LD	(IX+NXTREC),D	; Set next record count
2759:	D722  DD560E  		LD	D,(IX+FCBMOD)	; Get data module number
2760:	D725  CB72    		BIT	6,D		; Test error random record
2761:	D727  200E    		JR	NZ,LDFCB0	; Yes then jump
2762:	D729  79      		LD	A,C		; Get new extent number
2763:	D72A  DDBE0C  		CP	(IX+FCBEXT)	; Compare with FCB
2764:	D72D  2008    		JR	NZ,LDFCB0	; Not equal then open next extent
2765:	D72F  78      		LD	A,B		; Get new data module number
2766:	D730  DDAE0E  		XOR	(IX+FCBMOD)	; Compare with data module number
2767:	D733  E63F    		AND	MAXMOD		; Mask it
2768:	D735  2837    		JR	Z,LDFCB6	; Equal then return
2769:	D737  CB7A    	LDFCB0:	BIT	7,D		; Test FCB modified (write)
2770:	D739  200F    		JR	NZ,LDFCB1	; No then jump
2771:	D73B  D5      		PUSH	DE		; Save registers
2772:	D73C  C5      		PUSH	BC
2773:	D73D  CDABD1  		CALL	CLOSE		; Close extent
2774:	D740  C1      		POP	BC		; Restore registers
2775:	D741  D1      		POP	DE
2776:	D742  1E03    		LD	E,3		; Set close error
2777:	D744  3A4CCA  		LD	A,(PEXIT)	; Get exit code
2778:	D747  3C      		INC	A
2779:	D748  2827    		JR	Z,LDFCB7	; Error then exit
2780:	D74A  CD9ED5  	LDFCB1:	CALL	SETDME		; Save Data Module and Extent
2781:	D74D  CDF1D2  		CALL	SEAR15		; Search next FCB
2782:	D750  3A4CCA  		LD	A,(PEXIT)	; Get error code
2783:	D753  3C      		INC	A
2784:	D754  2015    		JR	NZ,LDFCB5	; No error then exit
2785:	D756  3A4FCA  		LD	A,(RDWR)	; Get read/write flag
2786:	D759  1E04    		LD	E,4		; Set read empty record
2787:	D75B  3C      		INC	A
2788:	D75C  2013    		JR	NZ,LDFCB7	; Read then error
2789:	D75E  CD09D5  		CALL	MAKES		; Make new FCB
2790:	D761  1E05    		LD	E,5		; Set make error
2791:	D763  3A4CCA  		LD	A,(PEXIT)	; Get error code
2792:	D766  3C      		INC	A
2793:	D767  2808    		JR	Z,LDFCB7	; Error then exit
2794:	D769  1803    		JR	LDFCB6		; No error exit (zero set)
2795:			
2796:	D76B  CDC2D4  	LDFCB5:	CALL	OPENF0		; Open file
2797:	D76E  C382D5  	LDFCB6:	JP	OPENX6		; Set zero flag and clear error code
2798:			
2799:	D771  DD360EC0	LDFCB7:	LD	(IX+FCBMOD),0C0H ; Set random record error
2800:	D775  7B      	LDFCB8:	LD	A,E		; Get error code
2801:	D776  324CCA  		LD	(PEXIT),A	; And save it
2802:	D779  B7      		OR	A		; Clear zero flag
2803:	D77A  DDCB0EFE	SETB14:	SET	7,(IX+FCBMOD)	; (hfb) get FCB/File Not Modified
2804:	D77E  C9      		RET			; And return to caller
2805:			
2806:			; Calculate Random Record
2807:			;  Entry HL=Offset in FCB
2808:			;	 DE=FCB Pointer
2809:			;  Exit  D=LSB Random Record
2810:			;	 C=ISB Random Record
2811:			;	 B=MSB Random Record
2812:			
2813:	D77F  19      	CALRRC:	ADD	HL,DE		; Pointer to FCB+15 or FCB+32
2814:	D780  7E      		LD	A,(HL)		; Get record number
2815:	D781  210C00  		LD	HL,12		; Offset to extent number
2816:	D784  19      		ADD	HL,DE		; Get pointer to extent byte
2817:	D785  57      		LD	D,A		; Save record number
2818:	D786  7E      		LD	A,(HL)		; Get extent byte
2819:	D787  E61F    		AND	MAXEXT		; Mask it 000eeeee
2820:	D789  CB12    		RL	D		; Shift MSB in Carry Cy=R, d=rrrrrrr0
2821:	D78B  CE00    		ADC	A,0		; Add Carry 00xeeeex
2822:	D78D  1F      		RRA			; Shift 1 time (16 bits) 000xeeee
2823:	D78E  CB1A    		RR	D		; D=xrrrrrrr
2824:	D790  4F      		LD	C,A		; Save ISB
2825:	D791  23      		INC	HL		; Increment to data module number
2826:	D792  23      		INC	HL
2827:	D793  7E      		LD	A,(HL)		; Get data module number 00mmmmmm
2828:	D794  0F      		RRCA			; Divide module by 16
2829:	D795  0F      		RRCA
2830:	D796  0F      		RRCA
2831:	D797  0F      		RRCA
2832:	D798  F5      		PUSH	AF		; Save it mmmm00mm
2833:	D799  E603    		AND	03H		; Mask for maximum module
2834:	D79B  47      		LD	B,A		; Save it 000000mm
2835:	D79C  F1      		POP	AF		; Get LSB
2836:	D79D  E6F0    		AND	0F0H		; Mask it mmmm0000
2837:	D79F  81      		ADD	A,C		; Add with ISB mmmxeeee
2838:	D7A0  4F      		LD	C,A		; Save ISB
2839:	D7A1  D0      		RET	NC		; No carry then return
2840:	D7A2  04      		INC	B		; Increment MSB 000000mm
2841:	D7A3  C9      		RET			; And return to caller
2842:							; 000000mm mmmxeeee xrrrrrrr
2844:	FFFF          		  IF  ZS
2845:			;************************************************************************
2846:			;*	  U n i v e r s a l   T i m e / D a t e   S u p p o r t 	*
2847:			;************************************************************************
2848:			
2849:			; In order to provide time/date support for as many systems as possible,
2850:			; a set of universal routines are used.  These routines do not do the
2851:			; actual stamping, but provide all the data required to method specific
2852:			; programs to perform the needed services.  To use the DOS services, the
2853:			; external handler needs to tie itself into the Time/Date vector table
2854:			; in the ZSDOS configuration area.  The Get Stamp, Put Stamp, Stamp Last
2855:			; Access, Stamp Create, and Stamp Modify routines receive the following
2856:			; parameters in the Z80 registers:
2857:			;	A  = Offset to DIR entry [0,20H,40H,60H]
2858:			;	BC = Address of ZSDOS WRFCB routine
2859:			;	DE = Pointer to Directory Buffer
2860:			;	HL = DMA address
2861:			;	IX = Pointer to FCB passed to DOS
2862:			; The directory buffer contains the dir entry for the FCB passed to DOS,
2863:			; A contains the offset.  The disk has been tested for R/O on all calls
2864:			; except get stamp and is R/W.	If a CP/M+ style stamping is used, a simple
2865:			; call to the address passed in BC is used to update the disk after adding
2866:			; the time as required.  This call is ALWAYS required.	The routines may
2867:			; use AF,BC,DE, and HL without restoring them.	Four levels of stack are
2868:			; available on the DOS stack for use by the functions.	All routines must
2869:			; exit with a RET instruction, and A=1 if successful, A=0FFH if error.
2870:			
2871:			; Get/put Timestamps
2872:			
2873:	D7A4          	CMD102:
2874:	D7A4  CD1FCF  	CMD103:	CALL	SELDRV		; Select DU: from FCB
2875:	D7A7  CD19D1  		CALL	SRCT15		; Find the FCB
2876:	D7AA  2831    		JR	Z,DOTDER	; If not found
2877:	D7AC  2A1ECA  		LD	HL,(GETSTV)	; Get time stamp function address
2878:	D7AF  3A4BCA  		LD	A,(FUNCT)
2879:	D7B2  FE66    		CP	102		; Get stamp?
2880:	D7B4  280A    		JR	Z,DOTDR3	; Yes
2881:	D7B6  2A20CA  		LD	HL,(PUTSTV)	; Get address of set stamp routine
2882:							; ..fall thru to common code..
2883:			; Enter here for Stamp Last Access, Stamp Create, Stamp Modify
2884:			
2885:	D7B9  E5      	STAMPT:	PUSH	HL
2886:	FFFF          	IF	HASEDS
2887:	D7BA  CDE7D7  		CALL	CHKEDS		; Test for disk W/P and embedded DateStamper
2888:			ELSE
2890:			ENDIF
2891:	D7BD  E1      		POP	HL
2892:	D7BE  281D    		JR	Z,DOTDER	; No stamp if disk is W/P (or no EDS)
2893:			
2894:	D7C0  CDA6D5  	DOTDR3:	CALL	GETDME		; Get Data Module and Extent Number
2895:	D7C3  2018    		JR	NZ,DOTDER	; ..Quit if Not Extent 0 of Module 0
2896:	D7C5  3A56CA  		LD	A,(SECPNT)	; Offset to FCB in dirbuf
2897:	D7C8  ED5B34CA		LD	DE,(DIRBUF)	; Dir buffer pointer
2898:	D7CC  0117D2  		LD	BC,WRFCB	; Address of WRFCB routine
2899:	D7CF  E5      		PUSH	HL		; Save function vector
2900:	D7D0  2A2ECA  		LD	HL,(DMA)	; Put DMA in HL
2901:	D7D3  C9      		RET			; Then vector to routine
2902:			
2903:			; Time and Date Routines.  Like the date stamping routines, the user must
2904:			; supply the actual driver routines for time and date.	These routines are
2905:			; attached to ZSDOS via the vector table in the configuration area.  The
2906:			; routines are passed the address to Get/Put the Time and Date in the DE
2907:			; and IX registers.  The routines may use AF,BC, and D without restor-
2908:			; ing them.  Four levels of stack are available on the DOS stack for use
2909:			; by the the functions.  All routines must exit with a RET instruction,
2910:			; and A=1 if successful, A=0FFH if error.
2911:			; In order to better provide for internal DateStamper, the clock routines
2912:			; must save the value at DE+5 when called, and return this value to the
2913:			; DOS in the E register.  In addition, the HL register must be returned
2914:			; as the called DE value +5.
2915:			; The Time/Date string consists of 6 packed BCD digits arrayed as:
2916:			;	Byte	00 01 02 03 04 05
2917:			;		YY MM DD HH MM SS
2918:			
2919:			; Set Time/Date from user-supplied buffer string
2920:			
2921:	D7D4  0E01    	CMD99:	LD	C,1		; Set parameter to set time/date
2922:	D7D6  21      		DEFB	21H		; ..and fall thru to GSTD
2923:			
2924:			; Get Time/Date to string whose address is supplied by the user
2925:			
2926:	D7D7  0E00    	CMD98:	LD	C,0		; Set parameter to get time/date
2927:	D7D9  2A16CA  	GSTD:	LD	HL,(GSTIME)	; Get time/date get/set routine address
2928:	D7DC  E5      		PUSH	HL		; ..to stack for pseudo "Jump"
2929:	D7DD  F6FF    	DOTDER:	OR	0FFH		; Save 1 T state while setting flags
2930:	D7DF  C9      		RET			; Vector to service routine
2931:				  ENDIF		;Zs
2933:	0000          		  IF  NOT ZS
3132:				  ENDIF
3133:			
3134:			; Calculate checksum of 127 bytes addressed by HL.  Return with HL
3135:			; pointing to the 128th byte.
3136:			
3137:	D7E0  067F    	CKS127:	LD	B,127		; Test 1st 127 bytes
3138:	D7E2  86      	CKSLP:	ADD	A,(HL)		; Sum all bytes to A
3139:	D7E3  23      		INC	HL
3140:	D7E4  10FC    		DJNZ	CKSLP
3141:	D7E6  C9      		RET
3142:			
3143:			;;
3144:			;; This check for the presence od the DateStamper routine embedded in
3145:			;; RCP space...
3146:			;;
3147:	FFFF          	IF	HASEDS
3148:	D7E7  3A38E8  	CHKEDS:	LD	A,(ZDSSTPR)		; ptr to embedded based
3149:	D7EA  B7      		OR	A			; zero chk.
3150:	D7EB  C8      		RET	Z			; no text in place
3151:	D7EC  C3E5D2  		JP	CHKRO1			; ok test w/p
3152:			ENDIF
3153:			
3155:			;**************************************************************
3156:			;*	 Z S D O S     H i g h	   R A M     D a t a	      *
3157:			;**************************************************************
3158:			
3159:			; High RAM area.  These locations are not stored by an IOP or
3160:			; BackGrounder.
3161:			
3162:	D7EF          	CODEND:
3163:	0000          		  IF  ROM
3168:				  ELSE
3169:	FFFF          		    IF  ZS
3170:	0000          		      IF  $-ZSDOS GT 0DF1H
3172:				      ENDIF		;$-zsdos
3173:	D7F1          		ORG	ZSDOS+0DF1H		; Set here for Internal Path
3174:				    ELSE
3179:				    ENDIF		;Zs
3180:				  ENDIF			;Rom
3181:	D7F1          	HIRAM:
3182:	FFFF          		  IF  ZS
3183:	D7F1  0100    	IPATH:	DEFB	1,0		; Internal Path = Drive A, User 0
3184:	D7F3  00000000		DEFW	00,00		; ..two more blank entries
3185:	D7F7  00      		DEFB	0		; ...and ending Null
3186:	D7F8  0000    	TDFVCT:	DEFW	00		; Time and date file vector
3187:				  ELSE
3189:				  ENDIF		;Zs
3190:	D7FA  0000    	LOGIN:	DEFW	00		; Login vector
3191:	D7FC  0000    	DSKWP:	DEFW	00		; Disk write protect vector
3192:	D7FE  0000    	HDLOG:	DEFW	00		; Fixed disk login vector
3193:			
3194:	0000          		  IF  ROM
3196:				  ELSE
3197:	0002          	FREEMEM	EQU	HIRAM-CODEND
3198:				  ENDIF		;Rom
3199:			
3200:			; Variables for use with BGii
3201:			
3202:	0008          	BGLOWL	EQU	BGHIRAM-BGLORAM	   ; Size of Low RAM save
3203:	006D          	BGHIL	EQU	BGRAMTOP-BGHIRAM   ; Size of Hi RAM save
3204:			
3205:			; symbols...
3206:			wsym zsdos.sym
3207:			
3208:	D800          		END			; End program



Statistics:

     6	passes
     0	jr promotions
   497	symbols
     0	bytes



Symbol Table:

alv             ca3a     extfcb         =edd0+    roatt          =   9+    
anddem          ce66     extrabias      =1200+    rom            =   0+    
arcatt         =   b+    extstk         =efd0+    rubout         =  7f+    
arword          ca5d     false          =   0+    savea           cebb     
base           =   0+    fcb0            ca2d     savhl           cef3     
bdlist         =d80f+    fcbext         =   c+    sdrvb           d04a     
bdos           =ca06+    fcbmod         =   e+    sdrvb0          d054     
bdosb          =ca00+    fcbrec         =   f+    sear12          d2ee     
bdread         =d827+    fcbusr         =   d+    sear15          d2f1     
bdvers         =  11+    fcontp          ca28     searc1          d32c     
bgckdro         d2d8+    fcp            =ea00+    searc2          d33a     
bgconst         ccb7+    fcps           =   4+    searc3          d36b     
bghil          =  6d+    ff             =   c+    searc4          d378     
bghiram         ca2e     filcnt          ca54     searc5          d37a     
bgloram         ca26     fillb0          d28b     searc6          d380     
bglowl         =   8+    fillb1          d298     searc7          d386     
bgptch0        =cc7c+    fillb2          d2a9     searc7a         d38c     
bgptch1        =d608+    fillbb          d283     searc8          d397     
bgptch2        =d1a9+    filsz           d42b     searc9          d39d     
bgramtop       =ca9b+    filsz0          d435     search          d2f3     
bgseldrv        cf1f+    findf           d457     searcn          d30a     
bias           =8e00+    findf0          d467     searex          ca5a     
bioreas        = a00+    findf1          d477     searnb          ca5b     
bios           =d800+    findf2          d488     searpu          ca51     
biostds        = 600+    findf3          d4a8     searqu          ca50     
boot           =d800+    flags           ca15     secpnt          ca56     
botdsk         =d836+    fldrv           ca4e     sectrn         =d830+    
btime          =d833+    flgbits        =  6d+    seg1           =e200+    
caldi0          d0f7     freemem        =   2+    seg10          =ec00+    
caldir          d0f1     funct           ca4b     seg11          =ef00+    
caldir1         d0f4+    gcons2          cccc     seg12          =efd0+    
calne1          d59a     getbit          d244     seg2           =ea00+    
calnex          d585     getbt0          d25b     seg3           =ea00+    
calrrc          d77f     getcdm          d047     seg4           =ed00+    
calsc0          d0df     getch           cb75     seg5           =ed80+    
calsec          d0d7     getdm           d0aa     seg6           =edd0+    
calst           d07a     getdm4          d0c0     seg7           =edf4+    
calst0          d080     getdme          d5a6     seg8           =edff+    
calst1          d088     getdmx          d0d4     seg9           =ee00+    
calst2          d093     getfr0          d639     seldk           cf81     
ccp            =c200+    getfr1          d648     seldk0          cf8a+    
chkdir          d15a     getfr2          d660     seldk2          cf94     
chkdr1          d176     getfr3          d666     seldk3          cf71     
chkeds          d7e7     getstv          ca1e     seldk4          cfe6     
chkfr2          d2cf     gstd            d7d9+    seldk5          cff9     
chkfr3          d2c4     gstime          ca16     seldr0          cf4e     
chkfr4          d2bf     haseds         =ffff+    seldr1          cf2d     
chkfro          d2ac     hdlog           d7fe     seldrv          cf1f     
chkro           d2d8     hiram           d7f1     seldsk         =d81b+    
chkro1          d2e5     hlorde          d058     setb14          d77a     
ckrodi          d0ee     home           =d818+    setbit          d260     
cks127          d7e0     idisk1         =  24+    setbt0          d268     
ckslp           d7e2     idisk2         =  24+    setdma         =d824+    
cksub           ce52     idisk3         =   1+    setdme          d59e     
close           d1ab     idisk4         =   1+    setfct          d0fc     
close0          d1c5     initd2          d020     setlf0          d114     
close1          d1ce     initdr          cffc     setpsf          d4af     
close3          d1e5     intron         =   0+    setsec         =d821+    
close4          d1fa     iop            =   0+    settrk         =d81e+    
close6          d208     iops           =   0+    sfilro          ca0f     
cmd100          cec2     ipath           d7f1     shrhl3          d05f     
cmd101          cebf     iuser1         =  24+    shrhlb          d061     
cmd102          d7a4     iuser2         =   f+    shsize         =  20+    
cmd103          d7a4     iuser3         =  24+    shstk          =ed00+    
cmd17a          ce83     iuser4         =   f+    shstks         =   4+    
cmd17b          ce85     ixp             ca36     slr            =ffff+    
cmd17c          ce88     ixsave          ca99     spsave          ca61     
cmd19a          ceab     jsear8          d32a     srct15          d119     
cmd98           d7d7     jsetdme         d205     stampt          d7b9     
cmd99           d7d4     jzrbx           cbb3     start           ca06+    
cmnd01          cb50     lastch          ca29     stbdsc          ca09     
cmnd06          cb5a     ldfcb           d6f6     stcrv           ca1a     
cmnd07          cb91     ldfcb0          d737     stdir           d068     
cmnd08          cb8e     ldfcb1          d74a     stdir1          d077+    
cmnd09          ccd5     ldfcb5          d76b     stdir2          d076+    
cmnd10          cb95     ldfcb6          d76e     stdma           d237     
cmnd11          ccb7     ldfcb7          d771     stlav           ca18     
cmnd12          cecf     ldfcb8          d775     stmpp2         =ffff+    
cmnd13          ce0a     ldrrc           cf15     stmpzs         =   0+    
cmnd14          cf7a     lf             =   a+    stro            ca0d     
cmnd15          d4b4     listst         =d82d+    stsel           ca0b     
cmnd16          d1a8     login           d7fa     stupdv          ca1c     
cmnd17          ce6e     make0           d52d     subext          ce4d     
cmnd18          ce95     makes           d509     subflg          ca57     
cmnd19          cea5     maxcmd         =  31+    sysatt         =   a+    
cmnd20          d5be     maxext         =  1f+    tab            =   9+    
cmnd21          d5ff     maxlen          ca41     tabcnt          ca26     
cmnd22          d502     maxmod         =  3f+    tabcx1          ca27     
cmnd23          ceb0     maxsec          ca3c     tdcksm         =  91+    
cmnd24          cee8     mbadsc          cd0a     tdfvct          d7f8     
cmnd25          ceb8     mberr           cd27     temp0           ca32     
cmnd26          d233     mbfunc          cd37     trans           ca30     
cmnd27          cee4     mcrlf           cd49     true           =ffff+    
cmnd28          d103     mdrive          cd3d     tstfct          d11c     
cmnd29          cedc     mdskch          cd02     tstlf           d123     
cmnd30          cec7     mfile           cd40     unload          ca24+    
cmnd31          ceec     mfilro          cd1e     unlog           ce5d     
cmnd32          cefb     mro             cd23     unroll         =ffff+    
cmnd33          d5b4     msel            cd15     unwpt1          ce2c     
cmnd34          d5f4     msize          =  3c+    upath          =ffff+    
cmnd35          cf07     mv2dma          ce8e+    user            ca2a     
cmnd36          cf0f     nblock          ca3e     vcstat          d405+    
cmnd37          ce1c     ncheck          ca47     vdel            d270+    
cmnd39          cee0     ndir0           ca45     vdel1           d27e     
cmnd40          d5f4     nextnd          ca40     vermaj         =   1+    
cmnd45          cef7     nfiles          ca43     vermin         =   1+    
cmnd47          cef0     nftrk           ca49     vers           =  16+    
cmnd48          ced8     nmask           ca3f     vrenam          d3da+    
codend          d7ef     num             cced     wboot          =d803+    
comco1          d3c3     num1            ccef     wheel           ca13     
comco2          d3cf     num2            cd00     whladr         =edff+    
comcod          d3bd     nxtrec         =  20+    whlatt         =   8+    
conin          =d809+    openex          d551     wrcon           cc64     
conout         =d80c+    openf0          d4c2     wrcon0          cc68     
const          =d806+    openf1          d4ef     wrcon1          cc77     
contc          =   3+    openx0          d564+    wrcon2          cc93     
conth          =   8+    openx2          d55f     wrcon3          ccad     
contp          =  10+    openx3          d577     wrcon4          ccb0     
contr          =  12+    openx4          d57c     wrctl           cc53     
conts          =  13+    openx5          d57f     wrfcb           d217     
contu          =  15+    openx6          d582     writd1          d229+    
contx          =  18+    opnxck          d5e9     write          =d82a+    
cr             =   d+    path            ca11     write0          d19d     
crout           ccd2     pathad         =d7f1+    writer          d19a     
cstat           d402     pexit           ca4c     writes          d602     
cstat1          d40d     pickey         =   0+    writs1          d637     
cstat2          d422     prdec           ccdf     writs2          d67f     
csv             ca38     psfatt         =   7+    writs3          d698     
ctable          cae2     pubatt         =   2+    writs4          d6a9     
ctlren         =ffff+    punch          =d812+    writs5          d6c3     
dcio1           cb71     putch           cb54     writs6          d6c5     
dcio2           cb66     putstv          ca20     writs7          d6e4     
dcopy           ca58     ramlow         =   0+    writs8          d6f1     
defdrv          ca2b     rcp            =e200+    writsa          d61e     
delete          d26d     rcps           =  10+    writsb          d621     
deval           ca5f     rdbuf1          cb9f     writsg          d66d     
dirbuf          ca34     rdbuf2          cbb6+    writsx          d68b     
dma             ca2e     rdbuf3          cbf4     z3cl           =ef00+    
dmadir          d23d     rdbuf4          cc06     z3cls          =  d0+    
dmadr0          d241     rdbuf5          cc2e     z3env          =ec00+    
doback          cbbe     rdbuf6          cc39     z3envs         =   2+    
dobak0          cbc1     rdbufx          cc4e     z3msg          =ed80+    
dobak1          cbd2     rddir           d130     z3ndir         =ee00+    
dobak2          cbd7     rddir0          d14d+    z3ndirs        =  1c+    
dobak5          cbdf     rdwr            ca4f     z3rev          =  21+    
dosexit         cde6     reader         =d815+    z3whl          =edff+    
dosext0         cdf8     readr           d195     zas            =   0+    
dotder          d7dd     reads           d5c1     zbufbas        =e200+    
dotdr3          d7c0     reads0          d5d1     zdpch1          cecf+    
dpbof          =  3c+    reads1          d5d5     zdpch2         =d01d+    
drive           ca2c     reads2          d5d8     zdpch3         =d037+    
dskwp           d7fc     recdir          ca52     zdsstpr        =e838+    
dummy           cebe     relog1          ce37     zdsstsz        = 1c8+    
eralin          cbfc     relog2          ce48+    zentry          ca9b     
ermode          ca5c     renam           d3d7     zentry0         cad2     
error           cd4c     renam1          d3f0     zentry1         cad6     
error0          cd91     renam2          d3fa     zflopkg        = 200+    
error1          cd9a     resdsk         =   0+    ziopkg         =   0+    
error2          cdab     resroom        = 400+    zrespkg        = 800+    
error3          cdaf     resus1          cf60     zrl            =   0+    
error4          cdc1     resusr          cf5e     zs             =ffff+    
error5          cdca     retcff          d57a     zsdos          =ca00+    
error6          cdcf     rety1a          cc1d     zsdos11        =ffff+    
error7          cddd     retyp1          cc1a     zsdoss          ca9b     
expath         =edf4+    retyp2          cc26     zstdovr        = 400+    
expaths        =   5+    retyp3          cc2b     
