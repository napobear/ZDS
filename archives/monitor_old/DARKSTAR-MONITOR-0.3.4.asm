;
;
; Z80 Nuova Elettronica Monitor 390 su eprom 2532 (4k)
;
; Disassemblato e ricostruito da Piergiorgio Betti <pbetti@lpconsul.net>
; 2005 01 26
;
; ---[20051030]--------------------------------------------------------
; Avviate modifiche per inserimento routine di download parallelo
; ---[20051109]--------------------------------------------------------
; Versionata come 0.2.0. Da questa release iniziano modifiche di
; struttura
; - rinominati entry point
; - cancellata UKROUT
; - cancellata DISPGR . ATTENZIONE: TUTTI GLI INDIRIZZI SONO CAMBIATI!!
; - DISPGR2 rinominata DISPGR
; - rilocati tutti i buffer nell'area $003b-$004f non usata dal CP/M
; - numero versione 1.0
; - removed code from $f97c to $f9f1....
; - removed code from $fa2f to $fa37....
; ---[20051113]--------------------------------------------------------
; - Completate routine di I/O su parallela. Nuova copia su EPROM.
; ---[20051114]--------------------------------------------------------
; Release 0.2.3
; - Gestione errore per link parallelo (TX only)
; ---[20051216]--------------------------------------------------------
; Versione 1.1, funzionamento ok del'i/o parallelo.
; Inserita routine di boot CP/M da parallela
; ---[20051216]--------------------------------------------------------
; Release 0.2.4
; - Riunificati MIOBYTE e CYOBYTE con conseguente eliminazione di
;   CYOBYTE
; - Eliminata doppia tabella di inizializzazione SY6545 e copia della
;   tabella in RAM ($0010)
; ---[20060204]--------------------------------------------------------
; Release 0.2.5
; - sistemazione del codice (maiuscolo, tabulazioni)
; - inserito menu do boot
; ---[20060213]--------------------------------------------------------
; Release 0.2.6
; - Fixed DSELBF init from previous release
; - Moved here some code from from BIOS to keep space
; - Removed GETKBD (redundant)
; - Moved SETSID from BIOS
; - Revised internal buffer organization
; - Removed unused routines (LPAGE,BLOOP) and data (RAMBLOCK)
; - Cleaned up splitted routines (BCONIN/BCONOUT)
; - Completeley revised BOOT routine
; ---[20060302]--------------------------------------------------------
; Release 0.3.0
; - Added the followin routines to cope with floppy bootloader (and
;   CP/M WBOOT) adding on-the-fly skew capabilities
;   o DIV16 - 16 by 16 integer division
;   o MUL16 - 16 by 16 integer multiplication
;   o TRANSK - calculate skew factor on-the-fly
;   o OFFCAL - apply a read skew factor to sequential written
;              floppies. Used by bootloader and CP/M WBOOT.
; - Version number moved to 2.0
; - drive i/o no more rely on sector lenght
; ---[20060409]--------------------------------------------------------
; Release 0.3.1
; CLOCK speed has been increased to 4MHz!!. This show some points to
; fix:
; - DELAY routine parameter MSCNT need adjust
; - DISPCH shows loss of characters in video update, expecially during
;   clean. So DISPGRCH has been used in place, renamed to DISPCH.
; ---[20060610]--------------------------------------------------------
; Release 0.3.2
; - Modified ctrl chars EOT, ENQ to set cursor OFF and ON.
;   Mofified ctrl char <0D> in IOCVEC2 to act as IOCNUL
; ---[20080125]--------------------------------------------------------
; - Release 0.3.3
; - Introducing interrupt handling...
; ---------------------------------------------------------------------
; - Release 0.3.4
; - Fixed PORTIN e PORTOUT
; - Added clock (DS1302) management
; ---------------------------------------------------------------------

;
; Monitor version numbers (major.minor)
;
MONMAJ		EQU	'2'
MONMIN		EQU	'4'

; Defines for the i/o ports
;
; *** LX529 VIDEO BOARD:
CRTBASE		EQU	$80
	; RAM0 for ascii chars & semi6. Combined with RAM1 and RAM2 for graphics
CRTRAM0DAT	EQU	CRTBASE		; RAM0 access: PIO0 port A data register
CRTRAM0CNT	EQU	CRTBASE+2	; RAM0 access: PIO0 port A control register
	; Printer port
CRTPRNTDAT	EQU	CRTBASE+1	; PRINTER (output): PIO0 port B data register
CRTPRNTCNT	EQU	CRTBASE+3	; PRINTER (output): PIO0 port B control register
					; STROBE is generated by hardware
	; RAM1 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM1DAT	EQU	CRTBASE+4	; RAM1 access: PIO1 port A data register
CRTRAM1CNT	EQU	CRTBASE+6	; RAM1 access: PIO1 port A control register
	; Keyboard port (negated). Bit 7 is for strobe
CRTKEYBDAT	EQU	CRTBASE+5	; KEYBOARD (input): PIO1 port B data register
CRTKEYBCNT	EQU	CRTBASE+7	; KEYBOARD (input): PIO1 port B control register
KEYBSTRBBIT	EQU	7		; Strobe bit
	; RAM2 for graphics. (pixel index by RAM0+RAM1+RAM2)
CRTRAM2DAT	EQU	CRTBASE+8	; RAM2 access: PIO2 port A data register
CRTRAM2CNT	EQU	CRTBASE+10	; RAM2 access: PIO2 port A control register
	; Service/User port
CRTSERVDAT	EQU	CRTBASE+9	; Service (i/o): PIO2 port B data register
CRTSERVCNT	EQU	CRTBASE+11	; Service (i/o): PIO2 port B control register
PRNTBUSYBIT	EQU	0		; Printer BUSY bit		(in)	1
CRTWIDTHBIT	EQU	1		; Set 40/80 chars per line	(out)	0
PIO2BIT2	EQU	2		; user 1 (input)		(in)	1
PIO2BIT3	EQU	3		; user 2 (input)		(in)	1
PIO2BIT4	EQU	4		; user 3 (input)		(in)	1
CLKSCLK		EQU	5		; DS1320 clock line		(out)	0
CLKIO		EQU	6		; DS1320 I/O line		(i/o)	1
CLKRST		EQU	7		; DS1320 RST line		(out)	0
	; normal set for PIO2 (msb) 01011101 (lsb) that is hex $5D
					; Other bits available to user
	; RAM3 control chars/graphics attributes
CRTRAM3PORT	EQU	CRTBASE+14	; RAM3 port
CRTBLINKBIT	EQU	0		; Blink
CRTREVRSBIT	EQU	1		; Reverse
CRTUNDERBIT	EQU	2		; Underline
CRTHILITBIT	EQU	3		; Highlight
CRTMODEBIT	EQU	4		; ASCII/GRAPHIC mode
	; Beeper port
CRTBEEPPORT	EQU	CRTBASE+15	; Beeper port
	; 6545 CRT controller ports
CRT6545ADST	EQU	CRTBASE+12	; Address & Status register
CRT6545DATA	EQU	CRTBASE+13	; Data register
;
; *** LX390 FDC CONTROLLER:
FDCBASE	EQU	$D0
FDCCMDSTATR	EQU	FDCBASE		; Command and status register
FDCTRAKREG	EQU	FDCBASE+1	; Track register
FDCSECTREG	EQU	FDCBASE+2	; Sector register
FDCDATAREG	EQU	FDCBASE+7	; Data register *** Verificare che sia $d7
FDCDRVRCNT	EQU	FDCBASE+6	; Driver select/control register
;
FDCRESTC	EQU	$07		; 1771 restore (seek to trak 0) cmd
FDCSEEKC	EQU	$17		; seek cmd
FDCREADC	EQU	$88		; read cmd
FDCWRITC	EQU	$A8		; write cmd
;
; alternate printer port
ALTPRNPRT	EQU	$03
;
; parallel port PC link
PPDATAP		EQU	$3		; Data port
PPCNTRP		EQU	$2		; Control port
PPSTROB		EQU	0		; Strobe bit
PPAKSTB		EQU	1		; Acknowledge/Stop bit
;
PPDINI		EQU	$0		; 00000000 Dnl Init byte
PPDRDY		EQU	$4		; 00000100 Dnl Ready
PPDSTP		EQU	$6		; 00000110 Dnl Stop
PPDOKG		EQU	$2		; 00000010 Dnl Ok Go
PPUINI		EQU	$1		; 00000001 Upl Init byte
PPURDY		EQU	$5		; 00000101 Upl Ready
PPUACK		EQU	$7		; 00000111 Upl Acknowledge
PPUOKG		EQU	$3		; 00000011 Upl Ok Go
;
; virtual disks (PC-linked over parallel port)
VDRDSEC		EQU	0		; read sector command
VDWRSEC		EQU	1		; write sector command
VDBUFSZ		EQU	10		; 9 bytes block
;
; Ram addresses labels
;
; -- Global --
IOBYTE		EQU	$0003		; byte: Intel IOBYTE (CP/M 2.2 only)
CDISK		EQU	$0004		; byte: Last logged drive (CP/M 2.2 only)
BTPASIZ		EQU	$0006		; word: size of tpa + 1
;
; -- Private --
PRVTOP		EQU	$004F		; top of private area storage
COLBUF		EQU	PRVTOP		; byte:
DSELBF		EQU	COLBUF-1	; byte: floppy drive select status
					; - bits: 0 = drive 0
					; - bits: 1 = drive 1
					; - bits: 2 = drive 2
					; - bits: 3 = drive 3
					; - bits: 4 = unused
					; - bits: 5 = head select
					; - bits: 6 = motor on (disabled by jumper)
					; - bits: 7 = unused
KBDBYTE		EQU	DSELBF-1	; byte: store keyboard input
MIOBYTE		EQU	KBDBYTE-1	; byte:
					; - bits: 0: 0 = floppy write		1 = floppy read
					;         1: 0 = no ctrl on keypress	1 = ctrl on keypress
					;         2: 0 = scroll			1 = no scroll
					;         3: 0 = accept lowercase	1 = convert to uppercase
					;         4: 0 = destr. bkspace		1 = non destr. bkspace
					;         5: 0 = console out		1 = printer out
					;         6: 0 = disp. all chars	1 = obscure non punct.
					;         7: 0 = ctrl chr set 1		1 = ctrl chr set 2
TMPBYTE		EQU	MIOBYTE-1	; byte: transients flags
					; - bits: 0: 0 = high in cursor addressing
					;         1: 0 = unused
					;         2: 0 = unused
					;         3: 0 = unused
					;         4: 0 = unused
					;         5: 0 = store interrupt status (on/off)
					;         6: 0 = floppy home on err	1 = no home on err
					;         7: 0 = used by BIOS read-after-write
CURPBUF		EQU	TMPBYTE-2	; word:
FTRKBUF		EQU	CURPBUF-2	; word: track # for i/o (0 - 65535)
FDRVBUF		EQU	FTRKBUF-1	; byte: drive number for i/0 (0 - 15)
FSECBUF		EQU	FDRVBUF-2	; word: sector # for i/o (1 .. 65535)
FRDPBUF		EQU	FSECBUF-2	; word: dma address for i/o
FSEKBUF		EQU	FRDPBUF-2	; word: current track number for drive A/B
RST7SPC		EQU	$0038		; keep clear area of RST38 (RST7)
RAM3BUF		EQU	RST7SPC-1	; byte:
RAM2BUF		EQU	RAM3BUF-1	; byte:
RAM1BUF		EQU	RAM2BUF-1	; byte:
RAM0BUF		EQU	RAM1BUF-1	; byte:
VDSKBUF		EQU	RAM0BUF-8	; table: 8 bytes command structure buffer
APPBUF		EQU	VDSKBUF-2	; word: generic buffer
	; Some commodity equs
CR		EQU	$0D		; ascii CR & LF
LF		EQU	$0A
TPA		EQU	$0100		; TPA base address (for CP/M)
;
; aliases
IOCACK		EQU	INICRTCUR
IOCVT		EQU	CHOME
IOCFF		EQU	CLRSCR
IOCSI		EQU	CLREOL
IOCDC1		EQU	RESATTR
IOCDC4		EQU	LINDN

	ORG	$F000		; THIS IS MONITOR EPROM BASE, (de)comment when you need to test
; 	ORG	$E000		; THIS FOR TESTING PURPOSES, (de)comment when you need it

ZDSMNTR	EQU	$		; start of monitor code

JBOOT:	JP	BOOT		; BOOT - Bring up system
JCONIN:	JP	BCONIN		; Char input
JCONOU:	JP	BCONOUT		; Char output
JHOME:	JP	BHOME		; move head to trak 0 (cp/m home like)
JSELDS:	JP	BSELDSK		; Drive select
JSETTR:	JP	BSETTRK		; Track Select
JSETSE:	JP	BSETSEC		; Sector select
JSETDM:	JP	BSETDMA		; DMA (io address) select
JREAD:	JP	BREAD		; read floppy sector
JWRITE:	JP	BWRITE		; write floppy sector
JFSTAT:	JP	GFDCSTAT	; get 1771 status
JFDCMD:	JP	SFDCCMD		; send cmd to 1771
JCURTR:	JP	GCURTRK		; get current track for current drive
JFSEEK:	JP	FSEEK		; floppy seek
JDRVSL:	JP	DRVSEL		; do drive selection
JDISPG:	JP	DISPNORTR	; graphic output (VERIFY NEED OF JUMP ENTRY)
JUSRCM:	JP	UCREJ		; negative monitor prompt
JCPMBT:	JP	CPMBOOT		; floppy bootstrap of CP/M
JGETHN:	JP	GETHNUM		; get hexadecimal number
JCONST:	JP	BCONST		; console status
JPRNCH:	JP	PRNCHR		; printer output

;; SET DISPLAY CURSOR ADDRESS EXTENDED
;
SDCUAE:
	LD	A,$0E			; was 00F060 3E 0E
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$0F
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
SDCUAE1:
	LD	A,$12
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$13
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	JR	CRTPRGEND
;;
;; SCUROF - turn off cursor
;
SCUROF:
	LD	A,$0A			; was 00F07E 3E 0A
	OUT	(CRT6545ADST),A
	LD	A,$20
	OUT	(CRT6545DATA),A
;;
;; CRTPRGEND
;; resets 6545 register pointer
;
CRTPRGEND:
	LD	A,$1F			; was 00F086 3E 1F
	OUT	(CRT6545ADST),A
	RET
;;
;; SCURON - turn on cursor
;
SCURON:
	LD	A,$0A			; was 00F08B 3E 0A
	OUT	(CRT6545ADST),A
	XOR	A
	OUT	(CRT6545DATA),A
	JR	CRTPRGEND
;;
;; INICRT - should be
;
INICRT:
					; initialize PIOs
	LD	A,$8F			; 10-00-1111 mode ctrl word
					; Mode 2 (I/O port A)
	OUT	(CRTRAM0CNT),A
	OUT	(CRTRAM1CNT),A
	OUT	(CRTRAM2CNT),A
	LD	A,$CF			; 11-00-1111 mode ctrl word
					; Mode 3 (bit mode port B)
	OUT	(CRTPRNTCNT),A		; send to PIO0
	EX	AF,AF'
	XOR	A			; bit mask 00000000 (all outputs)
	OUT	(CRTPRNTCNT),A		; send to PIO0
	EX	AF,AF'			; reload mode 3 ctrl word
	OUT	(CRTKEYBCNT),A		; send to PIO1
	EX	AF,AF'
	DEC	A			; load bit mask 11111111 (all inputs)
	OUT	(CRTKEYBCNT),A		; send to PIO1
	EX	AF,AF'
	OUT	(CRTSERVCNT),A		; reload mode 3 ctrl word
	LD	A,$5D			; bit mask 01011101
					;          ||||||||- b0 in  (printer busy line)
					;          |||||||-- b1 out (40/80 col. mode)
					;          ||||||--- b2 in  (unassigned)
					;          |||||---- b3 in  (unassigned)
					;          ||||----- b4 in  (unassigned)
					;          ||------- b5 out (ds1320 clock line)
					;          ||------- b6 in  (ds1320 i/o line)
					;          |-------- b7 out (ds1320 RST line)
	OUT	(CRTSERVCNT),A		; send to PIO2
	IN	A,(CRTSERVDAT)		; read data port PIO2
	RES	CLKRST,A		; ensure DS1320 RST line is low (active)
	RES	1,A			; Modo 40/80 colonne (80)
	OUT	(CRTSERVDAT),A		; send to PIO2
	CALL	INI6545			; init 6545
	JP	CRTPRGEND		; go on...

;;
;; return with interrupt enable checksum
;;
CKIRET:	PUSH	AF
	LD	A,(TMPBYTE)
	BIT	5,A			; interrupt disabled if zero
	JR	Z,CKINOI
	EI				; enabled...
CKINOI:	POP	AF
	RET

;;
;; reset (disable) interrupts restore
;;
GDISIN:
	LD	HL,TMPBYTE
	RES	5,(HL)
	RET
;;
;; set (enable) interrupts restore
;;
GENAIN:
	LD	HL,TMPBYTE
	SET	5,(HL)
	RET

;;
;; RTCWMOD
;; - set DS1302 I/O line as output

RTCWMOD:
	LD	A,$CF			; 11-00-1111 mode ctrl word
					; Mode 3 (bit mode port B)
	OUT	(CRTSERVCNT),A		; load mode 3 ctrl word
	LD	A,00011101B		; bit mask 00011101
					;           |------- b6 out  (ds1320 i/o line)
	OUT	(CRTSERVCNT),A		; send to PIO2
	RET

;;
;; RTCWMOD
;; - set DS1302 I/O line as output

RTCRMOD:
	LD	A,$CF			; 11-00-1111 mode ctrl word
					; Mode 3 (bit mode port B)
	OUT	(CRTSERVCNT),A		; load mode 3 ctrl word
	LD	A,01011101B		; bit mask 01011101
					;           |------- b6 in  (ds1320 i/o line)
	OUT	(CRTSERVCNT),A		; send to PIO2
	RET

CLUPSCLK:
	IN	A,(CRTSERVDAT)		; read data port PIO2
	SET	CLKSCLK,A
	OUT	(CRTSERVDAT),A		; send to PIO2
	RET

CLLOSCLK:
	IN	A,(CRTSERVDAT)		; read data port PIO2
	RES	CLKSCLK,A
	OUT	(CRTSERVDAT),A		; send to PIO2
	RET

CLUPRST:
	IN	A,(CRTSERVDAT)		; read data port PIO2
	SET	CLKRST,A
	OUT	(CRTSERVDAT),A		; send to PIO2
	RET

CLLORST:
	IN	A,(CRTSERVDAT)		; read data port PIO2
	RES	CLKRST,A
	OUT	(CRTSERVDAT),A		; send to PIO2
	RET

;-------------------------------------------------------------------------
; Dallas DS-1302 Clock Interface
;
;  Read the Clock to a buffer area in Memory.  Seven bytes are read
; in burst mode from the clock chip, one bit at a time. The Clock is accessed
; serially (LSB first) one byte at a time with a command byte being written to
; begin the Read/Write.  Burst Mode is used with a 0BFH byte for Reading,
; 0BEH for Writing as the Command.  Clock Setting clears the Write Protect
; bit before setting, and resets the chip to Read-Only when finished.
;  The Entire Date/Time String is eight bytes read as:
;
;	Sec   Min   Hour   Day   Mon   DOW   Year   WProt
;                  (12/24)                          (MSB)
;
; In this implementation, the 12/24 hour bit is always set to 24-hour
; mode by clearing the MSB.

RDTIME:	CALL	COPEN			; Set Clock to Read, returning BC->DRA Port
	LD	D,7			; 7 Bytes to Read

; Command the DS-1302 for Burst Read of Clock

	LD	A,$BF			; Load the Burst Clock Read Command
	CALL	WR1302			; and Send it

; Read the Clock Data.

RDDSRE:	PUSH	HL			; Save Ptr
	LD	E,8			; Gather 8 bit for a byte
RDTIM1:	CALL	CLLOSCLK		; Clock LO
	NOP				; (settle)
	IN	A,(CRTSERVDAT)		; Read Bit to LSB
	RLCA				; shift left to
	RLCA				; move bit 6 to carry
	RR	L			; to MSB of L
	CALL	CLUPSCLK		; Clock HI
	DEC	E			; Byte Done?
	JR	NZ,RDTIM1		; ..jump if Not
	LD	E,L			; Else Get Byte
	POP	HL			; Restore Ptr to Dest
	LD	(HL),E			; Save value in output string
	INC	HL			; back down to previous byte in output
	DEC	D			; decrement counter
	JR	NZ,RDDSRE		; ..get another byte if not done
	CALL	CCLOSE			; Else Deselect Clock
	LD	A,$01			; Set Good Exit
	RET

;.....
; Activate the Clock chip and set Date/Time from the parsed string

STTIM:	CALL	COPEN			; Open the Clock
	LD	A,10001110B		; select write to control register (8E)
	CALL	WR1302
	LD	A,0			; Write-Protect Off
	CALL	WR1302
	CALL	CCLOSW
	CALL	COPEN
	LD	A,10111110B		; Burst Write (BE)
	LD	B,8			; 8 bytes
	CALL	WR1302
STTI0:	LD	A,(HL)
	CALL	WR1302
	INC	HL
	DJNZ	STTI0
	CALL	CCLOSW
	RET

;;
;; Activate trickle charger
;;
STTCK:	CALL	COPEN			; Open the Clock
	LD	A,10010000B		; select write to trickle charger reg.
	CALL	WR1302
	LD	A,10100101B		; prog as 1 diode + 2kohm res. (2.2mA)
	CALL	WR1302
	CALL	CCLOSW
	RET

;.....
; Set up DS-1302 interface
; Entry: None
; Uses : AF

COPEN:	CALL	RTCRMOD		; Data Line to Input
	CALL	CLLOSCLK	; Clk LO to Start
	CALL	CLUPRST		; Clear Reset to HI
	RET

;.....
; Write the Byte in A to the clock (used for Command)
; Exit : None
; Uses : AF,E

WR1302:	PUSH	HL			; Save Regs
	LD	L,A			; Store byte
	LD	E,8			; set bit count
	CALL	RTCWMOD			; data line to output
WR130L:	CALL	CLLOSCLK
	RRC	L			; Data Byte LSB to Carry
	JR	NC,WR13B0		; is zero ?
	IN	A,(CRTSERVDAT)		; no set to 1
	SET	CLKIO,A
	OUT	(CRTSERVDAT),A
	JR	WR13NX			; next
WR13B0:	IN	A,(CRTSERVDAT)		; yes set to 0
	RES	CLKIO,A
	OUT	(CRTSERVDAT),A
WR13NX:	CALL	CLUPSCLK
	DEC	E			; Eight Bits Sent?
	JR	NZ,WR130L		; ..loop if Not
	;
	CALL	RTCRMOD			; Set Port to Data IN
	POP	HL			;  Restore Regs
	RET

;.....
; Deselect the Clock for Exit
; Uses : AF

CCLOSW:	CALL	RTCRMOD
CCLOSE:	CALL	CLUPSCLK		; HI CLK
	CALL	CLLORST			; LOW RST
	RET
;;
;; RDRR19R12 - zeroes SY6545 higher register (R12 to R19)
;;
RDRR19R12:
	LD	B,$08
ICLP1:	LD	A,B
	ADD	A,$0B
	OUT	(CRT6545ADST),A
	XOR	A
	OUT	(CRT6545DATA),A
	DJNZ	ICLP1
	JP	CRTPRGEND
;;
;; CLRSCRGR - Clear screen (80x24)
;
CLRSCRGR:
	CALL	SCUROF			; was 00F0E7 CD 7E F0
	LD	HL,$0020
	LD	(RAM0BUF),HL
	LD	HL,$FF00
	LD	(RAM2BUF),HL
	CALL	RDRR19R12
	LD	HL,$0000
CSGLP0:	LD	A,(RAM0BUF)
	CALL	DISPCH
	INC	HL
	LD	A,H
	CP	$07
	JR	NZ,CSGLP0
	LD	A,L
	CP	$80
	JR	NZ,CSGLP0
	CALL	RDRR19R12
	JP	SCURON
;;
;; DISPGRCH - Display a char (from A reg.) atrributed from RAM3BUF
;; NOW (20060409) TAKE THE PLACE OF DISPCH AND SO TAKES THAT NAME
;
; DISPGRCH:
DISPCH:
	PUSH	AF			; was 00F113 F5
DGCLP0:	IN	A,(CRT6545ADST)
	BIT	7,A
	JR	Z,DGCLP0
	POP	AF
	OUT	(CRTRAM0DAT),A
	LD	A,(RAM3BUF)
	OUT	(CRTRAM3PORT),A
	XOR	A
	OUT	(CRT6545DATA),A
	RET
;;
;; FILVRAMG - Fill the video ram in graphic mode (from RAMBUF)
;
; FILVRAMG:
; 	LD	HL,$0000		; was 00F126 21 00 00
; 	CALL	RDRR19R12
; FVLP0:	PUSH	HL
; 	CALL	DISPGR
; 	POP	HL
; 	INC	HL
; 	LD	A,H
; 	CP	$07
; 	JR	NZ,FVLP0
; 	LD	A,L
; 	CP	$80
; 	JR	NZ,FVLP0
; 	RET
;;
;; DELAY
;;
;; This routine generate a delay from 1 to 65535 milliseconds.
;;

MSCNT	EQU	246

DELAY:				; was F13D
	PUSH	BC		; 11 c.
	PUSH	AF		; 11 c.
DLY2:
	LD	C, MSCNT	; 7 c.	(assume de = 1 = 1msec.)
DLY1:
	DEC	C		; 4 c. * MSCNT
	JR	NZ, DLY1	; 7/12 c. * MSCNT
	DEC	DE		; 6 c.
	LD	A, D		; 4 c.
	OR	E		; 4 c.
	JR	NZ, DLY2	; 7/12 c.

	POP	AF		; 10 c.
	POP	BC		; 10 c.
	RET			; 10.c

;; MSEC evaluation (ret ignored):
;
; 42 + (de) * (7 + 16 * MSCNT - 5 + 26) - 5
;
; 65 + 16 * MSCNT = ClockSpeed   (ClockSpeed is 1920 for Z80 DarkStar)
; (ClockSpeed - 65) / 16 = MSCNT = 116
; 2006/04/09:
; clock speed has been increased to 4MHz so now:
; (ClockSpeed - 65) / 16 = MSCNT = 116
; is
; (4000 - 65) / 16 = 246 = MSCNT
;

;;
;; UPLOAD wait for remote to upload code/data through
;; parallel link board
;;
;; UPLCHR get a single byte from remote
;;

;;
;; get a byte from remote
;;
;; use:
;;	none
;; return:
;;	D  - received byte
;;	A  - parport status
;; unclean register usage: A, E
UPLCHR:
	IN	A, (PPCNTRP)		; wait for remote ready to tx
	BIT	PPAKSTB, A
	RET	NZ
	BIT	PPSTROB, A
	JR	NZ, UPLCHR

	LD	A, PPURDY		; signal ready to receivce
	OUT	(PPCNTRP), A
UPWSTRB:
	IN	A, (PPCNTRP)		; wait for data
	BIT	PPSTROB, A
	JR	Z, UPWSTRB

	IN	A,(PPDATAP)
	LD	D, A			; copy on d (return value)

	LD	A, PPUOKG		; let's remote run...
	OUT	(PPCNTRP), A
	LD	A, D
	LD	DE, 1			; 1 msec wait
	CALL	DELAY
	LD	D, A
	IN	A, (PPCNTRP)		; in remote answer
	RET
;
;; PRCVBLK - upload a block through parallel link
;;
;; use:
;;	HL - offset of storage area
;;	BC - block size
;; unclean register usage: A, A', IY
;; return:
;; C: Rx status 0 = ok >0 = error
PRCVBLK:
	PUSH	AF
	PUSH	DE
	LD	A, PPUINI		; init parallel port for rx
	OUT	(PPCNTRP), A
	EX	AF, AF'
	XOR	A			; a' is used to calc checksum
	EX	AF, AF'
	CALL	UPLCHR			; get two bytes of block size
	LD	A, D			; and store in APPBUF
	LD	(APPBUF), A
	CALL	UPLCHR
	LD	A, D
	LD	(APPBUF+1), A
	LD	IY, (APPBUF)		; IY count from remote size
PRBLOO:	CALL	UPLCHR			; begin real transfer
	BIT	PPAKSTB, A		; check for stop requests
	JR	NZ, PRNAK		; stopped here: error!
	LD	(HL), D			; store data
	EX	AF, AF'			; update csum
	ADD	A, D
	EX	AF, AF'
	INC	HL
	DEC	IY
	DEC	BC			; check for upload end
	LD	A, B
	OR	C
	JR	NZ, PRBLOO		; next
	LD	(APPBUF), IY		; receive buffer full
	LD	DE, (APPBUF)
	LD	A, D			; received size match?
	OR	E
	JR	NZ, PRNAK		; no
PRWCSM:	CALL	UPLCHR			; flush sender waiting checksum byte
	BIT	PPAKSTB, A		; check for stop requests
	JR	Z, PRWCSM		; WHY WAIT FOR STOP ??
	EX	AF, AF'			; block end: calc. final csum
	CPL
	INC	A
	CP	D			; match ?
	JR	Z, PRBEND		; yes: exit
PRNAK:	LD	A,PPUACK		; send negative aknowledge
	OUT	(PPCNTRP),A
	LD	C, 1			; rx error
PRBEND:	LD	DE, 50			; 50 msec wait
	CALL	DELAY
	LD	A, PPUINI		; clean handshake
	OUT	(PPCNTRP), A
	POP	DE
	POP	AF
	RET

;;
;; upload data through parallel link
;;
;; use:
;;	none
;; unclean register usage: ALL
UPLOAD:
	CALL	OUTCRLF
	LD	HL, STRWAIT
	CALL	CONSTR

	CALL	UPLCHR			; in hi byte of upload offset
	LD	H,D
	CALL	UPLCHR			; in lo byte of upload offset
	LD	L,D
	CALL	UPLCHR			; in hi byte of data size
	LD	B,D
	CALL	UPLCHR			; in lo byte of data size
	LD	C,D
	PUSH	HL
	CALL	OUTCRLF
	LD	HL, STRLOAD
	CALL	CONSTR
	POP	HL

	CALL	PRCVBLK			; upload data block
	CALL	OUTCRLF
	RET
;--------------------
;; Routines to manage data send (download) over parallel port
;;
;; PSNDCH - send a byte over parallel
;;
;; use:
;; HL - point to byte to transfer (updated after exec)
;; unclean register usage: A, DE
PSNDCH:
	IN	A, (PPCNTRP)		; wait synchro strobe from remote
	BIT	PPSTROB, A
	JR	NZ, PSNDCH

	LD	A, (HL)
	OUT	(PPDATAP), A		; out data and then emit ready signal
	INC	HL
	LD	A, PPDRDY
	OUT	(PPCNTRP), A
					;; remote should reset strobe when PPDRDY is get...
PWACKB:
	IN	A, (PPCNTRP)		; wait ack from remote
	BIT	PPAKSTB, A
	JR	Z, PWACKB

	LD	A, PPDOKG		; reset ready bit and let remote run waiting 1 msec.
	OUT	(PPCNTRP), A
					;; remote should reset ack when PPDOKG is get...
	LD	DE, 1
	CALL	DELAY
	RET

;;
;; PSNDBLK - send a block over parallel link
;;
;; use:
;; HL - point to the base of block to transfer
;; BC - block size
;; unclean register usage: A, A', HL'
;; return:
;; C: Tx status 0 = ok >0 = error
;;
PSNDBLK:
	PUSH	AF
	PUSH	DE
	EX	AF, AF'
	XOR	A			; a' will carry the checksum
	EX	AF, AF'
	LD	(APPBUF), BC		; store block size to send it
	LD	A, PPDINI		; setup port for tx
	OUT	(PPCNTRP), A
	EXX				; use alt. bank and send block size
	LD	HL, APPBUF
	CALL	PSNDCH			; send len. lsb
	CALL	PSNDCH			; send len. msb
	EXX				; restore reg. bank
PSNXTC:
	EX	AF, AF'
	ADD	A, (HL)			; block bytes summing
	EX	AF, AF'
	CALL	PSNDCH			; send byte
	DEC	BC			; check for transfer end
	LD	A, B
	OR	C
	JR	NZ, PSNXTC
	EX	AF, AF'			; block end: calc. final csum
	CPL
	INC	A
	LD	HL, APPBUF		; store in first byte of APPBUF
	LD	(HL), A
	EX	AF, AF'
	CALL	PSNDCH			; send csum
	LD	DE, 34			; 34 more msec. to get okgo
	CALL	DELAY
	LD	A, PPDSTP
	OUT	(PPCNTRP), A
	LD	DE, 35			; 35 msec. to stop remote
	CALL	DELAY
	LD	A, PPUINI
	OUT	(PPCNTRP), A		; leave parallel clean
	LD	C, 0			; ret ok (maybe)
	IN	A, (PPCNTRP)		; in result code
	AND	$FC			; mask
	CP	$02			; init and strobe set ?
	JR	NZ, PSBOK
	LD	C, 1			; ret nok on reg. C
PSBOK:
	POP	DE
	POP	AF
	RET

;;
;; PDNLOAD- prompt user for parallel download
;;
PDNLOAD:
	CALL	OUTCRLF
	LD	HL, S_DLPR
	CALL	CONSTR
	LD	B, 2			; get params (offset, size)
	CALL	GETHNUM
	POP	BC
	CALL	OUTCRLF
	LD	HL, STRWAIT
	CALL	CONSTR
	CALL	OUTCRLF
	POP	HL
	CALL	PSNDBLK			; send data
	RET
;----------------------------------------------------------
; PC-LINKED VIRTUAL DISK HANDLE ROUTINES
; ---------------------------------------------------------
;;
;; VDSKRD - read a sector form remote
;;
;; use:
;;	none
;; unclean register usage: A, IY

VDSKRD:
	PUSH	IY
	PUSH	DE
	PUSH	BC
	PUSH	HL
	LD	D, 5			; retries
VDRTRY:	LD	IY, VDSKBUF
	LD	HL, S_VHDR
	LD	B, 4
VDRSL1: LD	C, (HL)
	LD	(IY + 0), C
	INC	IY
	INC	HL
	DJNZ	VDRSL1

	LD	C, VDRDSEC		; read command
	LD	(IY + 0), C
	LD	HL, FDRVBUF
	LD	C, (HL)			; drive
	LD	(IY + 1), C
	LD	BC, (FSECBUF)		; sector
	DEC	BC			; base sector # is zero...
	LD	(IY + 2), C
	LD	(IY + 3), B
	LD	BC, (FTRKBUF)		; track
	LD	(IY + 4), C
	LD	(IY + 5), B

	LD	HL, VDSKBUF		; command offset
	LD	BC, VDBUFSZ		; block size
	CALL	PSNDBLK			; send command block
	LD	A, C
	CP	$00			; what happens ?
	JR	Z, VDROK		; tx ok
	DEC	D			; retry ?
	JR	NZ, VDRTRY
	LD	A, 1			; ret tx err
	JR	VDRNOK
					; receive sector now
VDROK:	LD	HL, (FRDPBUF)		; set dma address
;	LD	BC, VDSECLN		; vdisk sector length
	LD	C,(IX+2)		; vdisk sector length
	LD	B,(IX+3)
	CALL	PRCVBLK			; download sector
	LD	A, C
	CP	$00			; what happens ?
	JR	Z, VDREND		; rx ok
	DEC	D			; retry ?
	JP	NZ, VDRTRY
	LD	A, 1			; ret rx err
	JR	VDRNOK
VDREND:	XOR	A
VDRNOK:	POP 	HL
	POP	BC
	POP	DE
	POP	IY
	RET

;;
;; VDSKWR - read a sector form remote
;;
;; use:
;;	none
;; unclean register usage: A

VDSKWR:
	PUSH	IY
	PUSH	DE
	PUSH	BC
	PUSH	HL
	LD	D, 5			; retries
VDWTRY:	LD	IY, VDSKBUF
	LD	HL, S_VHDR
	LD	B, 4
VDWSL1: LD	C, (HL)
	LD	(IY + 0), C
	INC	IY
	INC	HL
	DJNZ	VDWSL1

	LD	C, VDWRSEC		; read command
	LD	(IY + 0), C
	LD	HL, FDRVBUF
	LD	C, (HL)			; drive
	LD	(IY + 1), C
	LD	BC, (FSECBUF)		; sector
	DEC	BC			; base sector # is zero...
	LD	(IY + 2), C
	LD	(IY + 3), B
	LD	BC, (FTRKBUF)		; track
	LD	(IY + 4), C
	LD	(IY + 5), B

	LD	HL, VDSKBUF		; command offset
	LD	BC, VDBUFSZ		; block size
	CALL	PSNDBLK			; send command block
	LD	A, C
	CP	$00			; what happens ?
	JR	Z, VDWOK		; tx ok
	DEC	D			; retry ?
	JR	NZ, VDWTRY
	LD	A, 1			; ret tx err
	JR	VDWNOK
					; receive sector now
VDWOK:	LD	HL, (FRDPBUF)		; set dma address
;	LD	BC, VDSECLN		; vdisk sector length
	LD	C,(IX+2)		; vdisk sector length
	LD	B,(IX+3)
	CALL	PSNDBLK			; upload sector
	LD	A, C
	CP	$00			; what happens ?
	JR	Z, VDWEND		; tx ok
	DEC	D			; retry ?
	JR	NZ, VDWTRY
	LD	A, 1			; ret tx err
	JR	VDWNOK
VDWEND:	LD	A, 0
VDWNOK:	POP 	HL
	POP	BC
	POP	DE
	POP	IY
	RET

S_DLPR	DEFB	'D', 'L'+$80
S_VHDR:	DEFB	"@IO@"
STRWAIT:
	DEFB	'Wait..', '.'+$80
STRLOAD:
	DEFB	'Loa', 'd'+$80
;;
;; VCPMBT
;;
;; Boot CP/M from parallel link
;
BLDOFFS		EQU	$2000		; place for disk bootloader
;
VCPMBT:
	LD	BC, BLDOFFS          	; base transfer address
	CALL	BSETDMA
	LD	A,(CDISK)		; get logged drive
	LD	C, A			; make active
	CALL	BSELDSK
	LD	BC, 0			; START TRACK
	CALL	BSETTRK
	LD	BC, 1			; start sector
	CALL	BSETSEC
	LD	IX,SSIZ1 - 2
	CALL	VDSKRD			; perform i/o 128
	CP	$00
	JP	Z,BLDOFFS
	LD	IX,SSIZ2 - 2
	CALL	VDSKRD			; perform i/o 256
	CP	$00
	JP	Z,BLDOFFS
	LD	IX,SSIZ5 - 2
	CALL	VDSKRD			; perform i/o 512
	CP	$00
	JP	Z,BLDOFFS
	JP	UCREJ
; sector lenghts for vboot
SSIZ5:	DEFW	512
SSIZ2:	DEFW	256
SSIZ1:	DEFW	128
	; This used to translate the drive number in a cmd byte suitable
	; for drive selection on the floppy board
HDRVV:	DEFB	$01			; drive 1
	DEFB	$02			; drive 2
	DEFB	$04			; drive 3
	DEFB	$08 			; drive 4

;;
;; DRVSEL - select drive for r/w ops
;
DRVSEL:
	PUSH	AF			;
	PUSH	HL			;
	LD	HL,HDRVV		; 10
	LD	A,(FDRVBUF)		; 13
	ADD	A,L			; 4
	LD	L,A			; 4
	LD	A,(HL)			; 7
	LD	H,A			;
	LD	A, (DSELBF)
	AND	$F0
	OR	H
	LD	(DSELBF),A		; 13
	OUT	(FDCDRVRCNT),A		; 11
	POP	HL			;
	POP	AF			;
	RET				;
;;
;; SETSID - set current side bit on DSELBF
;;          selected side on C
;;
SETSID:	LD	HL,DSELBF		; loads drive interf. buffer
	LD	A,C			; which side ?
	CP	0			;
	JR	NZ,SIDONE		; side 1
	RES	5,(HL)			; side 0
	RET				;
SIDONE:	SET	5,(HL)			;
	RET

;;
;; CPMBOOT - boostrap cp/m
;
CPMBOOT:
	LD	SP,$0080		; was 00F461 31 80 00
	LD	BC,$00
	CALL	BSETTRK
	LD	A,(CDISK)		; get logged drive
	LD	C,A
	CALL	BSELDSK
	CALL	DRVSEL
	CALL	BHOME
	JP	NZ,UCREJ
	LD	BC,BLDOFFS		; read in loader at $2000
	CALL	BSETDMA
	LD	BC,$01
	CALL	BSETSEC
	CALL	BREAD
	JP	NZ,UCREJ
	JP	BLDOFFS			; jump to the loader if all ok
BSETTRK:
;	ld     a,c             ; was 00F489 79
	LD	(FTRKBUF),BC
	RET
BSETSEC:
; 	ld     a,c             ; was 00F48E 79
	LD	(FSECBUF),BC
	RET
BSETDMA:
	LD	(FRDPBUF),BC		; was 00F493 ED 43 45 00
	RET
BSELDSK:
	LD	A,C			; was 00F498 79
	LD	(FDRVBUF),A
	RET
;;
;; SFDCCMD - send 1771 a command
;
SFDCCMD:
	PUSH	AF			; was 00F49D F5
SNDCL:
	IN	A,(FDCCMDSTATR)
	BIT	0,A			; check busy
	JR	NZ,SNDCL
	POP	AF
	OUT	(FDCCMDSTATR),A
	EX	(SP),HL
	EX	(SP),HL
	EX	(SP),HL
	EX	(SP),HL
	RET
;;
;; GFDCSTAT - get 1771 status and copy on buffer
;
GFDCSTAT:
	IN	A,(FDCCMDSTATR)		; was 00F4AF DB D0
	BIT	0,A
	JR	NZ,GFDCSTAT
	RET
;
GCURTRK:
	LD	HL,FSEKBUF		; was 00F4B9 21 4A 00
	LD	A,(FDRVBUF)
	ADD	A,L
	LD	L,A
	RET
;;
;; BHOME - move head to trak 0 (cp/m home like)
;;
BHOME:
	PUSH	BC			; was 00F4C2 C5
	LD	B,$03			; number of retries
FRETR0:	LD	A,FDCRESTC		; move to trak 0 cmd
	CALL	SFDCCMD
	CALL	GFDCSTAT
	AND	$18			; check for errors
	JR	Z,FOK0			; ok!
	DJNZ	FRETR0			; nok: retry
	LD	A,$82
	JR	FTERR			; error handle
FOK0:	CALL	GCURTRK			; proceed
	JR	FGTRK
;;
;; FSEEK - seek to specific track/sector
;
FSEEK:
	PUSH	BC              ; was 00F4DC C5
	LD	B,$03
	CALL	GCURTRK
	LD	A,(HL)
	OUT	(FDCTRAKREG),A
FRETR1:	LD	A,(FSECBUF)
	OUT	(FDCSECTREG),A
	LD	A,(FTRKBUF)
	OUT	(FDCDATAREG),A
	LD	A,FDCSEEKC           ; seek cmd
	CALL	SFDCCMD
	CALL	GFDCSTAT
	AND	$18
	JR	Z,FGTRK
	CALL	BHOME
	JR	NZ,FTERR
	DJNZ	FRETR1
	LD	A,$83
	JR	FTERR
FGTRK:	IN	A,(FDCTRAKREG)
	LD	(HL),A
FTERR:	POP	BC
	BIT	7,A             ; test if drive not ready
	RET
;;
;; BREAD - read a sector
;
BREAD:
	LD	A,(MIOBYTE)       ; was 00F50D 3A 47 00
	SET	0,A
	JR	BWAITIO
;;
;; BWRITE - write a sector
;
BWRITE:
	LD	A,(MIOBYTE)       ; was 00F514 3A 47 00
	RES	0,A
;;
;; BWAITIO - read or write a sector depending on MIOBYTE
;
BWAITIO:
	PUSH	DE
	LD	(MIOBYTE),A       ; was 00F519 32 47 00
FRWLP:	CALL	FSEEK
	JR	NZ,FSHTM
	LD	B,$0A           ; 10 retries
FRWNXT:	LD	HL,(FRDPBUF)
	LD	E,(IX+2)		; need to know buffer size on write
	LD	D,(IX+3)
	LD	A,(MIOBYTE)
	BIT	0,A
	JR	Z,FRWWRO
	LD	A,FDCREADC           ; read command
	CALL	SFDCCMD
	JR	FRRDY
FRBSY:	RRCA
	JR	NC,FWEND
FRRDY:	IN	A,(FDCCMDSTATR)
	BIT	1,A             ; sec found
	JR	Z,FRBSY
	IN	A,(FDCDATAREG)
	LD	(HL),A
	INC	HL
	JR	FRRDY
FRWWRO:	LD	A,FDCWRITC
	CALL	SFDCCMD
	JR	FWRDY
FRWBSY:	RRCA
	JR	NC,FWEND
FWRDY:	IN	A,(FDCCMDSTATR)
	BIT	1,A
	JR	Z,FRWBSY
	LD	A,(HL)
	OUT	(FDCDATAREG),A
	INC	HL
	DEC	DE		; 6 c.
	LD	A,D		; 4 c.
	OR	E		; 4 c.
	JR	NZ,FWRDY	; 7/12 c.
FWEND:	CALL	GFDCSTAT
	AND	$5C             ; test for errors
	JR	Z,FSHTM
	DJNZ	FRWNXT
	LD	A,(TMPBYTE)
	BIT	6,A
	JR	NZ,FSHTM
	SET	6,A
	LD	(TMPBYTE),A
	CALL	BHOME
	JR	NZ,FSHTM
	JR	FRWLP
FSHTM:
	PUSH	AF
	XOR	A
	OUT	(FDCDRVRCNT),A
	POP	AF
	POP	DE
	RET
;;
;; FLOPPYREAD - read from given drv,track,sector,ram address
;
FLOPPYREAD:
	LD	A,(MIOBYTE)       ; was 00F574 3A 47 00
	SET	0,A
	JR	FLOPIO
;;
;; FLOPPYWRIT - write to give ram address, sector, track, drive
;
FLOPPYWRIT:
	LD	A,(MIOBYTE)       ; was 00F57B 3A 47 00
	RES	0,A
FLOPIO:	LD	(MIOBYTE),A
	LD	B,$04
	CALL	GETHNUM
	POP	BC
	CALL	BSETDMA
	POP	BC
	CALL	BSETSEC
	POP	BC
	CALL	BSETTRK
	POP	BC
	CALL	BSELDSK
	CALL	DRVSEL
	CALL	FRWLP
	JP	USRCMD
;; Image to initalize location 0010H
CRTTAB1:
	DB	$6F,$50,$57,$28,$1A,0,$19,$19,$48,$0B
	DB	0,$0B,0,0,0,0,0,0,0,0
;;
; INIT0 - init buffers,6545,test vram,clear,leave cursor at home
;
INIT0:
	CALL	INICRT           ; was 00F5C8 CD A5 F0
	CALL	INICRTREG
	CALL	DLIGHT
	CALL	DBLANK
	LD	A,$FF
	LD	(RAM3BUF),A
	LD	HL,$0000
	LD	(CURPBUF),HL
	JP	INICRTCUR
;;
STR100:                        ; was 00F5E2
	DB	"Z80 DarkStar - Monitor - REL ",MONMAJ,'.',MONMIN

;;
CRLFTAB:
	DB	$0D,$8A,$00	;,$01

;;
;; INICRTREG
;;
INICRTREG:
	CALL	GDCUA           ; was 00F606 CD B0 F7
	PUSH	HL
	CALL	INI6545
	LD	HL,(CURPBUF)
	CALL	SDSTA
	POP	HL
	DEC	HL
	JP	SDCUAE

;;
;; INI6545 - initialize sy6545
;;
INI6545:
	LD	HL,CRTTAB1	; now read from eprom
	LD	B,$00
	LD	A,B
ICTLP0:	OUT    (CRT6545ADST),A
	LD	A,(HL)
	OUT	(CRT6545DATA),A
	INC	HL
	INC	B
	LD	A,B
	CP	$14
	JR	NZ,ICTLP0
	RET
;;
;; FMEMSIZ - cerca l'ultima pagina di memoria disponibile
;
FMEMSIZ:
	PUSH	BC			; was 00F67C C5 !!! NOT EXECUTED IF HERE FROM BOOT
	LD	BC,$FF00
	LD	HL,$FFFF
FMEMNP:
	INC	H
	LD	A,(HL)
	CPL
	LD	(HL),A
	CP	(HL)
	CPL
	LD	(HL),A
	JR	NZ,FMESTP
	LD	A,H
	CP	B
	JR	NZ,FMEMNP
FMESTP:
	DEC	H
	POP	BC
	RET

;;
;; BOOT - Bring up system
;;
BOOT:	DI				; disable interrupts
	; Reset bios position after reset
	IN	A,(FDCDRVRCNT)  ; was 00F630 DB D6
	LD	SP,$0080
	LD	HL,$0000
	LD	(CURPBUF),HL
	LD	A,00000000B		; disable interrupts globally
	LD	(TMPBYTE),A
	XOR	A
	LD	(CDISK),A
	LD	(COLBUF),A
	LD	(MIOBYTE),A
	LD	(DSELBF),A
	OUT	(FDCDRVRCNT),A		; resets floppy selection
	CPL
	LD	(RAM3BUF),A
	CALL	INIT0
	LD	HL,$FFFF
	LD	(FSEKBUF),HL
	XOR	A
	OUT	(CRTPRNTDAT),A
	OUT	(ALTPRNPRT),A
	CPL
	OUT	(CRTPRNTDAT),A
	OUT	(ALTPRNPRT),A
	LD	A, PPUINI		; init parallel port for rx
	OUT	(PPCNTRP), A
	LD	A,$C3
	LD	($0066),A
	LD	HL,JBOOT
	LD	($0067),HL
	LD	A,$C9
	LD	($0038),A
	CALL	FMEMSIZ			; check for available ram
	LD	SP,HL
 	LD	(BTPASIZ),HL
	;; print bios greetings
	LD	HL,STR100		; was 00F6CB 21 E2 F5
	CALL	GREET
;;
;; New code for direct access to bootloaders
;;
BOOTM:
	LD	HL,(BTPASIZ)		; The same as USRCMD
	LD	SP,HL
	LD	HL,USRCMD
	PUSH	HL
	LD	($0001),HL
	LD	A,$C3
	LD	($0000),A
	;
BMPRO:	LD	HL,MBMENU		; display the menu
	CALL	CONSTR
	CALL	DOGETCHR		; get user choice
	CP	CR			; go to monitor ?
	JP	Z,USRCMD		; yes
	CP	'A'			; is  a valid drive ?
	JP	M,BMPRO			; no < A
	CP	'Q'
	JP	P,BMPRO			; no > P
	SUB	'A'			; makes a number
	LD	(FDRVBUF),A		; is valid: store in monitor buffer
	LD	(CDISK),A		; and in CP/M buf
	CP	'C'-'A'			; is floppy ?
	JP	M,CPMBOOT		; yes
	CP	'O'-'A'			; is hard disk ?
	JP	M,HDBOOT		; yes
	JP	VCPMBT			; then is a virtual drive

	; Boot messages
MBMENU:	DEFB	CR,LF
	DEFB	"BOOT from:",CR,LF,LF
	DEFB	"A-B = Floppy",CR,LF
	DEFB	"C-N = HD",CR,LF
	DEFB	"O-P = Virtual",CR,LF
	DEFB	"RET = Monitor",CR,LF,LF
	DEFB	'>'+$80
;;
GET1HNUM:
	LD	B,$01			; was 00F6D3 06 01
	LD	HL,$0000
	JR	GENTR
HEHEX:	JR	NZ,UCREJ
POP1PRM:
	DEC	B
	RET	Z
;;
;; GETHNUM - get an hexadecimal string
;
GETHNUM:
	LD	HL,$0000		; was 00F6DE 21 00 00
GNXTC:	CALL	DOGETCHR
GENTR:	LD	C,A
	CALL	CHKHEX
	JR	C,HNHEX			; if not hex digit
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	OR	L
	LD	L,A
	JR	GNXTC
HNHEX:	EX	(SP),HL
	PUSH	HL
	LD	A,C
	CALL	CHKCTR
	JR	NC,HEHEX
	DJNZ	UCREJ
	RET
;;
;; USRCMD - display prompt and process user commands
;;
UCREJ:
	LD	HL,URESTR        ; was 00F6FD 21 0F FA
	CALL	CONSTR
USRCMD:
	LD	HL,(BTPASIZ)      ; was 00F703 2A 06 00
	LD	SP,HL
	LD	HL,USRCMD
	PUSH	HL
	LD	($0001),HL
	LD	A,$C3
	LD	($0000),A
	CALL	OUTCRLF
	CALL	DOPROMPT
	SUB	$41             ; convert to number
	JR	C,UCREJ         ; minor 0
	CP	$1A
	JR	NC,UCREJ        ; greater than jump table
	ADD	A,A
	LD	E,A
	LD	D,$00
	LD	B,$02
	LD	HL,UCMDTAB
	ADD	HL,DE
	LD	A,(HL)
	INC	HL
	LD	H,(HL)
	LD	L,A
	JP	(HL)
;;
;; FILLMEM - fill memory with a given values
;
FILLMEM:
	CALL	POP3NUM           ; was 00F730 CD 33 F9
FLME1:	LD	(HL),C
	CALL	CHKEOR
	JR	NC,FLME1
	POP	DE
	JR	USRCMD
;;
;; MEMCOMP - compare two ram regions
MEMCOMP:
	CALL	POP3NUM           ; was 00F73C CD 33 F9
MCONX:	LD	A,(BC)
	PUSH	BC
	LD	B,(HL)
	CP	B
	JR	Z,MCO1
	PUSH	AF
	CALL	HL2ASCB
	LD	A,B
	CALL	H2AJ3
	POP	AF
	CALL	H2AJ1
MCO1:	POP	BC
	CALL	IPTRCKBD
	JR	MCONX
;;
;; MEMDUMP - prompt user and dump memory area
;
MEMDUMP:
	CALL	POP2PRM           ; was 00F757 CD AB FA
MDP6:	CALL	HL2ASCB
	LD	A,L
	CALL	DMPALIB
	PUSH	HL
MDP2:	LD	A,(HL)
	CALL	H2AJ1
	CALL	CHKEOR
	JR	C,MDP1
	CALL	SPACER
	LD	A,L
	AND	$0F
	JR	NZ,MDP2
MDP7:	POP	HL
	LD	A,L
	AND	$0F
	CALL	DMPALIA
MDP5:	LD	A,(HL)
	NOP
	NOP
	LD	C,A
	CP	$20
	JR	C,MDP3
	NOP
	NOP
	JR	MDP4
MDP3:	LD	C,$2E
MDP4:	CALL	OUTCHR
	CALL	CHKBRK
	LD	A,L
	AND	$0F
	JR	NZ,MDP5
	JR	MDP6
MDP1:	SUB	E
	CALL	DMPALIB
	JR	MDP7
;;
;; DMPALIB - beginning align (spacing) for a memdump
DMPALIB:
	AND	$0F             ; was 00F79B E6 0F
	LD	B,A
	ADD	A,A
	ADD	A,B
;;
;; DMPALIB - ascii align (spacing) for a memdump
DMPALIA:
	LD	B,A             ; was 00F7A0 47
	INC	B
ALIBN:	CALL	SPACER
	DJNZ	ALIBN
	RET
;;
;; GOEXEC - execute from user address
;
GOEXEC:
	CALL	POP1PRM           ; was 00F7A8 CD DC F6
	POP	HL
	JP	(HL)
;;
;; GET DISPLAY CURSOR POSITION and return in HL
;
GDCUA:
	LD	A,$0E           ; was 00F7B0 3E 0E
	OUT	(CRT6545ADST),A
	IN	A,(CRT6545DATA)
	LD	H,A
	LD	A,$0F
	OUT	(CRT6545ADST),A
	IN	A,(CRT6545DATA)
	LD	L,A
	INC	HL
	LD	A,$1F
	OUT	(CRT6545ADST),A
	RET
;;
;; PORTIN - input a byte from given port (display it in binary)
;
PORTIN:
	CALL	POP1PRM           ; was 00F7F8 CD DC F6
	POP	BC
	IN	E,(C)
	CALL	BINDISP
	JP	USRCMD
;;
;; PORTOUT - output a byte to a give port
PORTOUT:
	CALL	GETHNUM           ; was 00F800 CD DE F6
	POP	DE
	POP	BC
	OUT	(C),E
 	JP	USRCMD
;;
;; MEMMOVE - move data in memory
;
MEMMOVE:
	CALL	POP3NUM           ; was 00F808 CD 33 F9
MMNXT:	LD	A,(HL)
	LD	(BC),A
	CALL	IPTRCKBD
	JR	MMNXT
;;
;; RWMEM - lets user alter memory content
;
RWMEM:
	CALL	POP1PRM         ; was 00F812 CD DC F6
	POP	HL
RWM3:	LD	A,(HL)
	CALL	H2AJ3
	CALL	VALGETCHR
	RET	C
	JR	Z,RWM1
	CP	$0A
	JR	Z,RWM2
	PUSH	HL
	CALL	GET1HNUM
	POP	DE
	POP	HL
	LD	(HL),E
	LD	A,C
	CP	$0D
	RET	Z
RWM1:	INC	HL
	INC	HL
RWM2:	DEC	HL
	LD	A,L
	AND	$07
	CALL	Z,HL2ASCB
	JR	RWM3
;;
;; MEMTEST - test ram region
MEMTEST:
	CALL	POP2PRM           ; was 00F83A CD AB FA
MTNXT:	LD	A,(HL)
	PUSH	AF
	CPL
	LD	(HL),A
	XOR	(HL)
	CALL	NZ,MTERR
	POP	AF
	LD	(HL),A
	CALL	CHKBRK
	JR	MTNXT
MTERR:	PUSH	DE
	LD	E,A
	CALL	HL2ASCB
;;
;; BINDISP - display E in binary form
;
BINDISP:
	LD	B,$08           ; was 00F851 06 08
BDNXT:	LD	A,E
	RLCA
	LD	E,A
	LD	A,$18
	RLA
	LD	C,A
	CALL	OUTCHR
	DJNZ	BDNXT
	POP	DE
	RET
;;
;; BCONIN - main keyboard input handle
;
CIRBF:	XOR	A			; was 00F861 3E 00
	LD	(KBDBYTE),A		; clear buffer
BCONIN:
	IN	A,(CRTKEYBDAT)		; in from PIO
	CPL
	BIT	7,A			; pressed ?
	JR	Z,CIRBF			; no: wait for user action
	PUSH	HL			; yes
	LD	HL,KBDBYTE
	CP	(HL)			; test input with buffer
	JR	Z,CIEQB			; EQUALS: enter autorepeat mode
	LD	HL,$A0FF		; auto repeat start time
	JR	CIPRC			; jump to press cycle
CIEQB:	LD	HL,$0400		; button autorepeat delay (in AR mode)
CIPRC:	PUSH	AF
CISTI:	IN	A,(CRTKEYBDAT)		; press cycle: check for keyb release
	CPL
	BIT	7,A			; is still pressed?
	JR	Z,CIGON			; no, go on
	DEC	HL			; dec AR start time
	LD	A,L
	OR	H			; timeout reached ?
	JR	NZ,CISTI		; no timeout: check again
CIGON:	POP	AF			; now process input
	LD	(KBDBYTE),A
	RES	7,A			; make ASCII
	LD	HL,MIOBYTE
	BIT	1,(HL)			; perform special processing ??
;	ld     hl,MIOBYTE
	JR	NZ,CIBT1		; yes
CILOP:	BIT	3,(HL)			; no: transform to uppercase ?
	POP	HL
	RET	Z			; no
	CP	'a'			; yes: is less then 'a' ?
	RET	M			; yes: return, already ok
	CP	'{'			; no: then is greater than 'z' ?
	RET	P			; yes: ok!
	RES	5,A			; no: convert uppercase...
	RET
CIBT1:	LD	HL,CIREN		; command chars processing...
	PUSH	HL
	LD	HL,MIOBYTE
	CP	'^'			; test == '^': enable software caps-lock ?
	JR	NZ,CITC1		; no
	SET	3,(HL)			; yes: enable software caps-lock
	RET				;
CITC1:	CP	$5C			; test == '\': disable soft. caps-lock ?
	JR	NZ,CITC2		; no
	RES	3,(HL)			; yes: disable software caps-lock
	RET
CITC2:	CP	$07			; test == CTRL+G ??
	JP	Z,CIGRTOG		; yes: switch to graphic mode
	CP	$05			; test ==CTRL+E ??
	JP	Z,LINDN			; yes: move cursor down one line
	CP	$13			; test == CTRL+S ??
	JP	Z,CIHCR			; yes: move cursor left one char
	CP	$04			; test == CTRL+D ??
	JP	Z,CURRGT		; yes: move cursor right one char
	CP	$18			; test == CTRL+X ??
	JP	Z,IOCSY2		; yes: move cursor up one line
	POP	HL
	LD	HL,MIOBYTE
	JP	GETLPEN			; go to check light pen status
CIREN:	POP	HL
	JP	BCONIN
CIHCR:	LD	HL,MIOBYTE		; manage backspace
	LD	A,(HL)
	PUSH	AF
	PUSH	HL
	SET	4,(HL)			; set destructive back-space
	CALL	IOCBS			; do backspace
	POP	HL
	POP	AF
	LD	(HL),A
	RET
;
;; GETLPEN - manage light-pen operations
GETLPEN:
	PUSH	AF
	PUSH	DE
	IN	A,(CRT6545ADST)
	BIT	6,A			; got LPEN strobe ?
	RET	Z			; no
	LD	A,$10			; yes...
	OUT	(CRT6545ADST),A		; get LPEN position
	IN	A,(CRT6545DATA)
	LD	H,A
	LD	A,$11
	OUT	(CRT6545ADST),A
	IN	A,(CRT6545DATA)
	LD	L,A			; ...in HL
	CALL	SDCUAE			; move cursor to LPEN pos
	EX	DE,HL
	LD	HL,(CURPBUF)
	EX	DE,HL
	XOR	A
	SBC	HL,DE
	LD	DE,$0050
CIJP4:	XOR	A
	SBC	HL,DE
	JR	NC,CIJP4
	ADD	HL,DE
	LD	A,L
	LD	(COLBUF),A		;
	POP	DE
	POP	AF
	JP	CILOP			; re-enter normal char processing
;;
;; CIGRTOG - toggle graphic mode on
;
CIGRTOG:
	IN	A,(CRT6545ADST)		; was 00FF40 DB 8C
	BIT	7,A
	JR	Z,CIGRTOG
	IN	A,(CRTRAM3PORT)
	SET	4,A
	LD	(RAM3BUF),A
	IN	A,(CRTRAM0DAT)
	POP	HL
	POP	HL
	RET
;;
;; SET DISPLAY START ADDRESS
;
SDSTA:
	LD	A,$0C			; was 00F90E 3E 0C
	OUT	(CRT6545ADST),A
	LD	A,H
	OUT	(CRT6545DATA),A
	LD	A,$0D
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	LD	A,$1F
	OUT	(CRT6545ADST),A
	RET
;;
;;
;; DOPROMPT - display prompt and wait for first key (uppercase)
;
DOPROMPT:
	CALL	MPROMPT			; was 00F925 CD 5F FA
;; get a char in uppercase, and display too...
DOGETCHR:
	CALL	COIUPC			; was 00F928 CD 89 FA
COUTCH:	PUSH	BC
	LD	C,A
	CALL	OUTCHR
	LD	A,C
	POP	BC
	RET
;
POP3NUM:
	INC	B			; was 00F933 04
	CALL	GETHNUM
	POP	BC
	POP	DE
	JP	OCRLF1
;;
;; inc HL and do a 16 bit compare between HL and DE
CHKEOR:
	INC	HL			; was 00F93C 23
	LD	A,H
	OR	L
	SCF
	RET	Z
	LD	A,E
	SUB	L
	LD	A,D
	SBC	A,H
	RET
;;
CBKEND:	POP	DE
	RET
;;
;; inc pointer BC and check kbd
IPTRCKBD:
	INC	BC
;;
CHKBRK:
	CALL	CHKEOR			; was 00F949 CD 3C F9
	JR	C,CBKEND
	CALL	BCONST
	OR	A
	RET	Z
	CALL	COIUPC
	CP	$13
	JR	NZ,CBKEND
	JP	COIUPC
;;
;; CHKHEX - check for hex ascii char in A
;
CHKHEX:
	SUB	$30			; was 00F95D D6 30
	RET	C
	CP	$17
	CCF
	RET	C
	CP	$0A
	CCF
	RET	NC
	SUB	$07
	CP	$0A
	RET
;; get chr and validate
VALGETCHR:
	CALL	DOGETCHR		; was 00F96D CD 28 F9
;;
;; CHKCTR: check for valid char in string (space,comma,<CR>)
;
CHKCTR:
	CP	$20			; was 00F970 FE 20
	RET	Z
	CP	$2C
	RET	Z
	CP	$0D
	SCF
	RET	Z
	CCF
	RET
;
;; User command reject string
URESTR:
	DB	$AA			; was 00FA0F AA
;
;; TOGPRNIO - toggle i/o on prn/crt
TOGPRNIO:
	LD	HL,MIOBYTE		; was 00FA10 21 47 00
	BIT	5,(HL)
	JR	Z,TOGPR
	RES	5,(HL)
	JR	TOGJU
TOGPR:	SET	5,(HL)
TOGJU:	JP	USRCMD
;;
;; SCRTST - Verify if we need video scroll
;
SCRTST:
	LD	DE,(CURPBUF)		; was 00FA20 ED 5B 48 00
	XOR	A
	SBC	HL,DE
	LD	A,H
	CP	$07
	RET	C
	LD	A,L
	CP	$CF
	RET
;;
;; CALCHLDE - perform 16 bit add & sub between HL and DE
;
CALCHLDE:
	CALL	POP2PRM           ; was 00FA38 CD AB FA
	PUSH	HL
	ADD	HL,DE
	CALL	HL2ASCB
	POP	HL
	OR	A
	SBC	HL,DE
	JR	H2AEN1
;;
;; HL2ASC - convert & display HL 2 ascii
HL2ASC:
	CALL	OUTCRLF           ; was 00FA46 CD B0 FA
H2AEN1:	LD	A,H
	CALL	H2AJ1
	LD	A,L
H2AJ1:	PUSH	AF
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	H2AJ2
	POP	AF
H2AJ2:	CALL	NIB2ASC
	JR	OUTCHR
H2AJ3:	CALL	H2AJ1           ; entry point to display HEX and a "-"
MPROMPT:
	LD	C,$2D
	JR	OUTCHR
;;
;; HL2ASCB - convert & display HL 2 ascii leave a blank after
HL2ASCB:
	CALL	HL2ASC           ; was 00FA63 CD 46 FA
SPACER:	LD	C,$20
;;
;; OUTCHR - send a char to the output
;; switch CRT/PRINTER depending of bit 5 of MIOBYTE
;
OUTCHR:
	LD	A,(MIOBYTE)		; was 00FA68 3A 47 00
	BIT	5,A			; printer or video ?
	JR	Z,OCJPV
	CALL	JPRNCH
OCJPV:
	JP	JCONOU
;;
;; PRNCHR - send a char to printer port (from C)
;
PRNCHR:
	IN	A,(CRTSERVDAT)         ; was 00FA75 DB 89
	BIT	PRNTBUSYBIT,A
	JR	NZ,PRNCHR
	LD	A,C
	OUT	(CRTPRNTDAT),A
	RET
;;
;;
;; COIUPC- convert reg A uppercase
COIUPC:
	CALL	JCONIN           ; was 00FA89 CD 03 F0
	CP	$60
	JP	M,COIRE
	CP	$7B
	JP	P,COIRE
	RES	5,A
COIRE:	RET
;;
;;
;; GREET - ...comes here from boot...
;
GREET:
	CALL	OUTCRLF           ; was 00FA99 CD B0 FA
;;
;; CONSTR print a string using OUTCHR -> BCONOUT
CONSTR:
	PUSH	BC              ; was 00FA9C C5
CSLP0:	LD	C,(HL)
	LD	B,(HL)
	RES	7,C
	CALL	OUTCHR
	INC	HL
	LD	A,B
	RLCA
	JR	NC,CSLP0
	POP	BC
	RET
;;
POP2PRM:
	CALL	GETHNUM			; was 00FAAB CD DE F6
	POP	DE
	POP	HL
;;
;; OUTCRLF - CR/LF through BCONOUT
;
OUTCRLF:
	PUSH	HL			; was 00FAB0 E5
OCRLF1:	LD	HL,CRLFTAB
	CALL	CONSTR
	POP	HL
	RET
;;
BCONST:
	IN	A,(CRTKEYBDAT)		; was 00FAB9 DB 85
	CPL
	BIT	7,A
	JR	NZ,BCONSP
	XOR	A
	LD	(KBDBYTE),A		; clear AR buffer...
; 	JR	BCONSTJ
; BCONSTJ:
	RET				; was 00FB07 C8
BCONSP:	LD	A,$FF
	RET

UCMDTAB:
	DW	UCREJ           ; (A) n/a
	DW	JCPMBT          ; (B) cp/m boot
	DW	UCREJ           ; (C) n/a
	DW	MEMDUMP         ; (D) dump memory
	DW	UCREJ           ; (E) n/a
	DW	FILLMEM         ; (F) fill memory
	DW	GOEXEC          ; (G) go exec a sub
	DW	CALCHLDE        ; (H) sum & subtract HL, DE
	DW	PORTIN          ; (I) port input
	DW	INIT0           ; (J) init, clear screen
	DW	JBOOT           ; (K) restart system
	DW	FLOPPYREAD      ; (L) read floppy,track,sec to ram
	DW	MEMMOVE         ; (M) move memory block
;	dw     NEDOSINI        ; (N) NEDOS boot page
	DW	UCREJ           ; (N) n/a
	DW	PORTOUT         ; (O) output to a port
	DW	TOGPRNIO        ; (P) toggle prn/crt i/o
	DW	UCREJ           ; (Q) n/a
	DW	FLOPPYWRIT      ; (R) write floppy,track,sec to ram
	DW	RWMEM           ; (S) alter memory
	DW	MEMTEST         ; (T) test ram region
;	dw     UCREJ           ; (U) n/a
	DW	UPLOAD          ; (U) Parallel Upload
	DW	MEMCOMP         ; (V) compare mem blocks
	DW	PDNLOAD         ; (W) Parallel DoWnload
	DW	VCPMBT          ; (X) n/a
	DW	INICRTREG       ; (Y) reinit 6545
;	DW	BLOOP           ; (Z) bloop - crazy routine
	DW	UCREJ           ; (Z) n/a
;;
;;
;; BCONOUT print out the char in reg C
;
BCONOUT:
	PUSH	AF			; was 00FB10 F5
	PUSH	BC
	PUSH	DE
	PUSH	HL
	; force jump to register restore and exit in stack
	LD	HL,VCRESREG
	PUSH	HL
	LD	A,C
	LD	HL,MIOBYTE
	BIT	7,(HL)			; alternate char processing ?
	EX	DE,HL
	JP	NZ,CONOU2		; yes: do alternate
	CP	$20			; no: is less then 0x20 (space) ?
	JR	NC,COJP1		; no: go further
	LD	HL,IOCVEC		; yes: is a special char
	ADD	A,L
	LD	L,A
	LD	C,(HL)
	LD	B,$00
	OR	A
	LD	HL,IOCBASE
	ADD	HL,BC
	JP	(HL)			; jump to IOCVEC handler
COJP1:	EX	DE,HL
	BIT	6,(HL)			; auto ctrl chars ??
	JR	Z,COJP2			; no
	CP	$40			; yes: convert
	JR	C,COJP2
	CP	$60
	JR	NC,COJP2
	SUB	$40
COJP2:	CALL	DISPCH			; display char
	; move cursor right
CURRGT:
	CALL	GDCUA			; update cursor position
	CALL	SDCUAE
	LD	A,(COLBUF)
	INC	A
	CP	$50
	JR	Z,MOVDN			; go down if needed
;;
SAVCOLB:
	LD	(COLBUF),A		; save cursor position
	RET
CONOU2:					; alternate processing....
	CP	$20			; is a ctrl char ??
	JR	NC,CURADR		; no: will set cursor pos
	LD	HL,IOCVEC2		; yes
	ADD	A,L
	LD	L,A
	LD	C,(HL)
	LD	B,$00
	OR	A
	LD	HL,IOCBAS2
	ADD	HL,BC
	NOP
	JP	(HL)			; jump to service routine... (IOCVEC2)
;; cursor addressing service routine
;; address is ESC + (COL # + 32) + (ROW # + 32) (then need a NUL to terminate...)
;CURADR:	EX	DE,HL
CURADR:	LD	HL,TMPBYTE
	BIT	0,(HL)
	JR	NZ,SETROW
	CP	$70			; greater then 80 ?
	RET	NC			; yes: error
	SUB	$20			; no: ok
	LD	(APPBUF),A		; store column
	SET	0,(HL)			; switch row/col flag
	RET
SETROW:	CP	$39			; greater than 24 ?
	RET	NC			; yes: error
	SUB	$1F			; no: ok
	RES	0,(HL)			; resets flags
	LD	HL,MIOBYTE
	RES	7,(HL)			; done reset
	LD	B,A
	LD	HL,$FFB0
	LD	DE,$0050
CUROFS:	ADD	HL,DE			; calc. new offset
	DJNZ	CUROFS
	LD	A,(APPBUF)
	LD	(COLBUF),A
	LD	E,A
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(CURPBUF)
	ADD	HL,DE
	JP	SDCUAE			; update position
VCRESREG:
	POP	HL
	POP	DE
	POP	BC
	POP	AF
	RET
;;
;; MOVDN: down one line, scroll, home, clreol
;
MOVDN:
	XOR	A               ; was 00FB60 AF
	LD	(COLBUF),A
MOVDN1:	CALL	SCRTST
	RET	C
	LD	HL,MIOBYTE
	BIT	2,(HL)
	LD	DE,$F830
	CALL	GDCUA
	DEC	HL
	JR	Z,MDJMP0
	ADD	HL,DE
	JP	SDCUAE
MDJMP0:	PUSH	HL
	CALL	CLRLIN
	LD	HL,(CURPBUF)
	LD	DE,$0050
	ADD	HL,DE
	LD	DE,$0820
	PUSH	HL
	SBC	HL,DE
	POP	HL
	JR	C,MDJMP1
	RES	3,H
MDJMP1:	LD	(CURPBUF),HL
	CALL	SDSTA
; 	JR	MOVEND
; MOVEND:
	POP	HL              ; was 00FBE3 E1
	JR	C,MEJP
	RES	3,H
MEJP:	JP	SDCUAE

CURBLB:
	LD	L,$40           ; (0 10 00000) 1/16 blink scan 0
	JR	CURSETMODE
CURBLL:
	LD	L,$4A           ; (0 10 01010) 1/16 blink scan 10
	JR	CURSETMODE
CURBFB:
	LD	L,$60           ; (0 11 00000) 1/32 blink scan 0
	JR	CURSETMODE
CURBFL:
	LD	L,$6A           ; (0 11 01010) 1/32 blink scan 10
	JR	CURSETMODE
CUROFB:
	LD	L,$20           ; (0 01 00000) no cursor scan 0
	JR	CURSETMODE
CURFXB:
	LD	L,$00           ; (0 00 00000) fixed scan 0
	JR	CURSETMODE
CURFXL:
	LD	L,$0A           ; (0 00 01010) fixed scan 10
CURSETMODE:
	LD	A,$0A           ; was 00FC0A 3E 0A
	OUT	(CRT6545ADST),A
	LD	A,L
	OUT	(CRT6545DATA),A
	LD	A,$1F
	OUT	(CRT6545ADST),A
	RET
;;
;; DLIGHT
;; fill video ram (2k) with ff's
;
DLIGHT:
	LD	HL,$FFFF        ; was 00FC16 21 FF FF
	LD	(RAM0BUF),HL
	LD	A,$FF
	LD	(RAM2BUF),A
	JP	CRTFIL
;;
;; DISMVC display char and move cursor
;
DISMVC:
	CALL	DISPCH           ; was 00FC24 CD D0 F7
	JP	SDCUAE
;;
;; IOCBASE (a void routine) from here a list of routines to handle
;; console char output
;
IOCBASE:
	RET	; was 00FC30 C9
;
IOCSOH:
	EX	DE,HL
	SET	3,(HL)
	RET
IOCSTX:
	EX	DE,HL
	RES	3,(HL)
	RET
;;
;; INICRTCUR - init CRT cursor at CURPBUF
;
INICRTCUR:
	LD	HL,(CURPBUF)
	CALL	SDCUAE
	XOR	A
	JP	SAVCOLB
;;
;; IOCBEL - sound beep
IOCBEL:
	OUT	(CRTBEEPPORT),A
	RET
;;
;;
;
IOCBS:
	CALL	GDCUA
	DEC	HL
	LD	DE,(CURPBUF)
	XOR	A
	SBC	HL,DE
	CP	H
	JR	NZ,IOCBS1
	CP	L
	RET	Z
IOCBS1:	DEC	HL
	ADD	HL,DE
	CALL	SDCUAE
	PUSH	HL
	LD	A,(COLBUF)
	DEC	A
	CP	$FF
	JR	NZ,IOCBS2
	LD	A,$4F
IOCBS2:	LD	(COLBUF),A
	LD	HL,MIOBYTE
	BIT	4,(HL)
	POP	HL
	RET	NZ
	LD	A,$20
	JP	DISMVC
;;
;; CHOME - move cursor at col 0
;
CHOME:
	LD	HL,COLBUF
	LD	E,(HL)
	XOR	A
	LD	(HL),A
	LD	D,A
	CALL	GDCUA
	DEC	HL
	SBC	HL,DE
	CALL	SDCUAE
	RET
;;
;; CLRSCR - clear screen (ASCII mode)
;
CLRSCR:
	LD	HL,$0000
	XOR	A
	LD	(COLBUF),A
	CPL
	LD	(RAM3BUF),A
	LD	(CURPBUF),HL
	CALL	SDCUAE
	CALL	SDSTA
	PUSH	HL
CLSNC:	LD	A,$20
	CALL	DISPCH
	INC	HL
	LD	A,H
	CP	$08
	JR	NZ,CLSNC
	POP	HL
	JP	SDCUAE
;; IOCCR - handle carriage return (0x0d)
;; should position the cursor at col 0
;
IOCCR:
	EX	DE,HL
	BIT	3,(HL)
	JR	Z,IOCCR1
	CALL	CLREOL
IOCCR1:	JP	CHOME
;;
IOCSO:
	XOR	A
	LD	HL,(CURPBUF)
	LD	DE,$07D0
	ADD	HL,DE
	EX	DE,HL
	CALL	GDCUA
	DEC	HL
	EX	DE,HL
	SBC	HL,DE
	PUSH	HL
	POP	BC
CLRJ0:	CALL	CLRLIN1
	EX	DE,HL
	JP	SDCUAE
IOCENQ:
; 	JP	CURBFL
	JP	SCURON
IOCUS:
	JP	SET3MIOB
;;
;; CLREOL - clear to end of line
;
CLREOL:
	LD	A,(COLBUF)
	LD	B,A
	LD	A,$50
	SUB	B
	LD	B,$00
	LD	C,A
	CALL	GDCUA
	DEC	HL
	EX	DE,HL
	JP	CLRJ0
;;
IOCSYN:
	EX	DE,HL
	SET	2,(HL)
	RET
IOCETB:
	EX	DE,HL
	RES	2,(HL)
	RET
IOCFS:
	EX	DE,HL
	RES	1,(HL)
	RET
IOCGS:
	EX	DE,HL
	SET	1,(HL)
	RET
IOCESC:
	EX	DE,HL
	SET	7,(HL)
	RET
;;
;; IOCLF - line feed handle
IOCLF:
	JP	LINDN
;;
;; RESATTR - reset all attributes
;
RESATTR:
	LD	A,$FF
	LD	(RAM3BUF),A
	RET
;;
IOCCAN:
	JP	INIT0
IOCRS:
	JP	OUTGRBUF
IOCEOT:
	JP	SCUROF

;;
;; IOCBASE2 (a void routine) from here a list of routines to handle
;; console char output
;; This is the same as IOCBASE but when bit 7 of MIOBYTE is set
;
IOCBAS2:
	RET	; was 00FD0F C9
IOCNAK:
	JP	CURRGT
IOCSY2:
	CALL	GDCUA
	LD	DE,$FFAF
	ADD	HL,DE
	EX	DE,HL
	LD	HL,(CURPBUF)
	EX	DE,HL
	XOR	A
	SBC	HL,DE
	CPL
	CP	H
	ADD	HL,DE
	RET	Z
	JP	SDCUAE
IOCUS2:
	JP	RES3MIOB
IOCCA2:
	EX	DE,HL
	RES	6,(HL)
	RET
IOCEM:
	EX	DE,HL
	SET	4,(HL)
	RET
IOCSUB:
	EX	DE,HL
	RES	4,(HL)
	RET
IOCSO2:
	LD	HL,RAM3BUF
	SET	0,(HL)
	RET
IOCFS2:
	LD	HL,RAM3BUF
	SET	1,(HL)
	RET
IOCETX:
	LD	HL,RAM3BUF
	SET	2,(HL)
	RET
IOCEN2:
	LD	HL,RAM3BUF
	SET	3,(HL)
	RET
IOCBE2:
	LD	HL,RAM3BUF
	SET	4,(HL)
	RET
IOCS2:
	LD	HL,RAM3BUF
	SET	5,(HL)
	RET
IOCDLE:
	LD	HL,RAM3BUF
	SET	6,(HL)
	RET
IOCGS2:
	LD	HL,RAM3BUF
	SET	7,(HL)
	RET
IOCST2:
	LD	HL,RAM3BUF
	RES	0,(HL)
	RET
IOCES2:
	LD	HL,RAM3BUF
	RES	1,(HL)
	RET
IOCEO2:
	LD	HL,RAM3BUF
	RES	2,(HL)
	RET
IOCAC2:
	LD	HL,RAM3BUF
	RES	3,(HL)
	RET
IOCHT:
	LD	HL,RAM3BUF
	RES	4,(HL)
	RET
IOCSI2:
	LD	HL,RAM3BUF
	RES	5,(HL)
	RET
IOCD12:
	LD	HL,RAM3BUF
	RES	6,(HL)
	RET
IOCRS2:
	LD	HL,RAM3BUF
	RES	7,(HL)
	RET
;;
;; LINDN - cursor down one line
;
LINDN:
	CALL	GDCUA
	DEC	HL
	LD	DE,$0050
	ADD	HL,DE
	CALL	SDCUAE
	JP	MOVDN1
;;
IOCNUL:
	EX	DE,HL
	RES	7,(HL)
	RET
;
IOCDC2:
	JP	CURBLB
IOCDC3:
	JP	CURBLL
IOCET2:
	EX	DE,HL
	SET	6,(HL)
	RET

;;
;; CLRLIN - clear current line
;
CLRLIN:
	LD	BC,$0050        ; was 00FDC0 01 50 00
CLRLIN1:
	LD	A,(RAM3BUF)
	PUSH	AF
	LD	A,$FF
	LD	(RAM3BUF),A
CLRLP1:	LD	A,$20
	CALL	DISPCH
	DEC	BC
	LD	A,B
	OR	C
	JR	NZ,CLRLP1
	POP	AF
	LD	(RAM3BUF),A
	RET
;;
;; NIB2ASC convert lower nibble in reg A to ascii in reg C
;
NIB2ASC:
	AND	$0F             ; was 00FDE0 E6 0F
	ADD	A,$90
	DAA
	ADC	A,$40
	DAA
	LD	C,A
	RET
IOCVT2:
	JP	CURFXL
IOCFF2:
	JP	DBLANK
;; This table define the offsets to jump from
;; IOCBASE (IOCBASE+IOCVEC) to a set for routines that
;; handles cntrl char < 0x20 when we are in BCONOUT
IOCVEC:
	DB	IOCBASE-IOCBASE          ; NUL 0x00 (00)  no-op
	DB	IOCSOH-IOCBASE           ; SOH 0x01 (01)  set bit 3 (de)
	DB	IOCSTX-IOCBASE           ; STX 0x02 (05)  res bit 3 (de)
	DB	IOCBASE-IOCBASE          ; ETX 0x03 (00)  no-op
	DB	IOCEOT-IOCBASE           ; EOT 0x04 (db)  cursor off
	DB	IOCENQ-IOCBASE           ; ENQ 0x05 (9e)  cursor on
	DB	IOCACK-IOCBASE           ; ACK 0x06 (09)  locate cursor at CURPBUF
	DB	IOCBEL-IOCBASE           ; BEL 0x07 (13)  beep
	DB	IOCBS-IOCBASE            ; BS  0x08 (16)  cursor back
	DB	IOCBASE-IOCBASE          ; HT  0x09 (00)  no-op
	DB	IOCLF-IOCBASE            ; LF  0x0a (cc)  cursor down one line
	DB	IOCVT-IOCBASE            ; VT  0x0b (45)  cursor home
	DB	IOCFF-IOCBASE            ; FF  0x0c (56)  page down (clear screen)
	DB	IOCCR-IOCBASE            ; CR  0x0d (7a)  cursor home
	DB	IOCSO-IOCBASE            ; SO  0x0e (85)  to end of page clear line
	DB	IOCSI-IOCBASE            ; SI  0x0f (a6)  clear to EOL
	DB	IOCBASE-IOCBASE          ; DLE 0x10 (00)  no-op
	DB	IOCDC1-IOCBASE           ; DC1 0x11 (cf)  reset all attributes
	DB	IOCBASE-IOCBASE          ; DC2 0x12 (00)  no-op
	DB	IOCBASE-IOCBASE          ; DC3 0x13 (00)  no-op
	DB	IOCBASE-IOCBASE          ; DC4 0x14 (00)  no-op
	DB	IOCBASE-IOCBASE          ; NAK 0x15 (00)  no-op
	DB	IOCSYN-IOCBASE           ; SYN 0x16 (b8) set bit 2 of (de)
	DB	IOCETB-IOCBASE           ; ETB 0x17 (bc) res bit 2 of (de)
	DB	IOCCAN-IOCBASE           ; CAN 0x18 (d5) hard crt reset and clear
	DB	IOCBASE-IOCBASE          ; EM  0x19 (00)  no-op
	DB	IOCBASE-IOCBASE          ; SUB 0x1a (00)  no-op
	DB	IOCESC-IOCBASE           ; ESC 0x1b (c8) set bit 7 of (de) (ACTIVATE ALTERNATE PROCESSING)
	DB	IOCFS-IOCBASE            ; FS  0x1c (c0) res bit 1 of (de)
	DB	IOCGS-IOCBASE            ; GS  0x1d (c4) set bit 1 of (de)
	DB	IOCRS-IOCBASE            ; RS  0x1e (d8) display graphic buffer (ram[012]buf)
	DB	IOCUS-IOCBASE            ; US  0x1f (a1) set bit 1 of (de)
;; This table define the offsets to jump from
;; IOCBAS2 (IOCBAS2+IOCVEC2) to a set fo routines that
;; handles cntrl char < 0x20 when we are in BCONOUT
IOCVEC2:
	DB	IOCNUL-IOCBAS2           ; NUL 0x00 (9a)  res bit 7 (de) (CLEAR ALTERNATE)
	DB	IOCSO2-IOCBAS2           ; SOH 0x01 (2c)  set bit 0 RAM3BUF (BLINK OFF)
	DB	IOCST2-IOCBAS2           ; STX 0x02 (5c)  res bit 0 RAM3BUF (BLINK ON)
	DB	IOCETX-IOCBAS2           ; ETX 0x03 (38)  set bit 2 RAM3BUF (UNDER OFF)
	DB	IOCEO2-IOCBAS2           ; EOT 0x04 (68)  res bit 2 RAM3BUF (UNDER ON)
	DB	IOCEN2-IOCBAS2           ; ENQ 0x05 (3e)  set bit 3 RAM3BUF (HLIGHT OFF)
	DB	IOCAC2-IOCBAS2           ; ACK 0x06 (6e)  res bit 3 RAM3BUF (HLIGHT ON)
	DB	IOCBE2-IOCBAS2           ; BEL 0x07 (44)  set bit 4 RAM3BUF (GRAPH OFF)
	DB	IOCBAS2-IOCBAS2          ; BS  0x08 (00)  no-op
	DB	IOCHT-IOCBAS2            ; HT  0x09 (74)  res bit 4 RAM3BUF (GRAPH ON)
	DB	IOCBAS2-IOCBAS2          ; LF  0x0a (00)  no-op
	DB	IOCVT2-IOCBAS2           ; VT  0x0b (db)  cursor fixed line
	DB	IOCFF2-IOCBAS2           ; FF  0x0c (e1)  clear screen
	DB	IOCNUL-IOCBAS2           ; CR  0x0d (00)  res bit 7 (de) (CLEAR ALTERNATE)
	DB	IOCS2-IOCBAS2            ; SO  0x0e (4a)  set bit 5 RAM3BUF
	DB	IOCSI2-IOCBAS2           ; SI  0x0f (7a)  res bit 5 RAM3BUF
	DB	IOCDLE-IOCBAS2           ; DLE 0x10 (50)  set bit 6 RAM3BUF
	DB	IOCD12-IOCBAS2           ; DC1 0x11 (80)  res bit 6 RAM3BUF
	DB	IOCDC2-IOCBAS2           ; DC2 0x12 (9e)  cursor blink slow block
	DB	IOCDC3-IOCBAS2           ; DC3 0x13 (a1)  cursor blink slow line
	DB	IOCDC4-IOCBAS2           ; DC4 0x14 (8c)  cursor down one line
	DB	IOCNAK-IOCBAS2           ; NAK 0x15 (01)  cursor right
	DB	IOCSY2-IOCBAS2           ; SYN 0x16 (04)  cursor up one line
	DB	IOCET2-IOCBAS2           ; ETB 0x17 (a4)  set bit 6 of (de)
	DB	IOCCA2-IOCBAS2           ; CAN 0x18 (20)  res bit 6 of (de)
	DB	IOCEM-IOCBAS2            ; EM  0x19 (24)  set bit 4 of (de)
	DB	IOCSUB-IOCBAS2           ; SUB 0x1a (28)  res bit 4 of (de)
	DB	IOCES2-IOCBAS2           ; ESC 0x1b (62)  res bit 1 RAM3BUF (REVERSE OFF)
	DB	IOCFS2-IOCBAS2           ; FS  0x1c (32)  set bit 1 RAM3BUF (REVERSE ON)
	DB	IOCGS2-IOCBAS2           ; GS  0x1d (56)  set bit 7 RAM3BUF
	DB	IOCRS2-IOCBAS2           ; RS  0x1e (86)  res bit 7 RAM3BUF
	DB	IOCUS2-IOCBAS2           ; US  0x1f (1a)  res bit 3 of MIOBYTE
;;
;; DBLANK
;; fill video ram (2k) with 0's
;
DBLANK:
	LD	HL,$0000        ; was 00FE40 21 00 00
	LD	(RAM0BUF),HL
	XOR	A
	LD	(RAM2BUF),A
;;
;; CRTFIL - Fill video ram with ram buffer chrs
;
CRTFIL:
	LD	A,$EF           ; was 00FE4A 3E EF
	LD	(RAM3BUF),A
	LD	HL,$0000
	LD	(CURPBUF),HL
	CALL	RDRR19R12
CFIL1:	PUSH	HL
	CALL	DISPGR
	POP	HL
	INC	HL
	LD	A,H
	CP	$08
	JR	NZ,CFIL1
	JP	RDRR19R12
;;
;; DISPGR - absolutely the same of DISPGR but takes chars from locs
;; 002a/b/c WHY THIS???
;
DISPGR:
	IN	A,(CRT6545ADST)         ; was 00FE66 DB 8C
	BIT	7,A
	JR	Z,DISPGR
DISPNORTR:
	LD	HL,RAM0BUF
	LD	A,(HL)
	OUT	(CRTRAM0DAT),A
	INC	HL
	LD	A,(HL)
	OUT	(CRTRAM1DAT),A
	INC	HL
	LD	A,(HL)
	OUT	(CRTRAM2DAT),A
	LD	A,(RAM3BUF)
	OUT	(CRTRAM3PORT),A
	XOR	A
	OUT	(CRT6545DATA),A
	RET

;;
;; OUTGRBUF - set graphic mode, display RAM[012]BUF and revert to ascii
;
OUTGRBUF:
	CALL	GDCUA           ; was 00FF59 CD B0 F7
	DEC	HL
	LD	A,(RAM3BUF)
	PUSH	AF
	PUSH	HL
	RES	4,A
	LD	(RAM3BUF),A
	CALL	DISPGR
	POP	HL
	POP	AF
	LD	(RAM3BUF),A
	JP	SDCUAE

SET3MIOB:
	LD	HL,MIOBYTE		; was 00FFF0 21 47 00
	SET	3,(HL)
	RET
RES3MIOB:
	LD	HL,MIOBYTE		; was 00FFF6 21 47 00
	RES	3,(HL)
	RET
;;
;; Here the routines hard disk management
;;
HDBOOT:
	LD	HL,MNOHD		; still unimplemented...
	CALL	CONSTR
	JP	USRCMD
	;
	;       character i/o handlers
	;	This are moved here from BIOS since we need to keep
	;	space...
	;
MCONIN:
	LD	A,(IOBYTE)		;
	AND	$03			;
	JP	Z,BCONIN		;
	CP	$02			;
	JP	M,BCONIN		;
	JP	Z,NDEVMSG		;
	JP	NDEVMSG			;
MCONOUT:
	LD	A,(IOBYTE)		;
	AND	$03			;
	JP	Z,BCONOUT		;
	CP	$02			;
	JP	M,BCONOUT		;
	JP	Z,NDEVMSG		;
	JP	NDEVMSG			;
MCONST:
	LD	A,(IOBYTE)		;
	AND	$03			;
	JP	Z,BCONST		;
	CP	$02			;
	JP	M,BCONST		;
	JP	Z,NDEVMSG		;
	JP	NDEVMSG			;
MCBLIST:
	LD	A,(IOBYTE)		;
	AND	$C0			;
	JP	Z,BCONOUT		;
	CP	$80			;
	JP	M,BCONOUT		;
	JP	Z,PRNCHR		;
	JP	NDEVMSG			;
MLISTST:
	LD	A,(IOBYTE)		;
	AND	$C0			;
	JP	Z,BCONST		;
	CP	$80			;
	JP	M,BCONST		;
	JP	Z,HLISTST		;
	JP	NDEVMSG			;
MPUNCH:
	LD	A,(IOBYTE)		;
	AND	$30			;
	JP	Z,BCONOUT		;
	CP	$20			;
	RET	M			;
	JP	Z,NDEVMSG		;
	JP	NDEVMSG			;

MREADER:
	LD	A,(IOBYTE)		;
	AND	$0C			;
	JP	Z,BCONIN		;
	CP	$08			;
	JP	M,NULFN2		;
	JP	Z,NDEVMSG		;
	JP	NDEVMSG			;
	; Test printer busy status
HLISTST:
	IN	A,(CRTSERVDAT)		;
	BIT	PRNTBUSYBIT,A		;
	XOR	A			;
	RET	NZ			;
	CPL				;
	RET				;
	;
NULFN2:	LD	A,$1A			;
	RET				;
	; Display a no device message
NDEVMSG:
	XOR	A			;
	LD	(IOBYTE),A		; reset IOBYTE
	LD	HL,MSNODEV		; load msg
	CALL	CONSTR			; display
	CALL	BCONIN			; wait for user...
	JP	$0000			; do a WBOOT
	;
MSNODEV:				;
	DEFB	CR,LF,"*NO DEVIC",'E'+$80


MNOHD:	DEFB	CR,LF,"NO HARD DISK!",CR,LF+$80
;;
;; DIV16 - 16 BY 16 BIT DIVISION
;;
;; in BC = dividend
;; in DE = divisor
;; ----
;; out BC = quotient
;; out HL = remainder
DIV16:	LD	A,B
	LD	B,16
	LD	HL,0
DIVLO:	RL	C
	RLA
	ADC	HL,HL
	SBC	HL,DE
	JR	NC,$+3
	ADD	HL,DE
	CCF
	DJNZ	DIVLO
	RL	C
	RLA
	LD	B,A
	RET
;;
;;	TRANSK - calculate skew factor on-the-fly
;;
;; input	E = current sec
;;	 	C = # secs/track
;; output 	A = trans. sec
TRANSK:	INC	C		; need for comparison
	LD	B,E		; init B as sec. counter
	LD	A,1		; start #
TRASK1:	DEC	B		; end ?
	RET	Z		; yes
	ADD	A,6		; apply skew factor
	CP	C		; # overflow ?
	JR	C,TRASK1	; no: next
	SUB	C		; correct to lowest
	INC	A		; done
	CP	1		; overflow ?
	JR	NZ,TRASK1	; no, next
	INC	A		; yes, adjust
	JR	TRASK1		; next


;;
;;	MUL16 - 16x16 bit multiplication
;;
;; 	in  DE = multiplicand
;;	    BC = multiplier
;;	out HL = result
MUL16:	LD	A,C		; A = low mpler
	LD	C,B		; C = high mpler
	LD	B,16		; counter
	LD	HL,0
ML1601:	SRL	C		; right shift mpr high
	RRA			; rot. right mpr low
	JR	NC,ML1602	; test carry
	ADD	HL,DE		; add mpd to result
ML1602:	EX	DE,HL
	ADD	HL,HL		; double shift mpd
	EX	DE,HL
	DJNZ	ML1601
	RET
;;
;;	OFFCAL - apply a read skew factor to sequential written
;;	         floppies. Used by bootloader and CP/M WBOOT.
;;
;;	in   E = current sector counter
OFFCAL:
	LD	C,(IX+0)	; loads sec./track
	CALL	TRANSK		; trans. sec. (in A)
	LD	(FSECBUF),A	; directly sets sector (no more then 255 secs/track !!)
	PUSH	DE		; saves DE
	LD	E,A		; now E has trans. value
	LD	A,(FTRKBUF)	; load track, no more than 255 system tracks !!
	LD	B,A		; counter
	OR	A		; zero ?
	JR	Z,OFFZER	; no
OFFGTZ:	XOR	A		; clear
OFFGT1:	ADD	A,(IX+0)	; shift index one track
	DJNZ	OFFGT1		; next
	ADD	A,E		; add sec. index
	LD	E,A		; reload on E
OFFZER: DEC	E		; correct index to zero base
	DEC	E
	LD	D,0		; DE now is dma offset
	PUSH	HL		; save base
	LD	C,(IX+2)	; sector len in BC
	LD	B,(IX+3)
	CALL	MUL16		; calc relative offset (sec len x offset)
	EX	DE,HL		; move result (rel.offset) in DE
	POP	HL		; restore base address
	PUSH	HL		; re-save
	ADD	HL,DE		; calc final address
	LD	(FRDPBUF),HL	; apply dma
	POP	HL		; re-restore base address
	POP	DE		; restore secs counters
	RET

EPFILL:
	DEFS	JBOOT + $0FFF - EPFILL + 1
;;
;; end of monitor code - this will fill with zeroes to the end of
;; the eprom

;
include usingasm.inc

IF	ZMAC
WSYM darkstar.sym
ENDIF
;
;
