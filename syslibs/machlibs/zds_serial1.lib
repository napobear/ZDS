;
;=======================================================================
;
; DarkStar (NE Z80) Serial support library - UART 1
;
;=======================================================================
;;---------------------------------------------------------------------
;; Version      : 1.0 - 20170311
;; Assemble     : SLR z80asm, myzmac
;; Revisions:
;; 20170311	- Initial revision
;;---------------------------------------------------------------------

	title	zds_serial1.lib - Serial i/o to host computer
;
; 	public	srlout1,srlin1,srchk1
; 	public	attach_1_legacy, detach_1_legacy
; 	public	set_speed1

; 	extern	cnfbyte

;;
;; Using this lib require inclusion of "darkstar.equ"
;;
;
;
xon		equ	11h
xoff		equ	13h
rst8op		equ	0008h
rst8adr		equ	0009h
op_ret		equ	0c9h
op_jp		equ	0c3h
;
; Receive lock workaround enable
;
lock_wround	equ	false

;;
;; attach_1_legacy
;;
;; connect to uart1 via legacy RST8
;;
;;

attach_1_legacy:
	push	af
	push	hl
	di				; hold interrupts
	ld	a,op_jp			; jp opcode
	ld	(rst8op),a		; in rst8 base
	ld	hl,isr_s1		; and isr routine
	ld	(rst8adr),hl
	ld	hl,cnfbyte
	set	0,(hl)			; enable rst8 redirect
at_fls:
	in	a,(uart1+r5lsr)		; read status to flush the queue
	bit	0,a			; data available in rx buffer?
	jr	z,at_clr			; no.
	in	a,(uart1+r0rxtx)	; read data
	jr	at_fls
at_clr:
	ei				; re-enable interrupts
	pop	hl
	pop	af
	ret				; done

;;
;; detach_1_legacy
;;
;; disconnect uart1 from RST8 redirect
;;

detach_1_legacy:
	push	af
	push	hl
	di				; hold interrupts

	ld	a,u1defspeed		; reset to defaults
	ld	(uart1br),a
	call	bbu1ini

	ld	a,op_ret		; ret opcode
	ld	(rst8op),a		; in rst8 base
	ld	hl,cnfbyte
	res	0,(hl)			; disable rst8 redirect

	ei				; re-enable interrupts
	pop	hl
	pop	af
	ret				; done

;;
;; set_fifo
;;
;; set fifo size, A is the define
;;

set_fifo1:
	push	de
	ld	e,a			; save param
	ld	a,ufifo1		; and validate it
	cp	e
	jr	z,set_fifo10
	ld	a,ufifo4
	cp	e
	jr	z,set_fifo10
	ld	a,ufifo8
	cp	e
	jr	z,set_fifo10
	ld	a,ufifo14
	cp	e
	jr	nz,set_fifo11		; wrong value entered
set_fifo10:
	out	(uart1+r2fcr),a		; transfer to uart
set_fifo11:
	pop	de
	ret

;;
;; set_speed1
;;
;; set baud rate, A is the define (no validation)
;;

set_speed1:
	ld	(uart1br),a		; store value
	call	bbu1ini
	ret

;;
;; set_mode1
;;
;; set baud rate, A is the define (no validation)
;;
;; TODO: Wrong, this should be done by sysbios.
;;       To be fixed in future release.

;set_mode1:


;;
;; Check for input (and get it)
;;
;; A contain input byte
;;

srlin1:
	in	a,(uart1+r5lsr)		; read status
	bit	7,a			; fifo overrun?
	call	nz,isr_s1		; try to flush the fifo

if	lock_wround
	; try to override receive lock (workaround)
	in	a,(uart1+r5lsr)		; get status
	rra				; save bit 0 (data ready)
	in	a,(uart1+r2iir)		; get interrupt status
	rla				; restore dr and shift ip
	and	00000011b		; mask
	cp	00000011b		; data ready & no interrupt pending!!!
	call	z,isr_s1		; try to flush the fifo
endif

	ld	a,(ilen)		; buffer length
	or	a			; empty ?
	ret	z			; yes -> forget it
	call	getbyte
	scf				; success
	ret

;;
;; Check for input (and get it)
;;

srchk1:
	ld	a,(ilen)		; buffer length
	or	a			; empty ?
	ret	z			; return Z flag



;;
;; getbyte - extract char from queue
;;

getbyte:
	push	hl
	push	de
	ld	hl,(ibgp)
	ld	a,(hl)			; get next char.
	inc	hl
	ld	de,ibend
	call	cphlde			; buffer end ?
	jr	c,noiwrap		; no ->
	ld	hl,ibstrt		; yes, back to start
noiwrap:
	ld	(ibgp),hl
	ld	hl,ilen
	dec	(hl)
	push	af
	ld	a,(ilen)
; 	cp	imax-20
	cp	imax-32
	call	z,pson
	pop	af
	pop	de
	pop	hl
	ret

;;
;; Read 16c550 LSR register and return in A
;;
getlsr1:
in	a,(uart1+r5lsr)		; read status
	ret

;;
;;  Output routine
;;  upon entry:	C contains the character to be output
;;

srlout1:
srlout:
	push	af
sot0:	ld	a,(opflg)		; test xon/xoff
	bit	0,a
	jr	nz,sot0			; idle if xoff
sot1:
	in	a,(uart1+r5lsr)		; read status
	bit	5,a			; ready to send?
	jp	z,sot1			; no, retry.

	ld	a,c			; fill in the char
	out	(uart1+r0rxtx),a	; send it
	pop	af
	ret
;;
;;	Interrupt Service Routines
;;

;;
;; psoff: send xoff to host
;;
psoff:
	ld	c,xoff
	call	srlout
	ret
;
;;
;; pson: send xon to host
;;
pson:	ld	c,xon
	jp	srlout

;;
;; isr_s1
;;
;; Called upon interrupt on uart1
;;

isr_s1:
	ld	(tstack),sp		; save status
	ld	sp,stack
	call	pushem
	call	psoff			; lock host

	ld	a,(ilen)		; buffer capacity ?
	ld	hl,opflg
 	cp	imax-16			; uart hw fifo is 16 bytes
	jr	z,iret			; wait for dequeue
;
isr_s10:
	in	a,(uart1+r5lsr)		; read status
	bit	0,a			; data available in rx buffer?
	jr	z,iret0			; no.
	in	a,(uart1+r0rxtx)	; read data

	cp	xoff
	call	z,idle
	cp	xon
	call	z,nidle

	ld	hl,(ibpp)
	ld	(hl),a
	inc	hl
	ld	de,ibend
	call	cphlde
	jr	c,norw
	ld	hl,ibstrt
norw:
	ld	(ibpp),hl
	ld	hl,ilen
	inc	(hl)
	jr	isr_s10			; repeat for more data in UART
iret0:
	call	pson
iret:
	call	popem
	ld	sp,(tstack)
dummy:	ret

idle:
	set	0,(hl)
	ret
;
nidle:
	res	0,(hl)
	ret
;
cphlde:
	push	hl		;compares hl & de
	or	a		;and sets flags.
	sbc	hl,de
	pop	hl
	ret
;
pushem:
	ex	(sp),hl		;save main regs on stack.
	push	de		;the hl pair is mod'd.
	push	bc
	push	af
	jp	(hl)
;
popem:
	pop	hl		;restore all main regs
	pop	af		;from stack after a
	pop	bc		;call to pushem.
	pop	de
	ex	(sp),hl
	ret
;

opflg	db	0
;
ilen	db	0		;input buffer length
ibgp	dw	ibstrt		;input buffer get pointer
ibpp	dw	ibstrt		;input buffer put pointer
ibstrt	equ	$		;input buffer start
ibuff	ds	0ffh		;input buffer
ibend	equ	$		;input buffer end
imax	equ	0ffh		;input buffer max length
;
tstack	ds	80h
stack	equ	$
;
	end
